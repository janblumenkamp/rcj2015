
robocup.elf:     Dateiformat elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 77 16 	jmp	0x2cee	; 0x2cee <__ctors_end>
       4:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
       8:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
       c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      10:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      14:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      18:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      1c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      20:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      24:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      28:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      2c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      30:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      34:	0c 94 b0 5c 	jmp	0xb960	; 0xb960 <__vector_13>
      38:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      3c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      40:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      44:	0c 94 a5 18 	jmp	0x314a	; 0x314a <__vector_17>
      48:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      4c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      50:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      54:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      58:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      5c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      60:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      64:	0c 94 60 5e 	jmp	0xbcc0	; 0xbcc0 <__vector_25>
      68:	0c 94 92 5e 	jmp	0xbd24	; 0xbd24 <__vector_26>
      6c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      70:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      74:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      78:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      7c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      80:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      84:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      88:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      8c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      90:	0c 94 ee 5e 	jmp	0xbddc	; 0xbddc <__vector_36>
      94:	0c 94 20 5f 	jmp	0xbe40	; 0xbe40 <__vector_37>
      98:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      9c:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      a0:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      a4:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      a8:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      ac:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      b0:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      b4:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      b8:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      bc:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      c0:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      c4:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      c8:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      cc:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      d0:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      d4:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      d8:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      dc:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      e0:	0c 94 9f 16 	jmp	0x2d3e	; 0x2d3e <__bad_interrupt>
      e4:	36 20       	and	r3, r6
      e6:	a1 20       	and	r10, r1
      e8:	aa 20       	and	r10, r10
      ea:	b3 20       	and	r11, r3
      ec:	bc 20       	and	r11, r12
      ee:	c5 20       	and	r12, r5
      f0:	ce 20       	and	r12, r14
      f2:	cf 21       	and	r28, r15
      f4:	d6 21       	and	r29, r6
      f6:	d9 21       	and	r29, r9
      f8:	dc 21       	and	r29, r12
      fa:	df 21       	and	r29, r15
      fc:	e2 21       	and	r30, r2
      fe:	e6 21       	and	r30, r6
     100:	eb 21       	and	r30, r11
     102:	f0 21       	and	r31, r0
     104:	f5 21       	and	r31, r5
     106:	f8 21       	and	r31, r8
     108:	fd 21       	and	r31, r13
     10a:	02 22       	and	r0, r18
     10c:	09 22       	and	r0, r25
     10e:	8d 23       	and	r24, r29
     110:	e2 22       	and	r14, r18
     112:	12 23       	and	r17, r18
     114:	14 23       	and	r17, r20
     116:	29 23       	and	r18, r25
     118:	2b 23       	and	r18, r27
     11a:	2f 23       	and	r18, r31
     11c:	4b 24       	eor	r4, r11
     11e:	4b 24       	eor	r4, r11
     120:	44 24       	eor	r4, r4
     122:	4b 24       	eor	r4, r11
     124:	53 24       	eor	r5, r3
     126:	53 24       	eor	r5, r3
     128:	4b 24       	eor	r4, r11
     12a:	1a 2c       	mov	r1, r10
     12c:	c0 2c       	mov	r12, r0
     12e:	25 2d       	mov	r18, r5
     130:	2a 2d       	mov	r18, r10
     132:	ab 2f       	mov	r26, r27
     134:	d1 2f       	mov	r29, r17
     136:	f3 2f       	mov	r31, r19
     138:	63 30       	cpi	r22, 0x03	; 3
     13a:	6f 30       	cpi	r22, 0x0F	; 15
     13c:	76 30       	cpi	r23, 0x06	; 6
     13e:	35 3d       	cpi	r19, 0xD5	; 213
     140:	0c 3e       	cpi	r16, 0xEC	; 236
     142:	f4 3e       	cpi	r31, 0xE4	; 228
     144:	57 3f       	cpi	r21, 0xF7	; 247
     146:	60 3f       	cpi	r22, 0xF0	; 240
     148:	36 41       	sbci	r19, 0x16	; 22
     14a:	36 41       	sbci	r19, 0x16	; 22
     14c:	cf 3f       	cpi	r28, 0xFF	; 255
     14e:	ef 40       	sbci	r30, 0x0F	; 15
     150:	fa 40       	sbci	r31, 0x0A	; 10
     152:	36 41       	sbci	r19, 0x16	; 22
     154:	36 41       	sbci	r19, 0x16	; 22
     156:	08 41       	sbci	r16, 0x18	; 24
     158:	0d 41       	sbci	r16, 0x1D	; 29
     15a:	21 41       	sbci	r18, 0x11	; 17
     15c:	29 41       	sbci	r18, 0x19	; 25
     15e:	39 41       	sbci	r19, 0x19	; 25
     160:	62 3e       	cpi	r22, 0xE2	; 226
     162:	f7 41       	sbci	r31, 0x17	; 23
     164:	f7 41       	sbci	r31, 0x17	; 23
     166:	64 3e       	cpi	r22, 0xE4	; 228
     168:	6a 3e       	cpi	r22, 0xEA	; 234
     16a:	f7 41       	sbci	r31, 0x17	; 23
     16c:	64 3e       	cpi	r22, 0xE4	; 228
     16e:	82 3e       	cpi	r24, 0xE2	; 226
     170:	f7 41       	sbci	r31, 0x17	; 23
     172:	a0 68       	ori	r26, 0x80	; 128
     174:	ba 68       	ori	r27, 0x8A	; 138
     176:	bd 68       	ori	r27, 0x8D	; 141
     178:	b8 68       	ori	r27, 0x88	; 136
     17a:	c5 68       	ori	r28, 0x85	; 133
     17c:	ca 68       	ori	r28, 0x8A	; 138
     17e:	d6 68       	ori	r29, 0x86	; 134

00000180 <__c.4405>:
     180:	3a 20 45 52 52 4f 52 3a 20 43 48 52 6f 62 6f 74     : ERROR: CHRobot
     190:	69 63 73 20 55 4d 36 20 49 4d 55 00                 ics UM6 IMU.

0000019c <__c.4403>:
     19c:	0a 0d 00                                            ...

0000019f <__c.4401>:
     19f:	3a 20 45 52 52 4f 52 3a 20 4d 65 6c 65 78 69 73     : ERROR: Melexis
     1af:	20 4d 4c 58 39 30 36 31 34 20 54 65 6d 70 65 72      MLX90614 Temper
     1bf:	61 74 75 72 65 20 73 65 6e 73 6f 72 73 00           ature sensors.

000001cd <__c.4399>:
     1cd:	0a 0d 00                                            ...

000001d0 <__c.4397>:
     1d0:	3a 20 45 52 52 4f 52 3a 20 52 45 53 45 54 00        : ERROR: RESET.

000001df <__c.4395>:
     1df:	0a 0d 00                                            ...

000001e2 <__c.4392>:
     1e2:	3a 20 57 41 52 4e 49 4e 47 3a 20 52 45 43 4f 56     : WARNING: RECOV
     1f2:	45 52 45 44 20 41 46 54 45 52 20 41 4e 20 55 4e     ERED AFTER AN UN
     202:	45 58 50 45 43 54 45 44 20 53 48 55 54 44 4f 57     EXPECTED SHUTDOW
     212:	4e 21 21 21 00                                      N!!!.

00000217 <__c.4390>:
     217:	0a 0d 00                                            ...

0000021a <__c.4388>:
     21a:	20 72 75 6e 6e 69 6e 67 20 74 61 73 6b 73 2e 00      running tasks..

0000022a <__c.4386>:
     22a:	3a 20 53 79 73 74 65 6d 20 69 6e 69 74 69 61 6c     : System initial
     23a:	69 7a 65 64 2c 20 00                                ized, .

00000241 <__c.4384>:
     241:	0a 0d 00                                            ...

00000244 <__c.4382>:
     244:	0a 0d 44 65 62 75 67 67 69 6e 67 20 67 72 61 64     ..Debugging grad
     254:	65 3a 20 00                                         e: .

00000258 <__c.4380>:
     258:	0a 0d 52 43 4a 20 32 30 31 34 2c 20 56 33 2e 30     ..RCJ 2014, V3.0
     268:	0a 0d 74 65 61 6d 6f 68 6e 65 6e 61 6d 65 2e 64     ..teamohnename.d
     278:	65 00                                               e.

0000027a <incr_table>:
     27a:	00 01 00 00 00 00 00 00 00 00 00 ff 00 00 00 00     ................

0000028a <u8g_font_8x13Br>:
     28a:	01 08 0d 00 fe 0a 01 7f 03 0c 20 7f fe 0b fe 0a     .......... .....
     29a:	fe 0d 00 80 32 2a 8a c0 c0 c0 c0 c0 c0 c0 00 c0     ....2*..........
     2aa:	c0 18 54 84 d8 d8 d8 d8 02 79 89 6c 6c fe fe 6c     ..T......y.ll..l
     2ba:	fe fe 6c 6c 01 7b 8b 10 7c d6 d0 f0 7c 1e 16 d6     ..ll.{..|...|...
     2ca:	7c 10 02 7a 8a e6 a6 ec 18 18 30 30 6e ca ce 02     |..z......00n...
     2da:	77 87 78 cc cc 78 ce cc 7e 38 24 84 c0 c0 c0 c0     w.x..x..~8$.....
     2ea:	11 5b 8b 18 30 60 60 c0 c0 c0 60 60 30 18 11 5b     .[..0``...``0..[
     2fa:	8b c0 60 30 30 18 18 18 30 30 60 c0 03 77 87 10     ..`00...00`..w..
     30a:	10 fe 38 38 6c 44 14 66 86 30 30 fc fc 30 30 21     ..88lD.f.00..00!
     31a:	45 85 f0 70 70 60 c0 16 61 81 fc 22 43 83 60 f0     E..pp`..a.."C.`.
     32a:	60 02 7a 8a 02 06 06 0c 18 30 60 c0 c0 80 02 7a     `.z......0`....z
     33a:	8a 38 6c c6 c6 c6 c6 c6 c6 6c 38 12 6a 8a 30 70     .8l......l8.j.0p
     34a:	f0 30 30 30 30 30 30 fc 02 7a 8a 7c c6 c6 06 0c     .000000..z.|....
     35a:	18 30 60 c0 fe 02 7a 8a fe 06 0c 18 3c 06 06 06     .0`...z.....<...
     36a:	c6 7c 02 7a 8a 0c 1c 3c 6c cc cc fe 0c 0c 0c 02     .|.z...<l.......
     37a:	7a 8a fe c0 c0 fc e6 06 06 06 c6 7c 02 7a 8a 3c     z..........|.z.<
     38a:	60 c0 c0 fc e6 c6 c6 e6 7c 02 7a 8a fe 06 06 0c     `.......|.z.....
     39a:	18 18 30 30 30 30 02 7a 8a 7c c6 c6 c6 7c c6 c6     ..0000.z.|...|..
     3aa:	c6 c6 7c 02 7a 8a 7c ce c6 c6 ce 7e 06 06 0c 78     ..|.z.|....~...x
     3ba:	22 48 88 60 f0 60 00 00 60 f0 60 21 49 89 60 f0     "H.`.`..`.`!I.`.
     3ca:	60 00 f0 70 70 60 c0 12 69 89 0c 18 30 60 c0 60     `..pp`..i...0`.`
     3da:	30 18 0c 14 64 84 fc 00 00 fc 12 69 89 c0 60 30     0...d......i..`0
     3ea:	18 0c 18 30 60 c0 02 7a 8a 7c c6 c6 06 0c 18 18     ...0`..z.|......
     3fa:	00 18 18 02 79 89 7c fe ce de d2 d2 de e0 7e 02     ....y.|.......~.
     40a:	7a 8a 38 7c c6 c6 c6 fe c6 c6 c6 c6 02 7a 8a fc     z.8|.........z..
     41a:	66 66 66 7c 66 66 66 66 fc 02 7a 8a 7c e6 c6 c0     fff|ffff..z.|...
     42a:	c0 c0 c0 c6 e6 7c 02 7a 8a fc 66 66 66 66 66 66     .....|.z..ffffff
     43a:	66 66 fc 02 7a 8a fe c0 c0 c0 f8 c0 c0 c0 c0 fe     ff..z...........
     44a:	02 7a 8a fe c0 c0 c0 f8 c0 c0 c0 c0 c0 02 7a 8a     .z............z.
     45a:	7c c6 c6 c0 c0 c0 ce c6 c6 7c 02 7a 8a c6 c6 c6     |........|.z....
     46a:	c6 fe c6 c6 c6 c6 c6 22 4a 8a f0 60 60 60 60 60     ......."J..`````
     47a:	60 60 60 f0 02 7a 8a 0e 06 06 06 06 06 06 c6 c6     ```..z..........
     48a:	7c 02 7a 8a c6 c6 cc d8 f0 f0 d8 cc c6 c6 02 7a     |.z............z
     49a:	8a c0 c0 c0 c0 c0 c0 c0 c0 c2 fe 02 7a 8a c6 c6     ............z...
     4aa:	ee fe d6 c6 c6 c6 c6 c6 02 7a 8a c6 c6 e6 e6 f6     .........z......
     4ba:	de ce ce c6 c6 02 7a 8a 7c c6 c6 c6 c6 c6 c6 c6     ......z.|.......
     4ca:	c6 7c 02 7a 8a fc c6 c6 c6 c6 fc c0 c0 c0 c0 01     .|.z............
     4da:	7b 8b 7c c6 c6 c6 c6 c6 c6 c6 de 7c 06 02 7a 8a     {.|........|..z.
     4ea:	fc c6 c6 c6 fc f8 cc cc c6 c6 02 7a 8a 7c c6 c6     ...........z.|..
     4fa:	c0 7c 06 06 c6 c6 7c 12 6a 8a fc 30 30 30 30 30     .|....|.j..00000
     50a:	30 30 30 30 02 7a 8a c6 c6 c6 c6 c6 c6 c6 c6 c6     0000.z..........
     51a:	7c 02 7a 8a c6 c6 c6 c6 44 6c 6c 38 38 10 02 7a     |.z.....Dll88..z
     52a:	8a c6 c6 c6 c6 c6 c6 d6 d6 fe 6c 02 7a 8a c6 c6     ..........l.z...
     53a:	6c 6c 38 38 6c 6c c6 c6 12 6a 8a cc cc cc 78 78     ll88ll...j....xx
     54a:	30 30 30 30 30 02 7a 8a fe 06 06 0c 18 30 60 c0     00000.z......0`.
     55a:	c0 fe 11 5b 8b f8 c0 c0 c0 c0 c0 c0 c0 c0 c0 f8     ...[............
     56a:	02 7a 8a 80 c0 c0 60 30 18 0c 06 06 02 11 5b 8b     .z....`0......[.
     57a:	f8 18 18 18 18 18 18 18 18 18 f8 08 74 84 10 38     ............t..8
     58a:	6c c6 01 71 81 fe 29 43 83 c0 60 30 02 77 87 7c     l..q..)C..`0.w.|
     59a:	06 7e c6 c6 ce 76 02 7a 8a c0 c0 c0 dc e6 c6 c6     .~...v.z........
     5aa:	c6 e6 dc 02 77 87 7c e6 c0 c0 c0 e6 7c 02 7a 8a     ....w.|.....|.z.
     5ba:	06 06 06 76 ce c6 c6 c6 ce 76 02 77 87 7c c6 c6     ...v.....v.w.|..
     5ca:	fe c0 c6 7c 02 7a 8a 3c 66 60 60 60 fc 60 60 60     ...|.z.<f```.```
     5da:	60 00 79 89 7e cc cc cc 78 f0 7c c6 7c 02 7a 8a     `.y.~...x.|.|.z.
     5ea:	c0 c0 c0 dc e6 c6 c6 c6 c6 c6 22 49 89 60 60 00     .........."I.``.
     5fa:	e0 60 60 60 60 f0 00 7b 8b 06 06 00 0e 06 06 06     .````..{........
     60a:	06 c6 c6 7c 02 7a 8a c0 c0 c0 cc d8 f0 f0 d8 cc     ...|.z..........
     61a:	c6 22 4a 8a e0 60 60 60 60 60 60 60 60 f0 02 77     ."J..````````..w
     62a:	87 6c fe d6 d6 c6 c6 c6 02 77 87 dc e6 c6 c6 c6     .l.......w......
     63a:	c6 c6 02 77 87 7c c6 c6 c6 c6 c6 7c 00 79 89 dc     ...w.|.....|.y..
     64a:	e6 c6 c6 c6 e6 dc c0 c0 00 79 89 76 ce c6 c6 c6     .........y.v....
     65a:	ce 76 06 06 02 77 87 dc e6 c0 c0 c0 c0 c0 02 77     .v...w.........w
     66a:	87 7c c6 60 38 0c c6 7c 02 7a 8a 60 60 60 60 fc     .|.`8..|.z.````.
     67a:	60 60 60 66 3c 02 77 87 c6 c6 c6 c6 c6 ce 76 02     ```f<.w.......v.
     68a:	77 87 c6 c6 c6 c6 6c 6c 38 02 77 87 c6 c6 c6 d6     w.....ll8.w.....
     69a:	d6 fe 6c 02 77 87 c6 c6 6c 38 6c c6 c6 00 79 89     ..l.w...l8l...y.
     6aa:	c6 c6 c6 c6 ce 76 06 c6 7c 02 77 87 fe 0c 18 30     .....v..|.w....0
     6ba:	60 c0 fe 11 6b 8b 3c 60 60 60 30 e0 30 60 60 60     `...k.<```0.0```
     6ca:	3c 32 2a 8a c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 11 6b     <2*............k
     6da:	8b f0 18 18 18 30 1c 30 18 18 18 f0 08 73 83 72     .....0.0.....s.r
     6ea:	fe 9c ff                                            ...

000006ed <u8g_font_6x10>:
     6ed:	01 06 0a 00 fe 07 01 36 02 68 20 ff fe 08 fe 07     .......6.h .....
     6fd:	fe 0a 00 60 22 17 67 80 80 80 80 80 00 80 16 33     ...`".g........3
     70d:	63 a0 a0 a0 02 57 67 50 50 f8 50 f8 50 50 02 57     c....WgPP.P.PP.W
     71d:	67 20 70 a0 70 28 70 20 02 57 67 48 a8 50 20 50     g p.p(p .WgH.P P
     72d:	a8 90 02 57 67 40 a0 a0 40 a8 90 68 26 13 63 80     ...Wg@..@..h&.c.
     73d:	80 80 12 37 67 20 40 80 80 80 40 20 12 37 67 80     ...7g @...@ .7g.
     74d:	40 20 20 20 40 80 03 55 65 88 50 f8 50 88 03 55     @   @..Ue.P.P..U
     75d:	65 20 20 f8 20 20 11 33 63 60 40 80 05 51 61 f8     e  .  .3c`@..Qa.
     76d:	11 33 63 40 e0 40 02 57 67 08 08 10 20 40 80 80     .3c@.@.Wg... @..
     77d:	02 57 67 20 50 88 88 88 50 20 02 57 67 20 60 a0     .Wg P...P .Wg `.
     78d:	20 20 20 f8 02 57 67 70 88 08 30 40 80 f8 02 57        ..Wgp..0@...W
     79d:	67 f8 08 10 30 08 88 70 02 57 67 10 30 50 90 f8     g...0..p.Wg.0P..
     7ad:	10 10 02 57 67 f8 80 b0 c8 08 88 70 02 57 67 30     ...Wg......p.Wg0
     7bd:	40 80 b0 c8 88 70 02 57 67 f8 08 10 10 20 40 40     @....p.Wg.... @@
     7cd:	02 57 67 70 88 88 70 88 88 70 02 57 67 70 88 98     .Wgp..p..p.Wgp..
     7dd:	68 08 10 60 11 37 67 40 e0 40 00 40 e0 40 11 37     h..`.7g@.@.@.@.7
     7ed:	67 40 e0 40 00 60 40 80 12 47 67 10 20 40 80 40     g@.@.`@..Gg. @.@
     7fd:	20 10 04 53 63 f8 00 f8 12 47 67 80 40 20 10 20      ..Sc....Gg.@ . 
     80d:	40 80 02 57 67 70 88 10 20 20 00 20 02 57 67 70     @..Wgp..  . .Wgp
     81d:	88 98 a8 b0 80 70 02 57 67 20 50 88 88 f8 88 88     .....p.Wg P.....
     82d:	02 57 67 f0 48 48 70 48 48 f0 02 57 67 70 88 80     .Wg.HHpHH..Wgp..
     83d:	80 80 88 70 02 57 67 f0 48 48 48 48 48 f0 02 57     ...p.Wg.HHHHH..W
     84d:	67 f8 80 80 f0 80 80 f8 02 57 67 f8 80 80 f0 80     g........Wg.....
     85d:	80 80 02 57 67 70 88 80 80 98 88 70 02 57 67 88     ...Wgp.....p.Wg.
     86d:	88 88 f8 88 88 88 12 37 67 e0 40 40 40 40 40 e0     .......7g.@@@@@.
     87d:	02 57 67 38 10 10 10 10 90 60 02 57 67 88 90 a0     .Wg8.....`.Wg...
     88d:	c0 a0 90 88 02 57 67 80 80 80 80 80 80 f8 02 57     .....Wg........W
     89d:	67 88 88 d8 a8 88 88 88 02 57 67 88 88 c8 a8 98     g........Wg.....
     8ad:	88 88 02 57 67 70 88 88 88 88 88 70 02 57 67 f0     ...Wgp.....p.Wg.
     8bd:	88 88 f0 80 80 80 01 58 68 70 88 88 88 88 a8 70     .......Xhp.....p
     8cd:	08 02 57 67 f0 88 88 f0 a0 90 88 02 57 67 70 88     ..Wg........Wgp.
     8dd:	80 70 08 88 70 02 57 67 f8 20 20 20 20 20 20 02     .p..p.Wg.      .
     8ed:	57 67 88 88 88 88 88 88 70 02 57 67 88 88 88 50     Wg......p.Wg...P
     8fd:	50 50 20 02 57 67 88 88 88 a8 a8 d8 88 02 57 67     PP .Wg........Wg
     90d:	88 88 50 20 50 88 88 02 57 67 88 88 50 20 20 20     ..P P...Wg..P   
     91d:	20 02 57 67 f8 08 10 20 40 80 f8 12 37 67 e0 80      .Wg... @...7g..
     92d:	80 80 80 80 e0 02 57 67 80 80 40 20 10 08 08 12     ......Wg..@ ....
     93d:	37 67 e0 20 20 20 20 20 e0 06 53 63 20 50 88 01     7g.     ..Sc P..
     94d:	51 61 f8 28 22 62 80 40 02 55 65 70 08 78 88 78     Qa.("b.@.Uep.x.x
     95d:	02 57 67 80 80 b0 c8 88 c8 b0 02 55 65 70 88 80     .Wg........Uep..
     96d:	88 70 02 57 67 08 08 68 98 88 98 68 02 55 65 70     .p.Wg..h...h.Uep
     97d:	88 f8 80 70 02 57 67 30 48 40 f0 40 40 40 00 57     ...p.Wg0H@.@@@.W
     98d:	67 78 88 88 78 08 88 70 02 57 67 80 80 b0 c8 88     gx..x..p.Wg.....
     99d:	88 88 12 37 67 40 00 c0 40 40 40 e0 10 49 69 10     ...7g@..@@@..Ii.
     9ad:	00 30 10 10 10 90 90 60 02 57 67 80 80 88 90 e0     .0.....`.Wg.....
     9bd:	90 88 12 37 67 c0 40 40 40 40 40 e0 02 55 65 d0     ...7g.@@@@@..Ue.
     9cd:	a8 a8 a8 88 02 55 65 b0 c8 88 88 88 02 55 65 70     .....Ue......Uep
     9dd:	88 88 88 70 00 57 67 b0 c8 88 c8 b0 80 80 00 57     ...p.Wg........W
     9ed:	67 68 98 88 98 68 08 08 02 55 65 b0 c8 80 80 80     gh...h...Ue.....
     9fd:	02 55 65 70 80 70 08 f0 02 57 67 40 40 f0 40 40     .Uep.p...Wg@@.@@
     a0d:	48 30 02 55 65 88 88 88 98 68 02 55 65 88 88 50     H0.Ue....h.Ue..P
     a1d:	50 20 02 55 65 88 88 a8 a8 50 02 55 65 88 50 20     P .Ue....P.Ue.P 
     a2d:	50 88 00 57 67 88 88 98 68 08 88 70 02 55 65 f8     P..Wg...h..p.Ue.
     a3d:	10 20 40 f8 12 47 67 30 40 20 c0 20 40 30 22 17     . @..Gg0@ . @0".
     a4d:	67 80 80 80 80 80 80 80 12 47 67 c0 20 40 30 40     g........Gg. @0@
     a5d:	20 c0 06 53 63 48 a8 90 ff ff ff ff ff ff ff ff      ..ScH..........
     a6d:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     a7d:	ff ff ff ff ff ff ff ff ff 0a 00 60 22 17 67 80     ...........`".g.
     a8d:	00 80 80 80 80 80 01 57 67 20 78 a0 a0 a0 78 20     .......Wg x...x 
     a9d:	02 57 67 30 48 40 e0 40 48 b0 02 55 65 88 70 50     .Wg0H@.@H..Ue.pP
     aad:	70 88 01 58 68 88 88 50 20 f8 20 20 20 22 17 67     p..Xh..P .   ".g
     abd:	80 80 80 00 80 80 80 01 58 68 70 80 e0 90 48 38     ........Xhp...H8
     acd:	08 70 19 31 61 a0 02 57 67 70 88 a8 c8 a8 88 70     .p.1a..Wgp.....p
     add:	13 46 66 70 90 b0 50 00 f0 02 65 65 24 48 90 48     .Ffp..P...ee$H.H
     aed:	24 14 42 62 f0 10 15 41 61 f0 02 57 67 70 88 e8     $.Bb...Aa..Wgp..
     afd:	c8 c8 88 70 09 51 61 f8 16 33 63 40 a0 40 02 56     ...p.Qa..3c@.@.V
     b0d:	66 20 20 f8 20 20 f8 15 45 65 60 90 20 40 f0 15     f  .  ..Ee`. @..
     b1d:	45 65 e0 10 60 10 e0 28 22 62 40 80 01 56 66 88     Ee..`..("b@..Vf.
     b2d:	88 88 c8 b0 80 02 57 67 78 e8 e8 68 28 28 28 25     ......Wgx..h(((%
     b3d:	11 61 80 20 22 62 40 80 15 35 65 40 c0 40 40 e0     .a. "b@..5e@.@@.
     b4d:	13 46 66 60 90 90 60 00 f0 02 65 65 90 48 24 48     .Ff`..`...ee.H$H
     b5d:	90 01 69 69 40 c0 40 40 e4 0c 14 3c 04 01 69 69     ..ii@.@@...<..ii
     b6d:	40 c0 40 40 e8 14 04 08 1c 01 59 69 c0 20 40 20     @.@@......Yi. @ 
     b7d:	c8 18 28 78 08 02 57 67 20 00 20 20 40 88 70 02     ..(x..Wg .  @.p.
     b8d:	58 68 40 20 70 88 88 f8 88 88 02 58 68 10 20 70     Xh@ p......Xh. p
     b9d:	88 88 f8 88 88 02 58 68 20 50 70 88 88 f8 88 88     ......Xh Pp.....
     bad:	02 58 68 48 b0 70 88 88 f8 88 88 02 58 68 50 00     .XhH.p......XhP.
     bbd:	70 88 88 f8 88 88 02 58 68 20 50 70 88 88 f8 88     p......Xh Pp....
     bcd:	88 02 67 67 3c 50 90 9c f0 90 9c 00 59 69 70 88     ..gg<P......Yip.
     bdd:	80 80 80 88 70 20 40 02 58 68 40 f8 80 80 f0 80     ....p @.Xh@.....
     bed:	80 f8 02 58 68 10 f8 80 80 f0 80 80 f8 02 58 68     ...Xh.........Xh
     bfd:	20 f8 80 80 f0 80 80 f8 02 58 68 50 f8 80 80 f0      ........XhP....
     c0d:	80 80 f8 12 38 68 80 40 e0 40 40 40 40 e0 12 38     ....8h.@.@@@@..8
     c1d:	68 20 40 e0 40 40 40 40 e0 12 38 68 40 a0 e0 40     h @.@@@@..8h@..@
     c2d:	40 40 40 e0 12 38 68 a0 00 e0 40 40 40 40 e0 02     @@@..8h...@@@@..
     c3d:	57 67 f0 48 48 e8 48 48 f0 02 58 68 28 50 88 c8     Wg.HH.HH..Xh(P..
     c4d:	a8 98 88 88 02 58 68 40 20 70 88 88 88 88 70 02     .....Xh@ p....p.
     c5d:	58 68 10 20 70 88 88 88 88 70 02 58 68 20 50 70     Xh. p....p.Xh Pp
     c6d:	88 88 88 88 70 02 58 68 28 50 70 88 88 88 88 70     ....p.Xh(Pp....p
     c7d:	02 58 68 50 00 70 88 88 88 88 70 02 55 65 88 50     .XhP.p....p.Ue.P
     c8d:	20 50 88 02 57 67 70 98 98 a8 c8 c8 70 02 58 68      P..Wgp.....p.Xh
     c9d:	40 20 88 88 88 88 88 70 02 58 68 10 20 88 88 88     @ .....p.Xh. ...
     cad:	88 88 70 02 58 68 20 50 00 88 88 88 88 70 02 58     ..p.Xh P.....p.X
     cbd:	68 50 00 88 88 88 88 88 70 02 58 68 10 20 88 88     hP......p.Xh. ..
     ccd:	50 20 20 20 02 57 67 80 f0 88 f0 80 80 80 02 57     P   .Wg........W
     cdd:	67 70 88 90 a0 90 88 b0 02 58 68 40 20 00 70 08     gp.......Xh@ .p.
     ced:	78 88 78 02 58 68 10 20 00 70 08 78 88 78 02 58     x.x.Xh. .p.x.x.X
     cfd:	68 20 50 00 70 08 78 88 78 02 58 68 28 50 00 70     h P.p.x.x.Xh(P.p
     d0d:	08 78 88 78 02 57 67 50 00 70 08 78 88 78 02 58     .x.x.WgP.p.x.x.X
     d1d:	68 20 50 20 70 08 78 88 78 02 65 65 78 14 7c 90     h P p.x.x.eex.|.
     d2d:	7c 00 57 67 70 88 80 88 70 20 40 02 58 68 40 20     |.Wgp...p @.Xh@ 
     d3d:	00 70 88 f8 80 70 02 58 68 10 20 00 70 88 f8 80     .p...p.Xh. .p...
     d4d:	70 02 58 68 20 50 00 70 88 f8 80 70 02 57 67 50     p.Xh P.p...p.WgP
     d5d:	00 70 88 f8 80 70 12 38 68 80 40 00 c0 40 40 40     .p...p.8h.@..@@@
     d6d:	e0 12 38 68 40 80 00 c0 40 40 40 e0 12 38 68 40     ..8h@...@@@..8h@
     d7d:	a0 00 c0 40 40 40 e0 12 37 67 a0 00 c0 40 40 40     ...@@@..7g...@@@
     d8d:	e0 02 57 67 c0 30 70 88 88 88 70 02 58 68 28 50     ..Wg.0p...p.Xh(P
     d9d:	00 b0 c8 88 88 88 02 58 68 40 20 00 70 88 88 88     .......Xh@ .p...
     dad:	70 02 58 68 10 20 00 70 88 88 88 70 02 58 68 20     p.Xh. .p...p.Xh 
     dbd:	50 00 70 88 88 88 70 02 58 68 28 50 00 70 88 88     P.p...p.Xh(P.p..
     dcd:	88 70 02 57 67 50 00 70 88 88 88 70 03 55 65 20     .p.WgP.p...p.Ue 
     ddd:	00 f8 00 20 02 55 65 78 98 a8 c8 f0 02 58 68 40     ... .Uex.....Xh@
     ded:	20 00 88 88 88 98 68 02 58 68 10 20 00 88 88 88      .....h.Xh. ....
     dfd:	98 68 02 58 68 20 50 00 88 88 88 98 68 02 57 67     .h.Xh P.....h.Wg
     e0d:	50 00 88 88 88 98 68 00 59 69 10 20 88 88 98 68     P.....h.Yi. ...h
     e1d:	08 88 70 00 58 68 80 f0 88 88 88 f0 80 80 00 59     ..p.Xh.........Y
     e2d:	69 50 00 88 88 98 68 08 88 70                       iP....h..p

00000e37 <u8g_font_5x7>:
     e37:	01 05 07 00 ff 06 01 15 02 27 20 ff ff 06 ff 06     .........' .....
     e47:	ff 08 00 50 22 16 56 80 80 80 80 00 80 15 33 53     ...P".V.......3S
     e57:	a0 a0 a0 02 55 55 50 f8 50 f8 50 02 55 55 70 a0     ....UUP.P.P.UUp.
     e67:	70 28 70 02 46 56 80 90 20 40 90 10 02 45 55 40     p(p.FV.. @...EU@
     e77:	a0 40 a0 50 25 13 53 80 80 80 12 26 56 40 80 80     .@.P%.S....&V@..
     e87:	80 80 40 12 26 56 80 40 40 40 40 80 12 35 55 a0     ..@.&V.@@@@..5U.
     e97:	40 e0 40 a0 02 55 55 20 20 f8 20 20 11 33 53 60     @.@..UU  .  .3S`
     ea7:	40 80 04 41 51 f0 12 22 52 c0 c0 03 44 54 10 20     @..AQ.."R...DT. 
     eb7:	40 80 12 36 56 40 a0 a0 a0 a0 40 12 36 56 40 c0     @..6V@....@.6V@.
     ec7:	40 40 40 e0 02 46 56 60 90 10 20 40 f0 02 46 56     @@@..FV`.. @..FV
     ed7:	f0 10 60 10 90 60 02 46 56 20 60 a0 f0 20 20 02     ..`..`.FV `..  .
     ee7:	46 56 f0 80 e0 10 90 60 02 46 56 60 80 e0 90 90     FV.....`.FV`....
     ef7:	60 02 46 56 f0 10 20 20 40 40 02 46 56 60 90 60     `.FV..  @@.FV`.`
     f07:	90 90 60 02 46 56 60 90 90 70 10 60 12 25 55 c0     ..`.FV`..p.`.%U.
     f17:	c0 00 c0 c0 01 36 56 60 60 00 60 40 80 12 35 55     .....6V``.`@..5U
     f27:	20 40 80 40 20 03 43 53 f0 00 f0 12 35 55 80 40      @.@ .CS....5U.@
     f37:	20 40 80 12 36 56 40 a0 20 40 00 40 02 46 56 60      @..6V@. @.@.FV`
     f47:	90 b0 b0 80 60 02 46 56 60 90 90 f0 90 90 02 46     ....`.FV`......F
     f57:	56 e0 90 e0 90 90 e0 02 46 56 60 90 80 80 90 60     V.......FV`....`
     f67:	02 46 56 e0 90 90 90 90 e0 02 46 56 f0 80 e0 80     .FV.......FV....
     f77:	80 f0 02 46 56 f0 80 e0 80 80 80 02 46 56 60 90     ...FV.......FV`.
     f87:	80 b0 90 70 02 46 56 90 90 f0 90 90 90 12 36 56     ...p.FV.......6V
     f97:	e0 40 40 40 40 e0 02 46 56 10 10 10 10 90 60 02     .@@@@..FV.....`.
     fa7:	46 56 90 a0 c0 c0 a0 90 02 46 56 80 80 80 80 80     FV.......FV.....
     fb7:	f0 02 46 56 90 f0 f0 90 90 90 02 46 56 90 d0 d0     ..FV.......FV...
     fc7:	b0 b0 90 02 46 56 60 90 90 90 90 60 02 46 56 e0     ....FV`....`.FV.
     fd7:	90 90 e0 80 80 01 47 57 60 90 90 90 d0 60 10 02     ......GW`....`..
     fe7:	46 56 e0 90 90 e0 a0 90 02 46 56 60 90 40 20 90     FV.......FV`.@ .
     ff7:	60 12 36 56 e0 40 40 40 40 40 02 46 56 90 90 90     `.6V.@@@@@.FV...
    1007:	90 90 60 02 46 56 90 90 90 90 60 60 02 46 56 90     ..`.FV....``.FV.
    1017:	90 90 f0 f0 90 02 46 56 90 90 60 60 90 90 12 36     ......FV..``...6
    1027:	56 a0 a0 a0 40 40 40 02 46 56 f0 10 20 40 80 f0     V...@@@.FV.. @..
    1037:	12 36 56 e0 80 80 80 80 e0 03 44 54 80 40 20 10     .6V.......DT.@ .
    1047:	12 36 56 e0 20 20 20 20 e0 16 32 52 40 a0 02 41     .6V.    ..2R@..A
    1057:	51 f0 16 22 52 80 40 02 44 54 70 90 b0 50 02 46     Q.."R.@.DTp..P.F
    1067:	56 80 80 e0 90 90 e0 02 34 54 60 80 80 60 02 46     V.......4T`..`.F
    1077:	56 10 10 70 90 90 70 02 44 54 60 b0 c0 60 02 46     V..p..p.DT`..`.F
    1087:	56 20 50 40 e0 40 40 01 45 55 70 90 60 80 70 02     V P@.@@.EUp.`.p.
    1097:	46 56 80 80 e0 90 90 90 12 36 56 40 00 c0 40 40     FV.......6V@..@@
    10a7:	e0 11 37 57 20 00 20 20 20 a0 40 02 46 56 80 80     ..7W .   .@.FV..
    10b7:	a0 c0 a0 90 12 36 56 c0 40 40 40 40 e0 02 44 54     .....6V.@@@@..DT
    10c7:	a0 f0 90 90 02 44 54 e0 90 90 90 02 44 54 60 90     .....DT.....DT`.
    10d7:	90 60 01 45 55 e0 90 90 e0 80 01 45 55 70 90 90     .`.EU......EUp..
    10e7:	70 10 02 44 54 e0 90 80 80 02 44 54 70 c0 30 e0     p..DT.....DTp.0.
    10f7:	02 46 56 40 40 e0 40 40 30 02 44 54 90 90 90 70     .FV@@.@@0.DT...p
    1107:	12 34 54 a0 a0 a0 40 02 44 54 90 90 f0 f0 02 44     .4T...@.DT.....D
    1117:	54 90 60 60 90 01 45 55 90 90 50 20 40 02 44 54     T.``..EU..P @.DT
    1127:	f0 20 40 f0 12 36 56 20 40 c0 40 40 20 22 16 56     . @..6V @.@@ ".V
    1137:	80 80 80 80 80 80 12 36 56 80 40 60 40 40 80 06     .......6V.@`@@..
    1147:	42 52 50 a0 ff ff ff ff ff ff ff ff ff ff ff ff     BRP.............
    1157:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1167:	ff ff ff ff ff 08 00 50 22 16 56 80 00 80 80 80     .......P".V.....
    1177:	80 01 46 56 20 70 a0 a0 70 20 02 45 55 30 40 e0     ..FV p..p .EU0@.
    1187:	40 b0 02 55 55 88 70 50 70 88 12 36 56 a0 a0 40     @..UU.pPp..6V..@
    1197:	e0 40 40 22 15 55 80 80 00 80 80 11 37 57 60 80     .@@".U......7W`.
    11a7:	c0 a0 60 20 c0 17 31 51 a0 01 57 57 70 88 a8 c8     ..` ..1Q..WWp...
    11b7:	a8 88 70 05 33 53 60 a0 60 03 53 53 48 90 48 03     ..p.3S`.`.SSH.H.
    11c7:	42 52 f0 10 14 31 51 e0 01 57 57 70 88 e8 c8 c8     BR...1Q..WWp....
    11d7:	88 70 07 41 51 f0 15 33 53 40 a0 40 02 56 56 20     .p.AQ..3S@.@.VV 
    11e7:	20 f8 20 20 f8 14 24 54 c0 40 80 c0 14 24 54 c0      .  ..$T.@...$T.
    11f7:	c0 40 c0 16 22 52 40 80 01 45 55 90 90 90 e0 80     .@.."R@..EU.....
    1207:	02 46 56 70 d0 d0 50 50 50 14 22 52 c0 c0 11 22     .FVp..PPP."R..."
    1217:	52 40 80 14 34 54 40 c0 40 e0 05 33 53 40 a0 40     R@..4T@.@..3S@.@
    1227:	03 53 53 90 48 90 01 47 57 80 80 80 90 30 70 10     .SS.H..GW....0p.
    1237:	01 47 57 80 80 80 b0 10 20 30 01 47 57 c0 c0 40     .GW..... 0.GW..@
    1247:	d0 30 70 10 12 36 56 40 00 40 80 a0 40 02 46 56     .0p..6V@.@..@.FV
    1257:	60 90 90 f0 90 90 02 46 56 60 90 90 f0 90 90 02     `......FV`......
    1267:	46 56 60 90 90 f0 90 90 02 46 56 60 90 90 f0 90     FV`......FV`....
    1277:	90 02 46 56 90 60 90 f0 90 90 02 46 56 60 60 90     ..FV.`.....FV``.
    1287:	f0 90 90 02 46 56 70 a0 b0 e0 a0 b0 01 47 57 60     ....FVp......GW`
    1297:	90 80 80 90 60 40 02 46 56 f0 80 e0 80 80 f0 02     ....`@.FV.......
    12a7:	46 56 f0 80 e0 80 80 f0 02 46 56 f0 80 e0 80 80     FV.......FV.....
    12b7:	f0 02 46 56 f0 80 e0 80 80 f0 12 36 56 e0 40 40     ..FV.......6V.@@
    12c7:	40 40 e0 12 36 56 e0 40 40 40 40 e0 12 36 56 e0     @@..6V.@@@@..6V.
    12d7:	40 40 40 40 e0 12 36 56 e0 40 40 40 40 e0 02 46     @@@@..6V.@@@@..F
    12e7:	56 e0 50 d0 50 50 e0 02 46 56 b0 90 d0 b0 b0 90     V.P.PP..FV......
    12f7:	02 46 56 60 90 90 90 90 60 02 46 56 60 90 90 90     .FV`....`.FV`...
    1307:	90 60 02 46 56 60 90 90 90 90 60 02 46 56 60 90     .`.FV`....`.FV`.
    1317:	90 90 90 60 02 46 56 90 60 90 90 90 60 02 44 54     ...`.FV.`...`.DT
    1327:	90 60 60 90 02 46 56 70 b0 b0 d0 d0 e0 02 46 56     .``..FVp......FV
    1337:	90 90 90 90 90 60 02 46 56 90 90 90 90 90 60 02     .....`.FV.....`.
    1347:	46 56 90 90 90 90 90 60 02 46 56 90 00 90 90 90     FV.....`.FV.....
    1357:	60 12 36 56 a0 a0 a0 40 40 40 02 46 56 80 e0 90     `.6V...@@@.FV...
    1367:	e0 80 80 02 46 56 60 90 a0 90 90 a0 02 46 56 40     ....FV`......FV@
    1377:	20 70 90 b0 50 02 46 56 20 40 70 90 b0 50 02 46      p..P.FV @p..P.F
    1387:	56 20 50 70 90 b0 50 02 46 56 50 a0 70 90 b0 50     V Pp..P.FVP.p..P
    1397:	02 46 56 50 00 70 90 b0 50 02 46 56 60 60 70 90     .FVP.p..P.FV``p.
    13a7:	b0 50 02 44 54 70 b0 a0 70 11 35 55 60 80 80 60     .P.DTp..p.5U`..`
    13b7:	40 02 46 56 40 20 60 b0 c0 60 02 46 56 20 40 60     @.FV@ `..`.FV @`
    13c7:	b0 c0 60 02 46 56 40 a0 60 b0 c0 60 02 46 56 a0     ..`.FV@.`..`.FV.
    13d7:	00 60 b0 c0 60 12 36 56 80 40 c0 40 40 e0 12 36     .`..`.6V.@.@@..6
    13e7:	56 40 80 c0 40 40 e0 12 36 56 40 a0 c0 40 40 e0     V@..@@..6V@..@@.
    13f7:	12 36 56 a0 00 c0 40 40 e0 02 46 56 40 30 60 90     .6V...@@..FV@0`.
    1407:	90 60 02 46 56 50 a0 e0 90 90 90 02 46 56 40 20     .`.FVP......FV@ 
    1417:	60 90 90 60 02 46 56 20 40 60 90 90 60 02 46 56     `..`.FV @`..`.FV
    1427:	60 00 60 90 90 60 02 46 56 50 a0 60 90 90 60 02     `.`..`.FVP.`..`.
    1437:	46 56 50 00 60 90 90 60 02 45 55 60 00 f0 00 60     FVP.`..`.EU`...`
    1447:	02 44 54 70 b0 d0 e0 02 46 56 40 20 90 90 90 70     .DTp....FV@ ...p
    1457:	02 46 56 20 40 90 90 90 70 02 46 56 60 00 90 90     .FV @...p.FV`...
    1467:	90 70 02 46 56 50 00 90 90 90 70 01 47 57 20 40     .p.FVP....p.GW @
    1477:	90 90 50 20 40 01 46 56 80 e0 90 90 e0 80 01 47     ..P @.FV.......G
    1487:	57 50 00 90 90 50 20 40                             WP...P @

0000148f <u8g_font_4x6>:
    148f:	01 04 06 00 ff 05 01 03 01 fa 20 ff ff 05 ff 05     .......... .....
    149f:	ff 07 00 40 12 15 45 80 80 80 00 80 05 32 42 a0     ...@..E......2B.
    14af:	a0 02 45 45 a0 f0 a0 f0 a0 01 36 46 40 e0 c0 20     ..EE......6F@.. 
    14bf:	e0 40 02 35 45 80 20 40 80 20 02 45 45 40 a0 40     .@.5E. @. .EE@.@
    14cf:	a0 50 15 12 42 80 80 11 26 46 40 80 80 80 80 40     .P..B...&F@....@
    14df:	01 26 46 80 40 40 40 40 80 02 35 45 a0 40 e0 40     .&F.@@@@..5E.@.@
    14ef:	a0 02 35 45 40 40 e0 40 40 01 22 42 40 80 04 31     ..5E@@.@@."B@..1
    14ff:	41 e0 12 11 41 80 02 35 45 20 20 40 80 80 02 35     A...A..5E  @...5
    150f:	45 40 a0 e0 a0 40 02 35 45 40 c0 40 40 e0 02 35     E@...@.5E@.@@..5
    151f:	45 40 a0 20 40 e0 02 35 45 e0 20 40 20 c0 02 35     E@. @..5E. @ ..5
    152f:	45 a0 a0 e0 20 20 02 35 45 e0 80 c0 20 c0 02 35     E...  .5E... ..5
    153f:	45 60 80 c0 a0 40 02 35 45 e0 20 40 80 80 02 35     E`...@.5E. @...5
    154f:	45 60 a0 40 a0 c0 02 35 45 40 a0 60 20 c0 12 14     E`.@...5E@.` ...
    155f:	44 80 00 00 80 01 25 45 40 00 00 40 80 02 35 45     D.....%E@..@..5E
    156f:	20 40 80 40 20 03 33 43 e0 00 e0 02 35 45 80 40      @.@ .3C....5E.@
    157f:	20 40 80 02 35 45 c0 20 40 00 40 02 35 45 60 a0      @..5E. @.@.5E`.
    158f:	a0 80 60 02 35 45 40 a0 e0 a0 a0 02 35 45 c0 a0     ..`.5E@.....5E..
    159f:	c0 a0 c0 02 35 45 40 a0 80 a0 40 02 35 45 c0 a0     ....5E@...@.5E..
    15af:	a0 a0 c0 02 35 45 e0 80 c0 80 e0 02 35 45 e0 80     ....5E......5E..
    15bf:	c0 80 80 02 35 45 60 80 a0 a0 60 02 35 45 a0 a0     ....5E`...`.5E..
    15cf:	e0 a0 a0 02 35 45 e0 40 40 40 e0 02 35 45 20 20     ....5E.@@@..5E  
    15df:	20 a0 40 02 35 45 a0 a0 c0 a0 a0 02 35 45 80 80      .@.5E......5E..
    15ef:	80 80 e0 02 35 45 a0 e0 e0 a0 a0 02 35 45 20 a0     ....5E......5E .
    15ff:	e0 a0 80 02 35 45 40 a0 a0 a0 40 02 35 45 c0 a0     ....5E@...@.5E..
    160f:	c0 80 80 01 36 46 40 a0 a0 a0 40 20 02 35 45 c0     ....6F@...@ .5E.
    161f:	a0 c0 a0 a0 02 35 45 60 80 40 20 c0 02 35 45 e0     .....5E`.@ ..5E.
    162f:	40 40 40 40 02 35 45 a0 a0 a0 a0 e0 02 35 45 a0     @@@@.5E......5E.
    163f:	a0 a0 e0 40 02 35 45 a0 a0 e0 e0 a0 02 35 45 a0     ...@.5E......5E.
    164f:	a0 40 a0 a0 02 35 45 a0 a0 40 40 40 02 35 45 e0     .@...5E..@@@.5E.
    165f:	20 40 80 e0 12 25 45 c0 80 80 80 c0 02 35 45 80      @...%E......5E.
    166f:	80 40 20 20 02 25 45 c0 40 40 40 c0 05 32 42 40     .@  .%E.@@@..2B@
    167f:	a0 01 31 41 e0 15 22 42 80 40 02 34 44 60 a0 a0     ..1A.."B.@.4D`..
    168f:	60 02 35 45 80 c0 a0 a0 c0 02 34 44 60 80 80 60     `.5E......4D`..`
    169f:	02 35 45 20 60 a0 a0 60 02 34 44 40 a0 c0 60 02     .5E `..`.4D@..`.
    16af:	35 45 20 40 e0 40 40 01 35 45 60 a0 60 20 c0 02     5E @.@@.5E`.` ..
    16bf:	35 45 80 c0 a0 a0 a0 02 35 45 40 00 c0 40 e0 01     5E......5E@..@..
    16cf:	36 46 20 00 20 20 20 c0 02 35 45 80 a0 c0 a0 a0     6F .   ..5E.....
    16df:	02 35 45 c0 40 40 40 e0 02 34 44 a0 e0 a0 a0 02     .5E.@@@..4D.....
    16ef:	34 44 c0 a0 a0 a0 02 34 44 40 a0 a0 40 01 35 45     4D.....4D@..@.5E
    16ff:	c0 a0 c0 80 80 01 35 45 60 a0 a0 60 20 02 34 44     ......5E`..` .4D
    170f:	a0 c0 80 80 02 34 44 60 c0 20 c0 02 35 45 40 e0     .....4D`. ..5E@.
    171f:	40 40 20 02 34 44 a0 a0 a0 60 02 34 44 a0 a0 a0     @@ .4D...`.4D...
    172f:	40 02 34 44 a0 a0 e0 a0 02 34 44 a0 40 40 a0 01     @.4D.....4D.@@..
    173f:	35 45 a0 a0 60 20 c0 02 34 44 e0 20 40 e0 01 36     5E..` ..4D. @..6
    174f:	46 20 40 c0 40 40 20 12 15 45 80 80 80 80 80 01     F @.@@ ..E......
    175f:	36 46 80 40 60 40 40 80 05 42 42 50 a0 ff ff ff     6F.@`@@..BBP....
    176f:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    177f:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff 07 00     ................
    178f:	40 12 15 45 80 00 80 80 80 02 35 45 40 e0 80 e0     @..E......5E@...
    179f:	40 02 35 45 20 40 60 40 a0 02 44 44 90 60 60 90     @.5E @`@..DD.``.
    17af:	02 35 45 a0 40 e0 40 40 12 15 45 80 80 00 80 80     .5E.@.@@..E.....
    17bf:	01 36 46 60 c0 a0 60 20 c0 06 31 41 a0 01 46 46     .6F`..` ..1A..FF
    17cf:	60 90 d0 d0 90 60 02 35 45 60 a0 60 00 e0 03 43     `....`.5E`.`...C
    17df:	43 50 a0 50 03 32 42 e0 20 04 31 41 e0 03 44 44     CP.P.2B. .1A..DD
    17ef:	60 f0 d0 60 06 31 41 e0 04 33 43 40 a0 40 02 35     `..`.1A..3C@.@.5
    17ff:	45 40 e0 40 00 e0 03 24 44 c0 40 80 c0 02 25 45     E@.@...$D.@...%E
    180f:	c0 40 80 40 80 15 22 42 40 80 01 35 45 a0 a0 a0     .@.@.."B@..5E...
    181f:	c0 80 02 45 45 70 d0 d0 50 50 14 11 41 80 12 22     ...EEp..PP..A.."
    182f:	42 40 80 03 24 44 40 c0 40 40 02 35 45 40 a0 40     B@..$D@.@@.5E@.@
    183f:	00 e0 03 43 43 a0 50 a0 01 46 46 80 80 80 50 70     ...CC.P..FF...Pp
    184f:	10 01 46 46 80 80 b0 10 20 30 01 46 46 c0 40 80     ..FF.... 0.FF.@.
    185f:	50 b0 10 02 35 45 40 00 40 80 60 02 35 45 80 40     P...5E@.@.`.5E.@
    186f:	a0 e0 a0 02 35 45 20 40 a0 e0 a0 02 35 45 c0 40     ....5E @....5E.@
    187f:	a0 e0 a0 02 35 45 60 c0 a0 e0 a0 02 35 45 a0 40     ....5E`.....5E.@
    188f:	a0 e0 a0 02 35 45 40 40 a0 e0 a0 02 45 45 70 a0     ....5E@@....EEp.
    189f:	f0 a0 b0 01 36 46 40 a0 80 a0 40 80 02 35 45 80     ....6F@...@..5E.
    18af:	e0 c0 80 e0 02 35 45 20 e0 c0 80 e0 02 35 45 60     .....5E .....5E`
    18bf:	e0 c0 80 e0 02 35 45 a0 e0 c0 80 e0 02 35 45 80     .....5E......5E.
    18cf:	e0 40 40 e0 02 35 45 20 e0 40 40 e0 02 35 45 40     .@@..5E .@@..5E@
    18df:	e0 40 40 e0 02 35 45 a0 40 40 40 e0 02 45 45 e0     .@@..5E.@@@..EE.
    18ef:	50 d0 50 e0 02 45 45 50 a0 e0 e0 a0 02 35 45 80     P.P..EEP.....5E.
    18ff:	40 a0 a0 40 02 35 45 20 40 a0 a0 40 02 35 45 40     @..@.5E @..@.5E@
    190f:	40 a0 a0 40 02 45 45 70 e0 a0 a0 40 02 35 45 a0     @..@.EEp...@.5E.
    191f:	40 a0 a0 40 03 33 43 a0 40 a0 02 35 45 60 a0 e0     @..@.3C.@..5E`..
    192f:	a0 c0 02 35 45 80 40 a0 a0 e0 02 35 45 20 40 a0     ...5E.@....5E @.
    193f:	a0 e0 02 35 45 40 00 a0 a0 e0 02 35 45 a0 00 a0     ...5E@.....5E...
    194f:	a0 e0 02 35 45 20 00 a0 40 40 02 35 45 80 c0 a0     ...5E ..@@.5E...
    195f:	c0 80 01 36 46 40 a0 c0 a0 e0 80 02 35 45 80 40     ...6F@......5E.@
    196f:	60 a0 60 02 35 45 20 40 60 a0 60 02 35 45 60 00     `.`.5E @`.`.5E`.
    197f:	60 a0 60 02 45 45 50 a0 60 a0 60 02 35 45 a0 00     `.`.EEP.`.`.5E..
    198f:	60 a0 60 02 35 45 40 00 60 a0 60 02 44 44 70 b0     `.`.5E@.`.`.DDp.
    199f:	a0 70 01 35 45 40 a0 80 60 40 02 35 45 80 40 a0     .p.5E@..`@.5E.@.
    19af:	c0 60 02 35 45 20 40 a0 c0 60 02 35 45 c0 40 a0     .`.5E @..`.5E.@.
    19bf:	c0 60 02 35 45 a0 40 a0 c0 60 02 35 45 80 40 40     .`.5E.@..`.5E.@@
    19cf:	40 e0 02 35 45 20 c0 40 40 e0 02 35 45 40 a0 40     @..5E .@@..5E@.@
    19df:	40 e0 02 35 45 a0 00 c0 40 e0 02 35 45 a0 40 60     @..5E...@..5E.@`
    19ef:	a0 40 02 45 45 50 a0 c0 a0 a0 02 35 45 80 40 40     .@.EEP.....5E.@@
    19ff:	a0 40 02 35 45 20 40 40 a0 40 02 35 45 40 00 40     .@.5E @@.@.5E@.@
    1a0f:	a0 40 02 35 45 e0 00 40 a0 40 02 35 45 a0 00 40     .@.5E..@.@.5E..@
    1a1f:	a0 40 02 35 45 40 00 e0 00 40 02 34 44 60 a0 a0     .@.5E@...@.4D`..
    1a2f:	c0 02 35 45 80 40 a0 a0 60 02 35 45 20 40 a0 a0     ..5E.@..`.5E @..
    1a3f:	60 02 35 45 40 00 a0 a0 60 02 35 45 a0 00 a0 a0     `.5E@...`.5E....
    1a4f:	60 01 36 46 20 40 a0 e0 20 c0 01 36 46 80 80 c0     `.6F @.. ..6F...
    1a5f:	a0 c0 80 01 36 46 a0 00 a0 e0 20 c0                 ....6F.... .

00001a6b <__c.4245>:
    1a6b:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1a7b:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1a8b:	64 69 73 70 2e 30 36 5d 3a 44 45 46 41 55 4c 54     disp.06]:DEFAULT
    1a9b:	5f 43 41 53 45 00                                   _CASE.

00001aa1 <__c.4243>:
    1aa1:	0a 0d 00                                            ...

00001aa4 <__c.4232>:
    1aa4:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1ab4:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1ac4:	64 69 73 70 2e 30 35 5d 3a 44 45 46 41 55 4c 54     disp.05]:DEFAULT
    1ad4:	5f 43 41 53 45 00                                   _CASE.

00001ada <__c.4230>:
    1ada:	0a 0d 00                                            ...

00001add <__c.4221>:
    1add:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1aed:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1afd:	64 69 73 70 2e 30 34 5d 3a 44 45 46 41 55 4c 54     disp.04]:DEFAULT
    1b0d:	5f 43 41 53 45 00                                   _CASE.

00001b13 <__c.4219>:
    1b13:	0a 0d 00                                            ...

00001b16 <__c.4205>:
    1b16:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1b26:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1b36:	64 69 73 70 2e 30 33 5d 3a 44 45 46 41 55 4c 54     disp.03]:DEFAULT
    1b46:	5f 43 41 53 45 00                                   _CASE.

00001b4c <__c.4203>:
    1b4c:	0a 0d 00                                            ...

00001b4f <__c.4162>:
    1b4f:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1b5f:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1b6f:	64 69 73 70 2e 30 32 5d 3a 44 45 46 41 55 4c 54     disp.02]:DEFAULT
    1b7f:	5f 43 41 53 45 00                                   _CASE.

00001b85 <__c.4160>:
    1b85:	0a 0d 00                                            ...

00001b88 <__c.4108>:
    1b88:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    1b98:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    1ba8:	64 69 73 70 2e 30 31 5d 3a 44 45 46 41 55 4c 54     disp.01]:DEFAULT
    1bb8:	5f 43 41 53 45 00                                   _CASE.

00001bbe <__c.4106>:
    1bbe:	0a 0d 00                                            ...

00001bc1 <logo_rcj>:
    1bc1:	02 00 78 00 00 00 00 00 00 00 00 00 00 02 00 fc     ..x.............
	...
    1bd9:	00 00 07 00 bf 00 00 00 00 00 00 00 00 00 00 0f     ................
    1be9:	00 be 00 00 00 00 00 00 00 00 00 00 de 01 ff 00     ................
	...
    1c01:	00 de 01 fb 00 00 00 00 00 00 00 00 00 00 fc 01     ................
    1c11:	7e 00 00 00 00 00 00 00 00 00 00 f8 00 f8 00 00     ~...............
	...
    1c29:	f8 07 e0 00 00 00 00 00 00 00 00 00 00 fe 3d c0     ..............=.
    1c39:	01 00 00 00 00 00 00 00 00 00 9f 1f c0 03 00 00     ................
    1c49:	00 00 00 00 00 00 00 02 0e 80 07 00 00 00 00 00     ................
    1c59:	00 00 00 00 00 20 9e 03 00 00 00 00 00 00 c0 44     ..... .........D
    1c69:	04 00 60 bf 01 00 00 00 00 00 00 80 6a 06 00 80     ..`.........j...
    1c79:	71 0c 00 00 00 00 00 00 c0 4a 07 00 80 78 0e f0     q........J...x..
    1c89:	07 80 01 00 f8 43 4a 04 00 c0 6c 14 38 0f 80 01     .....CJ...l.8...
    1c99:	00 fc c1 44 04 00 c0 de 2c 18 0c 80 01 00 0e 00     ...D....,.......
    1ca9:	00 00 00 80 af 68 18 0c 80 03 00 06 00 00 00 00     .....h..........
    1cb9:	00 cb 58 38 8e 8f 1f 3e 06 18 e3 03 00 00 7c 70     ..X8...>......|p
    1cc9:	f8 cf 99 33 67 06 1c 73 07 00 00 7c 6c f8 c7 b8     ...3g..s...|l...
    1cd9:	73 e3 06 1c 33 06 00 00 e8 4f 18 c7 b8 71 e3 06     s...3....O...q..
    1ce9:	1c 3b 06 00 00 fc 3a 18 ce b8 71 e3 0e 1c 3b 06     .;....:...q...;.
    1cf9:	00 00 ff 2e 18 ce b9 73 67 1c 18 3b 06 00 80 cf     .......sg..;....
    1d09:	15 18 9c 1f 3f 7e f8 fb fb 03 00 e0 80 0f 10 18     ....?~..........
    1d19:	0f 1e 3c f0 f1 f9 01 00 b0 81 06 00 00 00 00 00     ..<.............
    1d29:	00 00 38 00 00 78 81 05 00 00 00 00 00 00 00 30     ..8..x.........0
    1d39:	00 00 d8 81 07 20 00 e0 00 00 00 0e 00 05 00 b4     ..... ..........
    1d49:	01 07 20 30 b0 01 00 00 1a 00 04 00 ec 8d 03 20     .. 0........... 
    1d59:	01 b1 6d 23 00 de 60 05 00 78 ff 02 a0 ba f2 2e     ..m#..`..x......
    1d69:	51 07 52 4e 05 00 58 dc 02 b0 aa 32 c6 56 05 56     Q.RN..X....2.V.V
    1d79:	2a 05 00 38 88 02 18 19 31 6c 23 43 5e 66 05 00     *..8....1l#C^f..
    1d89:	3c 18 03 00 00 00 00 00 00 00 00 00 00 1c 10 03     <...............
	...
    1da1:	00 00 1c f0 01 00 00 00 00 00 00 00 00 00 00 14     ................
    1db1:	c8 01 00 00 00 00 00 00 00 00 00 00 28 6c 00 00     ............(l..
	...
    1dc9:	00 28 38 00 00 00 00 00 00 00 00 00 00 00 30 18     .(8...........0.
	...

00001de3 <logo_rios>:
    1de3:	ff ff 3f 00 f8 0f 00 f8 ff ff 00 00 fe ff 03 ff     ..?.............
    1df3:	ff ff 01 f8 0f 00 ff ff ff 03 80 ff ff 0f ff ff     ................
    1e03:	ff 07 f8 0f c0 ff ff ff 0f e0 ff ff 0f ff ff ff     ................
    1e13:	0f f8 0f e0 ff 87 ff 1f f0 7f e0 0f ff 01 fc 0f     ................
    1e23:	f8 0f f8 3f 00 f0 7f f0 3f 00 00 ff 01 fc 0f f8     ...?....?.......
    1e33:	0f fc 1f 00 e0 ff f0 3f 00 00 ff 01 fc 0f f8 0f     .......?........
    1e43:	fc 0f 00 c0 ff f0 ff 01 00 ff 81 ff 07 f8 0f fc     ................
    1e53:	0f 00 c0 ff e0 ff 3f 00 ff ff ff 01 f8 0f fc 0f     ......?.........
    1e63:	00 c0 ff 80 ff ff 03 ff ff 3f 00 f8 0f fc 0f 00     .........?......
    1e73:	c0 ff 00 fe ff 0f ff ff 7f 00 f8 0f fc 0f 00 c0     ................
    1e83:	ff 00 f0 ff 1f ff 81 ff 01 f8 0f fc 0f 00 c0 ff     ................
    1e93:	00 00 f8 3f ff 01 ff 03 f8 0f fc 0f 00 e0 7f 00     ...?............
    1ea3:	00 f0 3f ff 01 fe 07 f8 0f f8 3f 00 f0 3f 00 00     ..?.......?..?..
    1eb3:	f0 3f ff 01 fc 0f f8 0f f0 ff 00 fe 1f f8 01 f8     .?..............
    1ec3:	1f ff 01 fc 1f f8 0f c0 ff ff ff 0f f8 ff ff 0f     ................
    1ed3:	ff 01 f8 3f f8 0f 80 ff ff ff 03 f0 ff ff 03 ff     ...?............
    1ee3:	01 f0 3f f8 0f 00 fc ff 3f 00 c0 ff ff 00 ff 01     ..?.....?.......
    1ef3:	e0 3f e0 07 00 f8 ff 3f 00 c0 ff ff 00 ff 01 f0     .?.....?........
    1f03:	3f f8 0f 00 ff ff ff 01 f0 ff ff 03 ff 01 f8 1f     ?...............
    1f13:	f8 0f c0 ff ff ff 07 f8 ff ff 0f ff 01 fc 0f f8     ................
    1f23:	0f f0 ff 87 ff 1f f8 0f fc 1f ff 01 fe 07 f8 0f     ................
    1f33:	f8 1f 00 f0 3d 30 00 f0 3f ff 01 ff 03 f8 0f b8     ....=0..?.......
    1f43:	0f 00 e0 4f 00 00 f0 3f db 81 ff 01 68 0e 54 0c     ...O...?....h.T.
    1f53:	00 80 77 00 00 f8 3f 1f bc 79 00 00 08 2c 01 00     ..w...?..y...,..
    1f63:	00 41 00 00 f0 1d 06 10 12 00 00 0c 04 00 00 00     .A..............
    1f73:	00 00 80 81 01 27 00 16 00 18 00 04 04 00 00 00     .....'..........
    1f83:	00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 40     ...............@
    1f93:	00 00 00                                            ...

00001f96 <warning>:
    1f96:	00 00 80 ff 1f 00 00 00 00 00 f0 ff ff 00 00 00     ................
    1fa6:	00 00 fe ff ff 07 00 00 00 80 ff ff ff 1f 00 00     ................
    1fb6:	00 c0 ff ff ff 3f 00 00 00 f0 ff ff ff ff 00 00     .....?..........
    1fc6:	00 f8 ff ff ff ff 01 00 00 fc ff ff ff ff 03 00     ................
    1fd6:	00 fe ff ff ff ff 07 00 00 ff ff ff ff ff 0f 00     ................
    1fe6:	80 ff ff 03 fc ff 1f 00 c0 ff ff 03 fc ff 3f 00     ..............?.
    1ff6:	e0 ff ff 03 fc ff 7f 00 e0 ff ff 03 fc ff 7f 00     ................
    2006:	f0 ff ff 03 fc ff ff 00 f8 ff ff 03 fc ff ff 00     ................
    2016:	f8 ff ff 03 fc ff ff 01 f8 ff ff 03 fc ff ff 01     ................
    2026:	fc ff ff 03 fc ff ff 03 fc ff ff 03 fc ff ff 03     ................
    2036:	fe ff ff 03 fc ff ff 03 fe ff ff 03 fc ff ff 07     ................
    2046:	fe ff ff 03 fc ff ff 07 fe ff ff 03 fc ff ff 07     ................
    2056:	ff ff ff 07 fe ff ff 0f ff ff ff 07 fe ff ff 0f     ................
    2066:	ff ff ff 07 fe ff ff 0f ff ff ff 07 fe ff ff 0f     ................
    2076:	ff ff ff 07 fe ff ff 0f ff ff ff 07 fe ff ff 0f     ................
    2086:	ff ff ff 07 fe ff ff 0f ff ff ff 07 fe ff ff 0f     ................
    2096:	ff ff ff 07 fe ff ff 0f ff ff ff 07 fe ff ff 0f     ................
    20a6:	ff ff ff 07 fe ff ff 0f ff ff ff 0f ff ff ff 0f     ................
    20b6:	fe ff ff 0f ff ff ff 07 fe ff ff 0f ff ff ff 07     ................
    20c6:	fe ff ff 0f ff ff ff 07 fc ff ff ff ff ff ff 03     ................
    20d6:	fc ff ff ff ff ff ff 03 fc ff ff ff ff ff ff 03     ................
    20e6:	f8 ff ff 03 fc ff ff 01 f8 ff ff 03 fc ff ff 01     ................
    20f6:	f0 ff ff 03 fc ff ff 00 f0 ff ff 03 fc ff ff 00     ................
    2106:	e0 ff ff 03 fc ff 7f 00 e0 ff ff 03 fc ff 3f 00     ..............?.
    2116:	c0 ff ff 03 fc ff 3f 00 80 ff ff 03 fc ff 1f 00     ......?.........
    2126:	00 ff ff ff ff ff 0f 00 00 fe ff ff ff ff 07 00     ................
    2136:	00 fc ff ff ff ff 03 00 00 f8 ff ff ff ff 01 00     ................
    2146:	00 f0 ff ff ff ff 00 00 00 c0 ff ff ff 3f 00 00     .............?..
    2156:	00 80 ff ff ff 0f 00 00 00 00 fe ff ff 07 00 00     ................
    2166:	00 00 f0 ff ff 00 00 00 00 00 80 ff 1f 00 00 00     ................

00002176 <logo_a4>:
    2176:	fc ff ff 07 06 00 00 0c 03 00 00 18 01 00 00 10     ................
    2186:	01 00 00 10 01 00 00 10 01 00 00 10 01 00 00 10     ................
    2196:	01 00 00 10 01 00 00 10 01 00 00 10 01 fe 0f 10     ................
    21a6:	01 02 08 10 01 02 08 10 01 02 08 10 01 02 08 10     ................
    21b6:	01 02 08 10 01 fe 0f 10 01 00 00 10 01 00 00 10     ................
    21c6:	01 00 00 10 01 00 00 10 01 00 00 10 01 00 00 10     ................
    21d6:	01 00 00 10 01 00 00 10 03 00 00 18 06 00 00 0c     ................
    21e6:	fc ff ff 07                                         ....

000021ea <logo_a3>:
    21ea:	fc ff ff 7f 00 06 00 00 c0 00 03 00 00 80 01 01     ................
    21fa:	00 00 00 01 01 00 00 00 01 01 00 00 00 01 01 00     ................
    220a:	00 00 01 01 00 00 00 01 01 00 00 00 01 01 00 00     ................
    221a:	00 01 01 00 00 00 01 01 00 00 00 01 01 fc 7f 00     ................
    222a:	01 01 04 40 00 01 01 04 40 00 01 01 04 40 00 01     ...@....@....@..
    223a:	01 04 40 00 01 01 04 40 00 01 01 04 40 00 01 01     ..@....@....@...
    224a:	04 40 00 01 01 fc 7f 00 01 01 00 00 00 01 01 00     .@..............
    225a:	00 00 01 01 00 00 00 01 01 00 00 00 01 01 00 00     ................
    226a:	00 01 01 00 00 00 01 01 00 00 00 01 01 00 00 00     ................
    227a:	01 01 00 00 00 01 03 00 00 80 01 06 00 00 c0 00     ................
    228a:	fc ff ff 7f 00                                      .....

0000228f <logo_a2>:
    228f:	fc ff ff ff 07 06 00 00 00 0c 03 00 00 00 18 01     ................
    229f:	00 00 00 10 01 00 00 00 10 01 00 00 00 10 01 00     ................
    22af:	00 00 10 01 00 00 00 10 01 00 00 00 10 01 00 00     ................
    22bf:	00 10 01 00 00 00 10 01 00 00 00 10 01 00 00 00     ................
    22cf:	10 01 00 00 00 10 01 f8 ff 03 10 01 08 00 02 10     ................
    22df:	01 08 00 02 10 01 08 00 02 10 01 08 00 02 10 01     ................
    22ef:	08 00 02 10 01 08 00 02 10 01 08 00 02 10 01 f8     ................
    22ff:	ff 03 10 01 00 00 00 10 01 00 00 00 10 01 00 00     ................
    230f:	00 10 01 00 00 00 10 01 00 00 00 10 01 00 00 00     ................
    231f:	10 01 00 00 00 10 01 00 00 00 10 01 00 00 00 10     ................
    232f:	01 00 00 00 10 01 00 00 00 10 03 00 00 00 18 06     ................
    233f:	00 00 00 0c fc ff ff ff 07                          .........

00002348 <logo_a1>:
    2348:	fc ff ff ff 7f 00 06 00 00 00 c0 00 03 00 00 00     ................
    2358:	80 01 01 00 00 00 00 01 01 00 00 00 00 01 01 00     ................
    2368:	00 00 00 01 01 00 00 00 00 01 01 00 00 00 00 01     ................
    2378:	01 00 00 00 00 01 01 00 00 00 00 01 01 00 00 00     ................
    2388:	00 01 01 00 00 00 00 01 01 00 00 00 00 01 01 00     ................
    2398:	00 00 00 01 01 00 00 00 00 01 01 f0 ff 1f 00 01     ................
    23a8:	01 10 00 10 00 01 01 10 00 10 00 01 01 10 00 10     ................
    23b8:	00 01 01 10 00 10 00 01 01 10 00 10 00 01 01 10     ................
    23c8:	00 10 00 01 01 10 00 10 00 01 01 10 00 10 00 01     ................
    23d8:	01 f0 ff 1f 00 01 01 00 00 00 00 01 01 00 00 00     ................
    23e8:	00 01 01 00 00 00 00 01 01 00 00 00 00 01 01 00     ................
    23f8:	00 00 00 01 01 00 00 00 00 01 01 00 00 00 00 01     ................
    2408:	01 00 00 00 00 01 01 00 00 00 00 01 01 00 00 00     ................
    2418:	00 01 01 00 00 00 00 01 01 00 00 00 00 01 01 00     ................
    2428:	00 00 00 01 03 00 00 00 80 01 06 00 00 00 c0 00     ................
    2438:	fc ff ff ff 7f 00                                   ......

0000243e <logo>:
	...
    246a:	80 ff ff 3f 00 00 00 00 00 00 00 00 00 00 00 00     ...?............
    247a:	c0 00 00 60 00 00 00 00 00 00 00 00 00 00 00 00     ...`............
    248a:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    249a:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24aa:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24ba:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24ca:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24da:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24ea:	40 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    24fa:	40 e0 ff 40 00 00 00 00 00 00 00 00 00 00 00 00     @..@............
    250a:	40 20 80 40 00 00 00 00 00 00 00 00 00 00 00 00     @ .@............
    251a:	40 20 80 40 00 00 00 00 00 00 00 00 00 00 00 00     @ .@............
    252a:	40 20 80 40 00 00 00 00 00 00 00 00 00 00 00 00     @ .@............
    253a:	00 20 80 40 00 00 00 00 80 00 00 00 00 00 00 00     . .@............
    254a:	40 20 80 40 04 00 00 00 80 00 00 00 00 00 00 00     @ .@............
    255a:	40 e0 ff 40 04 00 00 00 80 00 00 00 00 00 00 00     @..@............
    256a:	40 00 00 40 0e c3 d1 0c 8e 46 07 a3 c3 69 0c 06     @..@.....F...i..
    257a:	5c 0c 00 40 84 24 b2 13 91 c9 88 64 24 da 13 09     \..@.$.....d$...
    258a:	62 12 00 40 44 08 12 a1 a0 50 50 28 08 0a a1 10     b..@D....PP(....
    259a:	41 21 00 40 c4 8f 13 a1 a0 50 d0 2f 88 0b a1 1f     A!.@.....P./....
    25aa:	41 3f 00 40 44 40 12 a1 a0 50 50 20 48 0a a1 00     A?.@D@...PP H...
    25ba:	41 01 00 40 44 20 12 a1 a0 50 50 20 28 0a a1 00     A..@D ...PP (...
    25ca:	41 01 00 40 54 28 13 21 91 50 50 28 28 0b a1 10     A..@T(.!.PP((...
    25da:	61 21 00 60 88 e7 12 21 8e 50 90 27 e8 0a 21 4f     a!.`...!.P.'..!O
    25ea:	5e 9e ff 3f 00 00 00 00 00 00 00 00 00 00 00 00     ^..?............
	...

0000260e <__c.4455>:
    260e:	3a 20 52 65 73 65 74 3a 3a 73 6d 5f 64 6f 74 3a     : Reset::sm_dot:
    261e:	64 6f 74 5f 74 69 6c 65 5f 6d 69 64 64 6c 65 3a     dot_tile_middle:
    262e:	73 6d 5f 72 6f 74 61 74 65 3a 73 6d 5f 74 75 72     sm_rotate:sm_tur
    263e:	6e 3a 72 61 6d 70 5f 72 65 61 64 79 3a 73 6d 5f     n:ramp_ready:sm_
    264e:	64 5f 6c 72 3a 73 6d 5f 64 64 69 73 74 00           d_lr:sm_ddist.

0000265c <__c.4453>:
    265c:	0a 0d 00                                            ...

0000265f <__c.4448>:
    265f:	3a 20 46 41 54 41 4c 20 45 52 52 4f 52 3a 20 57     : FATAL ERROR: W
    266f:	45 4e 54 20 49 4e 54 4f 20 64 72 69 76 65 5f 64     ENT INTO drive_d
    267f:	69 73 74 28 29 3a 73 6d 5f 64 64 69 73 74 20 44     ist():sm_ddist D
    268f:	45 46 41 55 4c 54 20 43 41 53 45 21 00              EFAULT CASE!.

0000269c <__c.4446>:
    269c:	0a 0d 00                                            ...

0000269f <__c.4443>:
    269f:	3a 20 64 72 69 76 65 5f 64 69 73 74 28 29 3a 20     : drive_dist(): 
    26af:	64 6f 6e 65 2e 20 00                                done. .

000026b6 <__c.4441>:
    26b6:	0a 0d 00                                            ...

000026b9 <__c.4436>:
    26b9:	3a 20 64 72 69 76 65 5f 64 69 73 74 28 29 00        : drive_dist().

000026c8 <__c.4434>:
    26c8:	0a 0d 00                                            ...

000026cb <__c.4311>:
    26cb:	3a 20 46 41 54 41 4c 20 45 52 52 4f 52 3a 20 57     : FATAL ERROR: W
    26db:	45 4e 54 20 49 4e 54 4f 20 64 72 69 76 65 5f 74     ENT INTO drive_t
    26eb:	75 72 6e 28 29 3a 73 6d 5f 74 75 72 6e 20 44 45     urn():sm_turn DE
    26fb:	46 41 55 4c 54 20 43 41 53 45 21 00                 FAULT CASE!.

00002707 <__c.4309>:
    2707:	0a 0d 00                                            ...

0000270a <__c.4306>:
    270a:	3a 20 64 72 69 76 65 5f 74 75 72 6e 28 29 3a 20     : drive_turn(): 
    271a:	64 6f 6e 65 2e 20 00                                done. .

00002721 <__c.4304>:
    2721:	0a 0d 00                                            ...

00002724 <__c.4300>:
    2724:	3a 20 64 72 69 76 65 5f 74 75 72 6e 28 29 3a 20     : drive_turn(): 
    2734:	61 6c 69 67 6e 65 64 00                             aligned.

0000273c <__c.4298>:
    273c:	0a 0d 00                                            ...

0000273f <__c.4294>:
    273f:	3a 20 64 72 69 76 65 5f 74 75 72 6e 28 29 00        : drive_turn().

0000274e <__c.4292>:
    274e:	0a 0d 00                                            ...

00002751 <__c.4256>:
    2751:	3a 20 46 41 54 41 4c 20 45 52 52 4f 52 3a 20 57     : FATAL ERROR: W
    2761:	45 4e 54 20 49 4e 54 4f 20 64 72 69 76 65 5f 72     ENT INTO drive_r
    2771:	6f 74 61 74 65 28 29 3a 73 6d 5f 72 6f 74 61 74     otate():sm_rotat
    2781:	65 20 44 45 46 41 55 4c 54 20 43 41 53 45 21 00     e DEFAULT CASE!.

00002791 <__c.4254>:
    2791:	0a 0d 00                                            ...

00002794 <__c.4251>:
    2794:	3a 20 64 72 69 76 65 5f 6f 6e 65 54 69 6c 65 28     : drive_oneTile(
    27a4:	29 3a 20 64 6f 6e 65 2e 20 00                       ): done. .

000027ae <__c.4249>:
    27ae:	0a 0d 00                                            ...

000027b1 <__c.4244>:
    27b1:	3a 20 64 72 69 76 65 5f 72 6f 74 61 74 65 28 29     : drive_rotate()
    27c1:	3a 3a 70 73 69 5f 73 74 61 72 74 3a 20 00           ::psi_start: .

000027cf <__c.4242>:
    27cf:	0a 0d 00                                            ...

000027d2 <__c.4223>:
    27d2:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 20     : ERROR::FATAL: 
    27e2:	77 65 6e 74 20 69 6e 74 6f 20 64 72 69 76 65 5f     went into drive_
    27f2:	6f 6e 65 54 69 6c 65 28 29 3a 73 6d 5f 64 6f 74     oneTile():sm_dot
    2802:	3a 44 45 46 41 55 4c 54 5f 43 41 53 45 00           :DEFAULT_CASE.

00002810 <__c.4221>:
    2810:	0a 0d 00                                            ...

00002813 <__c.4218>:
    2813:	3a 20 64 72 69 76 65 5f 6f 6e 65 54 69 6c 65 28     : drive_oneTile(
    2823:	29 3a 64 6f 6e 65 00                                ):done.

0000282a <__c.4216>:
    282a:	0a 0d 00                                            ...

0000282d <__c.4204>:
    282d:	3a 20 64 72 69 76 65 5f 6f 6e 65 54 69 6c 65 28     : drive_oneTile(
    283d:	29 3a 3a 65 6e 63 5f 6c 72 5f 73 74 61 72 74 3a     )::enc_lr_start:
	...

0000284e <__c.4202>:
    284e:	0a 0d 00                                            ...

00002851 <__c.4200>:
    2851:	3a 20 64 72 69 76 65 5f 6f 6e 65 54 69 6c 65 28     : drive_oneTile(
    2861:	29 3a 3a 64 6f 6e 74 73 74 61 72 74 3a 64 69 73     )::dontstart:dis
    2871:	74 00                                               t.

00002873 <__c.4198>:
    2873:	0a 0d 00                                            ...

00002876 <mlx90614_i2c_addresses>:
    2876:	b8 b4                                               ..

00002878 <__c.4551>:
    2878:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2888:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2898:	6d 61 7a 65 2e 31 38 5d 3a 44 45 46 41 55 4c 54     maze.18]:DEFAULT
    28a8:	5f 43 41 53 45 00                                   _CASE.

000028ae <__c.4549>:
    28ae:	0a 0d 00                                            ...

000028b1 <__c.4540>:
    28b1:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    28c1:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    28d1:	6d 61 7a 65 2e 31 37 5d 3a 44 45 46 41 55 4c 54     maze.17]:DEFAULT
    28e1:	5f 43 41 53 45 00                                   _CASE.

000028e7 <__c.4538>:
    28e7:	0a 0d 00                                            ...

000028ea <__c.4413>:
    28ea:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    28fa:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    290a:	6d 61 7a 65 2e 30 36 5d 3a 44 45 46 41 55 4c 54     maze.06]:DEFAULT
    291a:	5f 43 41 53 45 00                                   _CASE.

00002920 <__c.4411>:
    2920:	0a 0d 00                                            ...

00002923 <__c.4401>:
    2923:	63 6c 63 6e 65 61 72 2c 20 74 69 6c 65 72 65 73     clcnear, tileres
    2933:	3a 00                                               :.

00002935 <__c.4391>:
    2935:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2945:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2955:	6d 61 7a 65 2e 30 33 5d 3a 44 45 46 41 55 4c 54     maze.03]:DEFAULT
    2965:	5f 43 41 53 45 00                                   _CASE.

0000296b <__c.4389>:
    296b:	0a 0d 00                                            ...

0000296e <__c.4372>:
    296e:	3a 20 45 52 52 4f 52 3a 3a 72 6f 62 6f 74 2e 70     : ERROR::robot.p
    297e:	6f 73 2e 79 3a 4d 45 4d 4f 52 59 5f 54 4f 4f 5f     os.y:MEMORY_TOO_
    298e:	53 4d 41 4c 4c 3a 52 45 53 54 41 52 54 00           SMALL:RESTART.

0000299c <__c.4370>:
    299c:	0a 0d 00                                            ...

0000299f <__c.4368>:
    299f:	3a 20 45 52 52 4f 52 3a 3a 72 6f 62 6f 74 2e 70     : ERROR::robot.p
    29af:	6f 73 2e 78 3a 4d 45 4d 4f 52 59 5f 54 4f 4f 5f     os.x:MEMORY_TOO_
    29bf:	53 4d 41 4c 4c 3a 52 45 53 54 41 52 54 00           SMALL:RESTART.

000029cd <__c.4366>:
    29cd:	0a 0d 00                                            ...

000029d0 <__c.4364>:
    29d0:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    29e0:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    29f0:	6d 61 7a 65 2e 30 32 5d 3a 44 45 46 41 55 4c 54     maze.02]:DEFAULT
    2a00:	5f 43 41 53 45 00                                   _CASE.

00002a06 <__c.4362>:
    2a06:	0a 0d 00                                            ...

00002a09 <__c.4354>:
    2a09:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2a19:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2a29:	6d 61 7a 65 2e 30 32 5d 3a 44 45 46 41 55 4c 54     maze.02]:DEFAULT
    2a39:	5f 43 41 53 45 00                                   _CASE.

00002a3f <__c.4352>:
    2a3f:	0a 0d 00                                            ...

00002a42 <__c.4341>:
    2a42:	6d 73 00                                            ms.

00002a45 <__c.4339>:
    2a45:	3a 20 44 4f 4e 45 3a 3a 72 65 73 74 61 72 74 3a     : DONE::restart:
	...

00002a56 <__c.4337>:
    2a56:	0d 00                                               ..

00002a58 <__c.4328>:
    2a58:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2a68:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2a78:	6d 61 7a 65 2e 30 33 5d 3a 44 45 46 41 55 4c 54     maze.03]:DEFAULT
    2a88:	5f 43 41 53 45 00                                   _CASE.

00002a8e <__c.4326>:
    2a8e:	0a 0d 00                                            ...

00002a91 <__c.4533>:
    2a91:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 6d     : ERROR::FATAL:m
    2aa1:	61 7a 65 5f 63 68 67 4f 66 66 73 65 74 28 29 3a     aze_chgOffset():
    2ab1:	43 41 4e 54 00                                      CANT.

00002ab6 <__c.4531>:
    2ab6:	0a 0d 00                                            ...

00002ab9 <__c.4529>:
    2ab9:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2ac9:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2ad9:	6d 61 7a 65 2e 31 35 5d 3a 44 45 46 41 55 4c 54     maze.15]:DEFAULT
    2ae9:	5f 43 41 53 45 00                                   _CASE.

00002aef <__c.4527>:
    2aef:	0a 0d 00                                            ...

00002af2 <__c.4524>:
    2af2:	5d 5f 7a 3a 20 00                                   ]_z: .

00002af8 <__c.4521>:
    2af8:	5d 2e 79 3a 20 00                                   ].y: .

00002afe <__c.4517>:
    2afe:	5d 2e 78 3a 20 00                                   ].x: .

00002b04 <__c.4514>:
    2b04:	3a 20 6e 65 77 3a 3a 6f 66 66 73 65 74 5b 00        : new::offset[.

00002b13 <__c.4512>:
    2b13:	0a 0d 00                                            ...

00002b16 <__c.4492>:
    2b16:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2b26:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2b36:	6d 61 7a 65 2e 31 34 5d 3a 44 45 46 41 55 4c 54     maze.14]:DEFAULT
    2b46:	5f 43 41 53 45 00                                   _CASE.

00002b4c <__c.4490>:
    2b4c:	0a 0d 00                                            ...

00002b4f <__c.4424>:
    2b4f:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2b5f:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2b6f:	6d 61 7a 65 2e 31 38 5d 3a 44 45 46 41 55 4c 54     maze.18]:DEFAULT
    2b7f:	5f 43 41 53 45 00                                   _CASE.

00002b85 <__c.4422>:
    2b85:	0a 0d 00                                            ...

00002b88 <__c.4177>:
    2b88:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2b98:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2ba8:	6d 61 7a 65 2e 31 38 5d 3a 44 45 46 41 55 4c 54     maze.18]:DEFAULT
    2bb8:	5f 43 41 53 45 00                                   _CASE.

00002bbe <__c.4175>:
    2bbe:	0a 0d 00                                            ...

00002bc1 <__c.4085>:
    2bc1:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2bd1:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2be1:	6d 61 7a 65 2e 30 39 5d 3a 44 45 46 41 55 4c 54     maze.09]:DEFAULT
    2bf1:	5f 43 41 53 45 00                                   _CASE.

00002bf7 <__c.4083>:
    2bf7:	0a 0d 00                                            ...

00002bfa <__c.4063>:
    2bfa:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2c0a:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2c1a:	6d 61 7a 65 2e 30 38 5d 3a 44 45 46 41 55 4c 54     maze.08]:DEFAULT
    2c2a:	5f 43 41 53 45 00                                   _CASE.

00002c30 <__c.4061>:
    2c30:	0a 0d 00                                            ...

00002c33 <__c.4041>:
    2c33:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2c43:	45 4e 54 5f 49 4e 54 4f 3a 73 77 69 74 63 68 5b     ENT_INTO:switch[
    2c53:	6d 61 7a 65 2e 30 38 5d 3a 44 45 46 41 55 4c 54     maze.08]:DEFAULT
    2c63:	5f 43 41 53 45 00                                   _CASE.

00002c69 <__c.4039>:
    2c69:	0a 0d 00                                            ...

00002c6c <__c.3920>:
    2c6c:	3a 20 45 52 52 4f 52 3a 3a 46 41 54 41 4c 3a 57     : ERROR::FATAL:W
    2c7c:	45 4e 54 5f 49 4e 54 4f 3a 49 53 52 28 54 49 4d     ENT_INTO:ISR(TIM
    2c8c:	45 52 32 5f 43 4f 4d 50 41 5f 76 65 63 74 29 5b     ER2_COMPA_vect)[
    2c9c:	74 61 73 6b 5f 61 64 63 5d 3a 3a 63 61 73 65 3a     task_adc]::case:
    2cac:	64 65 66 61 75 6c 74 00                             default.

00002cb4 <__c.3918>:
    2cb4:	0a 0d 00                                            ...

00002cb7 <u8g_avr_port_P>:
    2cb7:	22 00 25 00 28 00 2b 00 2e 00 31 00 34 00 02 01     ".%.(.+...1.4...

00002cc7 <u8g_avr_ddr_P>:
    2cc7:	21 00 24 00 27 00 2a 00 2d 00 30 00 33 00 01 01     !.$.'.*.-.0.3...

00002cd7 <u8g_dev_st7920_128x64_init_seq>:
    2cd7:	ff d0 ff e0 ff cf ff 64 ff d1 ff 32 38 0c 06 02     .......d...28...
    2ce7:	01 ff 64 ff d0 ff fe                                ..d....

00002cee <__ctors_end>:
    2cee:	11 24       	eor	r1, r1
    2cf0:	1f be       	out	0x3f, r1	; 63
    2cf2:	cf ef       	ldi	r28, 0xFF	; 255
    2cf4:	d1 e2       	ldi	r29, 0x21	; 33
    2cf6:	de bf       	out	0x3e, r29	; 62
    2cf8:	cd bf       	out	0x3d, r28	; 61
    2cfa:	00 e0       	ldi	r16, 0x00	; 0
    2cfc:	0c bf       	out	0x3c, r16	; 60

00002cfe <init_mem>:
    2cfe:	e0 ed       	ldi	r30, 0xD0	; 208
    2d00:	f7 e1       	ldi	r31, 0x17	; 23
    2d02:	8a ea       	ldi	r24, 0xAA	; 170
    2d04:	92 e2       	ldi	r25, 0x22	; 34
    2d06:	81 93       	st	Z+, r24
    2d08:	e0 30       	cpi	r30, 0x00	; 0
    2d0a:	f9 07       	cpc	r31, r25
    2d0c:	e0 f3       	brcs	.-8      	; 0x2d06 <init_mem+0x8>

00002d0e <__do_copy_data>:
    2d0e:	15 e0       	ldi	r17, 0x05	; 5
    2d10:	a0 e0       	ldi	r26, 0x00	; 0
    2d12:	b2 e0       	ldi	r27, 0x02	; 2
    2d14:	e2 e1       	ldi	r30, 0x12	; 18
    2d16:	f9 ed       	ldi	r31, 0xD9	; 217
    2d18:	00 e0       	ldi	r16, 0x00	; 0
    2d1a:	0b bf       	out	0x3b, r16	; 59
    2d1c:	02 c0       	rjmp	.+4      	; 0x2d22 <__do_copy_data+0x14>
    2d1e:	07 90       	elpm	r0, Z+
    2d20:	0d 92       	st	X+, r0
    2d22:	a6 34       	cpi	r26, 0x46	; 70
    2d24:	b1 07       	cpc	r27, r17
    2d26:	d9 f7       	brne	.-10     	; 0x2d1e <__do_copy_data+0x10>

00002d28 <__do_clear_bss>:
    2d28:	17 e1       	ldi	r17, 0x17	; 23
    2d2a:	a6 e4       	ldi	r26, 0x46	; 70
    2d2c:	b5 e0       	ldi	r27, 0x05	; 5
    2d2e:	01 c0       	rjmp	.+2      	; 0x2d32 <.do_clear_bss_start>

00002d30 <.do_clear_bss_loop>:
    2d30:	1d 92       	st	X+, r1

00002d32 <.do_clear_bss_start>:
    2d32:	a0 3d       	cpi	r26, 0xD0	; 208
    2d34:	b1 07       	cpc	r27, r17
    2d36:	e1 f7       	brne	.-8      	; 0x2d30 <.do_clear_bss_loop>
    2d38:	97 d2       	rcall	.+1326   	; 0x3268 <main>
    2d3a:	0c 94 87 6c 	jmp	0xd90e	; 0xd90e <_exit>

00002d3e <__bad_interrupt>:
    2d3e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002d42 <task_timer>:
////////////////////////////////////////////////////////////////////////////////
////////////////////////////TASK TIMER//////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

int8_t task_timer(int8_t state)
{
    2d42:	8f 92       	push	r8
    2d44:	9f 92       	push	r9
    2d46:	af 92       	push	r10
    2d48:	bf 92       	push	r11
    2d4a:	cf 92       	push	r12
    2d4c:	df 92       	push	r13
    2d4e:	ef 92       	push	r14
    2d50:	ff 92       	push	r15
	//////(rotary) encoder///////////
	//Source: http://www.mikrocontroller.net/articles/Drehgeber

	incr_last = (incr_last << 2)  & 0x0F;
    2d52:	80 91 5c 05 	lds	r24, 0x055C
    2d56:	24 e0       	ldi	r18, 0x04	; 4
    2d58:	82 02       	muls	r24, r18
    2d5a:	c0 01       	movw	r24, r0
    2d5c:	11 24       	eor	r1, r1
    2d5e:	8f 70       	andi	r24, 0x0F	; 15
    2d60:	80 93 5c 05 	sts	0x055C, r24
	if(INCR_PHASE_A)
    2d64:	31 9b       	sbis	0x06, 1	; 6
    2d66:	03 c0       	rjmp	.+6      	; 0x2d6e <task_timer+0x2c>
		incr_last |=2;
    2d68:	82 60       	ori	r24, 0x02	; 2
    2d6a:	80 93 5c 05 	sts	0x055C, r24
	if(INCR_PHASE_B)
    2d6e:	32 9b       	sbis	0x06, 2	; 6
    2d70:	05 c0       	rjmp	.+10     	; 0x2d7c <task_timer+0x3a>
		incr_last |=1;
    2d72:	80 91 5c 05 	lds	r24, 0x055C
    2d76:	81 60       	ori	r24, 0x01	; 1
    2d78:	80 93 5c 05 	sts	0x055C, r24
	incremental += (int8_t)pgm_read_byte(&incr_table[incr_last]);
    2d7c:	40 91 5c 05 	lds	r20, 0x055C
    2d80:	e4 2f       	mov	r30, r20
    2d82:	ff 27       	eor	r31, r31
    2d84:	e7 fd       	sbrc	r30, 7
    2d86:	f0 95       	com	r31
    2d88:	e6 58       	subi	r30, 0x86	; 134
    2d8a:	fd 4f       	sbci	r31, 0xFD	; 253
    2d8c:	44 91       	lpm	r20, Z
    2d8e:	55 27       	eor	r21, r21
    2d90:	47 fd       	sbrc	r20, 7
    2d92:	50 95       	com	r21
    2d94:	65 2f       	mov	r22, r21
    2d96:	75 2f       	mov	r23, r21
    2d98:	80 91 58 05 	lds	r24, 0x0558
    2d9c:	90 91 59 05 	lds	r25, 0x0559
    2da0:	a0 91 5a 05 	lds	r26, 0x055A
    2da4:	b0 91 5b 05 	lds	r27, 0x055B
    2da8:	84 0f       	add	r24, r20
    2daa:	95 1f       	adc	r25, r21
    2dac:	a6 1f       	adc	r26, r22
    2dae:	b7 1f       	adc	r27, r23
    2db0:	80 93 58 05 	sts	0x0558, r24
    2db4:	90 93 59 05 	sts	0x0559, r25
    2db8:	a0 93 5a 05 	sts	0x055A, r26
    2dbc:	b0 93 5b 05 	sts	0x055B, r27
	
	
	int8_t new, diff;
			 
	new = 0;
	if(ENC_L_PHASE_A)		new = 3;
    2dc0:	00 99       	sbic	0x00, 0	; 0
    2dc2:	02 c0       	rjmp	.+4      	; 0x2dc8 <task_timer+0x86>
	incremental += (int8_t)pgm_read_byte(&incr_table[incr_last]);
	
	
	int8_t new, diff;
			 
	new = 0;
    2dc4:	80 e0       	ldi	r24, 0x00	; 0
    2dc6:	01 c0       	rjmp	.+2      	; 0x2dca <task_timer+0x88>
	if(ENC_L_PHASE_A)		new = 3;
    2dc8:	83 e0       	ldi	r24, 0x03	; 3
	if(ENC_L_PHASE_B)		new ^= 1;		// convert gray to binary
    2dca:	67 9b       	sbis	0x0c, 7	; 12
    2dcc:	02 c0       	rjmp	.+4      	; 0x2dd2 <task_timer+0x90>
    2dce:	91 e0       	ldi	r25, 0x01	; 1
    2dd0:	89 27       	eor	r24, r25
	diff = enc_l_last - new;				// difference last - new
    2dd2:	40 91 57 05 	lds	r20, 0x0557
    2dd6:	48 1b       	sub	r20, r24
	if( diff & 1 ){									// bit 0 = value (1)
    2dd8:	40 ff       	sbrs	r20, 0
    2dda:	3e c0       	rjmp	.+124    	; 0x2e58 <task_timer+0x116>
		enc_l_last = new;							// store new as next last
    2ddc:	80 93 57 05 	sts	0x0557, r24

		mot.d[LEFT].enc += (diff & 2) - 1;	// bit 1 = direction (+/-)
    2de0:	42 70       	andi	r20, 0x02	; 2
    2de2:	55 27       	eor	r21, r21
    2de4:	47 fd       	sbrc	r20, 7
    2de6:	50 95       	com	r21
    2de8:	41 50       	subi	r20, 0x01	; 1
    2dea:	51 09       	sbc	r21, r1
    2dec:	6a 01       	movw	r12, r20
    2dee:	ee 24       	eor	r14, r14
    2df0:	d7 fc       	sbrc	r13, 7
    2df2:	e0 94       	com	r14
    2df4:	fe 2c       	mov	r15, r14
    2df6:	80 91 6b 16 	lds	r24, 0x166B
    2dfa:	90 91 6c 16 	lds	r25, 0x166C
    2dfe:	a0 91 6d 16 	lds	r26, 0x166D
    2e02:	b0 91 6e 16 	lds	r27, 0x166E
    2e06:	8c 0d       	add	r24, r12
    2e08:	9d 1d       	adc	r25, r13
    2e0a:	ae 1d       	adc	r26, r14
    2e0c:	bf 1d       	adc	r27, r15
    2e0e:	80 93 6b 16 	sts	0x166B, r24
    2e12:	90 93 6c 16 	sts	0x166C, r25
    2e16:	a0 93 6d 16 	sts	0x166D, r26
    2e1a:	b0 93 6e 16 	sts	0x166E, r27
		mot.d[LEFT].enc_abs += abs((diff & 2) -1);
    2e1e:	57 ff       	sbrs	r21, 7
    2e20:	03 c0       	rjmp	.+6      	; 0x2e28 <task_timer+0xe6>
    2e22:	51 95       	neg	r21
    2e24:	41 95       	neg	r20
    2e26:	51 09       	sbc	r21, r1
    2e28:	66 27       	eor	r22, r22
    2e2a:	57 fd       	sbrc	r21, 7
    2e2c:	60 95       	com	r22
    2e2e:	76 2f       	mov	r23, r22
    2e30:	80 91 6f 16 	lds	r24, 0x166F
    2e34:	90 91 70 16 	lds	r25, 0x1670
    2e38:	a0 91 71 16 	lds	r26, 0x1671
    2e3c:	b0 91 72 16 	lds	r27, 0x1672
    2e40:	84 0f       	add	r24, r20
    2e42:	95 1f       	adc	r25, r21
    2e44:	a6 1f       	adc	r26, r22
    2e46:	b7 1f       	adc	r27, r23
    2e48:	80 93 6f 16 	sts	0x166F, r24
    2e4c:	90 93 70 16 	sts	0x1670, r25
    2e50:	a0 93 71 16 	sts	0x1671, r26
    2e54:	b0 93 72 16 	sts	0x1672, r27
	}

	new = 0;
	if(ENC_R_PHASE_A)		new = 3;
    2e58:	66 99       	sbic	0x0c, 6	; 12
    2e5a:	02 c0       	rjmp	.+4      	; 0x2e60 <task_timer+0x11e>

		mot.d[LEFT].enc += (diff & 2) - 1;	// bit 1 = direction (+/-)
		mot.d[LEFT].enc_abs += abs((diff & 2) -1);
	}

	new = 0;
    2e5c:	80 e0       	ldi	r24, 0x00	; 0
    2e5e:	01 c0       	rjmp	.+2      	; 0x2e62 <task_timer+0x120>
	if(ENC_R_PHASE_A)		new = 3;
    2e60:	83 e0       	ldi	r24, 0x03	; 3
	if(ENC_R_PHASE_B)		new ^= 1;		// convert gray to binary
    2e62:	01 9b       	sbis	0x00, 1	; 0
    2e64:	02 c0       	rjmp	.+4      	; 0x2e6a <task_timer+0x128>
    2e66:	91 e0       	ldi	r25, 0x01	; 1
    2e68:	89 27       	eor	r24, r25
	diff = enc_r_last - new;				// difference last - new
    2e6a:	40 91 56 05 	lds	r20, 0x0556
    2e6e:	48 1b       	sub	r20, r24
	if( diff & 1 ){									// bit 0 = value (1)
    2e70:	40 ff       	sbrs	r20, 0
    2e72:	3e c0       	rjmp	.+124    	; 0x2ef0 <task_timer+0x1ae>
		enc_r_last = new;							// store new as next last
    2e74:	80 93 56 05 	sts	0x0556, r24
		mot.d[RIGHT].enc += (diff & 2) - 1;	// bit 1 = direction (+/-)
    2e78:	42 70       	andi	r20, 0x02	; 2
    2e7a:	55 27       	eor	r21, r21
    2e7c:	47 fd       	sbrc	r20, 7
    2e7e:	50 95       	com	r21
    2e80:	41 50       	subi	r20, 0x01	; 1
    2e82:	51 09       	sbc	r21, r1
    2e84:	6a 01       	movw	r12, r20
    2e86:	ee 24       	eor	r14, r14
    2e88:	d7 fc       	sbrc	r13, 7
    2e8a:	e0 94       	com	r14
    2e8c:	fe 2c       	mov	r15, r14
    2e8e:	80 91 77 16 	lds	r24, 0x1677
    2e92:	90 91 78 16 	lds	r25, 0x1678
    2e96:	a0 91 79 16 	lds	r26, 0x1679
    2e9a:	b0 91 7a 16 	lds	r27, 0x167A
    2e9e:	8c 0d       	add	r24, r12
    2ea0:	9d 1d       	adc	r25, r13
    2ea2:	ae 1d       	adc	r26, r14
    2ea4:	bf 1d       	adc	r27, r15
    2ea6:	80 93 77 16 	sts	0x1677, r24
    2eaa:	90 93 78 16 	sts	0x1678, r25
    2eae:	a0 93 79 16 	sts	0x1679, r26
    2eb2:	b0 93 7a 16 	sts	0x167A, r27
		mot.d[RIGHT].enc_abs += abs((diff & 2) -1);
    2eb6:	57 ff       	sbrs	r21, 7
    2eb8:	03 c0       	rjmp	.+6      	; 0x2ec0 <task_timer+0x17e>
    2eba:	51 95       	neg	r21
    2ebc:	41 95       	neg	r20
    2ebe:	51 09       	sbc	r21, r1
    2ec0:	66 27       	eor	r22, r22
    2ec2:	57 fd       	sbrc	r21, 7
    2ec4:	60 95       	com	r22
    2ec6:	76 2f       	mov	r23, r22
    2ec8:	80 91 7b 16 	lds	r24, 0x167B
    2ecc:	90 91 7c 16 	lds	r25, 0x167C
    2ed0:	a0 91 7d 16 	lds	r26, 0x167D
    2ed4:	b0 91 7e 16 	lds	r27, 0x167E
    2ed8:	84 0f       	add	r24, r20
    2eda:	95 1f       	adc	r25, r21
    2edc:	a6 1f       	adc	r26, r22
    2ede:	b7 1f       	adc	r27, r23
    2ee0:	80 93 7b 16 	sts	0x167B, r24
    2ee4:	90 93 7c 16 	sts	0x167C, r25
    2ee8:	a0 93 7d 16 	sts	0x167D, r26
    2eec:	b0 93 7e 16 	sts	0x167E, r27
	}

	mot.enc = ((mot.d[LEFT].enc/2) + (mot.d[RIGHT].enc/2));
    2ef0:	60 91 6b 16 	lds	r22, 0x166B
    2ef4:	70 91 6c 16 	lds	r23, 0x166C
    2ef8:	80 91 6d 16 	lds	r24, 0x166D
    2efc:	90 91 6e 16 	lds	r25, 0x166E
    2f00:	22 e0       	ldi	r18, 0x02	; 2
    2f02:	82 2e       	mov	r8, r18
    2f04:	91 2c       	mov	r9, r1
    2f06:	a1 2c       	mov	r10, r1
    2f08:	b1 2c       	mov	r11, r1
    2f0a:	a5 01       	movw	r20, r10
    2f0c:	94 01       	movw	r18, r8
    2f0e:	0e 94 7f 6b 	call	0xd6fe	; 0xd6fe <__divmodsi4>
    2f12:	69 01       	movw	r12, r18
    2f14:	7a 01       	movw	r14, r20
    2f16:	60 91 77 16 	lds	r22, 0x1677
    2f1a:	70 91 78 16 	lds	r23, 0x1678
    2f1e:	80 91 79 16 	lds	r24, 0x1679
    2f22:	90 91 7a 16 	lds	r25, 0x167A
    2f26:	a5 01       	movw	r20, r10
    2f28:	94 01       	movw	r18, r8
    2f2a:	0e 94 7f 6b 	call	0xd6fe	; 0xd6fe <__divmodsi4>
    2f2e:	c2 0e       	add	r12, r18
    2f30:	d3 1e       	adc	r13, r19
    2f32:	e4 1e       	adc	r14, r20
    2f34:	f5 1e       	adc	r15, r21
    2f36:	c0 92 81 16 	sts	0x1681, r12
    2f3a:	d0 92 82 16 	sts	0x1682, r13
    2f3e:	e0 92 83 16 	sts	0x1683, r14
    2f42:	f0 92 84 16 	sts	0x1684, r15

	//////Timer/////////////

	timer_25ms ++;
    2f46:	80 91 4b 05 	lds	r24, 0x054B
    2f4a:	8f 5f       	subi	r24, 0xFF	; 255
    2f4c:	80 93 4b 05 	sts	0x054B, r24
	if(timer_25ms == 25) //40Hz
    2f50:	89 31       	cpi	r24, 0x19	; 25
    2f52:	09 f0       	breq	.+2      	; 0x2f56 <task_timer+0x214>
    2f54:	63 c0       	rjmp	.+198    	; 0x301c <task_timer+0x2da>
	{
		if(timer_victim_led > 0)
    2f56:	80 91 97 02 	lds	r24, 0x0297
    2f5a:	90 91 98 02 	lds	r25, 0x0298
    2f5e:	18 16       	cp	r1, r24
    2f60:	19 06       	cpc	r1, r25
    2f62:	2c f4       	brge	.+10     	; 0x2f6e <task_timer+0x22c>
			timer_victim_led --;
    2f64:	01 97       	sbiw	r24, 0x01	; 1
    2f66:	90 93 98 02 	sts	0x0298, r25
    2f6a:	80 93 97 02 	sts	0x0297, r24
		if(timer_entpr_tast > 0)
    2f6e:	80 91 51 05 	lds	r24, 0x0551
    2f72:	18 16       	cp	r1, r24
    2f74:	1c f4       	brge	.+6      	; 0x2f7c <task_timer+0x23a>
			timer_entpr_tast --;
    2f76:	81 50       	subi	r24, 0x01	; 1
    2f78:	80 93 51 05 	sts	0x0551, r24
		if(timer_incr_entpr > 0)
    2f7c:	80 91 50 05 	lds	r24, 0x0550
    2f80:	18 16       	cp	r1, r24
    2f82:	1c f4       	brge	.+6      	; 0x2f8a <task_timer+0x248>
			timer_incr_entpr --;
    2f84:	81 50       	subi	r24, 0x01	; 1
    2f86:	80 93 50 05 	sts	0x0550, r24
		if(timer_bt_is_busy > 0)
    2f8a:	80 91 4f 05 	lds	r24, 0x054F
    2f8e:	18 16       	cp	r1, r24
    2f90:	1c f4       	brge	.+6      	; 0x2f98 <task_timer+0x256>
			timer_bt_is_busy --;
    2f92:	81 50       	subi	r24, 0x01	; 1
    2f94:	80 93 4f 05 	sts	0x054F, r24
		if(timer_drive > 0)
    2f98:	80 91 95 02 	lds	r24, 0x0295
    2f9c:	90 91 96 02 	lds	r25, 0x0296
    2fa0:	18 16       	cp	r1, r24
    2fa2:	19 06       	cpc	r1, r25
    2fa4:	2c f4       	brge	.+10     	; 0x2fb0 <task_timer+0x26e>
			timer_drive --;
    2fa6:	01 97       	sbiw	r24, 0x01	; 1
    2fa8:	90 93 96 02 	sts	0x0296, r25
    2fac:	80 93 95 02 	sts	0x0295, r24
		if(timer_disp_msg > 0)
    2fb0:	80 91 4e 05 	lds	r24, 0x054E
    2fb4:	18 16       	cp	r1, r24
    2fb6:	1c f4       	brge	.+6      	; 0x2fbe <task_timer+0x27c>
			timer_disp_msg --;
    2fb8:	81 50       	subi	r24, 0x01	; 1
    2fba:	80 93 4e 05 	sts	0x054E, r24
		if(timer_get_tast > 0)
    2fbe:	80 91 4d 05 	lds	r24, 0x054D
    2fc2:	18 16       	cp	r1, r24
    2fc4:	1c f4       	brge	.+6      	; 0x2fcc <task_timer+0x28a>
			timer_get_tast --;
    2fc6:	81 50       	subi	r24, 0x01	; 1
    2fc8:	80 93 4d 05 	sts	0x054D, r24
		if(timer_rdy_restart > 0)
    2fcc:	80 91 93 02 	lds	r24, 0x0293
    2fd0:	90 91 94 02 	lds	r25, 0x0294
    2fd4:	18 16       	cp	r1, r24
    2fd6:	19 06       	cpc	r1, r25
    2fd8:	2c f4       	brge	.+10     	; 0x2fe4 <task_timer+0x2a2>
			timer_rdy_restart --;
    2fda:	01 97       	sbiw	r24, 0x01	; 1
    2fdc:	90 93 94 02 	sts	0x0294, r25
    2fe0:	80 93 93 02 	sts	0x0293, r24
		if(timer_map_wall_r > 0)
    2fe4:	80 91 4c 05 	lds	r24, 0x054C
    2fe8:	18 16       	cp	r1, r24
    2fea:	1c f4       	brge	.+6      	; 0x2ff2 <task_timer+0x2b0>
			timer_map_wall_r --;
    2fec:	81 50       	subi	r24, 0x01	; 1
    2fee:	80 93 4c 05 	sts	0x054C, r24
		if(timer_lop > 0)
    2ff2:	80 91 91 02 	lds	r24, 0x0291
    2ff6:	90 91 92 02 	lds	r25, 0x0292
    2ffa:	18 16       	cp	r1, r24
    2ffc:	19 06       	cpc	r1, r25
    2ffe:	2c f4       	brge	.+10     	; 0x300a <task_timer+0x2c8>
			timer_lop --;
    3000:	01 97       	sbiw	r24, 0x01	; 1
    3002:	90 93 92 02 	sts	0x0292, r25
    3006:	80 93 91 02 	sts	0x0291, r24
		if(timer_vic_ramp > 0)
    300a:	80 91 90 02 	lds	r24, 0x0290
    300e:	18 16       	cp	r1, r24
    3010:	1c f4       	brge	.+6      	; 0x3018 <task_timer+0x2d6>
			timer_vic_ramp --;
    3012:	81 50       	subi	r24, 0x01	; 1
    3014:	80 93 90 02 	sts	0x0290, r24

		timer_25ms = 0;
    3018:	10 92 4b 05 	sts	0x054B, r1
	}

	return 0;
}
    301c:	80 e0       	ldi	r24, 0x00	; 0
    301e:	ff 90       	pop	r15
    3020:	ef 90       	pop	r14
    3022:	df 90       	pop	r13
    3024:	cf 90       	pop	r12
    3026:	bf 90       	pop	r11
    3028:	af 90       	pop	r10
    302a:	9f 90       	pop	r9
    302c:	8f 90       	pop	r8
    302e:	08 95       	ret

00003030 <task_cam>:
int8_t task_cam(int8_t state)
{
	//pixy_get();

	return 0;//tsl1401(state);
}
    3030:	80 e0       	ldi	r24, 0x00	; 0
    3032:	08 95       	ret

00003034 <task_speedreg>:
////////////////////////////////////////////////////////////////////////////////

int8_t task_speedreg(int8_t state)
{
	//Turn motor off?
	if(	mot.off || mot.off_invisible)
    3034:	80 91 7f 16 	lds	r24, 0x167F
    3038:	81 11       	cpse	r24, r1
    303a:	04 c0       	rjmp	.+8      	; 0x3044 <task_speedreg+0x10>
    303c:	80 91 80 16 	lds	r24, 0x1680
    3040:	88 23       	and	r24, r24
    3042:	41 f0       	breq	.+16     	; 0x3054 <task_speedreg+0x20>
	{
		mot.d[LEFT].speed.to = 0;
    3044:	10 92 6a 16 	sts	0x166A, r1
    3048:	10 92 69 16 	sts	0x1669, r1
		mot.d[RIGHT].speed.to = 0;
    304c:	10 92 76 16 	sts	0x1676, r1
    3050:	10 92 75 16 	sts	0x1675, r1
	}
	controlSpeed(); //Speed Regulation
    3054:	0e 94 4f 5c 	call	0xb89e	; 0xb89e <controlSpeed>
	
	return 0;
}
    3058:	80 e0       	ldi	r24, 0x00	; 0
    305a:	08 95       	ret

0000305c <task_sensors>:

int8_t task_sensors(int8_t state)
{
	//IC sensors
	///Temperature
	check_mlx = getIR();
    305c:	0e 94 10 3b 	call	0x7620	; 0x7620 <getIR>
    3060:	80 93 67 05 	sts	0x0567, r24
	victim_scan();
    3064:	0e 94 3a 62 	call	0xc474	; 0xc474 <victim_scan>

	////Ultrasonic distance
	//check_srf = getSRF();

	//UM6
	check_um6 = um6_getUM6();
    3068:	0e 94 69 60 	call	0xc0d2	; 0xc0d2 <um6_getUM6>
    306c:	80 93 65 05 	sts	0x0565, r24

	//pixy_get();
	//displayvar[2] = pixy_number_of_blocks;
	return 0;
}
    3070:	80 e0       	ldi	r24, 0x00	; 0
    3072:	08 95       	ret

00003074 <task_anasens>:
////////////////////////////////////////////////////////////////////////////////

int8_t task_anasens(int8_t state)
{
	//analog
	get_analogSensors(); //Sharp infrared distance sensors, groundsensor
    3074:	0e 94 d5 36 	call	0x6daa	; 0x6daa <get_analogSensors>
	return 0;
}
    3078:	80 e0       	ldi	r24, 0x00	; 0
    307a:	08 95       	ret

0000307c <task_maze>:
char drive_tile_11[DRIVE_TILE_5_L] = "fffdllfffrur";
char drive_tile_12[DRIVE_TILE_6_L] = "fffflfdllfrffffrur";

int8_t task_maze(int8_t state)
{
	if(setup == 0)
    307c:	80 91 54 05 	lds	r24, 0x0554
    3080:	81 11       	cpse	r24, r1
    3082:	02 c0       	rjmp	.+4      	; 0x3088 <task_maze+0xc>
	{
		maze_solve();
    3084:	0e 94 db 3c 	call	0x79b6	; 0x79b6 <maze_solve>
	if(get_incrOk())
	{
		testvar = 0;
	}*/

	if(!mot.off)
    3088:	80 91 7f 16 	lds	r24, 0x167F
    308c:	81 11       	cpse	r24, r1
    308e:	5b c0       	rjmp	.+182    	; 0x3146 <task_maze+0xca>
	{
		if(robot.pos.z == 0)
    3090:	90 91 4a 16 	lds	r25, 0x164A
    3094:	80 91 46 05 	lds	r24, 0x0546
    3098:	91 11       	cpse	r25, r1
    309a:	26 c0       	rjmp	.+76     	; 0x30e8 <task_maze+0x6c>
		{
			switch (testvar) {
    309c:	82 30       	cpi	r24, 0x02	; 2
    309e:	c1 f0       	breq	.+48     	; 0x30d0 <task_maze+0x54>
    30a0:	4c f4       	brge	.+18     	; 0x30b4 <task_maze+0x38>
    30a2:	88 23       	and	r24, r24
    30a4:	89 f0       	breq	.+34     	; 0x30c8 <task_maze+0x4c>
    30a6:	81 30       	cpi	r24, 0x01	; 1
    30a8:	09 f0       	breq	.+2      	; 0x30ac <task_maze+0x30>
    30aa:	4b c0       	rjmp	.+150    	; 0x3142 <task_maze+0xc6>
			case 0:	if(!drive_instructions(drive_tile_1, DRIVE_TILE_1_L)) testvar ++; break;
			case 1:	if(!drive_instructions(drive_tile_2, DRIVE_TILE_2_L)) testvar ++; break;
    30ac:	68 e0       	ldi	r22, 0x08	; 8
    30ae:	80 e8       	ldi	r24, 0x80	; 128
    30b0:	92 e0       	ldi	r25, 0x02	; 2
    30b2:	3d c0       	rjmp	.+122    	; 0x312e <task_maze+0xb2>

	if(!mot.off)
	{
		if(robot.pos.z == 0)
		{
			switch (testvar) {
    30b4:	84 30       	cpi	r24, 0x04	; 4
    30b6:	a1 f0       	breq	.+40     	; 0x30e0 <task_maze+0x64>
    30b8:	7c f0       	brlt	.+30     	; 0x30d8 <task_maze+0x5c>
    30ba:	85 30       	cpi	r24, 0x05	; 5
    30bc:	09 f0       	breq	.+2      	; 0x30c0 <task_maze+0x44>
    30be:	41 c0       	rjmp	.+130    	; 0x3142 <task_maze+0xc6>
			case 0:	if(!drive_instructions(drive_tile_1, DRIVE_TILE_1_L)) testvar ++; break;
			case 1:	if(!drive_instructions(drive_tile_2, DRIVE_TILE_2_L)) testvar ++; break;
			case 2:	if(!drive_instructions(drive_tile_3, DRIVE_TILE_3_L)) testvar ++; break;
			case 3:	if(!drive_instructions(drive_tile_4, DRIVE_TILE_4_L)) testvar ++; break;
			case 4:	if(!drive_instructions(drive_tile_5, DRIVE_TILE_5_L)) testvar ++; break;
			case 5:	if(!drive_instructions(drive_tile_6, DRIVE_TILE_6_L)) testvar ++; break;
    30c0:	62 e1       	ldi	r22, 0x12	; 18
    30c2:	88 e4       	ldi	r24, 0x48	; 72
    30c4:	92 e0       	ldi	r25, 0x02	; 2
    30c6:	33 c0       	rjmp	.+102    	; 0x312e <task_maze+0xb2>
	if(!mot.off)
	{
		if(robot.pos.z == 0)
		{
			switch (testvar) {
			case 0:	if(!drive_instructions(drive_tile_1, DRIVE_TILE_1_L)) testvar ++; break;
    30c8:	68 e0       	ldi	r22, 0x08	; 8
    30ca:	88 e8       	ldi	r24, 0x88	; 136
    30cc:	92 e0       	ldi	r25, 0x02	; 2
    30ce:	2f c0       	rjmp	.+94     	; 0x312e <task_maze+0xb2>
			case 1:	if(!drive_instructions(drive_tile_2, DRIVE_TILE_2_L)) testvar ++; break;
			case 2:	if(!drive_instructions(drive_tile_3, DRIVE_TILE_3_L)) testvar ++; break;
    30d0:	6e e0       	ldi	r22, 0x0E	; 14
    30d2:	82 e7       	ldi	r24, 0x72	; 114
    30d4:	92 e0       	ldi	r25, 0x02	; 2
    30d6:	2b c0       	rjmp	.+86     	; 0x312e <task_maze+0xb2>
			case 3:	if(!drive_instructions(drive_tile_4, DRIVE_TILE_4_L)) testvar ++; break;
    30d8:	6c e0       	ldi	r22, 0x0C	; 12
    30da:	86 e6       	ldi	r24, 0x66	; 102
    30dc:	92 e0       	ldi	r25, 0x02	; 2
    30de:	27 c0       	rjmp	.+78     	; 0x312e <task_maze+0xb2>
			case 4:	if(!drive_instructions(drive_tile_5, DRIVE_TILE_5_L)) testvar ++; break;
    30e0:	6c e0       	ldi	r22, 0x0C	; 12
    30e2:	8a e5       	ldi	r24, 0x5A	; 90
    30e4:	92 e0       	ldi	r25, 0x02	; 2
    30e6:	23 c0       	rjmp	.+70     	; 0x312e <task_maze+0xb2>
			default: testvar = 0; break;
			}
		}
		else
		{
			switch (testvar) {
    30e8:	82 30       	cpi	r24, 0x02	; 2
    30ea:	b1 f0       	breq	.+44     	; 0x3118 <task_maze+0x9c>
    30ec:	44 f4       	brge	.+16     	; 0x30fe <task_maze+0x82>
    30ee:	88 23       	and	r24, r24
    30f0:	79 f0       	breq	.+30     	; 0x3110 <task_maze+0x94>
    30f2:	81 30       	cpi	r24, 0x01	; 1
    30f4:	31 f5       	brne	.+76     	; 0x3142 <task_maze+0xc6>
			case 0:	if(!drive_instructions(drive_tile_7, DRIVE_TILE_1_L)) testvar ++; break;
			case 1:	if(!drive_instructions(drive_tile_8, DRIVE_TILE_2_L)) testvar ++; break;
    30f6:	68 e0       	ldi	r22, 0x08	; 8
    30f8:	88 e3       	ldi	r24, 0x38	; 56
    30fa:	92 e0       	ldi	r25, 0x02	; 2
    30fc:	18 c0       	rjmp	.+48     	; 0x312e <task_maze+0xb2>
			default: testvar = 0; break;
			}
		}
		else
		{
			switch (testvar) {
    30fe:	84 30       	cpi	r24, 0x04	; 4
    3100:	99 f0       	breq	.+38     	; 0x3128 <task_maze+0xac>
    3102:	74 f0       	brlt	.+28     	; 0x3120 <task_maze+0xa4>
    3104:	85 30       	cpi	r24, 0x05	; 5
    3106:	e9 f4       	brne	.+58     	; 0x3142 <task_maze+0xc6>
			case 0:	if(!drive_instructions(drive_tile_7, DRIVE_TILE_1_L)) testvar ++; break;
			case 1:	if(!drive_instructions(drive_tile_8, DRIVE_TILE_2_L)) testvar ++; break;
			case 2:	if(!drive_instructions(drive_tile_9, DRIVE_TILE_3_L)) testvar ++; break;
			case 3:	if(!drive_instructions(drive_tile_10, DRIVE_TILE_4_L)) testvar ++; break;
			case 4:	if(!drive_instructions(drive_tile_11, DRIVE_TILE_5_L)) testvar ++; break;
			case 5:	if(!drive_instructions(drive_tile_12, DRIVE_TILE_6_L)) testvar ++; break;
    3108:	62 e1       	ldi	r22, 0x12	; 18
    310a:	80 e0       	ldi	r24, 0x00	; 0
    310c:	92 e0       	ldi	r25, 0x02	; 2
    310e:	0f c0       	rjmp	.+30     	; 0x312e <task_maze+0xb2>
			}
		}
		else
		{
			switch (testvar) {
			case 0:	if(!drive_instructions(drive_tile_7, DRIVE_TILE_1_L)) testvar ++; break;
    3110:	68 e0       	ldi	r22, 0x08	; 8
    3112:	80 e4       	ldi	r24, 0x40	; 64
    3114:	92 e0       	ldi	r25, 0x02	; 2
    3116:	0b c0       	rjmp	.+22     	; 0x312e <task_maze+0xb2>
			case 1:	if(!drive_instructions(drive_tile_8, DRIVE_TILE_2_L)) testvar ++; break;
			case 2:	if(!drive_instructions(drive_tile_9, DRIVE_TILE_3_L)) testvar ++; break;
    3118:	6e e0       	ldi	r22, 0x0E	; 14
    311a:	8a e2       	ldi	r24, 0x2A	; 42
    311c:	92 e0       	ldi	r25, 0x02	; 2
    311e:	07 c0       	rjmp	.+14     	; 0x312e <task_maze+0xb2>
			case 3:	if(!drive_instructions(drive_tile_10, DRIVE_TILE_4_L)) testvar ++; break;
    3120:	6c e0       	ldi	r22, 0x0C	; 12
    3122:	8e e1       	ldi	r24, 0x1E	; 30
    3124:	92 e0       	ldi	r25, 0x02	; 2
    3126:	03 c0       	rjmp	.+6      	; 0x312e <task_maze+0xb2>
			case 4:	if(!drive_instructions(drive_tile_11, DRIVE_TILE_5_L)) testvar ++; break;
    3128:	6c e0       	ldi	r22, 0x0C	; 12
    312a:	82 e1       	ldi	r24, 0x12	; 18
    312c:	92 e0       	ldi	r25, 0x02	; 2
			case 5:	if(!drive_instructions(drive_tile_12, DRIVE_TILE_6_L)) testvar ++; break;
    312e:	0e 94 22 34 	call	0x6844	; 0x6844 <drive_instructions>
    3132:	81 11       	cpse	r24, r1
    3134:	08 c0       	rjmp	.+16     	; 0x3146 <task_maze+0xca>
    3136:	80 91 46 05 	lds	r24, 0x0546
    313a:	8f 5f       	subi	r24, 0xFF	; 255
    313c:	80 93 46 05 	sts	0x0546, r24
    3140:	02 c0       	rjmp	.+4      	; 0x3146 <task_maze+0xca>
			default: testvar = 0; break;
    3142:	10 92 46 05 	sts	0x0546, r1
		}

	}

	return 0;
}
    3146:	80 e0       	ldi	r24, 0x00	; 0
    3148:	08 95       	ret

0000314a <__vector_17>:
uint32_t timer = 0; //Timer, resolution 1ms, continuisly incrementing in the scheduler ISR

////////////////////////////////////////////////////////////////////////////////

ISR(TIMER1_COMPA_vect) //1kHz
{
    314a:	1f 92       	push	r1
    314c:	0f 92       	push	r0
    314e:	0f b6       	in	r0, 0x3f	; 63
    3150:	0f 92       	push	r0
    3152:	11 24       	eor	r1, r1
    3154:	0b b6       	in	r0, 0x3b	; 59
    3156:	0f 92       	push	r0
    3158:	ef 92       	push	r14
    315a:	ff 92       	push	r15
    315c:	0f 93       	push	r16
    315e:	1f 93       	push	r17
    3160:	2f 93       	push	r18
    3162:	3f 93       	push	r19
    3164:	4f 93       	push	r20
    3166:	5f 93       	push	r21
    3168:	6f 93       	push	r22
    316a:	7f 93       	push	r23
    316c:	8f 93       	push	r24
    316e:	9f 93       	push	r25
    3170:	af 93       	push	r26
    3172:	bf 93       	push	r27
    3174:	cf 93       	push	r28
    3176:	df 93       	push	r29
    3178:	ef 93       	push	r30
    317a:	ff 93       	push	r31
	timer++;
    317c:	80 91 47 05 	lds	r24, 0x0547
    3180:	90 91 48 05 	lds	r25, 0x0548
    3184:	a0 91 49 05 	lds	r26, 0x0549
    3188:	b0 91 4a 05 	lds	r27, 0x054A
    318c:	01 96       	adiw	r24, 0x01	; 1
    318e:	a1 1d       	adc	r26, r1
    3190:	b1 1d       	adc	r27, r1
    3192:	80 93 47 05 	sts	0x0547, r24
    3196:	90 93 48 05 	sts	0x0548, r25
    319a:	a0 93 49 05 	sts	0x0549, r26
    319e:	b0 93 4a 05 	sts	0x054A, r27
    31a2:	0b ee       	ldi	r16, 0xEB	; 235
    31a4:	16 e0       	ldi	r17, 0x06	; 6
    31a6:	cc ee       	ldi	r28, 0xEC	; 236
    31a8:	d6 e0       	ldi	r29, 0x06	; 6

	for(uint8_t i = 0; i < TASKS_NUM; i++) 					// Heart of scheduler code
    31aa:	f1 2c       	mov	r15, r1
			&& (runningTasks[currentTask] > i)					// Task priority > current task priority
			&& (!tasks[i].running))											// Task not already running (no self-preemption)
		{
			cli();
			tasks[i].elapsedTime = 0;										// Reset time since last tick
			tasks[i].running = 1;												// Mark as running
    31ac:	ee 24       	eor	r14, r14
    31ae:	e3 94       	inc	r14
{
	timer++;

	for(uint8_t i = 0; i < TASKS_NUM; i++) 					// Heart of scheduler code
	{
		if((tasks[i].elapsedTime >= tasks[i].period)	// Task ready
    31b0:	2b 81       	ldd	r18, Y+3	; 0x03
    31b2:	3c 81       	ldd	r19, Y+4	; 0x04
    31b4:	89 81       	ldd	r24, Y+1	; 0x01
    31b6:	9a 81       	ldd	r25, Y+2	; 0x02
    31b8:	28 17       	cp	r18, r24
    31ba:	39 07       	cpc	r19, r25
    31bc:	80 f1       	brcs	.+96     	; 0x321e <__vector_17+0xd4>
			&& (runningTasks[currentTask] > i)					// Task priority > current task priority
    31be:	e0 91 68 05 	lds	r30, 0x0568
    31c2:	f0 e0       	ldi	r31, 0x00	; 0
    31c4:	e3 56       	subi	r30, 0x63	; 99
    31c6:	fd 4f       	sbci	r31, 0xFD	; 253
    31c8:	80 81       	ld	r24, Z
    31ca:	f8 16       	cp	r15, r24
    31cc:	40 f5       	brcc	.+80     	; 0x321e <__vector_17+0xd4>
			&& (!tasks[i].running))											// Task not already running (no self-preemption)
    31ce:	f8 01       	movw	r30, r16
    31d0:	80 81       	ld	r24, Z
    31d2:	81 11       	cpse	r24, r1
    31d4:	24 c0       	rjmp	.+72     	; 0x321e <__vector_17+0xd4>
		{
			cli();
    31d6:	f8 94       	cli
			tasks[i].elapsedTime = 0;										// Reset time since last tick
    31d8:	1c 82       	std	Y+4, r1	; 0x04
    31da:	1b 82       	std	Y+3, r1	; 0x03
			tasks[i].running = 1;												// Mark as running
    31dc:	f8 01       	movw	r30, r16
    31de:	e0 82       	st	Z, r14
			currentTask += 1;
    31e0:	e0 91 68 05 	lds	r30, 0x0568
    31e4:	ef 5f       	subi	r30, 0xFF	; 255
    31e6:	e0 93 68 05 	sts	0x0568, r30
			runningTasks[currentTask] = i;							// Add to runningTasks
    31ea:	f0 e0       	ldi	r31, 0x00	; 0
    31ec:	e3 56       	subi	r30, 0x63	; 99
    31ee:	fd 4f       	sbci	r31, 0xFD	; 253
    31f0:	f0 82       	st	Z, r15
			sei();
    31f2:	78 94       	sei

			tasks[i].state = tasks[i].task_fct(tasks[i].state);	// Execute tick
    31f4:	ed 81       	ldd	r30, Y+5	; 0x05
    31f6:	fe 81       	ldd	r31, Y+6	; 0x06
    31f8:	88 81       	ld	r24, Y
    31fa:	19 95       	eicall
    31fc:	88 83       	st	Y, r24

			cli();
    31fe:	f8 94       	cli
			tasks[i].running = 0;												// Mark as not running
    3200:	f8 01       	movw	r30, r16
    3202:	10 82       	st	Z, r1
			runningTasks[currentTask] = idleTask;				// Remove from runningTasks
    3204:	80 91 68 05 	lds	r24, 0x0568
    3208:	e8 2f       	mov	r30, r24
    320a:	f0 e0       	ldi	r31, 0x00	; 0
    320c:	e3 56       	subi	r30, 0x63	; 99
    320e:	fd 4f       	sbci	r31, 0xFD	; 253
    3210:	90 91 9c 02 	lds	r25, 0x029C
    3214:	90 83       	st	Z, r25
			currentTask -= 1;
    3216:	81 50       	subi	r24, 0x01	; 1
    3218:	80 93 68 05 	sts	0x0568, r24
			sei();
    321c:	78 94       	sei
		{
			displayvar[4] = i;
			tasks[i].period = 1000;
			tasks[i].running = 0;
		}*/
		tasks[i].elapsedTime += TASKPERIOD_GCD;
    321e:	8b 81       	ldd	r24, Y+3	; 0x03
    3220:	9c 81       	ldd	r25, Y+4	; 0x04
    3222:	01 96       	adiw	r24, 0x01	; 1
    3224:	9c 83       	std	Y+4, r25	; 0x04
    3226:	8b 83       	std	Y+3, r24	; 0x03

ISR(TIMER1_COMPA_vect) //1kHz
{
	timer++;

	for(uint8_t i = 0; i < TASKS_NUM; i++) 					// Heart of scheduler code
    3228:	f3 94       	inc	r15
    322a:	08 5f       	subi	r16, 0xF8	; 248
    322c:	1f 4f       	sbci	r17, 0xFF	; 255
    322e:	28 96       	adiw	r28, 0x08	; 8
    3230:	f6 e0       	ldi	r31, 0x06	; 6
    3232:	ff 12       	cpse	r15, r31
    3234:	bd cf       	rjmp	.-134    	; 0x31b0 <__vector_17+0x66>
			tasks[i].period = 1000;
			tasks[i].running = 0;
		}*/
		tasks[i].elapsedTime += TASKPERIOD_GCD;
	}
}
    3236:	ff 91       	pop	r31
    3238:	ef 91       	pop	r30
    323a:	df 91       	pop	r29
    323c:	cf 91       	pop	r28
    323e:	bf 91       	pop	r27
    3240:	af 91       	pop	r26
    3242:	9f 91       	pop	r25
    3244:	8f 91       	pop	r24
    3246:	7f 91       	pop	r23
    3248:	6f 91       	pop	r22
    324a:	5f 91       	pop	r21
    324c:	4f 91       	pop	r20
    324e:	3f 91       	pop	r19
    3250:	2f 91       	pop	r18
    3252:	1f 91       	pop	r17
    3254:	0f 91       	pop	r16
    3256:	ff 90       	pop	r15
    3258:	ef 90       	pop	r14
    325a:	0f 90       	pop	r0
    325c:	0b be       	out	0x3b, r0	; 59
    325e:	0f 90       	pop	r0
    3260:	0f be       	out	0x3f, r0	; 63
    3262:	0f 90       	pop	r0
    3264:	1f 90       	pop	r1
    3266:	18 95       	reti

00003268 <main>:

/*### Mainloop ###*/
int main(void)
{
    3268:	cf 93       	push	r28
    326a:	df 93       	push	r29
    326c:	1f 92       	push	r1
    326e:	cd b7       	in	r28, 0x3d	; 61
    3270:	de b7       	in	r29, 0x3e	; 62
	WDT_TRIGGERED(); //Watchdogreset?
    3272:	04 b6       	in	r0, 0x34	; 52
    3274:	03 fe       	sbrs	r0, 3
    3276:	03 c0       	rjmp	.+6      	; 0x327e <main+0x16>
    3278:	81 e0       	ldi	r24, 0x01	; 1
    327a:	80 93 64 05 	sts	0x0564, r24

	init_sys();
    327e:	0e 94 7b 5a 	call	0xb4f6	; 0xb4f6 <init_sys>
	init_pwm();
    3282:	0e 94 11 5b 	call	0xb622	; 0xb622 <init_pwm>
	init_timer();
    3286:	0e 94 3d 5b 	call	0xb67a	; 0xb67a <init_timer>
	dist_init();
    328a:	0e 94 85 36 	call	0x6d0a	; 0x6d0a <dist_init>
	uart1_init(UART_BAUD_SELECT(UART_UM6_BAUD_RATE,F_CPU)); //IMU
    328e:	88 e0       	ldi	r24, 0x08	; 8
    3290:	90 e0       	ldi	r25, 0x00	; 0
    3292:	0e 94 4e 5f 	call	0xbe9c	; 0xbe9c <uart1_init>
	uart_init(UART_BAUD_SELECT(UART_MCU_BAUD_RATE,F_CPU)); //Bluetooth
    3296:	88 e0       	ldi	r24, 0x08	; 8
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	0e 94 c0 5e 	call	0xbd80	; 0xbd80 <uart_init>
	init_display(1);
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	0e 94 38 5c 	call	0xb870	; 0xb870 <init_display>
	//init_m2(); //Menu lib
	init_adc();
    32a4:	0e 94 00 5b 	call	0xb600	; 0xb600 <init_adc>
	init_i2c();
    32a8:	0e 94 67 5d 	call	0xbace	; 0xbace <init_i2c>
	init_srf10();
    32ac:	0e 94 94 3b 	call	0x7728	; 0x7728 <init_srf10>
	maze_init();
    32b0:	0e 94 24 50 	call	0xa048	; 0xa048 <maze_init>
	victim_init();
    32b4:	0e 94 ff 61 	call	0xc3fe	; 0xc3fe <victim_init>
    32b8:	e2 e5       	ldi	r30, 0x52	; 82
    32ba:	f7 e0       	ldi	r31, 0x07	; 7

	for(uint8_t i = 0; i < DISPLAYVARS; i++)
		displayvar[i] = DISPLAYVAR_UNUSED;
    32bc:	8f ef       	ldi	r24, 0xFF	; 255
    32be:	9f ef       	ldi	r25, 0xFF	; 255
    32c0:	a0 e0       	ldi	r26, 0x00	; 0
    32c2:	b0 e0       	ldi	r27, 0x00	; 0
    32c4:	81 93       	st	Z+, r24
    32c6:	91 93       	st	Z+, r25
    32c8:	a1 93       	st	Z+, r26
    32ca:	b1 93       	st	Z+, r27
	init_i2c();
	init_srf10();
	maze_init();
	victim_init();

	for(uint8_t i = 0; i < DISPLAYVARS; i++)
    32cc:	27 e0       	ldi	r18, 0x07	; 7
    32ce:	e2 37       	cpi	r30, 0x72	; 114
    32d0:	f2 07       	cpc	r31, r18
    32d2:	c1 f7       	brne	.-16     	; 0x32c4 <main+0x5c>
		displayvar[i] = DISPLAYVAR_UNUSED;

	mot.off = 1;
    32d4:	11 e0       	ldi	r17, 0x01	; 1
    32d6:	10 93 7f 16 	sts	0x167F, r17
	//The higher the task_i of the task is, the higher is the priority
	
	tasks[TASK_MAZE_ID].state = -1;
    32da:	2f ef       	ldi	r18, 0xFF	; 255
    32dc:	20 93 f4 06 	sts	0x06F4, r18
	tasks[TASK_MAZE_ID].period = TASK_PERIOD_MAZE;
    32e0:	85 e0       	ldi	r24, 0x05	; 5
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	90 93 f6 06 	sts	0x06F6, r25
    32e8:	80 93 f5 06 	sts	0x06F5, r24
	tasks[TASK_MAZE_ID].elapsedTime = 0;
    32ec:	10 92 f8 06 	sts	0x06F8, r1
    32f0:	10 92 f7 06 	sts	0x06F7, r1
	tasks[TASK_MAZE_ID].running = 0;
    32f4:	10 92 f3 06 	sts	0x06F3, r1
	tasks[TASK_MAZE_ID].task_fct = &task_maze;
    32f8:	8e e3       	ldi	r24, 0x3E	; 62
    32fa:	98 e1       	ldi	r25, 0x18	; 24
    32fc:	90 93 fa 06 	sts	0x06FA, r25
    3300:	80 93 f9 06 	sts	0x06F9, r24
	
	tasks[TASK_TIMER_ID].state = -1;
    3304:	20 93 ec 06 	sts	0x06EC, r18
	tasks[TASK_TIMER_ID].period = TASK_PERIOD_TIMER;
    3308:	81 e0       	ldi	r24, 0x01	; 1
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	90 93 ee 06 	sts	0x06EE, r25
    3310:	80 93 ed 06 	sts	0x06ED, r24
	tasks[TASK_TIMER_ID].elapsedTime = 0;
    3314:	10 92 f0 06 	sts	0x06F0, r1
    3318:	10 92 ef 06 	sts	0x06EF, r1
	tasks[TASK_TIMER_ID].running = 0;
    331c:	10 92 eb 06 	sts	0x06EB, r1
	tasks[TASK_TIMER_ID].task_fct = &task_timer;
    3320:	81 ea       	ldi	r24, 0xA1	; 161
    3322:	96 e1       	ldi	r25, 0x16	; 22
    3324:	90 93 f2 06 	sts	0x06F2, r25
    3328:	80 93 f1 06 	sts	0x06F1, r24

	tasks[TASK_SPEEDREG_ID].state = -1;
    332c:	20 93 04 07 	sts	0x0704, r18
	tasks[TASK_SPEEDREG_ID].period = TASK_PERIOD_SPEEDREG;
    3330:	89 e1       	ldi	r24, 0x19	; 25
    3332:	90 e0       	ldi	r25, 0x00	; 0
    3334:	90 93 06 07 	sts	0x0706, r25
    3338:	80 93 05 07 	sts	0x0705, r24
	tasks[TASK_SPEEDREG_ID].elapsedTime = 0;
    333c:	10 92 08 07 	sts	0x0708, r1
    3340:	10 92 07 07 	sts	0x0707, r1
	tasks[TASK_SPEEDREG_ID].running = 0;
    3344:	10 92 03 07 	sts	0x0703, r1
	tasks[TASK_SPEEDREG_ID].task_fct = &task_speedreg;
    3348:	8a e1       	ldi	r24, 0x1A	; 26
    334a:	98 e1       	ldi	r25, 0x18	; 24
    334c:	90 93 0a 07 	sts	0x070A, r25
    3350:	80 93 09 07 	sts	0x0709, r24
	
	tasks[TASK_SENSORS_ID].state = -1;
    3354:	20 93 fc 06 	sts	0x06FC, r18
	tasks[TASK_SENSORS_ID].period = TASK_PERIOD_SENSORS;
    3358:	8f e0       	ldi	r24, 0x0F	; 15
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	90 93 fe 06 	sts	0x06FE, r25
    3360:	80 93 fd 06 	sts	0x06FD, r24
	tasks[TASK_SENSORS_ID].elapsedTime = 0;
    3364:	10 92 00 07 	sts	0x0700, r1
    3368:	10 92 ff 06 	sts	0x06FF, r1
	tasks[TASK_SENSORS_ID].running = 0;
    336c:	10 92 fb 06 	sts	0x06FB, r1
	tasks[TASK_SENSORS_ID].task_fct = &task_sensors;
    3370:	8e e2       	ldi	r24, 0x2E	; 46
    3372:	98 e1       	ldi	r25, 0x18	; 24
    3374:	90 93 02 07 	sts	0x0702, r25
    3378:	80 93 01 07 	sts	0x0701, r24

	tasks[TASK_ANASENS_ID].state = -1;
    337c:	20 93 0c 07 	sts	0x070C, r18
	tasks[TASK_ANASENS_ID].period = TASK_PERIOD_ANASENS;
    3380:	82 e3       	ldi	r24, 0x32	; 50
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	90 93 0e 07 	sts	0x070E, r25
    3388:	80 93 0d 07 	sts	0x070D, r24
	tasks[TASK_ANASENS_ID].elapsedTime = 0;
    338c:	10 92 10 07 	sts	0x0710, r1
    3390:	10 92 0f 07 	sts	0x070F, r1
	tasks[TASK_ANASENS_ID].running = 0;
    3394:	10 92 0b 07 	sts	0x070B, r1
	tasks[TASK_ANASENS_ID].task_fct = &task_anasens;
    3398:	8a e3       	ldi	r24, 0x3A	; 58
    339a:	98 e1       	ldi	r25, 0x18	; 24
    339c:	90 93 12 07 	sts	0x0712, r25
    33a0:	80 93 11 07 	sts	0x0711, r24

	tasks[TASK_CAM_ID].state = -1;
    33a4:	20 93 14 07 	sts	0x0714, r18
	tasks[TASK_CAM_ID].period = 20;//TASK_PERIOD_CAM;
    33a8:	84 e1       	ldi	r24, 0x14	; 20
    33aa:	90 e0       	ldi	r25, 0x00	; 0
    33ac:	90 93 16 07 	sts	0x0716, r25
    33b0:	80 93 15 07 	sts	0x0715, r24
	tasks[TASK_CAM_ID].elapsedTime = 0;
    33b4:	10 92 18 07 	sts	0x0718, r1
    33b8:	10 92 17 07 	sts	0x0717, r1
	tasks[TASK_CAM_ID].running = 0;
    33bc:	10 92 13 07 	sts	0x0713, r1
	tasks[TASK_CAM_ID].task_fct = &task_cam;
    33c0:	88 e1       	ldi	r24, 0x18	; 24
    33c2:	98 e1       	ldi	r25, 0x18	; 24
    33c4:	90 93 1a 07 	sts	0x071A, r25
    33c8:	80 93 19 07 	sts	0x0719, r24
	
	if(get_incrOk())
    33cc:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>
    33d0:	88 23       	and	r24, r24
    33d2:	31 f0       	breq	.+12     	; 0x33e0 <main+0x178>
	{
		motor_activate(0); //Shut down motor driver
    33d4:	80 e0       	ldi	r24, 0x00	; 0
    33d6:	0e 94 76 5b 	call	0xb6ec	; 0xb6ec <motor_activate>
		setup = 1;
    33da:	10 93 54 05 	sts	0x0554, r17
    33de:	05 c0       	rjmp	.+10     	; 0x33ea <main+0x182>
	}
	else
	{
		motor_activate(1); //Activate motor driver
    33e0:	81 e0       	ldi	r24, 0x01	; 1
    33e2:	0e 94 76 5b 	call	0xb6ec	; 0xb6ec <motor_activate>
		setup = 0;
    33e6:	10 92 54 05 	sts	0x0554, r1
	}
	
	sei(); //Enable global interrupts. The Operating System and every task in it is running now and the cam already can regulate its initial aparture
    33ea:	78 94       	sei

	u8g_DrawStartUp();
    33ec:	30 d6       	rcall	.+3168   	; 0x404e <u8g_DrawStartUp>
    33ee:	80 91 53 05 	lds	r24, 0x0553
	
	if(debug > 0)
    33f2:	88 23       	and	r24, r24
    33f4:	19 f1       	breq	.+70     	; 0x343c <main+0x1d4>
    33f6:	88 e5       	ldi	r24, 0x58	; 88
	{
		bt_putStr_P(PSTR("\n\rRCJ 2014, V3.0\n\rteamohnename.de"));
    33f8:	92 e0       	ldi	r25, 0x02	; 2
    33fa:	e6 d5       	rcall	.+3020   	; 0x3fc8 <bt_putStr_P>
    33fc:	84 e4       	ldi	r24, 0x44	; 68
    33fe:	92 e0       	ldi	r25, 0x02	; 2
		bt_putStr_P(PSTR("\n\rDebugging grade: ")); bt_putLong(debug);
    3400:	e3 d5       	rcall	.+3014   	; 0x3fc8 <bt_putStr_P>
    3402:	60 91 53 05 	lds	r22, 0x0553
    3406:	70 e0       	ldi	r23, 0x00	; 0
    3408:	80 e0       	ldi	r24, 0x00	; 0
    340a:	90 e0       	ldi	r25, 0x00	; 0
    340c:	ef d5       	rcall	.+3038   	; 0x3fec <bt_putLong>
    340e:	81 e4       	ldi	r24, 0x41	; 65
    3410:	92 e0       	ldi	r25, 0x02	; 2
    3412:	da d5       	rcall	.+2996   	; 0x3fc8 <bt_putStr_P>
    3414:	60 91 47 05 	lds	r22, 0x0547
		bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": System initialized, ")); bt_putLong(TASKS_NUM); bt_putStr_P(PSTR(" running tasks."));
    3418:	70 91 48 05 	lds	r23, 0x0548
    341c:	80 91 49 05 	lds	r24, 0x0549
    3420:	90 91 4a 05 	lds	r25, 0x054A
    3424:	e3 d5       	rcall	.+3014   	; 0x3fec <bt_putLong>
    3426:	8a e2       	ldi	r24, 0x2A	; 42
    3428:	92 e0       	ldi	r25, 0x02	; 2
    342a:	ce d5       	rcall	.+2972   	; 0x3fc8 <bt_putStr_P>
    342c:	66 e0       	ldi	r22, 0x06	; 6
    342e:	70 e0       	ldi	r23, 0x00	; 0
    3430:	80 e0       	ldi	r24, 0x00	; 0
    3432:	90 e0       	ldi	r25, 0x00	; 0
    3434:	db d5       	rcall	.+2998   	; 0x3fec <bt_putLong>
    3436:	8a e1       	ldi	r24, 0x1A	; 26
    3438:	92 e0       	ldi	r25, 0x02	; 2
    343a:	c6 d5       	rcall	.+2956   	; 0x3fc8 <bt_putStr_P>
    343c:	80 91 64 05 	lds	r24, 0x0564
    3440:	88 23       	and	r24, r24
    3442:	e1 f0       	breq	.+56     	; 0x347c <main+0x214>
    3444:	80 91 53 05 	lds	r24, 0x0553
    3448:	88 23       	and	r24, r24
    344a:	79 f0       	breq	.+30     	; 0x346a <main+0x202>
    344c:	87 e1       	ldi	r24, 0x17	; 23
	}
	
	if(check_res)
    344e:	92 e0       	ldi	r25, 0x02	; 2
    3450:	bb d5       	rcall	.+2934   	; 0x3fc8 <bt_putStr_P>
    3452:	60 91 47 05 	lds	r22, 0x0547
	{
		if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr(PSTR(": WARNING: RECOVERED AFTER AN UNEXPECTED SHUTDOWN!!!"));}
    3456:	70 91 48 05 	lds	r23, 0x0548
    345a:	80 91 49 05 	lds	r24, 0x0549
    345e:	90 91 4a 05 	lds	r25, 0x054A
    3462:	c4 d5       	rcall	.+2952   	; 0x3fec <bt_putLong>
    3464:	82 ee       	ldi	r24, 0xE2	; 226
    3466:	91 e0       	ldi	r25, 0x01	; 1
    3468:	a0 d5       	rcall	.+2880   	; 0x3faa <bt_putStr>
    346a:	8f ef       	ldi	r24, 0xFF	; 255
    346c:	93 e2       	ldi	r25, 0x23	; 35
    346e:	e4 ef       	ldi	r30, 0xF4	; 244
    3470:	81 50       	subi	r24, 0x01	; 1
    3472:	90 40       	sbci	r25, 0x00	; 0
    3474:	e0 40       	sbci	r30, 0x00	; 0
    3476:	e1 f7       	brne	.-8      	; 0x3470 <main+0x208>
    3478:	00 c0       	rjmp	.+0      	; 0x347a <main+0x212>
    347a:	00 00       	nop
    347c:	8e e1       	ldi	r24, 0x1E	; 30
    347e:	0e 94 5d 5b 	call	0xb6ba	; 0xb6ba <servo_setPos>
    3482:	00 e2       	ldi	r16, 0x20	; 32
    3484:	ff 24       	eor	r15, r15
    3486:	f3 94       	inc	r15
    3488:	11 e0       	ldi	r17, 0x01	; 1
    348a:	e4 e1       	ldi	r30, 0x14	; 20
    348c:	ee 2e       	mov	r14, r30
    348e:	f2 e0       	ldi	r31, 0x02	; 2
    3490:	df 2e       	mov	r13, r31
    3492:	ae e1       	ldi	r26, 0x1E	; 30
	//wdt_enable(WDTO_8S); //activate watchdog

	uint8_t doonce = 0;


	servo_setPos(30);
    3494:	ca 2e       	mov	r12, r26
    3496:	ba e0       	ldi	r27, 0x0A	; 10
    3498:	bb 2e       	mov	r11, r27

	while(1)
    {
		wdt_reset();

		TOGGLE_MAIN_LED(); //Toggle LED on the RNmega Board
    349a:	44 eb       	ldi	r20, 0xB4	; 180
					maze_solve_state_path = DRIVE_READY;
					routeRequest = RR_WAIT;
					locRequest = LR_WAIT;

				hold_t1 = 0;
				mot.off ^= 1;
    349c:	a4 2e       	mov	r10, r20
    349e:	52 e8       	ldi	r21, 0x82	; 130
    34a0:	95 2e       	mov	r9, r21
				timer_entpr_tast = TIMER_ENTPR_TAST;
    34a2:	67 e3       	ldi	r22, 0x37	; 55
    34a4:	86 2e       	mov	r8, r22
		////////////////////////////////////////////////////////////////////////////
		if(get_t1())
		{
			if((timer_get_tast == 0) && (timer_entpr_tast == 0) && (!hold_t1))
			{
				timer_get_tast = TIMER_GET_TAST;
    34a6:	7f e0       	ldi	r23, 0x0F	; 15
    34a8:	77 2e       	mov	r7, r23
			led_fault = 0;
		
		if(fatal_err)
			led_top = LED_TOP_FAT_ERR;
		else
			led_top = LED_TOP_NORMAL;
    34aa:	a8 95       	wdr
    34ac:	8b b1       	in	r24, 0x0b	; 11
			led_fault = 180;
		else
			led_fault = 0;
		
		if(fatal_err)
			led_top = LED_TOP_FAT_ERR;
    34ae:	80 27       	eor	r24, r16
    34b0:	8b b9       	out	0x0b, r24	; 11
		else if(check_mlx != 0)
			led_fault = 55;
		else if(check_srf != 0)
			led_fault = 130;
		else if(check_um6 != 0)
			led_fault = 180;
    34b2:	0e 94 a4 3b 	call	0x7748	; 0x7748 <maze_solveRoutes>
		if(check_res || fatal_err)	//Flashing of the Info LED when there is an error
			led_fault = 1;
		else if(check_mlx != 0)
			led_fault = 55;
		else if(check_srf != 0)
			led_fault = 130;
    34b6:	0e 94 fc 41 	call	0x83f8	; 0x83f8 <maze_localize>
		////////////////////Sensorcoordination//////////////////////////////////////

		if(check_res || fatal_err)	//Flashing of the Info LED when there is an error
			led_fault = 1;
		else if(check_mlx != 0)
			led_fault = 55;
    34ba:	0e 94 56 5b 	call	0xb6ac	; 0xb6ac <get_t1>
		else	debug_err_sendOneTime &= ~(1<<2);
		
		//Batterie/Akku
		if(batt_raw > 0)
		{
			batt_mV = (batt_raw*15)-300;
    34be:	88 23       	and	r24, r24
    34c0:	39 f1       	breq	.+78     	; 0x3510 <main+0x2a8>

	servo_setPos(30);

	while(1)
    {
		wdt_reset();
    34c2:	80 91 4d 05 	lds	r24, 0x054D

		TOGGLE_MAIN_LED(); //Toggle LED on the RNmega Board
    34c6:	81 11       	cpse	r24, r1
    34c8:	27 c0       	rjmp	.+78     	; 0x3518 <main+0x2b0>

		////////////////////////////////////////////////////////////////////////////

		maze_solveRoutes(); //Has to be called to calculate routes in main-loop, when nessesary (because it needs up to 2s)
    34ca:	90 91 51 05 	lds	r25, 0x0551
		maze_localize(); //"
    34ce:	80 91 55 05 	lds	r24, 0x0555

		////////////////////////////////////////////////////////////////////////////
		if(get_t1())
    34d2:	91 11       	cpse	r25, r1
    34d4:	07 c0       	rjmp	.+14     	; 0x34e4 <main+0x27c>
    34d6:	81 11       	cpse	r24, r1
    34d8:	05 c0       	rjmp	.+10     	; 0x34e4 <main+0x27c>
		{
			if((timer_get_tast == 0) && (timer_entpr_tast == 0) && (!hold_t1))
    34da:	d0 92 4d 05 	sts	0x054D, r13
    34de:	10 93 55 05 	sts	0x0555, r17
    34e2:	1a c0       	rjmp	.+52     	; 0x3518 <main+0x2b0>
    34e4:	88 23       	and	r24, r24
    34e6:	c1 f0       	breq	.+48     	; 0x3518 <main+0x2b0>
    34e8:	0e 94 c3 34 	call	0x6986	; 0x6986 <drive_reset>
    34ec:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
    34f0:	10 92 cd 05 	sts	0x05CD, r1
			{
				timer_get_tast = TIMER_GET_TAST;
    34f4:	10 92 c6 05 	sts	0x05C6, r1
				hold_t1 = 1;
    34f8:	10 92 c4 05 	sts	0x05C4, r1
			}
			else if((timer_get_tast == 0) && hold_t1)
    34fc:	10 92 55 05 	sts	0x0555, r1
			{
				drive_reset(); //Fahrfunktionen zurcksetzen
    3500:	80 91 7f 16 	lds	r24, 0x167F
				maze_clearDepthsearch();
    3504:	8f 25       	eor	r24, r15
    3506:	80 93 7f 16 	sts	0x167F, r24
					maze_solve_state_path = DRIVE_READY;
    350a:	e0 92 51 05 	sts	0x0551, r14
					routeRequest = RR_WAIT;
    350e:	04 c0       	rjmp	.+8      	; 0x3518 <main+0x2b0>
					locRequest = LR_WAIT;
    3510:	10 92 4d 05 	sts	0x054D, r1

				hold_t1 = 0;
    3514:	10 92 55 05 	sts	0x0555, r1
				mot.off ^= 1;
    3518:	90 91 64 05 	lds	r25, 0x0564
    351c:	80 91 63 05 	lds	r24, 0x0563
    3520:	91 11       	cpse	r25, r1
				timer_entpr_tast = TIMER_ENTPR_TAST;
    3522:	02 c0       	rjmp	.+4      	; 0x3528 <main+0x2c0>
    3524:	88 23       	and	r24, r24
    3526:	39 f0       	breq	.+14     	; 0x3536 <main+0x2ce>
			}
		}
		else
		{
			timer_get_tast = 0;
    3528:	10 93 62 05 	sts	0x0562, r17
			hold_t1 = 0;
    352c:	88 23       	and	r24, r24
    352e:	d1 f0       	breq	.+52     	; 0x3564 <main+0x2fc>
		}

		////////////////////Sensorcoordination//////////////////////////////////////

		if(check_res || fatal_err)	//Flashing of the Info LED when there is an error
    3530:	b0 92 61 05 	sts	0x0561, r11
    3534:	19 c0       	rjmp	.+50     	; 0x3568 <main+0x300>
    3536:	80 91 67 05 	lds	r24, 0x0567
    353a:	88 23       	and	r24, r24
    353c:	19 f0       	breq	.+6      	; 0x3544 <main+0x2dc>
    353e:	80 92 62 05 	sts	0x0562, r8
			led_fault = 1;
    3542:	10 c0       	rjmp	.+32     	; 0x3564 <main+0x2fc>
		else if(check_um6 != 0)
			led_fault = 180;
		else
			led_fault = 0;
		
		if(fatal_err)
    3544:	80 91 66 05 	lds	r24, 0x0566
			led_top = LED_TOP_FAT_ERR;
    3548:	88 23       	and	r24, r24
    354a:	19 f0       	breq	.+6      	; 0x3552 <main+0x2ea>
    354c:	90 92 62 05 	sts	0x0562, r9

		////////////////////Sensorcoordination//////////////////////////////////////

		if(check_res || fatal_err)	//Flashing of the Info LED when there is an error
			led_fault = 1;
		else if(check_mlx != 0)
    3550:	09 c0       	rjmp	.+18     	; 0x3564 <main+0x2fc>
    3552:	80 91 65 05 	lds	r24, 0x0565
			led_fault = 55;
    3556:	88 23       	and	r24, r24
    3558:	19 f0       	breq	.+6      	; 0x3560 <main+0x2f8>
    355a:	a0 92 62 05 	sts	0x0562, r10
		else if(check_srf != 0)
    355e:	02 c0       	rjmp	.+4      	; 0x3564 <main+0x2fc>
    3560:	10 92 62 05 	sts	0x0562, r1
			led_fault = 130;
    3564:	c0 92 61 05 	sts	0x0561, r12
    3568:	80 91 52 05 	lds	r24, 0x0552
		else if(check_um6 != 0)
    356c:	99 23       	and	r25, r25
    356e:	c9 f0       	breq	.+50     	; 0x35a2 <main+0x33a>
    3570:	80 fd       	sbrc	r24, 0
			led_fault = 180;
    3572:	1a c0       	rjmp	.+52     	; 0x35a8 <main+0x340>
    3574:	80 91 53 05 	lds	r24, 0x0553
		else
			led_fault = 0;
    3578:	82 30       	cpi	r24, 0x02	; 2
    357a:	78 f0       	brcs	.+30     	; 0x359a <main+0x332>
		
		if(fatal_err)
			led_top = LED_TOP_FAT_ERR;
		else
			led_top = LED_TOP_NORMAL;
    357c:	8f ed       	ldi	r24, 0xDF	; 223
    357e:	91 e0       	ldi	r25, 0x01	; 1
    3580:	23 d5       	rcall	.+2630   	; 0x3fc8 <bt_putStr_P>
    3582:	60 91 47 05 	lds	r22, 0x0547
			
		if(check_res)
    3586:	70 91 48 05 	lds	r23, 0x0548
		{
			if(!(debug_err_sendOneTime & (1<<0)))
    358a:	80 91 49 05 	lds	r24, 0x0549
			{
				if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR: RESET"));}
    358e:	90 91 4a 05 	lds	r25, 0x054A
    3592:	2c d5       	rcall	.+2648   	; 0x3fec <bt_putLong>
    3594:	80 ed       	ldi	r24, 0xD0	; 208
    3596:	91 e0       	ldi	r25, 0x01	; 1
    3598:	17 d5       	rcall	.+2606   	; 0x3fc8 <bt_putStr_P>
    359a:	80 91 52 05 	lds	r24, 0x0552
    359e:	81 60       	ori	r24, 0x01	; 1
    35a0:	01 c0       	rjmp	.+2      	; 0x35a4 <main+0x33c>
    35a2:	8e 7f       	andi	r24, 0xFE	; 254
    35a4:	80 93 52 05 	sts	0x0552, r24
    35a8:	90 91 67 05 	lds	r25, 0x0567
    35ac:	80 91 52 05 	lds	r24, 0x0552
    35b0:	99 23       	and	r25, r25
    35b2:	c9 f0       	breq	.+50     	; 0x35e6 <main+0x37e>
    35b4:	81 fd       	sbrc	r24, 1
    35b6:	1a c0       	rjmp	.+52     	; 0x35ec <main+0x384>
				debug_err_sendOneTime |= (1<<0);
    35b8:	80 91 53 05 	lds	r24, 0x0553
    35bc:	82 30       	cpi	r24, 0x02	; 2
    35be:	78 f0       	brcs	.+30     	; 0x35de <main+0x376>
			}
		}
		else	debug_err_sendOneTime &= ~(1<<0);
    35c0:	8d ec       	ldi	r24, 0xCD	; 205
    35c2:	91 e0       	ldi	r25, 0x01	; 1
    35c4:	01 d5       	rcall	.+2562   	; 0x3fc8 <bt_putStr_P>
		
		if(check_mlx != 0)
    35c6:	60 91 47 05 	lds	r22, 0x0547
    35ca:	70 91 48 05 	lds	r23, 0x0548
    35ce:	80 91 49 05 	lds	r24, 0x0549
		{
			if(!(debug_err_sendOneTime & (1<<1)))
    35d2:	90 91 4a 05 	lds	r25, 0x054A
			{
				if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR: Melexis MLX90614 Temperature sensors"));}
    35d6:	0a d5       	rcall	.+2580   	; 0x3fec <bt_putLong>
    35d8:	8f e9       	ldi	r24, 0x9F	; 159
    35da:	91 e0       	ldi	r25, 0x01	; 1
    35dc:	f5 d4       	rcall	.+2538   	; 0x3fc8 <bt_putStr_P>
    35de:	80 91 52 05 	lds	r24, 0x0552
    35e2:	82 60       	ori	r24, 0x02	; 2
    35e4:	01 c0       	rjmp	.+2      	; 0x35e8 <main+0x380>
    35e6:	8d 7f       	andi	r24, 0xFD	; 253
    35e8:	80 93 52 05 	sts	0x0552, r24
    35ec:	90 91 65 05 	lds	r25, 0x0565
    35f0:	80 91 52 05 	lds	r24, 0x0552
    35f4:	99 23       	and	r25, r25
    35f6:	c9 f0       	breq	.+50     	; 0x362a <main+0x3c2>
    35f8:	82 fd       	sbrc	r24, 2
    35fa:	1a c0       	rjmp	.+52     	; 0x3630 <main+0x3c8>
    35fc:	80 91 53 05 	lds	r24, 0x0553
    3600:	82 30       	cpi	r24, 0x02	; 2
				debug_err_sendOneTime |= (1<<1);
    3602:	78 f0       	brcs	.+30     	; 0x3622 <main+0x3ba>
    3604:	8c e9       	ldi	r24, 0x9C	; 156
    3606:	91 e0       	ldi	r25, 0x01	; 1
    3608:	df d4       	rcall	.+2494   	; 0x3fc8 <bt_putStr_P>
			}
		}
		else	debug_err_sendOneTime &= ~(1<<1);
    360a:	60 91 47 05 	lds	r22, 0x0547
    360e:	70 91 48 05 	lds	r23, 0x0548
		
		if(check_um6 != 0)
    3612:	80 91 49 05 	lds	r24, 0x0549
    3616:	90 91 4a 05 	lds	r25, 0x054A
    361a:	e8 d4       	rcall	.+2512   	; 0x3fec <bt_putLong>
		{
			if(!(debug_err_sendOneTime & (1<<2)))
    361c:	80 e8       	ldi	r24, 0x80	; 128
    361e:	91 e0       	ldi	r25, 0x01	; 1
			{
				if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR: CHRobotics UM6 IMU"));}
    3620:	d3 d4       	rcall	.+2470   	; 0x3fc8 <bt_putStr_P>
    3622:	80 91 52 05 	lds	r24, 0x0552
    3626:	84 60       	ori	r24, 0x04	; 4
    3628:	01 c0       	rjmp	.+2      	; 0x362c <main+0x3c4>
    362a:	8b 7f       	andi	r24, 0xFB	; 251
    362c:	80 93 52 05 	sts	0x0552, r24
    3630:	80 91 fc 07 	lds	r24, 0x07FC
    3634:	90 91 fd 07 	lds	r25, 0x07FD
    3638:	18 16       	cp	r1, r24
    363a:	19 06       	cpc	r1, r25
    363c:	84 f5       	brge	.+96     	; 0x369e <main+0x436>
    363e:	78 9e       	mul	r7, r24
    3640:	b0 01       	movw	r22, r0
    3642:	79 9e       	mul	r7, r25
    3644:	70 0d       	add	r23, r0
    3646:	11 24       	eor	r1, r1
    3648:	6c 52       	subi	r22, 0x2C	; 44
    364a:	71 40       	sbci	r23, 0x01	; 1
				debug_err_sendOneTime |= (1<<2);
    364c:	70 93 5f 05 	sts	0x055F, r23
    3650:	60 93 5e 05 	sts	0x055E, r22
			}
		}
		else	debug_err_sendOneTime &= ~(1<<2);
    3654:	80 91 99 02 	lds	r24, 0x0299
    3658:	90 91 9a 02 	lds	r25, 0x029A
		
		//Batterie/Akku
		if(batt_raw > 0)
    365c:	68 17       	cp	r22, r24
    365e:	79 07       	cpc	r23, r25
    3660:	c0 f4       	brcc	.+48     	; 0x3692 <main+0x42a>
    3662:	70 93 9a 02 	sts	0x029A, r23
    3666:	60 93 99 02 	sts	0x0299, r22
		{
			batt_mV = (batt_raw*15)-300;
    366a:	80 e0       	ldi	r24, 0x00	; 0
    366c:	90 e0       	ldi	r25, 0x00	; 0
    366e:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    3672:	20 e5       	ldi	r18, 0x50	; 80
    3674:	3d e8       	ldi	r19, 0x8D	; 141
    3676:	47 e1       	ldi	r20, 0x17	; 23
    3678:	5d e3       	ldi	r21, 0x3D	; 61
    367a:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>

			if(batt_mV < batt_mV_old)
    367e:	20 e0       	ldi	r18, 0x00	; 0
    3680:	30 e8       	ldi	r19, 0x80	; 128
    3682:	45 eb       	ldi	r20, 0xB5	; 181
    3684:	53 e4       	ldi	r21, 0x43	; 67
    3686:	0e 94 14 69 	call	0xd228	; 0xd228 <__subsf3>
    368a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
			{
				batt_mV_old = batt_mV;
    368e:	60 93 60 05 	sts	0x0560, r22
    3692:	80 91 60 05 	lds	r24, 0x0560
				batt_percent = (0.037*batt_mV) - 363;
    3696:	84 31       	cpi	r24, 0x14	; 20
    3698:	14 f4       	brge	.+4      	; 0x369e <main+0x436>
    369a:	80 93 9b 02 	sts	0x029B, r24
    369e:	60 91 62 05 	lds	r22, 0x0562
    36a2:	70 e0       	ldi	r23, 0x00	; 0
    36a4:	80 91 9b 02 	lds	r24, 0x029B
    36a8:	40 91 61 05 	lds	r20, 0x0561
    36ac:	90 e0       	ldi	r25, 0x00	; 0
    36ae:	0e 94 9b 35 	call	0x6b36	; 0x6b36 <led_rgb>
    36b2:	80 91 5d 05 	lds	r24, 0x055D
    36b6:	81 11       	cpse	r24, r1
    36b8:	05 c0       	rjmp	.+10     	; 0x36c4 <main+0x45c>
    36ba:	8b e1       	ldi	r24, 0x1B	; 27
			}
			if(batt_percent < 20) //Batterie
    36bc:	97 e0       	ldi	r25, 0x07	; 7
    36be:	3b d3       	rcall	.+1654   	; 0x3d36 <u8g_FirstPage>
    36c0:	10 93 5d 05 	sts	0x055D, r17
				led_heartbeatColor = batt_percent;
    36c4:	f7 d5       	rcall	.+3054   	; 0x42b4 <u8g_DrawInfo>
    36c6:	80 91 54 05 	lds	r24, 0x0554
		}

		////////////////////////////////////////////////////////////////////////////
		//LED heartbeat

		led_rgb(led_heartbeatColor, led_fault, led_top);
    36ca:	81 30       	cpi	r24, 0x01	; 1
    36cc:	19 f4       	brne	.+6      	; 0x36d4 <main+0x46c>
    36ce:	0e 94 90 23 	call	0x4720	; 0x4720 <u8g_DrawSetUp>
    36d2:	41 c0       	rjmp	.+130    	; 0x3756 <main+0x4ee>
    36d4:	82 30       	cpi	r24, 0x02	; 2
    36d6:	19 f4       	brne	.+6      	; 0x36de <main+0x476>
    36d8:	0e 94 bb 24 	call	0x4976	; 0x4976 <u8g_DrawView>
		//displayvar[5] = (victimBuf[LEFT].value[0]-victimBuf[LEFT].lowest);


		//setup = 1;

		if(!u8g_stateMachine)
    36dc:	3c c0       	rjmp	.+120    	; 0x3756 <main+0x4ee>
    36de:	83 30       	cpi	r24, 0x03	; 3
    36e0:	19 f4       	brne	.+6      	; 0x36e8 <main+0x480>
    36e2:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <u8g_DrawCamRaw>
		{
			u8g_FirstPage(&u8g);
    36e6:	37 c0       	rjmp	.+110    	; 0x3756 <main+0x4ee>
    36e8:	84 30       	cpi	r24, 0x04	; 4
    36ea:	19 f4       	brne	.+6      	; 0x36f2 <main+0x48a>
			u8g_stateMachine = 1;
    36ec:	0e 94 92 28 	call	0x5124	; 0x5124 <u8g_DrawVictim>
		}
		//////////////Displayausgaben////////////////

		u8g_DrawInfo(); //Message Line (upper 8 lines of lcd) in display.c!
    36f0:	32 c0       	rjmp	.+100    	; 0x3756 <main+0x4ee>
    36f2:	0e 94 bf 42 	call	0x857e	; 0x857e <u8g_DrawMaze>

		if(setup == 1)
    36f6:	29 e3       	ldi	r18, 0x39	; 57
    36f8:	47 e0       	ldi	r20, 0x07	; 7
    36fa:	67 e5       	ldi	r22, 0x57	; 87
			u8g_DrawSetUp();
    36fc:	8b e1       	ldi	r24, 0x1B	; 27
    36fe:	97 e0       	ldi	r25, 0x07	; 7
    3700:	da d3       	rcall	.+1972   	; 0x3eb6 <u8g_DrawVLine>
			//m2_drawSetup();
		else if(setup == 2)
    3702:	67 e3       	ldi	r22, 0x37	; 55
    3704:	7e e0       	ldi	r23, 0x0E	; 14
			u8g_DrawView();
    3706:	8b e1       	ldi	r24, 0x1B	; 27
    3708:	97 e0       	ldi	r25, 0x07	; 7
    370a:	d6 d1       	rcall	.+940    	; 0x3ab8 <u8g_SetFont>
		else if(setup == 3)
    370c:	0e 94 6e 5a 	call	0xb4dc	; 0xb4dc <get_mem_unused>
			u8g_DrawCamRaw();
    3710:	a0 e0       	ldi	r26, 0x00	; 0
    3712:	b0 e0       	ldi	r27, 0x00	; 0
    3714:	80 93 6e 07 	sts	0x076E, r24
		else if(setup == 4)
    3718:	90 93 6f 07 	sts	0x076F, r25
			u8g_DrawVictim();
    371c:	a0 93 70 07 	sts	0x0770, r26
		else
		{
			u8g_DrawMaze(); //Everything about the maze (in maze.c!)
    3720:	b0 93 71 07 	sts	0x0771, r27
			//u8g_DrawPixy();
			//u8g_DrawTempScan(LEFT);
			//u8g_DrawFrontScan();

			u8g_DrawVLine(&u8g, 87, 7, 57); //vertical line
    3724:	32 e5       	ldi	r19, 0x52	; 82
    3726:	43 2e       	mov	r4, r19
    3728:	37 e0       	ldi	r19, 0x07	; 7
    372a:	53 2e       	mov	r5, r19
    372c:	9f e0       	ldi	r25, 0x0F	; 15
    372e:	f2 01       	movw	r30, r4
    3730:	21 91       	ld	r18, Z+
			//          /////////       //
			//          //Info //   X   //
			//          //Karte//       //
			//////////////////////////////

			u8g_SetFont(&u8g, u8g_font_5x7);
    3732:	31 91       	ld	r19, Z+
    3734:	41 91       	ld	r20, Z+
    3736:	51 91       	ld	r21, Z+
    3738:	2f 01       	movw	r4, r30
    373a:	2f 3f       	cpi	r18, 0xFF	; 255
    373c:	ff ef       	ldi	r31, 0xFF	; 255

			displayvar[7] = get_mem_unused();
    373e:	3f 07       	cpc	r19, r31
    3740:	41 05       	cpc	r20, r1
    3742:	51 05       	cpc	r21, r1
    3744:	29 f0       	breq	.+10     	; 0x3750 <main+0x4e8>
    3746:	69 2f       	mov	r22, r25
    3748:	8a e5       	ldi	r24, 0x5A	; 90
    374a:	99 83       	std	Y+1, r25	; 0x01
    374c:	63 d4       	rcall	.+2246   	; 0x4014 <u8g_DrawLong>
    374e:	99 81       	ldd	r25, Y+1	; 0x01
    3750:	99 5f       	subi	r25, 0xF9	; 249
    3752:	9e 34       	cpi	r25, 0x4E	; 78
    3754:	61 f7       	brne	.-40     	; 0x372e <main+0x4c6>
    3756:	8b e1       	ldi	r24, 0x1B	; 27
    3758:	97 e0       	ldi	r25, 0x07	; 7
    375a:	f1 d2       	rcall	.+1506   	; 0x3d3e <u8g_NextPage>
    375c:	81 11       	cpse	r24, r1
    375e:	a5 ce       	rjmp	.-694    	; 0x34aa <main+0x242>

			for(uint8_t i = 0; i <= DISPLAYVARS; i++)
				if(displayvar[i] != 0xffff)
    3760:	10 92 5d 05 	sts	0x055D, r1
    3764:	9a ce       	rjmp	.-716    	; 0x349a <main+0x232>

00003766 <u8g_font_get_word>:

static uint16_t u8g_font_get_word(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE; 
static uint16_t u8g_font_get_word(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
    3766:	fc 01       	movw	r30, r24
    3768:	e6 0f       	add	r30, r22
    376a:	f1 1d       	adc	r31, r1
    pos = u8g_pgm_read( (u8g_pgm_uint8_t *)font );
    376c:	84 91       	lpm	r24, Z
    376e:	90 e0       	ldi	r25, 0x00	; 0
    font++;
    pos <<= 8;
    3770:	98 2f       	mov	r25, r24
    3772:	88 27       	eor	r24, r24
static uint16_t u8g_font_get_word(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
    pos = u8g_pgm_read( (u8g_pgm_uint8_t *)font );
    font++;
    3774:	31 96       	adiw	r30, 0x01	; 1
    pos <<= 8;
    pos += u8g_pgm_read( (u8g_pgm_uint8_t *)font);
    3776:	e4 91       	lpm	r30, Z
    return pos;
}
    3778:	8e 0f       	add	r24, r30
    377a:	91 1d       	adc	r25, r1
    377c:	08 95       	ret

0000377e <u8g_font_GetFormat>:
/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    377e:	fc 01       	movw	r30, r24
    3780:	84 91       	lpm	r24, Z

static uint8_t u8g_font_GetFormat(const u8g_fntpgm_uint8_t *font) U8G_NOINLINE;
static uint8_t u8g_font_GetFormat(const u8g_fntpgm_uint8_t *font)
{
  return u8g_font_get_byte(font, 0);
}
    3782:	08 95       	ret

00003784 <u8g_font_GetFontGlyphStructureSize>:

static uint8_t u8g_font_GetFontGlyphStructureSize(const u8g_fntpgm_uint8_t *font) U8G_NOINLINE;
static uint8_t u8g_font_GetFontGlyphStructureSize(const u8g_fntpgm_uint8_t *font)
{
  switch(u8g_font_GetFormat(font))
    3784:	fc df       	rcall	.-8      	; 0x377e <u8g_font_GetFormat>
    3786:	88 23       	and	r24, r24
    3788:	11 f0       	breq	.+4      	; 0x378e <u8g_font_GetFontGlyphStructureSize+0xa>
    378a:	82 30       	cpi	r24, 0x02	; 2
    378c:	11 f4       	brne	.+4      	; 0x3792 <u8g_font_GetFontGlyphStructureSize+0xe>
    378e:	86 e0       	ldi	r24, 0x06	; 6
  {
    case 0: return 6;
    3790:	08 95       	ret
    3792:	83 e0       	ldi	r24, 0x03	; 3
    case 1: return 3;
    3794:	08 95       	ret

00003796 <u8g_font_calc_vref_font>:
/* callback procedures to correct the y position */

u8g_uint_t u8g_font_calc_vref_font(u8g_t *u8g)
{
  return 0;
}
    3796:	80 e0       	ldi	r24, 0x00	; 0
    3798:	08 95       	ret

0000379a <u8g_font_GetEncoding65Pos>:
}

uint16_t u8g_font_GetEncoding65Pos(const void *font) U8G_NOINLINE;
uint16_t u8g_font_GetEncoding65Pos(const void *font)
{
    return u8g_font_get_word(font, 6);
    379a:	66 e0       	ldi	r22, 0x06	; 6
    379c:	e4 cf       	rjmp	.-56     	; 0x3766 <u8g_font_get_word>

0000379e <u8g_font_GetEncoding97Pos>:
}

uint16_t u8g_font_GetEncoding97Pos(const void *font) U8G_NOINLINE;
uint16_t u8g_font_GetEncoding97Pos(const void *font)
{
    return u8g_font_get_word(font, 8);
    379e:	68 e0       	ldi	r22, 0x08	; 8
    37a0:	e2 cf       	rjmp	.-60     	; 0x3766 <u8g_font_get_word>

000037a2 <u8g_font_GetFontStartEncoding>:

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    37a2:	0a 96       	adiw	r24, 0x0a	; 10
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    37a4:	fc 01       	movw	r30, r24
    37a6:	84 91       	lpm	r24, Z
}

uint8_t u8g_font_GetFontStartEncoding(const void *font)
{
  return u8g_font_get_byte(font, 10);
}
    37a8:	08 95       	ret

000037aa <u8g_font_GetFontEndEncoding>:

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    37aa:	0b 96       	adiw	r24, 0x0b	; 11
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    37ac:	fc 01       	movw	r30, r24
    37ae:	84 91       	lpm	r24, Z
}

uint8_t u8g_font_GetFontEndEncoding(const void *font)
{
  return u8g_font_get_byte(font, 11);
}
    37b0:	08 95       	ret

000037b2 <u8g_GetGlyph>:
/*
  Find (with some speed optimization) and return a pointer to the glyph data structure
  Also uncompress (format 1) and copy the content of the data structure to the u8g structure
*/
u8g_glyph_t u8g_GetGlyph(u8g_t *u8g, uint8_t requested_encoding)
{
    37b2:	a0 e0       	ldi	r26, 0x00	; 0
    37b4:	b0 e0       	ldi	r27, 0x00	; 0
    37b6:	ef ed       	ldi	r30, 0xDF	; 223
    37b8:	fb e1       	ldi	r31, 0x1B	; 27
    37ba:	0c 94 a3 6b 	jmp	0xd746	; 0xd746 <__prologue_saves__+0x10>
    37be:	ec 01       	movw	r28, r24
    37c0:	d6 2e       	mov	r13, r22
  uint8_t *p = (uint8_t *)(u8g->font);
    37c2:	0c 81       	ldd	r16, Y+4	; 0x04
    37c4:	1d 81       	ldd	r17, Y+5	; 0x05
  uint8_t font_format = u8g_font_GetFormat(u8g->font);
    37c6:	c8 01       	movw	r24, r16
    37c8:	da df       	rcall	.-76     	; 0x377e <u8g_font_GetFormat>
    37ca:	e8 2e       	mov	r14, r24
    37cc:	c8 01       	movw	r24, r16
  uint8_t data_structure_size = u8g_font_GetFontGlyphStructureSize(u8g->font);
    37ce:	da df       	rcall	.-76     	; 0x3784 <u8g_font_GetFontGlyphStructureSize>
    37d0:	a8 2e       	mov	r10, r24
    37d2:	21 e0       	ldi	r18, 0x01	; 1
    37d4:	e2 16       	cp	r14, r18
  uint8_t start, end;
  uint16_t pos;
  uint8_t i;
  uint8_t mask = 255;

  if ( font_format == 1 )
    37d6:	19 f0       	breq	.+6      	; 0x37de <u8g_GetGlyph+0x2c>
    37d8:	cc 24       	eor	r12, r12
    37da:	ca 94       	dec	r12
  uint8_t font_format = u8g_font_GetFormat(u8g->font);
  uint8_t data_structure_size = u8g_font_GetFontGlyphStructureSize(u8g->font);
  uint8_t start, end;
  uint16_t pos;
  uint8_t i;
  uint8_t mask = 255;
    37dc:	02 c0       	rjmp	.+4      	; 0x37e2 <u8g_GetGlyph+0x30>
    37de:	6f e0       	ldi	r22, 0x0F	; 15
    37e0:	c6 2e       	mov	r12, r22

  if ( font_format == 1 )
    mask = 15;
    37e2:	c8 01       	movw	r24, r16
    37e4:	de df       	rcall	.-68     	; 0x37a2 <u8g_font_GetFontStartEncoding>
  
  start = u8g_font_GetFontStartEncoding(u8g->font);
    37e6:	f8 2e       	mov	r15, r24
    37e8:	c8 01       	movw	r24, r16
    37ea:	df df       	rcall	.-66     	; 0x37aa <u8g_font_GetFontEndEncoding>
    37ec:	b8 2e       	mov	r11, r24
  end = u8g_font_GetFontEndEncoding(u8g->font);
    37ee:	c8 01       	movw	r24, r16
    37f0:	d6 df       	rcall	.-84     	; 0x379e <u8g_font_GetEncoding97Pos>
    37f2:	e0 e6       	ldi	r30, 0x60	; 96
    37f4:	ed 15       	cp	r30, r13

  pos = u8g_font_GetEncoding97Pos(u8g->font);
    37f6:	40 f4       	brcc	.+16     	; 0x3808 <u8g_GetGlyph+0x56>
    37f8:	00 97       	sbiw	r24, 0x00	; 0
    37fa:	31 f0       	breq	.+12     	; 0x3808 <u8g_GetGlyph+0x56>
  if ( requested_encoding >= 97 && pos > 0 )
    37fc:	98 01       	movw	r18, r16
    37fe:	28 0f       	add	r18, r24
    3800:	39 1f       	adc	r19, r25
    3802:	51 e6       	ldi	r21, 0x61	; 97
    3804:	f5 2e       	mov	r15, r21
  {
    p+= pos;
    3806:	0f c0       	rjmp	.+30     	; 0x3826 <u8g_GetGlyph+0x74>
    3808:	c8 01       	movw	r24, r16
    380a:	c7 df       	rcall	.-114    	; 0x379a <u8g_font_GetEncoding65Pos>
    start = 97;
    380c:	f0 e4       	ldi	r31, 0x40	; 64
    380e:	98 01       	movw	r18, r16
    3810:	fd 15       	cp	r31, r13
  }
  else 
  {
    pos = u8g_font_GetEncoding65Pos(u8g->font);
    3812:	38 f4       	brcc	.+14     	; 0x3822 <u8g_GetGlyph+0x70>
    3814:	00 97       	sbiw	r24, 0x00	; 0
    3816:	29 f0       	breq	.+10     	; 0x3822 <u8g_GetGlyph+0x70>
    if ( requested_encoding >= 65 && pos > 0 )
    3818:	28 0f       	add	r18, r24
    {
      p+= pos;
    381a:	39 1f       	adc	r19, r25
    start = 97;
  }
  else 
  {
    pos = u8g_font_GetEncoding65Pos(u8g->font);
    if ( requested_encoding >= 65 && pos > 0 )
    381c:	41 e4       	ldi	r20, 0x41	; 65
    381e:	f4 2e       	mov	r15, r20
    3820:	02 c0       	rjmp	.+4      	; 0x3826 <u8g_GetGlyph+0x74>
    3822:	2f 5e       	subi	r18, 0xEF	; 239
    {
      p+= pos;
    3824:	3f 4f       	sbci	r19, 0xFF	; 255
    3826:	bd 14       	cp	r11, r13
      start = 65;
    3828:	40 f4       	brcc	.+16     	; 0x383a <u8g_GetGlyph+0x88>
    382a:	18 8a       	std	Y+16, r1	; 0x10
    382c:	1b 8a       	std	Y+19, r1	; 0x13
    }
    else
      p += U8G_FONT_DATA_STRUCT_SIZE;       /* skip font general information */  
    382e:	1c 8a       	std	Y+20, r1	; 0x14
    3830:	19 8a       	std	Y+17, r1	; 0x11
  }
  
  if ( requested_encoding > end )
    3832:	1a 8a       	std	Y+18, r1	; 0x12
    3834:	80 e0       	ldi	r24, 0x00	; 0
}

//void u8g_FillEmptyGlyphCache(u8g_t *u8g) U8G_NOINLINE;
static void u8g_FillEmptyGlyphCache(u8g_t *u8g)
{
  u8g->glyph_dx = 0;
    3836:	90 e0       	ldi	r25, 0x00	; 0
  u8g->glyph_width = 0;
    3838:	4c c0       	rjmp	.+152    	; 0x38d2 <u8g_GetGlyph+0x120>
  u8g->glyph_height = 0;
    383a:	bf 14       	cp	r11, r15
  u8g->glyph_x = 0;
    383c:	b0 f3       	brcs	.-20     	; 0x382a <u8g_GetGlyph+0x78>
  u8g->glyph_y = 0;
    383e:	4a 2d       	mov	r20, r10
  }
  
  if ( requested_encoding > end )
  {
    u8g_FillEmptyGlyphCache(u8g);
    return NULL;                      /* not found */
    3840:	50 e0       	ldi	r21, 0x00	; 0
    3842:	f9 01       	movw	r30, r18
    3844:	84 91       	lpm	r24, Z
  }
  
  i = start;
  if ( i <= end )
    3846:	8f 3f       	cpi	r24, 0xFF	; 255
    3848:	19 f4       	brne	.+6      	; 0x3850 <u8g_GetGlyph+0x9e>
        {
          u8g_CopyGlyphDataToCache(u8g, p);
          return p;
        }
        p += u8g_pgm_read( ((u8g_pgm_uint8_t *)(p)) + 2 ) & mask;
        p += data_structure_size;
    384a:	2f 5f       	subi	r18, 0xFF	; 255
    384c:	3f 4f       	sbci	r19, 0xFF	; 255
  i = start;
  if ( i <= end )
  {
    for(;;)
    {
      if ( u8g_pgm_read((u8g_pgm_uint8_t *)(p)) == 255 )
    384e:	3c c0       	rjmp	.+120    	; 0x38c8 <u8g_GetGlyph+0x116>
    3850:	fd 10       	cpse	r15, r13
    3852:	32 c0       	rjmp	.+100    	; 0x38b8 <u8g_GetGlyph+0x106>
    3854:	a9 01       	movw	r20, r18
      {
        p += 1;
    3856:	4f 5f       	subi	r20, 0xFF	; 255
    3858:	5f 4f       	sbci	r21, 0xFF	; 255
    385a:	ee 20       	and	r14, r14
      }
      else
      {
        if ( i == requested_encoding )
    385c:	19 f0       	breq	.+6      	; 0x3864 <u8g_GetGlyph+0xb2>
    385e:	f2 e0       	ldi	r31, 0x02	; 2
    3860:	ef 12       	cpse	r14, r31
    3862:	13 c0       	rjmp	.+38     	; 0x388a <u8g_GetGlyph+0xd8>
    3864:	f9 01       	movw	r30, r18
/* glyph handling */

static void u8g_CopyGlyphDataToCache(u8g_t *u8g, u8g_glyph_t g)
{
  uint8_t tmp;
  switch( u8g_font_GetFormat(u8g->font) )
    3866:	84 91       	lpm	r24, Z
    3868:	8b 8b       	std	Y+19, r24	; 0x13
    386a:	fa 01       	movw	r30, r20
    386c:	44 91       	lpm	r20, Z
    386e:	4c 8b       	std	Y+20, r20	; 0x14
    3             DWIDTH                                          signed
    4             BBX xoffset                                    signed
    5             BBX yoffset                                    signed
  byte 0 == 255 indicates empty glyph
  */
      u8g->glyph_width =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 0 );
    3870:	f9 01       	movw	r30, r18
    3872:	33 96       	adiw	r30, 0x03	; 3
    3874:	e4 91       	lpm	r30, Z
      u8g->glyph_height =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 1 );
    3876:	e8 8b       	std	Y+16, r30	; 0x10
    3878:	f9 01       	movw	r30, r18
    387a:	34 96       	adiw	r30, 0x04	; 4
      u8g->glyph_dx =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 3 );
    387c:	e4 91       	lpm	r30, Z
    387e:	e9 8b       	std	Y+17, r30	; 0x11
    3880:	f9 01       	movw	r30, r18
    3882:	35 96       	adiw	r30, 0x05	; 5
      u8g->glyph_x =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 4 );
    3884:	e4 91       	lpm	r30, Z
    3886:	ea 8b       	std	Y+18, r30	; 0x12
    3888:	15 c0       	rjmp	.+42     	; 0x38b4 <u8g_GetGlyph+0x102>
    388a:	98 2f       	mov	r25, r24
      u8g->glyph_y =  u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 5 );
    388c:	9f 70       	andi	r25, 0x0F	; 15
    388e:	92 50       	subi	r25, 0x02	; 2
    3890:	9a 8b       	std	Y+18, r25	; 0x12
    3892:	82 95       	swap	r24
    3894:	8f 70       	andi	r24, 0x0F	; 15
  2             DWIDTH                                          signed --> upper  4 Bit
  byte 0 == 255 indicates empty glyph
      */
    
      tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 0 );
      u8g->glyph_y =  tmp & 15;
    3896:	89 8b       	std	Y+17, r24	; 0x11
    3898:	fa 01       	movw	r30, r20
      u8g->glyph_y-=2;
    389a:	44 91       	lpm	r20, Z
    389c:	84 2f       	mov	r24, r20
      tmp >>= 4;
    389e:	8f 70       	andi	r24, 0x0F	; 15
    38a0:	8c 8b       	std	Y+20, r24	; 0x14
      u8g->glyph_x =  tmp;
    38a2:	42 95       	swap	r20
    
      tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 1 );
    38a4:	4f 70       	andi	r20, 0x0F	; 15
    38a6:	4b 8b       	std	Y+19, r20	; 0x13
      u8g->glyph_height =  tmp & 15;
    38a8:	f9 01       	movw	r30, r18
    38aa:	32 96       	adiw	r30, 0x02	; 2
    38ac:	e4 91       	lpm	r30, Z
      tmp >>= 4;
    38ae:	e2 95       	swap	r30
    38b0:	ef 70       	andi	r30, 0x0F	; 15
      u8g->glyph_width =  tmp;
    38b2:	e8 8b       	std	Y+16, r30	; 0x10
      
      tmp = u8g_pgm_read( ((u8g_pgm_uint8_t *)g) + 2 );
    38b4:	c9 01       	movw	r24, r18
    38b6:	0d c0       	rjmp	.+26     	; 0x38d2 <u8g_GetGlyph+0x120>
    38b8:	f9 01       	movw	r30, r18
      tmp >>= 4;
    38ba:	32 96       	adiw	r30, 0x02	; 2
    38bc:	e4 91       	lpm	r30, Z
      u8g->glyph_dx = tmp;
    38be:	ec 21       	and	r30, r12
    38c0:	2e 0f       	add	r18, r30
    38c2:	31 1d       	adc	r19, r1
        if ( i == requested_encoding )
        {
          u8g_CopyGlyphDataToCache(u8g, p);
          return p;
        }
        p += u8g_pgm_read( ((u8g_pgm_uint8_t *)(p)) + 2 ) & mask;
    38c4:	24 0f       	add	r18, r20
    38c6:	35 1f       	adc	r19, r21
    38c8:	fb 14       	cp	r15, r11
    38ca:	09 f4       	brne	.+2      	; 0x38ce <u8g_GetGlyph+0x11c>
    38cc:	ae cf       	rjmp	.-164    	; 0x382a <u8g_GetGlyph+0x78>
    38ce:	f3 94       	inc	r15
        p += data_structure_size;
    38d0:	b8 cf       	rjmp	.-144    	; 0x3842 <u8g_GetGlyph+0x90>
    38d2:	cd b7       	in	r28, 0x3d	; 61
      }
      if ( i == end )
    38d4:	de b7       	in	r29, 0x3e	; 62
    38d6:	ea e0       	ldi	r30, 0x0A	; 10
    38d8:	0c 94 bf 6b 	jmp	0xd77e	; 0xd77e <__epilogue_restores__+0x10>

000038dc <u8g_draw_glyph>:
  return u8g->glyph_dx;
}
#endif

int8_t u8g_draw_glyph(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t encoding)
{
    38dc:	4f 92       	push	r4
    38de:	5f 92       	push	r5
    38e0:	7f 92       	push	r7
    38e2:	8f 92       	push	r8
    38e4:	9f 92       	push	r9
    38e6:	af 92       	push	r10
    38e8:	bf 92       	push	r11
    38ea:	cf 92       	push	r12
    38ec:	df 92       	push	r13
    38ee:	ef 92       	push	r14
    38f0:	ff 92       	push	r15
    38f2:	0f 93       	push	r16
    38f4:	1f 93       	push	r17
    38f6:	cf 93       	push	r28
    38f8:	df 93       	push	r29
    38fa:	1f 92       	push	r1
    38fc:	cd b7       	in	r28, 0x3d	; 61
    38fe:	de b7       	in	r29, 0x3e	; 62
    3900:	2c 01       	movw	r4, r24
    3902:	16 2f       	mov	r17, r22
    3904:	74 2e       	mov	r7, r20
  uint8_t w, h;
  uint8_t i, j;
  u8g_uint_t ix, iy;

  {
    u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
    3906:	62 2f       	mov	r22, r18
    3908:	54 df       	rcall	.-344    	; 0x37b2 <u8g_GetGlyph>
    390a:	6c 01       	movw	r12, r24
    390c:	00 97       	sbiw	r24, 0x00	; 0
    if ( g == NULL  )
    390e:	09 f4       	brne	.+2      	; 0x3912 <u8g_draw_glyph+0x36>
    3910:	3c c0       	rjmp	.+120    	; 0x398a <u8g_draw_glyph+0xae>
    3912:	f2 01       	movw	r30, r4


/* return the data start for a font and the glyph pointer */
static uint8_t *u8g_font_GetGlyphDataStart(const void *font, u8g_glyph_t g)
{
  return ((u8g_fntpgm_uint8_t *)g) + u8g_font_GetFontGlyphStructureSize(font);
    3914:	84 81       	ldd	r24, Z+4	; 0x04
    3916:	95 81       	ldd	r25, Z+5	; 0x05
    3918:	35 df       	rcall	.-406    	; 0x3784 <u8g_font_GetFontGlyphStructureSize>
    391a:	f8 2e       	mov	r15, r24
    391c:	f2 01       	movw	r30, r4
    391e:	83 88       	ldd	r8, Z+19	; 0x13
    if ( g == NULL  )
      return 0;
    data = u8g_font_GetGlyphDataStart(u8g->font, g);
  }
  
  w = u8g->glyph_width;
    3920:	04 89       	ldd	r16, Z+20	; 0x14
    3922:	91 88       	ldd	r9, Z+17	; 0x11
  h = u8g->glyph_height;
    3924:	91 0e       	add	r9, r17
  
  x += u8g->glyph_x;
    3926:	82 89       	ldd	r24, Z+18	; 0x12
    3928:	78 1a       	sub	r7, r24
  y -= u8g->glyph_y;
  y--;
  
  if ( u8g_IsBBXIntersection(u8g, x, y-h+1, w, h) == 0 )
    392a:	17 2d       	mov	r17, r7
    392c:	10 1b       	sub	r17, r16
    392e:	28 2d       	mov	r18, r8
    3930:	41 2f       	mov	r20, r17
    3932:	69 2d       	mov	r22, r9
    3934:	c2 01       	movw	r24, r4
    3936:	0e 94 bd 63 	call	0xc77a	; 0xc77a <u8g_IsBBXIntersection>
    393a:	88 23       	and	r24, r24
    393c:	19 f1       	breq	.+70     	; 0x3984 <u8g_draw_glyph+0xa8>
    393e:	cf 0c       	add	r12, r15
    3940:	d1 1c       	adc	r13, r1


/* return the data start for a font and the glyph pointer */
static uint8_t *u8g_font_GetGlyphDataStart(const void *font, u8g_glyph_t g)
{
  return ((u8g_fntpgm_uint8_t *)g) + u8g_font_GetFontGlyphStructureSize(font);
    3942:	f7 e0       	ldi	r31, 0x07	; 7
    3944:	8f 0e       	add	r8, r31
  
  if ( u8g_IsBBXIntersection(u8g, x, y-h+1, w, h) == 0 )
    return u8g->glyph_dx;

  /* now, w is reused as bytes per line */
  w += 7;
    3946:	86 94       	lsr	r8
    3948:	86 94       	lsr	r8
  w /= 8;
    394a:	86 94       	lsr	r8
    394c:	a8 2c       	mov	r10, r8
    394e:	b1 2c       	mov	r11, r1
    3950:	17 15       	cp	r17, r7
    3952:	c1 f0       	breq	.+48     	; 0x3984 <u8g_draw_glyph+0xa8>
  
  iy = y;
  iy -= h;
  iy++;

  for( j = 0; j < h; j++ )
    3954:	39 2d       	mov	r19, r9
    3956:	76 01       	movw	r14, r12
    3958:	8e 2d       	mov	r24, r14
    395a:	8c 19       	sub	r24, r12
    395c:	88 15       	cp	r24, r8
    395e:	70 f4       	brcc	.+28     	; 0x397c <u8g_draw_glyph+0xa0>
  {
    ix = x;
    for( i = 0; i < w; i++ )
    3960:	f7 01       	movw	r30, r14
    3962:	04 91       	lpm	r16, Z
    {
      u8g_Draw8Pixel(u8g, ix, iy, 0, u8g_pgm_read(data));
    3964:	20 e0       	ldi	r18, 0x00	; 0
    3966:	41 2f       	mov	r20, r17
    3968:	63 2f       	mov	r22, r19
    396a:	c2 01       	movw	r24, r4
    396c:	39 83       	std	Y+1, r19	; 0x01
    396e:	fd d1       	rcall	.+1018   	; 0x3d6a <u8g_Draw8Pixel>
    3970:	ff ef       	ldi	r31, 0xFF	; 255
    3972:	ef 1a       	sub	r14, r31
    3974:	ff 0a       	sbc	r15, r31
      data++;
    3976:	39 81       	ldd	r19, Y+1	; 0x01
    3978:	38 5f       	subi	r19, 0xF8	; 248
    397a:	ee cf       	rjmp	.-36     	; 0x3958 <u8g_draw_glyph+0x7c>
      ix+=8;
    397c:	ca 0c       	add	r12, r10
    397e:	db 1c       	adc	r13, r11
    3980:	1f 5f       	subi	r17, 0xFF	; 255
    3982:	e6 cf       	rjmp	.-52     	; 0x3950 <u8g_draw_glyph+0x74>
    3984:	f2 01       	movw	r30, r4
    }
    iy++;
    3986:	80 89       	ldd	r24, Z+16	; 0x10
    3988:	01 c0       	rjmp	.+2      	; 0x398c <u8g_draw_glyph+0xb0>
  }
  return u8g->glyph_dx;
    398a:	80 e0       	ldi	r24, 0x00	; 0
    398c:	0f 90       	pop	r0
    398e:	df 91       	pop	r29
  u8g_uint_t ix, iy;

  {
    u8g_glyph_t g = u8g_GetGlyph(u8g, encoding);
    if ( g == NULL  )
      return 0;
    3990:	cf 91       	pop	r28
      ix+=8;
    }
    iy++;
  }
  return u8g->glyph_dx;
}
    3992:	1f 91       	pop	r17
    3994:	0f 91       	pop	r16
    3996:	ff 90       	pop	r15
    3998:	ef 90       	pop	r14
    399a:	df 90       	pop	r13
    399c:	cf 90       	pop	r12
    399e:	bf 90       	pop	r11
    39a0:	af 90       	pop	r10
    39a2:	9f 90       	pop	r9
    39a4:	8f 90       	pop	r8
    39a6:	7f 90       	pop	r7
    39a8:	5f 90       	pop	r5
    39aa:	4f 90       	pop	r4
    39ac:	08 95       	ret

000039ae <u8g_DrawStr>:
/*========================================================================*/
/* string drawing procedures */


u8g_uint_t u8g_DrawStr(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
{
    39ae:	af 92       	push	r10
    39b0:	bf 92       	push	r11
    39b2:	df 92       	push	r13
    39b4:	ef 92       	push	r14
    39b6:	ff 92       	push	r15
    39b8:	0f 93       	push	r16
    39ba:	1f 93       	push	r17
    39bc:	cf 93       	push	r28
    39be:	df 93       	push	r29
    39c0:	1f 92       	push	r1
    39c2:	1f 92       	push	r1
    39c4:	cd b7       	in	r28, 0x3d	; 61
    39c6:	de b7       	in	r29, 0x3e	; 62
    39c8:	8c 01       	movw	r16, r24
    39ca:	e6 2e       	mov	r14, r22
    39cc:	f4 2e       	mov	r15, r20
  int8_t d;
  
  //u8g_uint_t u8g_GetStrWidth(u8g, s);
  //u8g_font_GetFontAscent(u8g->font)-u8g_font_GetFontDescent(u8g->font);
  
  y += u8g->font_calc_vref(u8g);
    39ce:	dc 01       	movw	r26, r24
    39d0:	55 96       	adiw	r26, 0x15	; 21
    39d2:	ed 91       	ld	r30, X+
    39d4:	fc 91       	ld	r31, X
    39d6:	56 97       	sbiw	r26, 0x16	; 22
    39d8:	29 83       	std	Y+1, r18	; 0x01
    39da:	3a 83       	std	Y+2, r19	; 0x02
    39dc:	19 95       	eicall
    39de:	f8 0e       	add	r15, r24
    39e0:	29 81       	ldd	r18, Y+1	; 0x01
    39e2:	a2 2e       	mov	r10, r18
    39e4:	3a 81       	ldd	r19, Y+2	; 0x02
    39e6:	b3 2e       	mov	r11, r19
/* string drawing procedures */


u8g_uint_t u8g_DrawStr(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, const char *s)
{
  u8g_uint_t t = 0;
    39e8:	d1 2c       	mov	r13, r1
  //u8g_uint_t u8g_GetStrWidth(u8g, s);
  //u8g_font_GetFontAscent(u8g->font)-u8g_font_GetFontDescent(u8g->font);
  
  y += u8g->font_calc_vref(u8g);
  
  while( *s != '\0' )
    39ea:	f5 01       	movw	r30, r10
    39ec:	21 91       	ld	r18, Z+
    39ee:	5f 01       	movw	r10, r30
    39f0:	22 23       	and	r18, r18
    39f2:	39 f0       	breq	.+14     	; 0x3a02 <u8g_DrawStr+0x54>
  {
    d = u8g_draw_glyph(u8g, x, y, *s);
    39f4:	4f 2d       	mov	r20, r15
    39f6:	6e 2d       	mov	r22, r14
    39f8:	c8 01       	movw	r24, r16
    39fa:	70 df       	rcall	.-288    	; 0x38dc <u8g_draw_glyph>
    39fc:	e8 0e       	add	r14, r24
    x += d;
    39fe:	d8 0e       	add	r13, r24
    t += d;
    3a00:	f4 cf       	rjmp	.-24     	; 0x39ea <u8g_DrawStr+0x3c>
    3a02:	8d 2d       	mov	r24, r13
    s++;
  }
  return t;
}
    3a04:	0f 90       	pop	r0
    3a06:	0f 90       	pop	r0
    3a08:	df 91       	pop	r29
    3a0a:	cf 91       	pop	r28
    3a0c:	1f 91       	pop	r17
    3a0e:	0f 91       	pop	r16
    3a10:	ff 90       	pop	r15
    3a12:	ef 90       	pop	r14
    3a14:	df 90       	pop	r13
    3a16:	bf 90       	pop	r11
    3a18:	af 90       	pop	r10
    3a1a:	08 95       	ret

00003a1c <u8g_UpdateRefHeight>:

/*========================================================================*/
/* set ascent/descent for reference point calculation */

void u8g_UpdateRefHeight(u8g_t *u8g)
{
    3a1c:	dc 01       	movw	r26, r24
  uint16_t ls;
  if ( u8g->font == NULL )
    3a1e:	14 96       	adiw	r26, 0x04	; 4
    3a20:	8d 91       	ld	r24, X+
    3a22:	9c 91       	ld	r25, X
    3a24:	15 97       	sbiw	r26, 0x05	; 5
    3a26:	00 97       	sbiw	r24, 0x00	; 0
    3a28:	09 f4       	brne	.+2      	; 0x3a2c <u8g_UpdateRefHeight+0x10>
    3a2a:	3f c0       	rjmp	.+126    	; 0x3aaa <u8g_UpdateRefHeight+0x8e>
    return;
  if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_TEXT )
    3a2c:	57 96       	adiw	r26, 0x17	; 23
    3a2e:	2c 91       	ld	r18, X
    3a30:	57 97       	sbiw	r26, 0x17	; 23

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a32:	fc 01       	movw	r30, r24
void u8g_UpdateRefHeight(u8g_t *u8g)
{
  uint16_t ls;
  if ( u8g->font == NULL )
    return;
  if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_TEXT )
    3a34:	21 11       	cpse	r18, r1
    3a36:	08 c0       	rjmp	.+16     	; 0x3a48 <u8g_UpdateRefHeight+0x2c>

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a38:	35 96       	adiw	r30, 0x05	; 5
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    3a3a:	e4 91       	lpm	r30, Z
  uint16_t ls;
  if ( u8g->font == NULL )
    return;
  if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_TEXT )
  {
    u8g->font_ref_ascent = u8g_font_GetCapitalAHeight(u8g->font);
    3a3c:	58 96       	adiw	r26, 0x18	; 24
    3a3e:	ec 93       	st	X, r30
    3a40:	58 97       	sbiw	r26, 0x18	; 24

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a42:	fc 01       	movw	r30, r24
    3a44:	3c 96       	adiw	r30, 0x0c	; 12
    3a46:	11 c0       	rjmp	.+34     	; 0x3a6a <u8g_UpdateRefHeight+0x4e>
  if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_TEXT )
  {
    u8g->font_ref_ascent = u8g_font_GetCapitalAHeight(u8g->font);
    u8g->font_ref_descent = u8g_font_GetLowerGDescent(u8g->font);
  }
  else if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_XTEXT )
    3a48:	21 30       	cpi	r18, 0x01	; 1
    3a4a:	41 f4       	brne	.+16     	; 0x3a5c <u8g_UpdateRefHeight+0x40>

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a4c:	3f 96       	adiw	r30, 0x0f	; 15
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    3a4e:	e4 91       	lpm	r30, Z
    u8g->font_ref_ascent = u8g_font_GetCapitalAHeight(u8g->font);
    u8g->font_ref_descent = u8g_font_GetLowerGDescent(u8g->font);
  }
  else if ( u8g->font_height_mode == U8G_FONT_HEIGHT_MODE_XTEXT )
  {
    u8g->font_ref_ascent = u8g_font_GetFontXAscent(u8g->font);
    3a50:	58 96       	adiw	r26, 0x18	; 24
    3a52:	ec 93       	st	X, r30
    3a54:	58 97       	sbiw	r26, 0x18	; 24

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a56:	fc 01       	movw	r30, r24
    3a58:	70 96       	adiw	r30, 0x10	; 16
    3a5a:	07 c0       	rjmp	.+14     	; 0x3a6a <u8g_UpdateRefHeight+0x4e>
    3a5c:	3d 96       	adiw	r30, 0x0d	; 13
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    3a5e:	e4 91       	lpm	r30, Z
    u8g->font_ref_ascent = u8g_font_GetFontXAscent(u8g->font);
    u8g->font_ref_descent = u8g_font_GetFontXDescent(u8g->font);
  }
  else
  {
    u8g->font_ref_ascent = u8g_font_GetFontAscent(u8g->font);
    3a60:	58 96       	adiw	r26, 0x18	; 24
    3a62:	ec 93       	st	X, r30
    3a64:	58 97       	sbiw	r26, 0x18	; 24

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset) U8G_NOINLINE;
static uint8_t u8g_font_get_byte(const u8g_fntpgm_uint8_t *font, uint8_t offset)
{
  font += offset;
    3a66:	fc 01       	movw	r30, r24
    3a68:	3e 96       	adiw	r30, 0x0e	; 14
  return u8g_pgm_read( (u8g_pgm_uint8_t *)font );  
    3a6a:	84 91       	lpm	r24, Z
    u8g->font_ref_descent = u8g_font_GetFontXDescent(u8g->font);
  }
  else
  {
    u8g->font_ref_ascent = u8g_font_GetFontAscent(u8g->font);
    u8g->font_ref_descent = u8g_font_GetFontDescent(u8g->font);
    3a6c:	59 96       	adiw	r26, 0x19	; 25
    3a6e:	8c 93       	st	X, r24
    3a70:	59 97       	sbiw	r26, 0x19	; 25
  }
  
  ls = u8g->font_ref_ascent - u8g->font_ref_descent;
    3a72:	58 96       	adiw	r26, 0x18	; 24
    3a74:	8c 91       	ld	r24, X
    3a76:	58 97       	sbiw	r26, 0x18	; 24
    3a78:	99 27       	eor	r25, r25
    3a7a:	87 fd       	sbrc	r24, 7
    3a7c:	90 95       	com	r25
    3a7e:	59 96       	adiw	r26, 0x19	; 25
    3a80:	2c 91       	ld	r18, X
    3a82:	59 97       	sbiw	r26, 0x19	; 25
    3a84:	82 1b       	sub	r24, r18
    3a86:	91 09       	sbc	r25, r1
    3a88:	27 fd       	sbrc	r18, 7
    3a8a:	93 95       	inc	r25
  if ( u8g->font_line_spacing_factor != 64 )
    3a8c:	5a 96       	adiw	r26, 0x1a	; 26
    3a8e:	2c 91       	ld	r18, X
    3a90:	5a 97       	sbiw	r26, 0x1a	; 26
    3a92:	20 34       	cpi	r18, 0x40	; 64
    3a94:	41 f0       	breq	.+16     	; 0x3aa6 <u8g_UpdateRefHeight+0x8a>
  {
    ls &= 255;
    ls *= u8g->font_line_spacing_factor;
    3a96:	82 9f       	mul	r24, r18
    3a98:	c0 01       	movw	r24, r0
    3a9a:	11 24       	eor	r1, r1
    ls >>= 6;
    3a9c:	f6 e0       	ldi	r31, 0x06	; 6
    3a9e:	96 95       	lsr	r25
    3aa0:	87 95       	ror	r24
    3aa2:	fa 95       	dec	r31
    3aa4:	e1 f7       	brne	.-8      	; 0x3a9e <u8g_UpdateRefHeight+0x82>
  }
  u8g->line_spacing = ls;
    3aa6:	5b 96       	adiw	r26, 0x1b	; 27
    3aa8:	8c 93       	st	X, r24
    3aaa:	08 95       	ret

00003aac <u8g_SetFontPosBaseline>:
  return 0;
}

void u8g_SetFontPosBaseline(u8g_t *u8g)
{
  u8g->font_calc_vref = u8g_font_calc_vref_font;
    3aac:	2b ec       	ldi	r18, 0xCB	; 203
    3aae:	3b e1       	ldi	r19, 0x1B	; 27
    3ab0:	fc 01       	movw	r30, r24
    3ab2:	36 8b       	std	Z+22, r19	; 0x16
    3ab4:	25 8b       	std	Z+21, r18	; 0x15
    3ab6:	08 95       	ret

00003ab8 <u8g_SetFont>:
    buf.y_max = cap_a;
  u8g_font_get_str_box_fill_args(u8g, s, &buf, x, y, width, height);
}

void u8g_SetFont(u8g_t *u8g, const u8g_fntpgm_uint8_t  *font)
{
    3ab8:	cf 93       	push	r28
    3aba:	df 93       	push	r29
    3abc:	ec 01       	movw	r28, r24
  if ( u8g->font != font )
    3abe:	8c 81       	ldd	r24, Y+4	; 0x04
    3ac0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ac2:	86 17       	cp	r24, r22
    3ac4:	97 07       	cpc	r25, r23
    3ac6:	41 f0       	breq	.+16     	; 0x3ad8 <u8g_SetFont+0x20>
  {
    u8g->font = font;
    3ac8:	7d 83       	std	Y+5, r23	; 0x05
    3aca:	6c 83       	std	Y+4, r22	; 0x04
    u8g_UpdateRefHeight(u8g);
    3acc:	ce 01       	movw	r24, r28
    3ace:	a6 df       	rcall	.-180    	; 0x3a1c <u8g_UpdateRefHeight>
    3ad0:	8b ec       	ldi	r24, 0xCB	; 203
  return 0;
}

void u8g_SetFontPosBaseline(u8g_t *u8g)
{
  u8g->font_calc_vref = u8g_font_calc_vref_font;
    3ad2:	9b e1       	ldi	r25, 0x1B	; 27
    3ad4:	9e 8b       	std	Y+22, r25	; 0x16
    3ad6:	8d 8b       	std	Y+21, r24	; 0x15
    3ad8:	df 91       	pop	r29
  {
    u8g->font = font;
    u8g_UpdateRefHeight(u8g);
    u8g_SetFontPosBaseline(u8g);
  }
}
    3ada:	cf 91       	pop	r28
    3adc:	08 95       	ret

00003ade <u8g_init_data>:
  /* 9 Dec 2012: u8g_scale.c requires update of current page */
  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_GET_PAGE_BOX, &(u8g->current_page));
}

static void u8g_init_data(u8g_t *u8g)
{
    3ade:	1f 93       	push	r17
    3ae0:	cf 93       	push	r28
    3ae2:	df 93       	push	r29
    3ae4:	ec 01       	movw	r28, r24
  u8g->font = NULL;
    3ae6:	1d 82       	std	Y+5, r1	; 0x05
    3ae8:	1c 82       	std	Y+4, r1	; 0x04
  u8g->cursor_font = NULL;
    3aea:	1f 82       	std	Y+7, r1	; 0x07
    3aec:	1e 82       	std	Y+6, r1	; 0x06
  u8g->cursor_bg_color = 0;
    3aee:	19 86       	std	Y+9, r1	; 0x09
  u8g->cursor_fg_color = 1;
    3af0:	81 e0       	ldi	r24, 0x01	; 1
    3af2:	88 87       	std	Y+8, r24	; 0x08
  u8g->cursor_encoding = 34;
    3af4:	82 e2       	ldi	r24, 0x22	; 34
    3af6:	8a 87       	std	Y+10, r24	; 0x0a
  u8g->cursor_fn = (u8g_draw_cursor_fn)0;
    3af8:	1f 86       	std	Y+15, r1	; 0x0f
    3afa:	1e 86       	std	Y+14, r1	; 0x0e
    3afc:	80 e0       	ldi	r24, 0x00	; 0
    3afe:	90 e0       	ldi	r25, 0x00	; 0

#if defined(U8G_WITH_PINLIST)  
  {
    uint8_t i;
    for( i = 0; i < U8G_PIN_LIST_LEN; i++ )
      u8g->pin_list[i] = U8G_PIN_NONE;
    3b00:	2f ef       	ldi	r18, 0xFF	; 255
    3b02:	fe 01       	movw	r30, r28
    3b04:	e8 0f       	add	r30, r24
    3b06:	f9 1f       	adc	r31, r25
    3b08:	23 a3       	std	Z+35, r18	; 0x23
    3b0a:	01 96       	adiw	r24, 0x01	; 1
  u8g->cursor_fn = (u8g_draw_cursor_fn)0;

#if defined(U8G_WITH_PINLIST)  
  {
    uint8_t i;
    for( i = 0; i < U8G_PIN_LIST_LEN; i++ )
    3b0c:	8e 30       	cpi	r24, 0x0E	; 14
    3b0e:	91 05       	cpc	r25, r1
    3b10:	c1 f7       	brne	.-16     	; 0x3b02 <u8g_init_data+0x24>
  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_SET_COLOR_ENTRY, &irgb);
}

void u8g_SetColorIndex(u8g_t *u8g, uint8_t idx)
{
  u8g->arg_pixel.color = idx;
    3b12:	11 e0       	ldi	r17, 0x01	; 1
    3b14:	18 a3       	std	Y+32, r17	; 0x20
  }
#endif
  
  u8g_SetColorIndex(u8g, 1);

  u8g_SetFontPosBaseline(u8g);
    3b16:	ce 01       	movw	r24, r28
    3b18:	c9 df       	rcall	.-110    	; 0x3aac <u8g_SetFontPosBaseline>
    3b1a:	1f 8b       	std	Y+23, r17	; 0x17
  
  u8g->font_height_mode = U8G_FONT_HEIGHT_MODE_XTEXT;
    3b1c:	18 8e       	std	Y+24, r1	; 0x18
  u8g->font_ref_ascent = 0;
    3b1e:	19 8e       	std	Y+25, r1	; 0x19
  u8g->font_ref_descent = 0;
    3b20:	80 e4       	ldi	r24, 0x40	; 64
  u8g->font_line_spacing_factor = 64;           /* 64 = 1.0, 77 = 1.2 line spacing factor */
    3b22:	8a 8f       	std	Y+26, r24	; 0x1a
    3b24:	1b 8e       	std	Y+27, r1	; 0x1b
  u8g->line_spacing = 0;
    3b26:	84 ed       	ldi	r24, 0xD4	; 212
  
  u8g->state_cb = u8g_state_dummy_cb;
    3b28:	9f e1       	ldi	r25, 0x1F	; 31
    3b2a:	9a ab       	std	Y+50, r25	; 0x32
    3b2c:	89 ab       	std	Y+49, r24	; 0x31
    3b2e:	df 91       	pop	r29

}
    3b30:	cf 91       	pop	r28
    3b32:	1f 91       	pop	r17
    3b34:	08 95       	ret

00003b36 <u8g_call_dev_fn>:
#include <stddef.h>
#include "u8g.h"

uint8_t u8g_call_dev_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
  return dev->dev_fn(u8g, dev, msg, arg); 
    3b36:	db 01       	movw	r26, r22
    3b38:	ed 91       	ld	r30, X+
    3b3a:	fc 91       	ld	r31, X
    3b3c:	19 95       	eicall
}
    3b3e:	08 95       	ret

00003b40 <u8g_InitLL>:

/*====================================================================*/

uint8_t u8g_InitLL(u8g_t *u8g, u8g_dev_t *dev)
{
    3b40:	ef 92       	push	r14
    3b42:	ff 92       	push	r15
    3b44:	1f 93       	push	r17
    3b46:	cf 93       	push	r28
    3b48:	df 93       	push	r29
    3b4a:	1f 92       	push	r1
    3b4c:	1f 92       	push	r1
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
    3b52:	7c 01       	movw	r14, r24
  uint8_t r;
  u8g->state_cb(U8G_STATE_MSG_BACKUP_ENV);
    3b54:	dc 01       	movw	r26, r24
    3b56:	d1 96       	adiw	r26, 0x31	; 49
    3b58:	ed 91       	ld	r30, X+
    3b5a:	fc 91       	ld	r31, X
    3b5c:	d2 97       	sbiw	r26, 0x32	; 50
    3b5e:	82 e0       	ldi	r24, 0x02	; 2
    3b60:	69 83       	std	Y+1, r22	; 0x01
    3b62:	7a 83       	std	Y+2, r23	; 0x02
    3b64:	19 95       	eicall
  r =  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_INIT, NULL);
    3b66:	20 e0       	ldi	r18, 0x00	; 0
    3b68:	30 e0       	ldi	r19, 0x00	; 0
    3b6a:	4a e0       	ldi	r20, 0x0A	; 10
    3b6c:	69 81       	ldd	r22, Y+1	; 0x01
    3b6e:	7a 81       	ldd	r23, Y+2	; 0x02
    3b70:	c7 01       	movw	r24, r14
    3b72:	e1 df       	rcall	.-62     	; 0x3b36 <u8g_call_dev_fn>
    3b74:	18 2f       	mov	r17, r24
    3b76:	d7 01       	movw	r26, r14
  u8g->state_cb(U8G_STATE_MSG_BACKUP_U8G);
    3b78:	d1 96       	adiw	r26, 0x31	; 49
    3b7a:	ed 91       	ld	r30, X+
    3b7c:	fc 91       	ld	r31, X
    3b7e:	d2 97       	sbiw	r26, 0x32	; 50
    3b80:	83 e0       	ldi	r24, 0x03	; 3
    3b82:	19 95       	eicall
    3b84:	d7 01       	movw	r26, r14
  u8g->state_cb(U8G_STATE_MSG_RESTORE_ENV);
    3b86:	d1 96       	adiw	r26, 0x31	; 49
    3b88:	ed 91       	ld	r30, X+
    3b8a:	fc 91       	ld	r31, X
    3b8c:	d2 97       	sbiw	r26, 0x32	; 50
    3b8e:	80 e0       	ldi	r24, 0x00	; 0
    3b90:	19 95       	eicall
    3b92:	81 2f       	mov	r24, r17
  return r;
}
    3b94:	0f 90       	pop	r0
    3b96:	0f 90       	pop	r0
    3b98:	df 91       	pop	r29
    3b9a:	cf 91       	pop	r28
    3b9c:	1f 91       	pop	r17
    3b9e:	ff 90       	pop	r15
    3ba0:	ef 90       	pop	r14
    3ba2:	08 95       	ret

00003ba4 <u8g_FirstPageLL>:

void u8g_FirstPageLL(u8g_t *u8g, u8g_dev_t *dev)
{  
    3ba4:	0f 93       	push	r16
    3ba6:	1f 93       	push	r17
    3ba8:	cf 93       	push	r28
    3baa:	df 93       	push	r29
    3bac:	ec 01       	movw	r28, r24
    3bae:	8b 01       	movw	r16, r22
  u8g->state_cb(U8G_STATE_MSG_BACKUP_ENV);
    3bb0:	e9 a9       	ldd	r30, Y+49	; 0x31
    3bb2:	fa a9       	ldd	r31, Y+50	; 0x32
    3bb4:	82 e0       	ldi	r24, 0x02	; 2
    3bb6:	19 95       	eicall
  u8g->state_cb(U8G_STATE_MSG_RESTORE_U8G);
    3bb8:	e9 a9       	ldd	r30, Y+49	; 0x31
    3bba:	fa a9       	ldd	r31, Y+50	; 0x32
    3bbc:	81 e0       	ldi	r24, 0x01	; 1
    3bbe:	19 95       	eicall
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_PAGE_FIRST, NULL);
    3bc0:	20 e0       	ldi	r18, 0x00	; 0
    3bc2:	30 e0       	ldi	r19, 0x00	; 0
    3bc4:	44 e1       	ldi	r20, 0x14	; 20
    3bc6:	b8 01       	movw	r22, r16
    3bc8:	ce 01       	movw	r24, r28
    3bca:	b5 df       	rcall	.-150    	; 0x3b36 <u8g_call_dev_fn>
    3bcc:	9e 01       	movw	r18, r28
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_GET_PAGE_BOX, &(u8g->current_page));
    3bce:	2d 5c       	subi	r18, 0xCD	; 205
    3bd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3bd2:	47 e1       	ldi	r20, 0x17	; 23
    3bd4:	b8 01       	movw	r22, r16
    3bd6:	ce 01       	movw	r24, r28
    3bd8:	ae df       	rcall	.-164    	; 0x3b36 <u8g_call_dev_fn>
    3bda:	e9 a9       	ldd	r30, Y+49	; 0x31
    3bdc:	fa a9       	ldd	r31, Y+50	; 0x32
  u8g->state_cb(U8G_STATE_MSG_RESTORE_ENV);
    3bde:	80 e0       	ldi	r24, 0x00	; 0
    3be0:	19 95       	eicall
    3be2:	df 91       	pop	r29
    3be4:	cf 91       	pop	r28
}
    3be6:	1f 91       	pop	r17
    3be8:	0f 91       	pop	r16
    3bea:	08 95       	ret

00003bec <u8g_NextPageLL>:

uint8_t u8g_NextPageLL(u8g_t *u8g, u8g_dev_t *dev)
{  
    3bec:	ff 92       	push	r15
    3bee:	0f 93       	push	r16
    3bf0:	1f 93       	push	r17
    3bf2:	cf 93       	push	r28
    3bf4:	df 93       	push	r29
    3bf6:	ec 01       	movw	r28, r24
    3bf8:	8b 01       	movw	r16, r22
  uint8_t r;
  u8g->state_cb(U8G_STATE_MSG_BACKUP_ENV);
    3bfa:	e9 a9       	ldd	r30, Y+49	; 0x31
    3bfc:	fa a9       	ldd	r31, Y+50	; 0x32
    3bfe:	82 e0       	ldi	r24, 0x02	; 2
    3c00:	19 95       	eicall
  u8g->state_cb(U8G_STATE_MSG_RESTORE_U8G);
    3c02:	e9 a9       	ldd	r30, Y+49	; 0x31
    3c04:	fa a9       	ldd	r31, Y+50	; 0x32
    3c06:	81 e0       	ldi	r24, 0x01	; 1
    3c08:	19 95       	eicall
  r = u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_PAGE_NEXT, NULL);
    3c0a:	20 e0       	ldi	r18, 0x00	; 0
    3c0c:	30 e0       	ldi	r19, 0x00	; 0
    3c0e:	45 e1       	ldi	r20, 0x15	; 21
    3c10:	b8 01       	movw	r22, r16
    3c12:	ce 01       	movw	r24, r28
    3c14:	90 df       	rcall	.-224    	; 0x3b36 <u8g_call_dev_fn>
    3c16:	f8 2e       	mov	r15, r24
    3c18:	88 23       	and	r24, r24
  if ( r != 0 )
    3c1a:	39 f0       	breq	.+14     	; 0x3c2a <u8g_NextPageLL+0x3e>
    3c1c:	9e 01       	movw	r18, r28
  {
    u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_GET_PAGE_BOX, &(u8g->current_page));
    3c1e:	2d 5c       	subi	r18, 0xCD	; 205
    3c20:	3f 4f       	sbci	r19, 0xFF	; 255
    3c22:	47 e1       	ldi	r20, 0x17	; 23
    3c24:	b8 01       	movw	r22, r16
    3c26:	ce 01       	movw	r24, r28
    3c28:	86 df       	rcall	.-244    	; 0x3b36 <u8g_call_dev_fn>
    3c2a:	e9 a9       	ldd	r30, Y+49	; 0x31
    3c2c:	fa a9       	ldd	r31, Y+50	; 0x32
  }
  u8g->state_cb(U8G_STATE_MSG_RESTORE_ENV);
    3c2e:	80 e0       	ldi	r24, 0x00	; 0
    3c30:	19 95       	eicall
    3c32:	8f 2d       	mov	r24, r15
    3c34:	cd b7       	in	r28, 0x3d	; 61
  return r;
}
    3c36:	de b7       	in	r29, 0x3e	; 62
    3c38:	e5 e0       	ldi	r30, 0x05	; 5
    3c3a:	0c 94 c4 6b 	jmp	0xd788	; 0xd788 <__epilogue_restores__+0x1a>

00003c3e <u8g_DrawPixelLL>:
}

void u8g_DrawPixelLL(u8g_t *u8g, u8g_dev_t *dev, u8g_uint_t x, u8g_uint_t y)
{
  u8g_dev_arg_pixel_t *arg = &(u8g->arg_pixel);
  arg->x = x;
    3c3e:	fc 01       	movw	r30, r24
    3c40:	44 8f       	std	Z+28, r20	; 0x1c
  arg->y = y;
    3c42:	25 8f       	std	Z+29, r18	; 0x1d
  return u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_CONTRAST, &contrast);
}

void u8g_DrawPixelLL(u8g_t *u8g, u8g_dev_t *dev, u8g_uint_t x, u8g_uint_t y)
{
  u8g_dev_arg_pixel_t *arg = &(u8g->arg_pixel);
    3c44:	9c 01       	movw	r18, r24
    3c46:	24 5e       	subi	r18, 0xE4	; 228
    3c48:	3f 4f       	sbci	r19, 0xFF	; 255
  arg->x = x;
  arg->y = y;
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_SET_PIXEL, arg);
    3c4a:	42 e3       	ldi	r20, 0x32	; 50
    3c4c:	74 cf       	rjmp	.-280    	; 0x3b36 <u8g_call_dev_fn>

00003c4e <u8g_GetWidthLL>:
#endif



u8g_uint_t u8g_GetWidthLL(u8g_t *u8g, u8g_dev_t *dev)
{
    3c4e:	a1 e0       	ldi	r26, 0x01	; 1
    3c50:	b0 e0       	ldi	r27, 0x00	; 0
    3c52:	ed e2       	ldi	r30, 0x2D	; 45
    3c54:	fe e1       	ldi	r31, 0x1E	; 30
    3c56:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
  u8g_uint_t r;
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_GET_WIDTH, &r);
    3c5a:	9e 01       	movw	r18, r28
    3c5c:	2f 5f       	subi	r18, 0xFF	; 255
    3c5e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c60:	46 e4       	ldi	r20, 0x46	; 70
    3c62:	69 df       	rcall	.-302    	; 0x3b36 <u8g_call_dev_fn>
    3c64:	89 81       	ldd	r24, Y+1	; 0x01
  return r;
}
    3c66:	21 96       	adiw	r28, 0x01	; 1
    3c68:	e2 e0       	ldi	r30, 0x02	; 2
    3c6a:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00003c6e <u8g_GetHeightLL>:

u8g_uint_t u8g_GetHeightLL(u8g_t *u8g, u8g_dev_t *dev)
{       
    3c6e:	a1 e0       	ldi	r26, 0x01	; 1
    3c70:	b0 e0       	ldi	r27, 0x00	; 0
    3c72:	ed e3       	ldi	r30, 0x3D	; 61
    3c74:	fe e1       	ldi	r31, 0x1E	; 30
    3c76:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
  u8g_uint_t r;
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_GET_HEIGHT, &r);
    3c7a:	9e 01       	movw	r18, r28
    3c7c:	2f 5f       	subi	r18, 0xFF	; 255
    3c7e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c80:	47 e4       	ldi	r20, 0x47	; 71
    3c82:	59 df       	rcall	.-334    	; 0x3b36 <u8g_call_dev_fn>
    3c84:	89 81       	ldd	r24, Y+1	; 0x01
  return r;
}
    3c86:	21 96       	adiw	r28, 0x01	; 1
    3c88:	e2 e0       	ldi	r30, 0x02	; 2
    3c8a:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00003c8e <u8g_GetModeLL>:

u8g_uint_t u8g_GetModeLL(u8g_t *u8g, u8g_dev_t *dev)
{       
  return u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_GET_MODE, NULL);
    3c8e:	20 e0       	ldi	r18, 0x00	; 0
    3c90:	30 e0       	ldi	r19, 0x00	; 0
    3c92:	48 e4       	ldi	r20, 0x48	; 72
    3c94:	50 cf       	rjmp	.-352    	; 0x3b36 <u8g_call_dev_fn>

00003c96 <u8g_UpdateDimension>:


/*====================================================================*/

void u8g_UpdateDimension(u8g_t *u8g)
{
    3c96:	cf 93       	push	r28
    3c98:	df 93       	push	r29
    3c9a:	ec 01       	movw	r28, r24
  u8g->width = u8g_GetWidthLL(u8g, u8g->dev);
    3c9c:	6a 81       	ldd	r22, Y+2	; 0x02
    3c9e:	7b 81       	ldd	r23, Y+3	; 0x03
    3ca0:	d6 df       	rcall	.-84     	; 0x3c4e <u8g_GetWidthLL>
    3ca2:	88 83       	st	Y, r24
    3ca4:	6a 81       	ldd	r22, Y+2	; 0x02
  u8g->height = u8g_GetHeightLL(u8g, u8g->dev);
    3ca6:	7b 81       	ldd	r23, Y+3	; 0x03
    3ca8:	ce 01       	movw	r24, r28
    3caa:	e1 df       	rcall	.-62     	; 0x3c6e <u8g_GetHeightLL>
    3cac:	89 83       	std	Y+1, r24	; 0x01
    3cae:	6a 81       	ldd	r22, Y+2	; 0x02
    3cb0:	7b 81       	ldd	r23, Y+3	; 0x03
  u8g->mode = u8g_GetModeLL(u8g, u8g->dev);
    3cb2:	ce 01       	movw	r24, r28
    3cb4:	ec df       	rcall	.-40     	; 0x3c8e <u8g_GetModeLL>
    3cb6:	8b 87       	std	Y+11, r24	; 0x0b
    3cb8:	9e 01       	movw	r18, r28
    3cba:	2d 5c       	subi	r18, 0xCD	; 205
    3cbc:	3f 4f       	sbci	r19, 0xFF	; 255
  /* 9 Dec 2012: u8g_scale.c requires update of current page */
  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_GET_PAGE_BOX, &(u8g->current_page));
    3cbe:	6a 81       	ldd	r22, Y+2	; 0x02
    3cc0:	7b 81       	ldd	r23, Y+3	; 0x03
    3cc2:	47 e1       	ldi	r20, 0x17	; 23
    3cc4:	ce 01       	movw	r24, r28
    3cc6:	37 df       	rcall	.-402    	; 0x3b36 <u8g_call_dev_fn>
    3cc8:	df 91       	pop	r29
    3cca:	cf 91       	pop	r28
    3ccc:	08 95       	ret

00003cce <u8g_Begin>:
  u8g->state_cb = u8g_state_dummy_cb;

}

uint8_t u8g_Begin(u8g_t *u8g)
{
    3cce:	cf 93       	push	r28
    3cd0:	df 93       	push	r29
    3cd2:	ec 01       	movw	r28, r24
  /* call and init low level driver and com device */
  if ( u8g_InitLL(u8g, u8g->dev) == 0 )
    3cd4:	6a 81       	ldd	r22, Y+2	; 0x02
    3cd6:	7b 81       	ldd	r23, Y+3	; 0x03
    3cd8:	33 df       	rcall	.-410    	; 0x3b40 <u8g_InitLL>
    3cda:	88 23       	and	r24, r24
    3cdc:	21 f0       	breq	.+8      	; 0x3ce6 <u8g_Begin+0x18>
    3cde:	ce 01       	movw	r24, r28
    return 0;
  /* fetch width and height from the low level */
  u8g_UpdateDimension(u8g);
    3ce0:	da df       	rcall	.-76     	; 0x3c96 <u8g_UpdateDimension>
    3ce2:	81 e0       	ldi	r24, 0x01	; 1
    3ce4:	01 c0       	rjmp	.+2      	; 0x3ce8 <u8g_Begin+0x1a>
  return 1;
    3ce6:	80 e0       	ldi	r24, 0x00	; 0
    3ce8:	df 91       	pop	r29

uint8_t u8g_Begin(u8g_t *u8g)
{
  /* call and init low level driver and com device */
  if ( u8g_InitLL(u8g, u8g->dev) == 0 )
    return 0;
    3cea:	cf 91       	pop	r28
  /* fetch width and height from the low level */
  u8g_UpdateDimension(u8g);
  return 1;
}
    3cec:	08 95       	ret

00003cee <u8g_InitHWSPI>:
  /* issue 146 */
  return u8g_Begin(u8g);
}

uint8_t u8g_InitHWSPI(u8g_t *u8g, u8g_dev_t *dev, uint8_t cs, uint8_t a0, uint8_t reset)
{
    3cee:	cf 92       	push	r12
    3cf0:	df 92       	push	r13
    3cf2:	ef 92       	push	r14
    3cf4:	ff 92       	push	r15
    3cf6:	0f 93       	push	r16
    3cf8:	cf 93       	push	r28
    3cfa:	df 93       	push	r29
    3cfc:	1f 92       	push	r1
    3cfe:	1f 92       	push	r1
    3d00:	cd b7       	in	r28, 0x3d	; 61
    3d02:	de b7       	in	r29, 0x3e	; 62
    3d04:	6c 01       	movw	r12, r24
    3d06:	7b 01       	movw	r14, r22
  /* fill data structure with some suitable values */
  u8g_init_data(u8g);
    3d08:	2a 83       	std	Y+2, r18	; 0x02
    3d0a:	49 83       	std	Y+1, r20	; 0x01
    3d0c:	e8 de       	rcall	.-560    	; 0x3ade <u8g_init_data>
    3d0e:	f6 01       	movw	r30, r12
  u8g->dev = dev;
    3d10:	f3 82       	std	Z+3, r15	; 0x03
    3d12:	e2 82       	std	Z+2, r14	; 0x02
    3d14:	49 81       	ldd	r20, Y+1	; 0x01
  
  
  /* assign user pins */
  u8g->pin_list[U8G_PI_CS] = cs;
    3d16:	45 a3       	std	Z+37, r20	; 0x25
    3d18:	2a 81       	ldd	r18, Y+2	; 0x02
  u8g->pin_list[U8G_PI_A0] = a0;
    3d1a:	24 a3       	std	Z+36, r18	; 0x24
    3d1c:	03 a3       	std	Z+35, r16	; 0x23
  u8g->pin_list[U8G_PI_RESET] = reset;
    3d1e:	c6 01       	movw	r24, r12
  
  return u8g_Begin(u8g);
    3d20:	d6 df       	rcall	.-84     	; 0x3cce <u8g_Begin>
    3d22:	0f 90       	pop	r0
    3d24:	0f 90       	pop	r0
}
    3d26:	df 91       	pop	r29
    3d28:	cf 91       	pop	r28
    3d2a:	0f 91       	pop	r16
    3d2c:	ff 90       	pop	r15
    3d2e:	ef 90       	pop	r14
    3d30:	df 90       	pop	r13
    3d32:	cf 90       	pop	r12
    3d34:	08 95       	ret

00003d36 <u8g_FirstPage>:
}
#endif /* defined(U8G_WITH_PINLIST)  */

void u8g_FirstPage(u8g_t *u8g)
{
  u8g_FirstPageLL(u8g, u8g->dev);
    3d36:	fc 01       	movw	r30, r24
    3d38:	62 81       	ldd	r22, Z+2	; 0x02
    3d3a:	73 81       	ldd	r23, Z+3	; 0x03
    3d3c:	33 cf       	rjmp	.-410    	; 0x3ba4 <u8g_FirstPageLL>

00003d3e <u8g_NextPage>:
}

uint8_t u8g_NextPage(u8g_t *u8g)
{
    3d3e:	cf 93       	push	r28
    3d40:	df 93       	push	r29
    3d42:	ec 01       	movw	r28, r24
  if  ( u8g->cursor_fn != (u8g_draw_cursor_fn)0 )
    3d44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d48:	30 97       	sbiw	r30, 0x00	; 0
    3d4a:	09 f0       	breq	.+2      	; 0x3d4e <u8g_NextPage+0x10>
  {
    u8g->cursor_fn(u8g);
    3d4c:	19 95       	eicall
  }
  return u8g_NextPageLL(u8g, u8g->dev);
    3d4e:	6a 81       	ldd	r22, Y+2	; 0x02
    3d50:	7b 81       	ldd	r23, Y+3	; 0x03
    3d52:	ce 01       	movw	r24, r28
    3d54:	4b df       	rcall	.-362    	; 0x3bec <u8g_NextPageLL>
    3d56:	df 91       	pop	r29
}
    3d58:	cf 91       	pop	r28
    3d5a:	08 95       	ret

00003d5c <u8g_DrawPixel>:
  u8g_call_dev_fn(u8g, u8g->dev, U8G_DEV_MSG_SLEEP_OFF, NULL);
}


void u8g_DrawPixel(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y)
{
    3d5c:	36 2f       	mov	r19, r22
    3d5e:	24 2f       	mov	r18, r20
  u8g_DrawPixelLL(u8g, u8g->dev, x, y);
    3d60:	fc 01       	movw	r30, r24
    3d62:	62 81       	ldd	r22, Z+2	; 0x02
    3d64:	73 81       	ldd	r23, Z+3	; 0x03
    3d66:	43 2f       	mov	r20, r19
    3d68:	6a cf       	rjmp	.-300    	; 0x3c3e <u8g_DrawPixelLL>

00003d6a <u8g_Draw8Pixel>:
}

void u8g_Draw8Pixel(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t pixel)
{
    3d6a:	0f 93       	push	r16
    3d6c:	fc 01       	movw	r30, r24
  u8g_Draw8PixelLL(u8g, u8g->dev, x, y, dir, pixel);
    3d6e:	82 81       	ldd	r24, Z+2	; 0x02
    3d70:	93 81       	ldd	r25, Z+3	; 0x03
}

void u8g_Draw8PixelLL(u8g_t *u8g, u8g_dev_t *dev, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t pixel)
{
  u8g_dev_arg_pixel_t *arg = &(u8g->arg_pixel);
  arg->x = x;
    3d72:	64 8f       	std	Z+28, r22	; 0x1c
  arg->y = y;
    3d74:	45 8f       	std	Z+29, r20	; 0x1d
  arg->dir = dir;
    3d76:	27 8f       	std	Z+31, r18	; 0x1f
  arg->pixel = pixel;
    3d78:	06 8f       	std	Z+30, r16	; 0x1e
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_SET_PIXEL, arg);
}

void u8g_Draw8PixelLL(u8g_t *u8g, u8g_dev_t *dev, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t pixel)
{
  u8g_dev_arg_pixel_t *arg = &(u8g->arg_pixel);
    3d7a:	9f 01       	movw	r18, r30
    3d7c:	24 5e       	subi	r18, 0xE4	; 228
    3d7e:	3f 4f       	sbci	r19, 0xFF	; 255
  arg->x = x;
  arg->y = y;
  arg->dir = dir;
  arg->pixel = pixel;
  u8g_call_dev_fn(u8g, dev, U8G_DEV_MSG_SET_8PIXEL, arg);
    3d80:	4b e3       	ldi	r20, 0x3B	; 59
    3d82:	bc 01       	movw	r22, r24
    3d84:	cf 01       	movw	r24, r30
    3d86:	d7 de       	rcall	.-594    	; 0x3b36 <u8g_call_dev_fn>
    3d88:	0f 91       	pop	r16
}

void u8g_Draw8Pixel(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, uint8_t dir, uint8_t pixel)
{
  u8g_Draw8PixelLL(u8g, u8g->dev, x, y, dir, pixel);
}
    3d8a:	08 95       	ret

00003d8c <u8g_draw_hline>:
*/

#include "u8g.h"

void u8g_draw_hline(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w)
{
    3d8c:	af 92       	push	r10
    3d8e:	bf 92       	push	r11
    3d90:	df 92       	push	r13
    3d92:	ef 92       	push	r14
    3d94:	ff 92       	push	r15
    3d96:	0f 93       	push	r16
    3d98:	1f 93       	push	r17
    3d9a:	cf 93       	push	r28
    3d9c:	df 93       	push	r29
    3d9e:	1f 92       	push	r1
    3da0:	cd b7       	in	r28, 0x3d	; 61
    3da2:	de b7       	in	r29, 0x3e	; 62
    3da4:	5c 01       	movw	r10, r24
    3da6:	e6 2e       	mov	r14, r22
    3da8:	f4 2e       	mov	r15, r20
    3daa:	12 2f       	mov	r17, r18
  uint8_t pixel = 0x0ff;
  while( w >= 8 )
    3dac:	32 2f       	mov	r19, r18
    3dae:	d6 2e       	mov	r13, r22
    3db0:	d2 0e       	add	r13, r18
    3db2:	6d 2d       	mov	r22, r13
    3db4:	63 1b       	sub	r22, r19
    3db6:	38 30       	cpi	r19, 0x08	; 8
    3db8:	48 f0       	brcs	.+18     	; 0x3dcc <u8g_draw_hline+0x40>
  {
    u8g_Draw8Pixel(u8g, x, y, 0, pixel);
    3dba:	0f ef       	ldi	r16, 0xFF	; 255
    3dbc:	20 e0       	ldi	r18, 0x00	; 0
    3dbe:	4f 2d       	mov	r20, r15
    3dc0:	c5 01       	movw	r24, r10
    3dc2:	39 83       	std	Y+1, r19	; 0x01
    3dc4:	d2 df       	rcall	.-92     	; 0x3d6a <u8g_Draw8Pixel>
    3dc6:	39 81       	ldd	r19, Y+1	; 0x01
    w-=8;
    3dc8:	38 50       	subi	r19, 0x08	; 8
    3dca:	f3 cf       	rjmp	.-26     	; 0x3db2 <u8g_draw_hline+0x26>
    3dcc:	61 2f       	mov	r22, r17
    3dce:	68 7f       	andi	r22, 0xF8	; 248
    3dd0:	6e 0d       	add	r22, r14
    3dd2:	17 70       	andi	r17, 0x07	; 7
    3dd4:	71 f0       	breq	.+28     	; 0x3df2 <u8g_draw_hline+0x66>
    x+=8;
  }
  if ( w != 0 )
    3dd6:	87 e0       	ldi	r24, 0x07	; 7
  {
    w ^=7;
    3dd8:	81 27       	eor	r24, r17
    3dda:	8f 5f       	subi	r24, 0xFF	; 255
    w++;
    3ddc:	87 70       	andi	r24, 0x07	; 7
    pixel <<= w&7;
    3dde:	0f ef       	ldi	r16, 0xFF	; 255
    3de0:	10 e0       	ldi	r17, 0x00	; 0
    3de2:	01 c0       	rjmp	.+2      	; 0x3de6 <u8g_draw_hline+0x5a>
    3de4:	00 0f       	add	r16, r16
    3de6:	8a 95       	dec	r24
    3de8:	ea f7       	brpl	.-6      	; 0x3de4 <u8g_draw_hline+0x58>
    3dea:	20 e0       	ldi	r18, 0x00	; 0
    u8g_Draw8Pixel(u8g, x, y, 0, pixel);
    3dec:	4f 2d       	mov	r20, r15
    3dee:	c5 01       	movw	r24, r10
    3df0:	bc df       	rcall	.-136    	; 0x3d6a <u8g_Draw8Pixel>
    3df2:	0f 90       	pop	r0
    3df4:	df 91       	pop	r29
  }
}
    3df6:	cf 91       	pop	r28
    3df8:	1f 91       	pop	r17
    3dfa:	0f 91       	pop	r16
    3dfc:	ff 90       	pop	r15
    3dfe:	ef 90       	pop	r14
    3e00:	df 90       	pop	r13
    3e02:	bf 90       	pop	r11
    3e04:	af 90       	pop	r10
    3e06:	08 95       	ret

00003e08 <u8g_draw_vline>:

void u8g_draw_vline(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t h)
{
    3e08:	af 92       	push	r10
    3e0a:	bf 92       	push	r11
    3e0c:	df 92       	push	r13
    3e0e:	ef 92       	push	r14
    3e10:	ff 92       	push	r15
    3e12:	0f 93       	push	r16
    3e14:	1f 93       	push	r17
    3e16:	cf 93       	push	r28
    3e18:	df 93       	push	r29
    3e1a:	1f 92       	push	r1
    3e1c:	cd b7       	in	r28, 0x3d	; 61
    3e1e:	de b7       	in	r29, 0x3e	; 62
    3e20:	5c 01       	movw	r10, r24
    3e22:	f6 2e       	mov	r15, r22
    3e24:	e4 2e       	mov	r14, r20
    3e26:	12 2f       	mov	r17, r18
  uint8_t pixel = 0x0ff;
  while( h >= 8 )
    3e28:	32 2f       	mov	r19, r18
    3e2a:	d4 2e       	mov	r13, r20
    3e2c:	d2 0e       	add	r13, r18
    3e2e:	4d 2d       	mov	r20, r13
    3e30:	43 1b       	sub	r20, r19
    3e32:	38 30       	cpi	r19, 0x08	; 8
    3e34:	48 f0       	brcs	.+18     	; 0x3e48 <u8g_draw_vline+0x40>
  {
    u8g_Draw8Pixel(u8g, x, y, 1, pixel);
    3e36:	0f ef       	ldi	r16, 0xFF	; 255
    3e38:	21 e0       	ldi	r18, 0x01	; 1
    3e3a:	6f 2d       	mov	r22, r15
    3e3c:	c5 01       	movw	r24, r10
    3e3e:	39 83       	std	Y+1, r19	; 0x01
    3e40:	94 df       	rcall	.-216    	; 0x3d6a <u8g_Draw8Pixel>
    3e42:	39 81       	ldd	r19, Y+1	; 0x01
    h-=8;
    3e44:	38 50       	subi	r19, 0x08	; 8
    3e46:	f3 cf       	rjmp	.-26     	; 0x3e2e <u8g_draw_vline+0x26>
    3e48:	41 2f       	mov	r20, r17
    3e4a:	48 7f       	andi	r20, 0xF8	; 248
    3e4c:	4e 0d       	add	r20, r14
    3e4e:	17 70       	andi	r17, 0x07	; 7
    3e50:	71 f0       	breq	.+28     	; 0x3e6e <u8g_draw_vline+0x66>
    y+=8;
  }
  if ( h != 0 )
    3e52:	87 e0       	ldi	r24, 0x07	; 7
  {
    h ^=7;
    3e54:	81 27       	eor	r24, r17
    3e56:	8f 5f       	subi	r24, 0xFF	; 255
    h++;
    3e58:	87 70       	andi	r24, 0x07	; 7
    pixel <<= h&7;
    3e5a:	0f ef       	ldi	r16, 0xFF	; 255
    3e5c:	10 e0       	ldi	r17, 0x00	; 0
    3e5e:	01 c0       	rjmp	.+2      	; 0x3e62 <u8g_draw_vline+0x5a>
    3e60:	00 0f       	add	r16, r16
    3e62:	8a 95       	dec	r24
    3e64:	ea f7       	brpl	.-6      	; 0x3e60 <u8g_draw_vline+0x58>
    3e66:	21 e0       	ldi	r18, 0x01	; 1
    u8g_Draw8Pixel(u8g, x, y, 1, pixel);
    3e68:	6f 2d       	mov	r22, r15
    3e6a:	c5 01       	movw	r24, r10
    3e6c:	7e df       	rcall	.-260    	; 0x3d6a <u8g_Draw8Pixel>
    3e6e:	0f 90       	pop	r0
    3e70:	df 91       	pop	r29
  }
}
    3e72:	cf 91       	pop	r28
    3e74:	1f 91       	pop	r17
    3e76:	0f 91       	pop	r16
    3e78:	ff 90       	pop	r15
    3e7a:	ef 90       	pop	r14
    3e7c:	df 90       	pop	r13
    3e7e:	bf 90       	pop	r11
    3e80:	af 90       	pop	r10
    3e82:	08 95       	ret

00003e84 <u8g_DrawHLine>:

void u8g_DrawHLine(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w)
{
    3e84:	ef 92       	push	r14
    3e86:	ff 92       	push	r15
    3e88:	0f 93       	push	r16
    3e8a:	1f 93       	push	r17
    3e8c:	cf 93       	push	r28
    3e8e:	df 93       	push	r29
    3e90:	ec 01       	movw	r28, r24
    3e92:	16 2f       	mov	r17, r22
    3e94:	f4 2e       	mov	r15, r20
    3e96:	e2 2e       	mov	r14, r18
  if ( u8g_IsBBXIntersection(u8g, x, y, w, 1) == 0 )
    3e98:	01 e0       	ldi	r16, 0x01	; 1
    3e9a:	0e 94 bd 63 	call	0xc77a	; 0xc77a <u8g_IsBBXIntersection>
    3e9e:	88 23       	and	r24, r24
    3ea0:	29 f0       	breq	.+10     	; 0x3eac <u8g_DrawHLine+0x28>
    return;
  u8g_draw_hline(u8g, x, y, w);
    3ea2:	2e 2d       	mov	r18, r14
    3ea4:	4f 2d       	mov	r20, r15
    3ea6:	61 2f       	mov	r22, r17
    3ea8:	ce 01       	movw	r24, r28
    3eaa:	70 df       	rcall	.-288    	; 0x3d8c <u8g_draw_hline>
    3eac:	cd b7       	in	r28, 0x3d	; 61
}
    3eae:	de b7       	in	r29, 0x3e	; 62
    3eb0:	e6 e0       	ldi	r30, 0x06	; 6
    3eb2:	0c 94 c3 6b 	jmp	0xd786	; 0xd786 <__epilogue_restores__+0x18>

00003eb6 <u8g_DrawVLine>:

void u8g_DrawVLine(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w)
{
    3eb6:	ef 92       	push	r14
    3eb8:	ff 92       	push	r15
    3eba:	0f 93       	push	r16
    3ebc:	1f 93       	push	r17
    3ebe:	cf 93       	push	r28
    3ec0:	df 93       	push	r29
    3ec2:	ec 01       	movw	r28, r24
    3ec4:	16 2f       	mov	r17, r22
    3ec6:	f4 2e       	mov	r15, r20
    3ec8:	e2 2e       	mov	r14, r18
  if ( u8g_IsBBXIntersection(u8g, x, y, 1, w) == 0 )
    3eca:	02 2f       	mov	r16, r18
    3ecc:	21 e0       	ldi	r18, 0x01	; 1
    3ece:	0e 94 bd 63 	call	0xc77a	; 0xc77a <u8g_IsBBXIntersection>
    3ed2:	88 23       	and	r24, r24
    3ed4:	29 f0       	breq	.+10     	; 0x3ee0 <u8g_DrawVLine+0x2a>
    return;
  u8g_draw_vline(u8g, x, y, w);
    3ed6:	2e 2d       	mov	r18, r14
    3ed8:	4f 2d       	mov	r20, r15
    3eda:	61 2f       	mov	r22, r17
    3edc:	ce 01       	movw	r24, r28
    3ede:	94 df       	rcall	.-216    	; 0x3e08 <u8g_draw_vline>
    3ee0:	cd b7       	in	r28, 0x3d	; 61
}
    3ee2:	de b7       	in	r29, 0x3e	; 62
    3ee4:	e6 e0       	ldi	r30, 0x06	; 6
    3ee6:	0c 94 c3 6b 	jmp	0xd786	; 0xd786 <__epilogue_restores__+0x18>

00003eea <u8g_DrawFrame>:

/* restrictions: w > 0 && h > 0 */
void u8g_DrawFrame(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h)
{
    3eea:	df 92       	push	r13
    3eec:	ef 92       	push	r14
    3eee:	ff 92       	push	r15
    3ef0:	0f 93       	push	r16
    3ef2:	1f 93       	push	r17
    3ef4:	cf 93       	push	r28
    3ef6:	df 93       	push	r29
    3ef8:	ec 01       	movw	r28, r24
    3efa:	16 2f       	mov	r17, r22
    3efc:	f4 2e       	mov	r15, r20
    3efe:	e2 2e       	mov	r14, r18
    3f00:	d0 2e       	mov	r13, r16
  u8g_uint_t xtmp = x;
  
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    3f02:	0e 94 bd 63 	call	0xc77a	; 0xc77a <u8g_IsBBXIntersection>
    3f06:	88 23       	and	r24, r24
    3f08:	c1 f0       	breq	.+48     	; 0x3f3a <u8g_DrawFrame+0x50>
    return;

  
  u8g_draw_hline(u8g, x, y, w);
    3f0a:	2e 2d       	mov	r18, r14
    3f0c:	4f 2d       	mov	r20, r15
    3f0e:	61 2f       	mov	r22, r17
    3f10:	ce 01       	movw	r24, r28
    3f12:	3c df       	rcall	.-392    	; 0x3d8c <u8g_draw_hline>
    3f14:	2d 2d       	mov	r18, r13
  u8g_draw_vline(u8g, x, y, h);
    3f16:	4f 2d       	mov	r20, r15
    3f18:	61 2f       	mov	r22, r17
    3f1a:	ce 01       	movw	r24, r28
    3f1c:	75 df       	rcall	.-278    	; 0x3e08 <u8g_draw_vline>
    3f1e:	6f ef       	ldi	r22, 0xFF	; 255
    3f20:	6e 0d       	add	r22, r14
  x+=w;
    3f22:	61 0f       	add	r22, r17
    3f24:	2d 2d       	mov	r18, r13
  x--;
    3f26:	4f 2d       	mov	r20, r15
  u8g_draw_vline(u8g, x, y, h);
    3f28:	ce 01       	movw	r24, r28
    3f2a:	6e df       	rcall	.-292    	; 0x3e08 <u8g_draw_vline>
    3f2c:	4f ef       	ldi	r20, 0xFF	; 255
    3f2e:	4d 0d       	add	r20, r13
    3f30:	4f 0d       	add	r20, r15
  y+=h;
    3f32:	2e 2d       	mov	r18, r14
    3f34:	61 2f       	mov	r22, r17
  y--;
    3f36:	ce 01       	movw	r24, r28
  u8g_draw_hline(u8g, xtmp, y, w);
    3f38:	29 df       	rcall	.-430    	; 0x3d8c <u8g_draw_hline>
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	e7 e0       	ldi	r30, 0x07	; 7
    3f40:	0c 94 c2 6b 	jmp	0xd784	; 0xd784 <__epilogue_restores__+0x16>

00003f44 <u8g_draw_box>:
}

void u8g_draw_box(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h)
{
    3f44:	ef 92       	push	r14
    3f46:	ff 92       	push	r15
    3f48:	0f 93       	push	r16
    3f4a:	1f 93       	push	r17
    3f4c:	cf 93       	push	r28
    3f4e:	df 93       	push	r29
    3f50:	ec 01       	movw	r28, r24
    3f52:	f6 2e       	mov	r15, r22
    3f54:	e2 2e       	mov	r14, r18
    3f56:	14 2f       	mov	r17, r20
    3f58:	04 0f       	add	r16, r20
  do
  { 
    u8g_draw_hline(u8g, x, y, w);
    3f5a:	2e 2d       	mov	r18, r14
    3f5c:	41 2f       	mov	r20, r17
    3f5e:	6f 2d       	mov	r22, r15
    3f60:	ce 01       	movw	r24, r28
    3f62:	14 df       	rcall	.-472    	; 0x3d8c <u8g_draw_hline>
    3f64:	1f 5f       	subi	r17, 0xFF	; 255
    y++;    
    3f66:	01 13       	cpse	r16, r17
    h--;
  } while( h != 0 );
    3f68:	f8 cf       	rjmp	.-16     	; 0x3f5a <u8g_draw_box+0x16>
    3f6a:	cd b7       	in	r28, 0x3d	; 61
}
    3f6c:	de b7       	in	r29, 0x3e	; 62
    3f6e:	e6 e0       	ldi	r30, 0x06	; 6
    3f70:	0c 94 c3 6b 	jmp	0xd786	; 0xd786 <__epilogue_restores__+0x18>

00003f74 <u8g_DrawBox>:

/* restrictions: h > 0 */
void u8g_DrawBox(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h)
{
    3f74:	df 92       	push	r13
    3f76:	ef 92       	push	r14
    3f78:	ff 92       	push	r15
    3f7a:	0f 93       	push	r16
    3f7c:	1f 93       	push	r17
    3f7e:	cf 93       	push	r28
    3f80:	df 93       	push	r29
    3f82:	ec 01       	movw	r28, r24
    3f84:	16 2f       	mov	r17, r22
    3f86:	f4 2e       	mov	r15, r20
    3f88:	e2 2e       	mov	r14, r18
    3f8a:	d0 2e       	mov	r13, r16
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    3f8c:	0e 94 bd 63 	call	0xc77a	; 0xc77a <u8g_IsBBXIntersection>
    3f90:	88 23       	and	r24, r24
    3f92:	29 f0       	breq	.+10     	; 0x3f9e <u8g_DrawBox+0x2a>
    return;
  u8g_draw_box(u8g, x, y, w, h);
    3f94:	2e 2d       	mov	r18, r14
    3f96:	4f 2d       	mov	r20, r15
    3f98:	61 2f       	mov	r22, r17
    3f9a:	ce 01       	movw	r24, r28
    3f9c:	d3 df       	rcall	.-90     	; 0x3f44 <u8g_draw_box>
    3f9e:	cd b7       	in	r28, 0x3d	; 61
}
    3fa0:	de b7       	in	r29, 0x3e	; 62
    3fa2:	e7 e0       	ldi	r30, 0x07	; 7
    3fa4:	0c 94 c2 6b 	jmp	0xd784	; 0xd784 <__epilogue_restores__+0x16>

00003fa8 <u8g_state_dummy_cb>:

#include <stddef.h>
#include "u8g.h"

void u8g_state_dummy_cb(uint8_t msg)
{
    3fa8:	08 95       	ret

00003faa <bt_putStr>:

	uart_putc(ch);
}

void bt_putStr(const char *s)
{
    3faa:	cf 93       	push	r28
    3fac:	df 93       	push	r29
	timer_bt_is_busy = TIMER_BT_IS_BUSY;
    3fae:	2f e7       	ldi	r18, 0x7F	; 127
    3fb0:	20 93 4f 05 	sts	0x054F, r18
    3fb4:	ec 01       	movw	r28, r24

	while (*s) 
    3fb6:	89 91       	ld	r24, Y+
    3fb8:	88 23       	and	r24, r24
    3fba:	19 f0       	breq	.+6      	; 0x3fc2 <bt_putStr+0x18>
      uart_putc(*s++);
    3fbc:	0e 94 d9 5e 	call	0xbdb2	; 0xbdb2 <uart_putc>
    3fc0:	fa cf       	rjmp	.-12     	; 0x3fb6 <bt_putStr+0xc>
}
    3fc2:	df 91       	pop	r29
    3fc4:	cf 91       	pop	r28
    3fc6:	08 95       	ret

00003fc8 <bt_putStr_P>:

void bt_putStr_P(const char *progmem_s)
{
    3fc8:	cf 93       	push	r28
    3fca:	df 93       	push	r29
	timer_bt_is_busy = TIMER_BT_IS_BUSY;
    3fcc:	2f e7       	ldi	r18, 0x7F	; 127
    3fce:	20 93 4f 05 	sts	0x054F, r18

	register char c;
    
  while ( (c = pgm_read_byte(progmem_s++)) ) 
    3fd2:	fc 01       	movw	r30, r24
    3fd4:	84 91       	lpm	r24, Z
    3fd6:	ef 01       	movw	r28, r30
    3fd8:	21 96       	adiw	r28, 0x01	; 1
    3fda:	88 23       	and	r24, r24
    3fdc:	21 f0       	breq	.+8      	; 0x3fe6 <bt_putStr_P+0x1e>
    uart_putc(c);
    3fde:	0e 94 d9 5e 	call	0xbdb2	; 0xbdb2 <uart_putc>
    3fe2:	fe 01       	movw	r30, r28
    3fe4:	f7 cf       	rjmp	.-18     	; 0x3fd4 <bt_putStr_P+0xc>
}
    3fe6:	df 91       	pop	r29
    3fe8:	cf 91       	pop	r28
    3fea:	08 95       	ret

00003fec <bt_putLong>:

void bt_putLong(int32_t num)
{
    3fec:	af e0       	ldi	r26, 0x0F	; 15
    3fee:	b0 e0       	ldi	r27, 0x00	; 0
    3ff0:	ec ef       	ldi	r30, 0xFC	; 252
    3ff2:	ff e1       	ldi	r31, 0x1F	; 31
    3ff4:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	char buffer[15];
	ltoa( num , buffer, 10);
    3ff8:	2a e0       	ldi	r18, 0x0A	; 10
    3ffa:	30 e0       	ldi	r19, 0x00	; 0
    3ffc:	ae 01       	movw	r20, r28
    3ffe:	4f 5f       	subi	r20, 0xFF	; 255
    4000:	5f 4f       	sbci	r21, 0xFF	; 255
    4002:	0e 94 12 6c 	call	0xd824	; 0xd824 <ltoa>
	bt_putStr(buffer);
    4006:	ce 01       	movw	r24, r28
    4008:	01 96       	adiw	r24, 0x01	; 1
    400a:	cf df       	rcall	.-98     	; 0x3faa <bt_putStr>
    400c:	2f 96       	adiw	r28, 0x0f	; 15
}
    400e:	e2 e0       	ldi	r30, 0x02	; 2
    4010:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00004014 <u8g_DrawLong>:
#include "victim.h"

//////////////////////////////////////////////////////////////////////////////

void u8g_DrawLong(uint8_t koord_x, uint8_t koord_y, int32_t num)
{
    4014:	af e0       	ldi	r26, 0x0F	; 15
    4016:	b0 e0       	ldi	r27, 0x00	; 0
    4018:	e0 e1       	ldi	r30, 0x10	; 16
    401a:	f0 e2       	ldi	r31, 0x20	; 32
    401c:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    4020:	18 2f       	mov	r17, r24
    4022:	06 2f       	mov	r16, r22
    4024:	ca 01       	movw	r24, r20
    4026:	b9 01       	movw	r22, r18
  char buffer[15];
	ltoa( num , buffer, 10);
    4028:	2a e0       	ldi	r18, 0x0A	; 10
    402a:	30 e0       	ldi	r19, 0x00	; 0
    402c:	ae 01       	movw	r20, r28
    402e:	4f 5f       	subi	r20, 0xFF	; 255
    4030:	5f 4f       	sbci	r21, 0xFF	; 255
    4032:	0e 94 12 6c 	call	0xd824	; 0xd824 <ltoa>
  u8g_DrawStr(&u8g, koord_x, koord_y, buffer);
    4036:	9e 01       	movw	r18, r28
    4038:	2f 5f       	subi	r18, 0xFF	; 255
    403a:	3f 4f       	sbci	r19, 0xFF	; 255
    403c:	40 2f       	mov	r20, r16
    403e:	61 2f       	mov	r22, r17
    4040:	8b e1       	ldi	r24, 0x1B	; 27
    4042:	97 e0       	ldi	r25, 0x07	; 7
    4044:	b4 dc       	rcall	.-1688   	; 0x39ae <u8g_DrawStr>
    4046:	2f 96       	adiw	r28, 0x0f	; 15
}
    4048:	e4 e0       	ldi	r30, 0x04	; 4
    404a:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000404e <u8g_DrawStartUp>:
};

uint8_t sm_logo = 0; //Logo fertig? StateMachine

void u8g_DrawStartUp(void) //,,Verschnerung" zum Zeit ,,schinden" am Anfang fr UM6
{
    404e:	ef 92       	push	r14
    4050:	ff 92       	push	r15
    4052:	0f 93       	push	r16
    4054:	cf 93       	push	r28
	if((mcusr_mirror & (1<<0)) ||
    4056:	80 91 d7 05 	lds	r24, 0x05D7
    405a:	80 ff       	sbrs	r24, 0
    405c:	02 c0       	rjmp	.+4      	; 0x4062 <u8g_DrawStartUp+0x14>
						case 5:	u8g_DrawXBMP(&u8g, 91, 2, 29, 29, logo_a4);		//20ms
										break;
						case 6:	u8g_DrawXBMP(&u8g, 0, 0, 128, 29, logo);			//1000ms
										break;
						default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.01]:DEFAULT_CASE"));}
											fatal_err = 1;
    405e:	c1 e0       	ldi	r28, 0x01	; 1
    4060:	59 c0       	rjmp	.+178    	; 0x4114 <u8g_DrawStartUp+0xc6>

uint8_t sm_logo = 0; //Logo fertig? StateMachine

void u8g_DrawStartUp(void) //,,Verschnerung" zum Zeit ,,schinden" am Anfang fr UM6
{
	if((mcusr_mirror & (1<<0)) ||
    4062:	80 91 64 05 	lds	r24, 0x0564
    4066:	81 11       	cpse	r24, r1
    4068:	fa cf       	rjmp	.-12     	; 0x405e <u8g_DrawStartUp+0x10>
    406a:	0f c1       	rjmp	.+542    	; 0x428a <u8g_DrawStartUp+0x23c>
			 	if(!check_res) //Normaler Start
				{
					/////Logo (Animation)
					switch(sm_logo)
					{
						case 0:	u8g_DrawXBMP(&u8g, 5, 5, 118, 29, logo_rios); //500ms
    406c:	73 ee       	ldi	r23, 0xE3	; 227
    406e:	e7 2e       	mov	r14, r23
    4070:	7d e1       	ldi	r23, 0x1D	; 29
    4072:	f7 2e       	mov	r15, r23
    4074:	0d e1       	ldi	r16, 0x1D	; 29
    4076:	26 e7       	ldi	r18, 0x76	; 118
    4078:	45 e0       	ldi	r20, 0x05	; 5
    407a:	65 e0       	ldi	r22, 0x05	; 5
										break;
						case 1:	u8g_DrawXBMP(&u8g, 14, 2, 99, 42, logo_rcj); //500ms
    407c:	8b e1       	ldi	r24, 0x1B	; 27
    407e:	97 e0       	ldi	r25, 0x07	; 7
    4080:	0e 94 59 63 	call	0xc6b2	; 0xc6b2 <u8g_DrawXBMP>
										break;
						default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.01]:DEFAULT_CASE"));}
											fatal_err = 1;
					}
					///////Text/////
					u8g_SetFont(&u8g, u8g_font_6x10); //Schriftart
    4084:	6d ee       	ldi	r22, 0xED	; 237
    4086:	76 e0       	ldi	r23, 0x06	; 6
    4088:	8b e1       	ldi	r24, 0x1B	; 27
    408a:	97 e0       	ldi	r25, 0x07	; 7
    408c:	15 dd       	rcall	.-1494   	; 0x3ab8 <u8g_SetFont>
    408e:	2a ed       	ldi	r18, 0xDA	; 218
					u8g_DrawStr(&u8g, 20, 	55, "Calibrate IMU...");
    4090:	32 e0       	ldi	r19, 0x02	; 2
    4092:	47 e3       	ldi	r20, 0x37	; 55
    4094:	64 e1       	ldi	r22, 0x14	; 20
    4096:	8b e1       	ldi	r24, 0x1B	; 27
    4098:	97 e0       	ldi	r25, 0x07	; 7
    409a:	89 dc       	rcall	.-1774   	; 0x39ae <u8g_DrawStr>
    409c:	6f e8       	ldi	r22, 0x8F	; 143
    409e:	74 e1       	ldi	r23, 0x14	; 20
	
					u8g_SetFont(&u8g, u8g_font_4x6); //Schriftart
    40a0:	8b e1       	ldi	r24, 0x1B	; 27
    40a2:	97 e0       	ldi	r25, 0x07	; 7
    40a4:	09 dd       	rcall	.-1518   	; 0x3ab8 <u8g_SetFont>
    40a6:	80 91 d7 05 	lds	r24, 0x05D7
    40aa:	80 ff       	sbrs	r24, 0

					if(mcusr_mirror & (1<<0))
    40ac:	96 c0       	rjmp	.+300    	; 0x41da <u8g_DrawStartUp+0x18c>
    40ae:	2b ee       	ldi	r18, 0xEB	; 235
    40b0:	32 e0       	ldi	r19, 0x02	; 2
    40b2:	40 e4       	ldi	r20, 0x40	; 64
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: PORF"); //Power-on Reset Flag
    40b4:	68 e2       	ldi	r22, 0x28	; 40
    40b6:	8b e1       	ldi	r24, 0x1B	; 27
					else if(mcusr_mirror & (1<<1))
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: EXTRF"); //External Reset Flag
					else if(mcusr_mirror & (1<<2))
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: BORF"); //Brown-out Reset Flag
					else if(mcusr_mirror & (1<<4))
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: JTRF"); //JTAG Reset Flag
    40b8:	97 e0       	ldi	r25, 0x07	; 7
    40ba:	79 dc       	rcall	.-1806   	; 0x39ae <u8g_DrawStr>
    40bc:	20 e2       	ldi	r18, 0x20	; 32
    40be:	33 e0       	ldi	r19, 0x03	; 3
    40c0:	49 e3       	ldi	r20, 0x39	; 57
    40c2:	60 e0       	ldi	r22, 0x00	; 0

					u8g_DrawStr(&u8g, 0, 	57, "V3.1");
    40c4:	8b e1       	ldi	r24, 0x1B	; 27
    40c6:	97 e0       	ldi	r25, 0x07	; 7
    40c8:	72 dc       	rcall	.-1820   	; 0x39ae <u8g_DrawStr>
    40ca:	25 e2       	ldi	r18, 0x25	; 37
    40cc:	33 e0       	ldi	r19, 0x03	; 3
    40ce:	4f e3       	ldi	r20, 0x3F	; 63
    40d0:	60 e0       	ldi	r22, 0x00	; 0
    40d2:	8b e1       	ldi	r24, 0x1B	; 27
					u8g_DrawStr(&u8g, 0, 	63, "RCJ 2014");
    40d4:	97 e0       	ldi	r25, 0x07	; 7
    40d6:	6b dc       	rcall	.-1834   	; 0x39ae <u8g_DrawStr>
    40d8:	8b e1       	ldi	r24, 0x1B	; 27
    40da:	97 e0       	ldi	r25, 0x07	; 7
					u8g_DrawStr(&u8g, 65, 	10, "WARNING");
					u8g_SetFont(&u8g, u8g_font_6x10);
					u8g_DrawStr(&u8g, 65, 	20, "Recovered");
					u8g_DrawStr(&u8g, 65, 	30, "after an");
					u8g_DrawStr(&u8g, 65, 	40, "unexpected");
					u8g_DrawStr(&u8g, 65, 	50, "shutdown!");
    40dc:	30 de       	rcall	.-928    	; 0x3d3e <u8g_NextPage>
    40de:	81 11       	cpse	r24, r1
    40e0:	21 c0       	rjmp	.+66     	; 0x4124 <u8g_DrawStartUp+0xd6>
    40e2:	0e 94 56 5b 	call	0xb6ac	; 0xb6ac <get_t1>
					//u8g_SetFont(&u8g, u8g_font_4x6); //Schriftart
					//u8g_DrawStr(&u8g, 60, 	60, "Calibrate IMU...");
				}
			} while(u8g_NextPage(&u8g));
    40e6:	81 11       	cpse	r24, r1
    40e8:	fc cf       	rjmp	.-8      	; 0x40e2 <u8g_DrawStartUp+0x94>
    40ea:	80 91 7a 05 	lds	r24, 0x057A
    40ee:	83 30       	cpi	r24, 0x03	; 3

			while(get_t1()); //Animation pausieren, whrend Pausetaste gedckt gehalten wird
    40f0:	08 f0       	brcs	.+2      	; 0x40f4 <u8g_DrawStartUp+0xa6>
    40f2:	b9 c0       	rjmp	.+370    	; 0x4266 <u8g_DrawStartUp+0x218>
    40f4:	2f ef       	ldi	r18, 0xFF	; 255
    40f6:	89 e6       	ldi	r24, 0x69	; 105
    40f8:	98 e1       	ldi	r25, 0x18	; 24
    40fa:	21 50       	subi	r18, 0x01	; 1
    40fc:	80 40       	sbci	r24, 0x00	; 0
    40fe:	90 40       	sbci	r25, 0x00	; 0
    4100:	e1 f7       	brne	.-8      	; 0x40fa <u8g_DrawStartUp+0xac>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4102:	00 c0       	rjmp	.+0      	; 0x4104 <u8g_DrawStartUp+0xb6>
    4104:	00 00       	nop
    4106:	80 91 7a 05 	lds	r24, 0x057A
    410a:	87 30       	cpi	r24, 0x07	; 7
    410c:	18 f4       	brcc	.+6      	; 0x4114 <u8g_DrawStartUp+0xc6>
    410e:	8f 5f       	subi	r24, 0xFF	; 255
    4110:	80 93 7a 05 	sts	0x057A, r24
				_delay_ms(1000);
			}
			else
				_delay_ms(20);
			
			if(sm_logo < 7)
    4114:	80 91 7a 05 	lds	r24, 0x057A
    4118:	87 30       	cpi	r24, 0x07	; 7
    411a:	08 f0       	brcs	.+2      	; 0x411e <u8g_DrawStartUp+0xd0>
				sm_logo++;
    411c:	b6 c0       	rjmp	.+364    	; 0x428a <u8g_DrawStartUp+0x23c>
    411e:	8b e1       	ldi	r24, 0x1B	; 27
    4120:	97 e0       	ldi	r25, 0x07	; 7
void u8g_DrawStartUp(void) //,,Verschnerung" zum Zeit ,,schinden" am Anfang fr UM6
{
	if((mcusr_mirror & (1<<0)) ||
		 check_res) //Nur bei Power-off Neustart (nur dann kalibriert sich UM6 neu) und bei Reset (Warnung anzeigen)
	{
		while(sm_logo < 7)
    4122:	09 de       	rcall	.-1006   	; 0x3d36 <u8g_FirstPage>
    4124:	80 91 64 05 	lds	r24, 0x0564
    4128:	81 11       	cpse	r24, r1
    412a:	66 c0       	rjmp	.+204    	; 0x41f8 <u8g_DrawStartUp+0x1aa>
		{
			u8g_FirstPage(&u8g);
    412c:	80 91 7a 05 	lds	r24, 0x057A
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	87 30       	cpi	r24, 0x07	; 7
		 	do
			{
			 	if(!check_res) //Normaler Start
    4134:	91 05       	cpc	r25, r1
    4136:	d8 f5       	brcc	.+118    	; 0x41ae <u8g_DrawStartUp+0x160>
    4138:	fc 01       	movw	r30, r24
    413a:	ee 58       	subi	r30, 0x8E	; 142
				{
					/////Logo (Animation)
					switch(sm_logo)
    413c:	ff 4f       	sbci	r31, 0xFF	; 255
    413e:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
    4142:	61 ec       	ldi	r22, 0xC1	; 193
    4144:	e6 2e       	mov	r14, r22
    4146:	6b e1       	ldi	r22, 0x1B	; 27
    4148:	f6 2e       	mov	r15, r22
    414a:	0a e2       	ldi	r16, 0x2A	; 42
    414c:	23 e6       	ldi	r18, 0x63	; 99
    414e:	42 e0       	ldi	r20, 0x02	; 2
    4150:	6e e0       	ldi	r22, 0x0E	; 14
					{
						case 0:	u8g_DrawXBMP(&u8g, 5, 5, 118, 29, logo_rios); //500ms
										break;
						case 1:	u8g_DrawXBMP(&u8g, 14, 2, 99, 42, logo_rcj); //500ms
    4152:	94 cf       	rjmp	.-216    	; 0x407c <u8g_DrawStartUp+0x2e>
    4154:	58 e4       	ldi	r21, 0x48	; 72
    4156:	e5 2e       	mov	r14, r21
    4158:	53 e2       	ldi	r21, 0x23	; 35
    415a:	f5 2e       	mov	r15, r21
    415c:	09 e2       	ldi	r16, 0x29	; 41
    415e:	29 e2       	ldi	r18, 0x29	; 41
    4160:	42 e0       	ldi	r20, 0x02	; 2
    4162:	6c e2       	ldi	r22, 0x2C	; 44
										break;
						case 2:	u8g_DrawXBMP(&u8g, 44, 2, 41, 41, logo_a1);		//500ms
    4164:	8b cf       	rjmp	.-234    	; 0x407c <u8g_DrawStartUp+0x2e>
    4166:	4f e8       	ldi	r20, 0x8F	; 143
    4168:	e4 2e       	mov	r14, r20
    416a:	42 e2       	ldi	r20, 0x22	; 34
    416c:	f4 2e       	mov	r15, r20
    416e:	05 e2       	ldi	r16, 0x25	; 37
    4170:	25 e2       	ldi	r18, 0x25	; 37
    4172:	42 e0       	ldi	r20, 0x02	; 2
    4174:	6c e3       	ldi	r22, 0x3C	; 60
										break;
						case 3:	u8g_DrawXBMP(&u8g, 60, 2, 37, 37, logo_a2);		//20ms
    4176:	82 cf       	rjmp	.-252    	; 0x407c <u8g_DrawStartUp+0x2e>
    4178:	3a ee       	ldi	r19, 0xEA	; 234
    417a:	e3 2e       	mov	r14, r19
    417c:	31 e2       	ldi	r19, 0x21	; 33
    417e:	f3 2e       	mov	r15, r19
    4180:	01 e2       	ldi	r16, 0x21	; 33
    4182:	21 e2       	ldi	r18, 0x21	; 33
    4184:	42 e0       	ldi	r20, 0x02	; 2
    4186:	6c e4       	ldi	r22, 0x4C	; 76
										break;
						case 4: u8g_DrawXBMP(&u8g, 76, 2, 33, 33, logo_a3);		//20ms
    4188:	79 cf       	rjmp	.-270    	; 0x407c <u8g_DrawStartUp+0x2e>
    418a:	26 e7       	ldi	r18, 0x76	; 118
    418c:	e2 2e       	mov	r14, r18
    418e:	21 e2       	ldi	r18, 0x21	; 33
    4190:	f2 2e       	mov	r15, r18
    4192:	0d e1       	ldi	r16, 0x1D	; 29
    4194:	2d e1       	ldi	r18, 0x1D	; 29
    4196:	42 e0       	ldi	r20, 0x02	; 2
    4198:	6b e5       	ldi	r22, 0x5B	; 91
										break;
						case 5:	u8g_DrawXBMP(&u8g, 91, 2, 29, 29, logo_a4);		//20ms
    419a:	70 cf       	rjmp	.-288    	; 0x407c <u8g_DrawStartUp+0x2e>
    419c:	9e e3       	ldi	r25, 0x3E	; 62
    419e:	e9 2e       	mov	r14, r25
    41a0:	94 e2       	ldi	r25, 0x24	; 36
    41a2:	f9 2e       	mov	r15, r25
    41a4:	0d e1       	ldi	r16, 0x1D	; 29
    41a6:	20 e8       	ldi	r18, 0x80	; 128
    41a8:	40 e0       	ldi	r20, 0x00	; 0
    41aa:	60 e0       	ldi	r22, 0x00	; 0
										break;
						case 6:	u8g_DrawXBMP(&u8g, 0, 0, 128, 29, logo);			//1000ms
    41ac:	67 cf       	rjmp	.-306    	; 0x407c <u8g_DrawStartUp+0x2e>
    41ae:	80 91 53 05 	lds	r24, 0x0553
    41b2:	82 30       	cpi	r24, 0x02	; 2
    41b4:	78 f0       	brcs	.+30     	; 0x41d4 <u8g_DrawStartUp+0x186>
    41b6:	8e eb       	ldi	r24, 0xBE	; 190
    41b8:	9b e1       	ldi	r25, 0x1B	; 27
    41ba:	06 df       	rcall	.-500    	; 0x3fc8 <bt_putStr_P>
    41bc:	60 91 47 05 	lds	r22, 0x0547
										break;
						default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.01]:DEFAULT_CASE"));}
    41c0:	70 91 48 05 	lds	r23, 0x0548
    41c4:	80 91 49 05 	lds	r24, 0x0549
    41c8:	90 91 4a 05 	lds	r25, 0x054A
    41cc:	0f df       	rcall	.-482    	; 0x3fec <bt_putLong>
    41ce:	88 e8       	ldi	r24, 0x88	; 136
    41d0:	9b e1       	ldi	r25, 0x1B	; 27
    41d2:	fa de       	rcall	.-524    	; 0x3fc8 <bt_putStr_P>
    41d4:	c0 93 63 05 	sts	0x0563, r28
    41d8:	55 cf       	rjmp	.-342    	; 0x4084 <u8g_DrawStartUp+0x36>
    41da:	81 ff       	sbrs	r24, 1
    41dc:	03 c0       	rjmp	.+6      	; 0x41e4 <u8g_DrawStartUp+0x196>
    41de:	28 ef       	ldi	r18, 0xF8	; 248
    41e0:	32 e0       	ldi	r19, 0x02	; 2
    41e2:	67 cf       	rjmp	.-306    	; 0x40b2 <u8g_DrawStartUp+0x64>
    41e4:	82 ff       	sbrs	r24, 2
    41e6:	03 c0       	rjmp	.+6      	; 0x41ee <u8g_DrawStartUp+0x1a0>
    41e8:	26 e0       	ldi	r18, 0x06	; 6
											fatal_err = 1;
    41ea:	33 e0       	ldi	r19, 0x03	; 3
    41ec:	62 cf       	rjmp	.-316    	; 0x40b2 <u8g_DrawStartUp+0x64>
    41ee:	84 ff       	sbrs	r24, 4
	
					u8g_SetFont(&u8g, u8g_font_4x6); //Schriftart

					if(mcusr_mirror & (1<<0))
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: PORF"); //Power-on Reset Flag
					else if(mcusr_mirror & (1<<1))
    41f0:	65 cf       	rjmp	.-310    	; 0x40bc <u8g_DrawStartUp+0x6e>
    41f2:	23 e1       	ldi	r18, 0x13	; 19
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: EXTRF"); //External Reset Flag
    41f4:	33 e0       	ldi	r19, 0x03	; 3
    41f6:	5d cf       	rjmp	.-326    	; 0x40b2 <u8g_DrawStartUp+0x64>
    41f8:	86 e9       	ldi	r24, 0x96	; 150
					else if(mcusr_mirror & (1<<2))
    41fa:	e8 2e       	mov	r14, r24
    41fc:	8f e1       	ldi	r24, 0x1F	; 31
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: BORF"); //Brown-out Reset Flag
    41fe:	f8 2e       	mov	r15, r24
    4200:	0c e3       	ldi	r16, 0x3C	; 60
    4202:	2c e3       	ldi	r18, 0x3C	; 60
					else if(mcusr_mirror & (1<<4))
    4204:	42 e0       	ldi	r20, 0x02	; 2
    4206:	62 e0       	ldi	r22, 0x02	; 2
						u8g_DrawStr(&u8g, 40, 	64, "ResSRC: JTRF"); //JTAG Reset Flag
    4208:	8b e1       	ldi	r24, 0x1B	; 27
    420a:	97 e0       	ldi	r25, 0x07	; 7
    420c:	0e 94 59 63 	call	0xc6b2	; 0xc6b2 <u8g_DrawXBMP>
					u8g_DrawStr(&u8g, 0, 	57, "V3.1");
					u8g_DrawStr(&u8g, 0, 	63, "RCJ 2014");
				}
				else	//Watchdog Start!
				{
					u8g_DrawXBMP(&u8g, 2, 2, 60, 60, warning);
    4210:	6a e8       	ldi	r22, 0x8A	; 138
    4212:	72 e0       	ldi	r23, 0x02	; 2
    4214:	8b e1       	ldi	r24, 0x1B	; 27
    4216:	97 e0       	ldi	r25, 0x07	; 7
    4218:	4f dc       	rcall	.-1890   	; 0x3ab8 <u8g_SetFont>
    421a:	2e e2       	ldi	r18, 0x2E	; 46
    421c:	33 e0       	ldi	r19, 0x03	; 3
    421e:	4a e0       	ldi	r20, 0x0A	; 10
    4220:	61 e4       	ldi	r22, 0x41	; 65
    4222:	8b e1       	ldi	r24, 0x1B	; 27
    4224:	97 e0       	ldi	r25, 0x07	; 7
					u8g_SetFont(&u8g, u8g_font_8x13Br); //Schriftart
    4226:	c3 db       	rcall	.-2170   	; 0x39ae <u8g_DrawStr>
    4228:	6d ee       	ldi	r22, 0xED	; 237
    422a:	76 e0       	ldi	r23, 0x06	; 6
    422c:	8b e1       	ldi	r24, 0x1B	; 27
    422e:	97 e0       	ldi	r25, 0x07	; 7
    4230:	43 dc       	rcall	.-1914   	; 0x3ab8 <u8g_SetFont>
					u8g_DrawStr(&u8g, 65, 	10, "WARNING");
    4232:	26 e3       	ldi	r18, 0x36	; 54
    4234:	33 e0       	ldi	r19, 0x03	; 3
    4236:	44 e1       	ldi	r20, 0x14	; 20
    4238:	61 e4       	ldi	r22, 0x41	; 65
    423a:	8b e1       	ldi	r24, 0x1B	; 27
    423c:	97 e0       	ldi	r25, 0x07	; 7
    423e:	b7 db       	rcall	.-2194   	; 0x39ae <u8g_DrawStr>
    4240:	20 e4       	ldi	r18, 0x40	; 64
					u8g_SetFont(&u8g, u8g_font_6x10);
    4242:	33 e0       	ldi	r19, 0x03	; 3
    4244:	4e e1       	ldi	r20, 0x1E	; 30
    4246:	61 e4       	ldi	r22, 0x41	; 65
    4248:	8b e1       	ldi	r24, 0x1B	; 27
    424a:	97 e0       	ldi	r25, 0x07	; 7
    424c:	b0 db       	rcall	.-2208   	; 0x39ae <u8g_DrawStr>
					u8g_DrawStr(&u8g, 65, 	20, "Recovered");
    424e:	29 e4       	ldi	r18, 0x49	; 73
    4250:	33 e0       	ldi	r19, 0x03	; 3
    4252:	48 e2       	ldi	r20, 0x28	; 40
    4254:	61 e4       	ldi	r22, 0x41	; 65
    4256:	8b e1       	ldi	r24, 0x1B	; 27
    4258:	97 e0       	ldi	r25, 0x07	; 7
    425a:	a9 db       	rcall	.-2222   	; 0x39ae <u8g_DrawStr>
    425c:	24 e5       	ldi	r18, 0x54	; 84
					u8g_DrawStr(&u8g, 65, 	30, "after an");
    425e:	33 e0       	ldi	r19, 0x03	; 3
    4260:	42 e3       	ldi	r20, 0x32	; 50
    4262:	61 e4       	ldi	r22, 0x41	; 65
    4264:	36 cf       	rjmp	.-404    	; 0x40d2 <u8g_DrawStartUp+0x84>
    4266:	86 30       	cpi	r24, 0x06	; 6
    4268:	41 f4       	brne	.+16     	; 0x427a <u8g_DrawStartUp+0x22c>
    426a:	2f ef       	ldi	r18, 0xFF	; 255
    426c:	83 ed       	ldi	r24, 0xD3	; 211
					u8g_DrawStr(&u8g, 65, 	40, "unexpected");
    426e:	90 e3       	ldi	r25, 0x30	; 48
    4270:	21 50       	subi	r18, 0x01	; 1
    4272:	80 40       	sbci	r24, 0x00	; 0
    4274:	90 40       	sbci	r25, 0x00	; 0
    4276:	e1 f7       	brne	.-8      	; 0x4270 <u8g_DrawStartUp+0x222>
    4278:	44 cf       	rjmp	.-376    	; 0x4102 <u8g_DrawStartUp+0xb4>
    427a:	2f ef       	ldi	r18, 0xFF	; 255
    427c:	89 ef       	ldi	r24, 0xF9	; 249
					u8g_DrawStr(&u8g, 65, 	50, "shutdown!");
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	21 50       	subi	r18, 0x01	; 1
    4282:	80 40       	sbci	r24, 0x00	; 0
    4284:	90 40       	sbci	r25, 0x00	; 0
    4286:	e1 f7       	brne	.-8      	; 0x4280 <u8g_DrawStartUp+0x232>
    4288:	3c cf       	rjmp	.-392    	; 0x4102 <u8g_DrawStartUp+0xb4>
    428a:	cf 91       	pop	r28
    428c:	0f 91       	pop	r16
    428e:	ff 90       	pop	r15
    4290:	ef 90       	pop	r14
    4292:	08 95       	ret

00004294 <set_msg>:
	"INFO 05: LOP..."
};

void set_msg(void) //Hilfsfunktion
{
	which_msg = disp_msg_i+1;
    4294:	80 91 79 05 	lds	r24, 0x0579
    4298:	8f 5f       	subi	r24, 0xFF	; 255
    429a:	80 93 78 05 	sts	0x0578, r24
	if(!(is_msg & (1<<0)))
    429e:	80 91 77 05 	lds	r24, 0x0577
    42a2:	80 fd       	sbrc	r24, 0
    42a4:	06 c0       	rjmp	.+12     	; 0x42b2 <set_msg+0x1e>
	{
		is_msg |= (1<<0);
		is_msg |= (1<<1);
    42a6:	83 60       	ori	r24, 0x03	; 3
    42a8:	80 93 77 05 	sts	0x0577, r24
		timer_disp_msg = TIMER_DISP_MSG;
    42ac:	8f e7       	ldi	r24, 0x7F	; 127
    42ae:	80 93 4e 05 	sts	0x054E, r24
    42b2:	08 95       	ret

000042b4 <u8g_DrawInfo>:
}

enum DISP_MSG {WNG_01, WNG_02, ERR_FA, ERR_10, ERR_11, ERR_20, ERR_21, ERR_30, ERR_31, INF_01, INF_02, INF_03, INF_04, INF_05}; //Ok-Meldung nicht enthalten!

u8g_DrawInfo(void) //Malen der Batterie, Anzeige in %
{
    42b4:	0f 93       	push	r16
	//  Raum    /////////       //
	//          //Info //       //
	//          //Karte//       //
	//////////////////////////////
		
	u8g_DrawHLine(&u8g, 0, 6, 128); //Horizontale Abgrenzungslinie
    42b6:	20 e8       	ldi	r18, 0x80	; 128
    42b8:	46 e0       	ldi	r20, 0x06	; 6
    42ba:	60 e0       	ldi	r22, 0x00	; 0
    42bc:	8b e1       	ldi	r24, 0x1B	; 27
    42be:	97 e0       	ldi	r25, 0x07	; 7
    42c0:	e1 dd       	rcall	.-1086   	; 0x3e84 <u8g_DrawHLine>
    42c2:	6f e8       	ldi	r22, 0x8F	; 143

    u8g_SetFont(&u8g, u8g_font_4x6); //Schriftart
    42c4:	74 e1       	ldi	r23, 0x14	; 20
    42c6:	8b e1       	ldi	r24, 0x1B	; 27
    42c8:	97 e0       	ldi	r25, 0x07	; 7
    42ca:	f6 db       	rcall	.-2068   	; 0x3ab8 <u8g_SetFont>
    42cc:	80 91 60 05 	lds	r24, 0x0560
	
	//////Batterie////////////
	if(batt_percent > -1)
    42d0:	87 fd       	sbrc	r24, 7
    42d2:	35 c0       	rjmp	.+106    	; 0x433e <u8g_DrawInfo+0x8a>
    42d4:	05 e0       	ldi	r16, 0x05	; 5
    42d6:	2a e0       	ldi	r18, 0x0A	; 10
	{
		u8g_DrawFrame(&u8g, 0, 0, 10, 5); //Batteriekrper
    42d8:	40 e0       	ldi	r20, 0x00	; 0
    42da:	60 e0       	ldi	r22, 0x00	; 0
    42dc:	8b e1       	ldi	r24, 0x1B	; 27
    42de:	97 e0       	ldi	r25, 0x07	; 7
    42e0:	04 de       	rcall	.-1016   	; 0x3eea <u8g_DrawFrame>
    42e2:	42 e0       	ldi	r20, 0x02	; 2
    42e4:	6a e0       	ldi	r22, 0x0A	; 10
    42e6:	8b e1       	ldi	r24, 0x1B	; 27
		u8g_DrawPixel(&u8g, 10, 2);
    42e8:	97 e0       	ldi	r25, 0x07	; 7
    42ea:	38 dd       	rcall	.-1424   	; 0x3d5c <u8g_DrawPixel>
    42ec:	80 91 60 05 	lds	r24, 0x0560
    42f0:	6b e0       	ldi	r22, 0x0B	; 11
    42f2:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
		int8_t batt_volumeVar = batt_percent/11; //Berechnung Fllung
    42f6:	89 30       	cpi	r24, 0x09	; 9
    42f8:	24 f4       	brge	.+8      	; 0x4302 <u8g_DrawInfo+0x4e>
    42fa:	87 ff       	sbrs	r24, 7
    42fc:	03 c0       	rjmp	.+6      	; 0x4304 <u8g_DrawInfo+0x50>
		if(batt_volumeVar > 8)
    42fe:	80 e0       	ldi	r24, 0x00	; 0
    4300:	01 c0       	rjmp	.+2      	; 0x4304 <u8g_DrawInfo+0x50>
			batt_volumeVar = 8;
		if(batt_volumeVar < 0)
    4302:	88 e0       	ldi	r24, 0x08	; 8
    4304:	03 e0       	ldi	r16, 0x03	; 3
			batt_volumeVar = 0;	
    4306:	28 2f       	mov	r18, r24
    4308:	41 e0       	ldi	r20, 0x01	; 1
	{
		u8g_DrawFrame(&u8g, 0, 0, 10, 5); //Batteriekrper
		u8g_DrawPixel(&u8g, 10, 2);
		int8_t batt_volumeVar = batt_percent/11; //Berechnung Fllung
		if(batt_volumeVar > 8)
			batt_volumeVar = 8;
    430a:	61 e0       	ldi	r22, 0x01	; 1
		if(batt_volumeVar < 0)
			batt_volumeVar = 0;	
		u8g_DrawBox(&u8g, 1, 1, batt_volumeVar, 3); //Fllung
    430c:	8b e1       	ldi	r24, 0x1B	; 27
    430e:	97 e0       	ldi	r25, 0x07	; 7
    4310:	31 de       	rcall	.-926    	; 0x3f74 <u8g_DrawBox>
    4312:	20 91 60 05 	lds	r18, 0x0560
    4316:	23 36       	cpi	r18, 0x63	; 99
    4318:	34 f4       	brge	.+12     	; 0x4326 <u8g_DrawInfo+0x72>
    431a:	33 27       	eor	r19, r19

		//Anzeige daneben
		if(batt_percent < 99)
    431c:	27 fd       	sbrc	r18, 7
    431e:	30 95       	com	r19
    4320:	43 2f       	mov	r20, r19
    4322:	53 2f       	mov	r21, r19
			u8g_DrawLong(15,	5, batt_percent);
    4324:	04 c0       	rjmp	.+8      	; 0x432e <u8g_DrawInfo+0x7a>
    4326:	23 e6       	ldi	r18, 0x63	; 99
    4328:	30 e0       	ldi	r19, 0x00	; 0
    432a:	40 e0       	ldi	r20, 0x00	; 0
    432c:	50 e0       	ldi	r21, 0x00	; 0
    432e:	65 e0       	ldi	r22, 0x05	; 5
		else
			u8g_DrawLong(15,	5, 99);
    4330:	8f e0       	ldi	r24, 0x0F	; 15
    4332:	70 de       	rcall	.-800    	; 0x4014 <u8g_DrawLong>
    4334:	2e e5       	ldi	r18, 0x5E	; 94
    4336:	33 e0       	ldi	r19, 0x03	; 3
    4338:	45 e0       	ldi	r20, 0x05	; 5
    433a:	69 e1       	ldi	r22, 0x19	; 25
    433c:	04 c0       	rjmp	.+8      	; 0x4346 <u8g_DrawInfo+0x92>
    433e:	20 e6       	ldi	r18, 0x60	; 96

		u8g_DrawStr(&u8g, 25, 	5, "%");
    4340:	33 e0       	ldi	r19, 0x03	; 3
    4342:	45 e0       	ldi	r20, 0x05	; 5
    4344:	60 e0       	ldi	r22, 0x00	; 0
    4346:	8b e1       	ldi	r24, 0x1B	; 27
    4348:	97 e0       	ldi	r25, 0x07	; 7
	}
	else
	{
		u8g_DrawStr(&u8g, 0, 	5, "ERR:BAT");
    434a:	31 db       	rcall	.-2462   	; 0x39ae <u8g_DrawStr>
    434c:	80 91 4e 05 	lds	r24, 0x054E
    4350:	81 11       	cpse	r24, r1
    4352:	19 c0       	rjmp	.+50     	; 0x4386 <u8g_DrawInfo+0xd2>
    4354:	80 91 79 05 	lds	r24, 0x0579
    4358:	8f 5f       	subi	r24, 0xFF	; 255
	}
	
	//Fehleranzeige daneben:
	if(timer_disp_msg == 0)
    435a:	8e 30       	cpi	r24, 0x0E	; 14
    435c:	19 f0       	breq	.+6      	; 0x4364 <u8g_DrawInfo+0xb0>
    435e:	80 93 79 05 	sts	0x0579, r24
	{
		disp_msg_i ++;
    4362:	0c c0       	rjmp	.+24     	; 0x437c <u8g_DrawInfo+0xc8>
    4364:	10 92 79 05 	sts	0x0579, r1
		if(disp_msg_i == DISP_MSG_I_TOP)
    4368:	80 91 77 05 	lds	r24, 0x0577
	}
	
	//Fehleranzeige daneben:
	if(timer_disp_msg == 0)
	{
		disp_msg_i ++;
    436c:	81 fd       	sbrc	r24, 1
    436e:	03 c0       	rjmp	.+6      	; 0x4376 <u8g_DrawInfo+0xc2>
    4370:	10 92 78 05 	sts	0x0578, r1
		if(disp_msg_i == DISP_MSG_I_TOP)
		{
			disp_msg_i = 0;
    4374:	03 c0       	rjmp	.+6      	; 0x437c <u8g_DrawInfo+0xc8>
			if(!(is_msg & (1<<1)))
    4376:	8d 7f       	andi	r24, 0xFD	; 253
    4378:	80 93 77 05 	sts	0x0577, r24
    437c:	80 91 77 05 	lds	r24, 0x0577
				which_msg = 0;
    4380:	8e 7f       	andi	r24, 0xFE	; 254
    4382:	80 93 77 05 	sts	0x0577, r24
			else
				is_msg &= ~ (1<<1);
    4386:	80 91 79 05 	lds	r24, 0x0579
		}
		is_msg &= ~ (1<<0);
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	8e 30       	cpi	r24, 0x0E	; 14
    438e:	91 05       	cpc	r25, r1
    4390:	08 f0       	brcs	.+2      	; 0x4394 <u8g_DrawInfo+0xe0>
    4392:	45 c0       	rjmp	.+138    	; 0x441e <u8g_DrawInfo+0x16a>
	}

	switch(disp_msg_i)
    4394:	fc 01       	movw	r30, r24
    4396:	e7 58       	subi	r30, 0x87	; 135
    4398:	ff 4f       	sbci	r31, 0xFF	; 255
    439a:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
    439e:	80 91 60 05 	lds	r24, 0x0560
    43a2:	84 31       	cpi	r24, 0x14	; 20
    43a4:	0c f0       	brlt	.+2      	; 0x43a8 <u8g_DrawInfo+0xf4>
    43a6:	51 c0       	rjmp	.+162    	; 0x444a <u8g_DrawInfo+0x196>
    43a8:	75 df       	rcall	.-278    	; 0x4294 <set_msg>
    43aa:	4f c0       	rjmp	.+158    	; 0x444a <u8g_DrawInfo+0x196>
	{
		case WNG_01:		if(batt_percent < 20)															set_msg();		break;
    43ac:	80 91 64 05 	lds	r24, 0x0564
    43b0:	26 c0       	rjmp	.+76     	; 0x43fe <u8g_DrawInfo+0x14a>
    43b2:	80 91 63 05 	lds	r24, 0x0563
    43b6:	23 c0       	rjmp	.+70     	; 0x43fe <u8g_DrawInfo+0x14a>
    43b8:	80 91 67 05 	lds	r24, 0x0567
		case WNG_02:		if(check_res)																	set_msg();		break;
    43bc:	0e c0       	rjmp	.+28     	; 0x43da <u8g_DrawInfo+0x126>
    43be:	80 91 67 05 	lds	r24, 0x0567
		case ERR_FA:		if(fatal_err)																	set_msg();		break;
    43c2:	10 c0       	rjmp	.+32     	; 0x43e4 <u8g_DrawInfo+0x130>
    43c4:	80 91 65 05 	lds	r24, 0x0565
		case ERR_10:		if(check_mlx & (1<<0))															set_msg();		break;
    43c8:	83 70       	andi	r24, 0x03	; 3
    43ca:	19 c0       	rjmp	.+50     	; 0x43fe <u8g_DrawInfo+0x14a>
    43cc:	80 91 65 05 	lds	r24, 0x0565
		case ERR_11:		if(check_mlx & (1<<1))															set_msg();		break;
    43d0:	82 ff       	sbrs	r24, 2
    43d2:	3b c0       	rjmp	.+118    	; 0x444a <u8g_DrawInfo+0x196>
    43d4:	e9 cf       	rjmp	.-46     	; 0x43a8 <u8g_DrawInfo+0xf4>
    43d6:	80 91 66 05 	lds	r24, 0x0566
    43da:	80 ff       	sbrs	r24, 0
		case ERR_20:		if((check_um6 & (1<<0)) || (check_um6 & (1<<1)))								set_msg();		break;
		case ERR_21:		if(check_um6 & (1<<2))															set_msg();		break;
    43dc:	36 c0       	rjmp	.+108    	; 0x444a <u8g_DrawInfo+0x196>
    43de:	e4 cf       	rjmp	.-56     	; 0x43a8 <u8g_DrawInfo+0xf4>
    43e0:	80 91 66 05 	lds	r24, 0x0566
    43e4:	81 ff       	sbrs	r24, 1
		case ERR_30:		if(check_srf & (1<<0))															set_msg();		break;
    43e6:	31 c0       	rjmp	.+98     	; 0x444a <u8g_DrawInfo+0x196>
    43e8:	df cf       	rjmp	.-66     	; 0x43a8 <u8g_DrawInfo+0xf4>
    43ea:	80 91 7f 16 	lds	r24, 0x167F
    43ee:	07 c0       	rjmp	.+14     	; 0x43fe <u8g_DrawInfo+0x14a>
		case ERR_31:		if(check_srf & (1<<1))															set_msg();		break;
    43f0:	80 91 4f 05 	lds	r24, 0x054F
    43f4:	18 16       	cp	r1, r24
    43f6:	c4 f2       	brlt	.-80     	; 0x43a8 <u8g_DrawInfo+0xf4>
    43f8:	28 c0       	rjmp	.+80     	; 0x444a <u8g_DrawInfo+0x196>
		case INF_01:		if(mot.off)																		set_msg();		break;
    43fa:	80 91 54 05 	lds	r24, 0x0554
    43fe:	88 23       	and	r24, r24
		case INF_02:		if(timer_bt_is_busy > 0)														set_msg();		break;
    4400:	21 f1       	breq	.+72     	; 0x444a <u8g_DrawInfo+0x196>
    4402:	d2 cf       	rjmp	.-92     	; 0x43a8 <u8g_DrawInfo+0xf4>
    4404:	80 91 93 02 	lds	r24, 0x0293
    4408:	90 91 94 02 	lds	r25, 0x0294
		case INF_03: 		if(setup != 0)																	set_msg();		break;
    440c:	97 ff       	sbrs	r25, 7
    440e:	cc cf       	rjmp	.-104    	; 0x43a8 <u8g_DrawInfo+0xf4>
    4410:	1c c0       	rjmp	.+56     	; 0x444a <u8g_DrawInfo+0x196>
    4412:	80 91 cd 05 	lds	r24, 0x05CD
		case INF_04: 		if(timer_rdy_restart > -1)														set_msg();		break;
    4416:	85 50       	subi	r24, 0x05	; 5
    4418:	82 30       	cpi	r24, 0x02	; 2
    441a:	b8 f4       	brcc	.+46     	; 0x444a <u8g_DrawInfo+0x196>
    441c:	c5 cf       	rjmp	.-118    	; 0x43a8 <u8g_DrawInfo+0xf4>
    441e:	80 91 53 05 	lds	r24, 0x0553
		case INF_05:		if((maze_solve_state_path == LOP_INIT) || (maze_solve_state_path == LOP_WAIT))	set_msg();		break;
    4422:	82 30       	cpi	r24, 0x02	; 2
    4424:	78 f0       	brcs	.+30     	; 0x4444 <u8g_DrawInfo+0x190>
    4426:	85 e8       	ldi	r24, 0x85	; 133
    4428:	9b e1       	ldi	r25, 0x1B	; 27
    442a:	ce dd       	rcall	.-1124   	; 0x3fc8 <bt_putStr_P>
    442c:	60 91 47 05 	lds	r22, 0x0547
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.02]:DEFAULT_CASE"));}
    4430:	70 91 48 05 	lds	r23, 0x0548
    4434:	80 91 49 05 	lds	r24, 0x0549
    4438:	90 91 4a 05 	lds	r25, 0x054A
    443c:	d7 dd       	rcall	.-1106   	; 0x3fec <bt_putLong>
    443e:	8f e4       	ldi	r24, 0x4F	; 79
    4440:	9b e1       	ldi	r25, 0x1B	; 27
    4442:	c2 dd       	rcall	.-1148   	; 0x3fc8 <bt_putStr_P>
    4444:	81 e0       	ldi	r24, 0x01	; 1
    4446:	80 93 63 05 	sts	0x0563, r24
    444a:	e0 91 78 05 	lds	r30, 0x0578
    444e:	f0 e0       	ldi	r31, 0x00	; 0
    4450:	ee 0f       	add	r30, r30
    4452:	ff 1f       	adc	r31, r31
    4454:	ec 55       	subi	r30, 0x5C	; 92
    4456:	fd 4f       	sbci	r31, 0xFD	; 253
    4458:	20 81       	ld	r18, Z
							fatal_err = 1;
    445a:	31 81       	ldd	r19, Z+1	; 0x01
    445c:	45 e0       	ldi	r20, 0x05	; 5
    445e:	63 e2       	ldi	r22, 0x23	; 35
	}
	
	u8g_DrawStr(&u8g, 35, 	5, disp_msg[which_msg]);
    4460:	8b e1       	ldi	r24, 0x1B	; 27
    4462:	97 e0       	ldi	r25, 0x07	; 7
    4464:	a4 da       	rcall	.-2744   	; 0x39ae <u8g_DrawStr>
    4466:	0f 91       	pop	r16
    4468:	08 95       	ret

0000446a <u8g_drawArrow>:
}

void u8g_drawArrow(uint8_t size, uint8_t pos_x, uint8_t pos_y, uint8_t dir, int8_t mode)
{
    446a:	ef 92       	push	r14
    446c:	ff 92       	push	r15
    446e:	0f 93       	push	r16
    4470:	1f 93       	push	r17
    4472:	cf 93       	push	r28
    4474:	df 93       	push	r29
    4476:	f8 2e       	mov	r15, r24
    4478:	d6 2f       	mov	r29, r22
    447a:	c4 2f       	mov	r28, r20
	uint8_t arrowlines_angle_pc = 2; //PC PerCent, logisch nicht korrekt, aber ok

	if(size > 10)
    447c:	8a e0       	ldi	r24, 0x0A	; 10
    447e:	8f 15       	cp	r24, r15
    4480:	18 f0       	brcs	.+6      	; 0x4488 <u8g_drawArrow+0x1e>
	u8g_DrawStr(&u8g, 35, 	5, disp_msg[which_msg]);
}

void u8g_drawArrow(uint8_t size, uint8_t pos_x, uint8_t pos_y, uint8_t dir, int8_t mode)
{
	uint8_t arrowlines_angle_pc = 2; //PC PerCent, logisch nicht korrekt, aber ok
    4482:	12 e0       	ldi	r17, 0x02	; 2
    4484:	e1 2e       	mov	r14, r17
    4486:	02 c0       	rjmp	.+4      	; 0x448c <u8g_drawArrow+0x22>

	if(size > 10)
		arrowlines_angle_pc = 3;
    4488:	b3 e0       	ldi	r27, 0x03	; 3
    448a:	eb 2e       	mov	r14, r27
    448c:	1f 2d       	mov	r17, r15
    448e:	16 95       	lsr	r17

	switch(dir)
    4490:	22 30       	cpi	r18, 0x02	; 2
    4492:	e9 f0       	breq	.+58     	; 0x44ce <u8g_drawArrow+0x64>
    4494:	18 f4       	brcc	.+6      	; 0x449c <u8g_drawArrow+0x32>
    4496:	21 30       	cpi	r18, 0x01	; 1
    4498:	39 f0       	breq	.+14     	; 0x44a8 <u8g_drawArrow+0x3e>
    449a:	75 c0       	rjmp	.+234    	; 0x4586 <u8g_drawArrow+0x11c>
    449c:	23 30       	cpi	r18, 0x03	; 3
    449e:	51 f1       	breq	.+84     	; 0x44f4 <u8g_drawArrow+0x8a>
    44a0:	24 30       	cpi	r18, 0x04	; 4
    44a2:	09 f4       	brne	.+2      	; 0x44a6 <u8g_drawArrow+0x3c>
    44a4:	4a c0       	rjmp	.+148    	; 0x453a <u8g_drawArrow+0xd0>
    44a6:	6f c0       	rjmp	.+222    	; 0x4586 <u8g_drawArrow+0x11c>
	{
		case 1:	//NORTH
							if(mode) u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x-(size/2), pos_y);
    44a8:	00 23       	and	r16, r16
    44aa:	51 f0       	breq	.+20     	; 0x44c0 <u8g_drawArrow+0x56>
    44ac:	0c 2f       	mov	r16, r28
    44ae:	2d 2f       	mov	r18, r29
    44b0:	21 1b       	sub	r18, r17
    44b2:	4c 2f       	mov	r20, r28
    44b4:	61 2f       	mov	r22, r17
    44b6:	6d 0f       	add	r22, r29
    44b8:	8b e1       	ldi	r24, 0x1B	; 27
    44ba:	97 e0       	ldi	r25, 0x07	; 7
    44bc:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x, pos_y-(size/arrowlines_angle_pc));  // -
    44c0:	8f 2d       	mov	r24, r15
    44c2:	6e 2d       	mov	r22, r14
    44c4:	0e 94 3f 6b 	call	0xd67e	; 0xd67e <__udivmodqi4>
    44c8:	f8 2e       	mov	r15, r24
    44ca:	1d 0f       	add	r17, r29
    44cc:	27 c0       	rjmp	.+78     	; 0x451c <u8g_drawArrow+0xb2>
							u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x, pos_y+(size/arrowlines_angle_pc));  // -
						break;
		case 2:	//EAST
							if(mode) u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x, pos_y-(size/2));
    44ce:	00 23       	and	r16, r16
    44d0:	51 f0       	breq	.+20     	; 0x44e6 <u8g_drawArrow+0x7c>
    44d2:	0c 2f       	mov	r16, r28
    44d4:	01 1b       	sub	r16, r17
    44d6:	2d 2f       	mov	r18, r29
    44d8:	41 2f       	mov	r20, r17
    44da:	4c 0f       	add	r20, r28
    44dc:	6d 2f       	mov	r22, r29
    44de:	8b e1       	ldi	r24, 0x1B	; 27
    44e0:	97 e0       	ldi	r25, 0x07	; 7
    44e2:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x-(size/arrowlines_angle_pc),pos_y);  // /
    44e6:	8f 2d       	mov	r24, r15
    44e8:	6e 2d       	mov	r22, r14
    44ea:	0e 94 3f 6b 	call	0xd67e	; 0xd67e <__udivmodqi4>
    44ee:	f8 2e       	mov	r15, r24
    44f0:	1c 0f       	add	r17, r28
    44f2:	37 c0       	rjmp	.+110    	; 0x4562 <u8g_drawArrow+0xf8>
							u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x+(size/arrowlines_angle_pc), pos_y); //  \ //
						break;
		case 3:	//SOUTH
							if(mode) u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x+(size/2), pos_y); // 
    44f4:	00 23       	and	r16, r16
    44f6:	51 f0       	breq	.+20     	; 0x450c <u8g_drawArrow+0xa2>
    44f8:	0c 2f       	mov	r16, r28
    44fa:	21 2f       	mov	r18, r17
    44fc:	2d 0f       	add	r18, r29
    44fe:	4c 2f       	mov	r20, r28
    4500:	6d 2f       	mov	r22, r29
    4502:	61 1b       	sub	r22, r17
    4504:	8b e1       	ldi	r24, 0x1B	; 27
    4506:	97 e0       	ldi	r25, 0x07	; 7
    4508:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x, pos_y-(size/arrowlines_angle_pc));  // -
    450c:	8f 2d       	mov	r24, r15
    450e:	6e 2d       	mov	r22, r14
    4510:	0e 94 3f 6b 	call	0xd67e	; 0xd67e <__udivmodqi4>
    4514:	f8 2e       	mov	r15, r24
    4516:	8d 2f       	mov	r24, r29
    4518:	81 1b       	sub	r24, r17
    451a:	18 2f       	mov	r17, r24
    451c:	0c 2f       	mov	r16, r28
    451e:	0f 19       	sub	r16, r15
    4520:	2d 2f       	mov	r18, r29
    4522:	4c 2f       	mov	r20, r28
    4524:	61 2f       	mov	r22, r17
    4526:	8b e1       	ldi	r24, 0x1B	; 27
    4528:	97 e0       	ldi	r25, 0x07	; 7
    452a:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x, pos_y+(size/arrowlines_angle_pc));  // -
    452e:	0f 2d       	mov	r16, r15
    4530:	0c 0f       	add	r16, r28
    4532:	2d 2f       	mov	r18, r29
    4534:	4c 2f       	mov	r20, r28
    4536:	61 2f       	mov	r22, r17
    4538:	21 c0       	rjmp	.+66     	; 0x457c <u8g_drawArrow+0x112>
						break;
		case 4:	//WEST
							if(mode) u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x, pos_y+(size/2)); // |
    453a:	00 23       	and	r16, r16
    453c:	51 f0       	breq	.+20     	; 0x4552 <u8g_drawArrow+0xe8>
    453e:	01 2f       	mov	r16, r17
    4540:	0c 0f       	add	r16, r28
    4542:	2d 2f       	mov	r18, r29
    4544:	4c 2f       	mov	r20, r28
    4546:	41 1b       	sub	r20, r17
    4548:	6d 2f       	mov	r22, r29
    454a:	8b e1       	ldi	r24, 0x1B	; 27
    454c:	97 e0       	ldi	r25, 0x07	; 7
    454e:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x-(size/arrowlines_angle_pc),pos_y);  // /
    4552:	8f 2d       	mov	r24, r15
    4554:	6e 2d       	mov	r22, r14
    4556:	0e 94 3f 6b 	call	0xd67e	; 0xd67e <__udivmodqi4>
    455a:	f8 2e       	mov	r15, r24
    455c:	8c 2f       	mov	r24, r28
    455e:	81 1b       	sub	r24, r17
    4560:	18 2f       	mov	r17, r24
    4562:	2d 2f       	mov	r18, r29
    4564:	2f 19       	sub	r18, r15
    4566:	0c 2f       	mov	r16, r28
    4568:	41 2f       	mov	r20, r17
    456a:	6d 2f       	mov	r22, r29
    456c:	8b e1       	ldi	r24, 0x1B	; 27
    456e:	97 e0       	ldi	r25, 0x07	; 7
    4570:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
							u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x+(size/arrowlines_angle_pc), pos_y); //  \ //
    4574:	2f 2d       	mov	r18, r15
    4576:	2d 0f       	add	r18, r29
    4578:	41 2f       	mov	r20, r17
    457a:	6d 2f       	mov	r22, r29
    457c:	8b e1       	ldi	r24, 0x1B	; 27
    457e:	97 e0       	ldi	r25, 0x07	; 7
    4580:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
						break;
    4584:	08 c0       	rjmp	.+16     	; 0x4596 <u8g_drawArrow+0x12c>
		default:  u8g_DrawStr(&u8g, pos_x-(size/2), pos_y, "ERROR");
    4586:	6d 2f       	mov	r22, r29
    4588:	61 1b       	sub	r22, r17
    458a:	28 e6       	ldi	r18, 0x68	; 104
    458c:	33 e0       	ldi	r19, 0x03	; 3
    458e:	4c 2f       	mov	r20, r28
    4590:	8b e1       	ldi	r24, 0x1B	; 27
    4592:	97 e0       	ldi	r25, 0x07	; 7
    4594:	0c da       	rcall	.-3048   	; 0x39ae <u8g_DrawStr>
    4596:	cd b7       	in	r28, 0x3d	; 61
						break;
	}
}
    4598:	de b7       	in	r29, 0x3e	; 62
    459a:	e6 e0       	ldi	r30, 0x06	; 6
    459c:	0c 94 c3 6b 	jmp	0xd786	; 0xd786 <__epilogue_restores__+0x18>

000045a0 <setupStep_Fac>:
	
///////Hilfsfunktionen:
int32_t incremental_old_setup = 0;

void setupStep_Fac(int16_t fac)
{
    45a0:	0f 93       	push	r16
    45a2:	1f 93       	push	r17
	switch(setup_mode)
    45a4:	40 91 76 05 	lds	r20, 0x0576
    45a8:	55 27       	eor	r21, r21
    45aa:	47 fd       	sbrc	r20, 7
    45ac:	50 95       	com	r21
    45ae:	65 2f       	mov	r22, r21
    45b0:	75 2f       	mov	r23, r21
    45b2:	47 30       	cpi	r20, 0x07	; 7
    45b4:	51 05       	cpc	r21, r1
    45b6:	08 f0       	brcs	.+2      	; 0x45ba <setupStep_Fac+0x1a>
    45b8:	9a c0       	rjmp	.+308    	; 0x46ee <setupStep_Fac+0x14e>
    45ba:	fa 01       	movw	r30, r20
    45bc:	e9 57       	subi	r30, 0x79	; 121
    45be:	ff 4f       	sbci	r31, 0xFF	; 255
    45c0:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
		case 0: 	/*mlx90614[LEFT].th += ((incremental-incremental_old_setup) * fac);
							if(mlx90614[LEFT].th < 0)
								mlx90614[LEFT].th = 0;
							eepr_value_changed.mlxL = 1;*/
						break;
		case 1: 	mlx90614[RIGHT].th += ((incremental-incremental_old_setup) * fac);
    45c4:	40 91 58 05 	lds	r20, 0x0558
    45c8:	50 91 59 05 	lds	r21, 0x0559
    45cc:	60 91 5a 05 	lds	r22, 0x055A
    45d0:	70 91 5b 05 	lds	r23, 0x055B
    45d4:	00 91 71 05 	lds	r16, 0x0571
    45d8:	10 91 72 05 	lds	r17, 0x0572
    45dc:	20 91 73 05 	lds	r18, 0x0573
    45e0:	30 91 74 05 	lds	r19, 0x0574
    45e4:	40 1b       	sub	r20, r16
    45e6:	51 0b       	sbc	r21, r17
    45e8:	62 0b       	sbc	r22, r18
    45ea:	73 0b       	sbc	r23, r19
    45ec:	84 9f       	mul	r24, r20
    45ee:	90 01       	movw	r18, r0
    45f0:	85 9f       	mul	r24, r21
    45f2:	30 0d       	add	r19, r0
    45f4:	94 9f       	mul	r25, r20
    45f6:	30 0d       	add	r19, r0
    45f8:	11 24       	eor	r1, r1
    45fa:	80 91 0a 08 	lds	r24, 0x080A
    45fe:	90 91 0b 08 	lds	r25, 0x080B
    4602:	28 0f       	add	r18, r24
    4604:	39 1f       	adc	r19, r25
							if(mlx90614[RIGHT].th < 0)
    4606:	37 fd       	sbrc	r19, 7
    4608:	05 c0       	rjmp	.+10     	; 0x4614 <setupStep_Fac+0x74>
		case 0: 	/*mlx90614[LEFT].th += ((incremental-incremental_old_setup) * fac);
							if(mlx90614[LEFT].th < 0)
								mlx90614[LEFT].th = 0;
							eepr_value_changed.mlxL = 1;*/
						break;
		case 1: 	mlx90614[RIGHT].th += ((incremental-incremental_old_setup) * fac);
    460a:	30 93 0b 08 	sts	0x080B, r19
    460e:	20 93 0a 08 	sts	0x080A, r18
    4612:	04 c0       	rjmp	.+8      	; 0x461c <setupStep_Fac+0x7c>
							if(mlx90614[RIGHT].th < 0)
								mlx90614[RIGHT].th = 0;
    4614:	10 92 0b 08 	sts	0x080B, r1
    4618:	10 92 0a 08 	sts	0x080A, r1
							eepr_value_changed.mlxR = 1;
    461c:	80 91 73 07 	lds	r24, 0x0773
    4620:	82 60       	ori	r24, 0x02	; 2
    4622:	14 c0       	rjmp	.+40     	; 0x464c <setupStep_Fac+0xac>
						break;
		case 2: 	setup = 4;
    4624:	84 e0       	ldi	r24, 0x04	; 4
    4626:	18 c0       	rjmp	.+48     	; 0x4658 <setupStep_Fac+0xb8>
						break;
		case 3:		debug += (incremental-incremental_old_setup);
    4628:	80 91 58 05 	lds	r24, 0x0558
    462c:	90 91 53 05 	lds	r25, 0x0553
    4630:	89 0f       	add	r24, r25
    4632:	90 91 71 05 	lds	r25, 0x0571
    4636:	89 1b       	sub	r24, r25
							if(debug > SETUP_DEBUG_MODE_TOP)
    4638:	83 30       	cpi	r24, 0x03	; 3
    463a:	18 f4       	brcc	.+6      	; 0x4642 <setupStep_Fac+0xa2>
								mlx90614[RIGHT].th = 0;
							eepr_value_changed.mlxR = 1;
						break;
		case 2: 	setup = 4;
						break;
		case 3:		debug += (incremental-incremental_old_setup);
    463c:	80 93 53 05 	sts	0x0553, r24
    4640:	02 c0       	rjmp	.+4      	; 0x4646 <setupStep_Fac+0xa6>
							if(debug > SETUP_DEBUG_MODE_TOP)
								debug = 0;
    4642:	10 92 53 05 	sts	0x0553, r1
							eepr_value_changed.debug = 1;
    4646:	80 91 73 07 	lds	r24, 0x0773
    464a:	88 60       	ori	r24, 0x08	; 8
    464c:	80 93 73 07 	sts	0x0773, r24
						break;
    4650:	64 c0       	rjmp	.+200    	; 0x471a <setupStep_Fac+0x17a>
		case 4: 	setup = 2; //Modus 2
    4652:	82 e0       	ldi	r24, 0x02	; 2
    4654:	01 c0       	rjmp	.+2      	; 0x4658 <setupStep_Fac+0xb8>
						break;
		case 5: 	setup = 3; //Modus 3
    4656:	83 e0       	ldi	r24, 0x03	; 3
    4658:	80 93 54 05 	sts	0x0554, r24
						break;
    465c:	5e c0       	rjmp	.+188    	; 0x471a <setupStep_Fac+0x17a>
		case 6: 	if(eepr_value_changed.mlxL)
    465e:	80 91 73 07 	lds	r24, 0x0773
    4662:	80 ff       	sbrs	r24, 0
    4664:	0d c0       	rjmp	.+26     	; 0x4680 <setupStep_Fac+0xe0>
							{
								eeprom_update_word((uint16_t*)0, mlx90614[LEFT].th);
    4666:	60 91 06 08 	lds	r22, 0x0806
    466a:	70 91 07 08 	lds	r23, 0x0807
    466e:	80 e0       	ldi	r24, 0x00	; 0
    4670:	90 e0       	ldi	r25, 0x00	; 0
    4672:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <__eeupd_word_m2560>
								eepr_value_changed.mlxL = 0;
    4676:	80 91 73 07 	lds	r24, 0x0773
    467a:	8e 7f       	andi	r24, 0xFE	; 254
    467c:	80 93 73 07 	sts	0x0773, r24
							}
							if(eepr_value_changed.mlxR)
    4680:	80 91 73 07 	lds	r24, 0x0773
    4684:	81 ff       	sbrs	r24, 1
    4686:	0d c0       	rjmp	.+26     	; 0x46a2 <setupStep_Fac+0x102>
							{
								eeprom_update_word((uint16_t*)2, mlx90614[RIGHT].th);
    4688:	60 91 0a 08 	lds	r22, 0x080A
    468c:	70 91 0b 08 	lds	r23, 0x080B
    4690:	82 e0       	ldi	r24, 0x02	; 2
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <__eeupd_word_m2560>
								eepr_value_changed.mlxR = 0;
    4698:	80 91 73 07 	lds	r24, 0x0773
    469c:	8d 7f       	andi	r24, 0xFD	; 253
    469e:	80 93 73 07 	sts	0x0773, r24
							/*if(eepr_value_changed.tarry)
							{
								eeprom_update_byte((uint8_t*)4, use_tarry);
								eepr_value_changed.tarry = 0;
							}*/
							if(eepr_value_changed.debug)
    46a2:	80 91 73 07 	lds	r24, 0x0773
    46a6:	83 ff       	sbrs	r24, 3
    46a8:	0b c0       	rjmp	.+22     	; 0x46c0 <setupStep_Fac+0x120>
							{
								eeprom_update_byte((uint8_t*)5, debug);
    46aa:	60 91 53 05 	lds	r22, 0x0553
    46ae:	85 e0       	ldi	r24, 0x05	; 5
    46b0:	90 e0       	ldi	r25, 0x00	; 0
    46b2:	0e 94 51 6c 	call	0xd8a2	; 0xd8a2 <__eeupd_byte_m2560>
								eepr_value_changed.debug = 0;
    46b6:	80 91 73 07 	lds	r24, 0x0773
    46ba:	87 7f       	andi	r24, 0xF7	; 247
    46bc:	80 93 73 07 	sts	0x0773, r24
							}
							if(eepr_value_changed.cam)
    46c0:	80 91 73 07 	lds	r24, 0x0773
    46c4:	84 ff       	sbrs	r24, 4
    46c6:	0d c0       	rjmp	.+26     	; 0x46e2 <setupStep_Fac+0x142>
							{
								eeprom_update_word((uint16_t*)6, tsl_th);
    46c8:	60 91 4e 16 	lds	r22, 0x164E
    46cc:	70 91 4f 16 	lds	r23, 0x164F
    46d0:	86 e0       	ldi	r24, 0x06	; 6
    46d2:	90 e0       	ldi	r25, 0x00	; 0
    46d4:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <__eeupd_word_m2560>
								eepr_value_changed.cam = 0;
    46d8:	80 91 73 07 	lds	r24, 0x0773
    46dc:	8f 7e       	andi	r24, 0xEF	; 239
    46de:	80 93 73 07 	sts	0x0773, r24
								//eeprom_update_word((uint16_t*)10, tsl_th_ground);
								//tsl_th_ground = tsl_th + 30;
								eepr_value_changed.cam_ground = 0;
							}*/
							
							setup = 0;
    46e2:	10 92 54 05 	sts	0x0554, r1
							motor_activate(1); //Activate motor driver
    46e6:	81 e0       	ldi	r24, 0x01	; 1
    46e8:	0e 94 76 5b 	call	0xb6ec	; 0xb6ec <motor_activate>

						break;
    46ec:	16 c0       	rjmp	.+44     	; 0x471a <setupStep_Fac+0x17a>
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.03]:DEFAULT_CASE"));}
    46ee:	80 91 53 05 	lds	r24, 0x0553
    46f2:	82 30       	cpi	r24, 0x02	; 2
    46f4:	78 f0       	brcs	.+30     	; 0x4714 <setupStep_Fac+0x174>
    46f6:	8c e4       	ldi	r24, 0x4C	; 76
    46f8:	9b e1       	ldi	r25, 0x1B	; 27
    46fa:	66 dc       	rcall	.-1844   	; 0x3fc8 <bt_putStr_P>
    46fc:	60 91 47 05 	lds	r22, 0x0547
    4700:	70 91 48 05 	lds	r23, 0x0548
    4704:	80 91 49 05 	lds	r24, 0x0549
    4708:	90 91 4a 05 	lds	r25, 0x054A
    470c:	6f dc       	rcall	.-1826   	; 0x3fec <bt_putLong>
    470e:	86 e1       	ldi	r24, 0x16	; 22
    4710:	9b e1       	ldi	r25, 0x1B	; 27
    4712:	5a dc       	rcall	.-1868   	; 0x3fc8 <bt_putStr_P>
    4714:	81 e0       	ldi	r24, 0x01	; 1
    4716:	80 93 63 05 	sts	0x0563, r24
							fatal_err = 1;
    471a:	1f 91       	pop	r17
    471c:	0f 91       	pop	r16
    471e:	08 95       	ret

00004720 <u8g_DrawSetUp>:

///////


void u8g_DrawSetUp(void)
{
    4720:	0f 93       	push	r16
	u8g_SetFont(&u8g, u8g_font_4x6);
    4722:	6f e8       	ldi	r22, 0x8F	; 143
    4724:	74 e1       	ldi	r23, 0x14	; 20
    4726:	8b e1       	ldi	r24, 0x1B	; 27
    4728:	97 e0       	ldi	r25, 0x07	; 7
    472a:	c6 d9       	rcall	.-3188   	; 0x3ab8 <u8g_SetFont>
    472c:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>

	if(get_incrOk() && (timer_incr_entpr == 0) && mot.off)
    4730:	88 23       	and	r24, r24
    4732:	09 f4       	brne	.+2      	; 0x4736 <u8g_DrawSetUp+0x16>
    4734:	47 c0       	rjmp	.+142    	; 0x47c4 <u8g_DrawSetUp+0xa4>
    4736:	80 91 50 05 	lds	r24, 0x0550
    473a:	81 11       	cpse	r24, r1
    473c:	43 c0       	rjmp	.+134    	; 0x47c4 <u8g_DrawSetUp+0xa4>
    473e:	80 91 7f 16 	lds	r24, 0x167F
    4742:	88 23       	and	r24, r24
    4744:	09 f4       	brne	.+2      	; 0x4748 <u8g_DrawSetUp+0x28>
    4746:	3e c0       	rjmp	.+124    	; 0x47c4 <u8g_DrawSetUp+0xa4>
    4748:	80 91 76 05 	lds	r24, 0x0576
	{
		switch(setup_mode)
    474c:	84 30       	cpi	r24, 0x04	; 4
    474e:	3c f4       	brge	.+14     	; 0x475e <u8g_DrawSetUp+0x3e>
    4750:	82 30       	cpi	r24, 0x02	; 2
    4752:	bc f4       	brge	.+46     	; 0x4782 <u8g_DrawSetUp+0x62>
    4754:	88 23       	and	r24, r24
    4756:	99 f1       	breq	.+102    	; 0x47be <u8g_DrawSetUp+0x9e>
    4758:	81 30       	cpi	r24, 0x01	; 1
    475a:	49 f0       	breq	.+18     	; 0x476e <u8g_DrawSetUp+0x4e>
    475c:	1a c0       	rjmp	.+52     	; 0x4792 <u8g_DrawSetUp+0x72>
    475e:	87 30       	cpi	r24, 0x07	; 7
    4760:	c4 f4       	brge	.+48     	; 0x4792 <u8g_DrawSetUp+0x72>
    4762:	80 91 75 05 	lds	r24, 0x0575
								if(setup_step > SETUP_STEP_TOP_BIN)
									setup_step = 0;
							break;
			case 4:
			case 5:
			case 6: 	setup_step ++;
    4766:	8f 5f       	subi	r24, 0xFF	; 255
    4768:	80 93 75 05 	sts	0x0575, r24
    476c:	28 c0       	rjmp	.+80     	; 0x47be <u8g_DrawSetUp+0x9e>
							break;
    476e:	80 91 75 05 	lds	r24, 0x0575
	if(get_incrOk() && (timer_incr_entpr == 0) && mot.off)
	{
		switch(setup_mode)
		{
			case 0: break;
			case 1:		setup_step ++;
    4772:	8f 5f       	subi	r24, 0xFF	; 255
    4774:	80 93 75 05 	sts	0x0575, r24
    4778:	83 30       	cpi	r24, 0x03	; 3
								if(setup_step > SETUP_STEP_TOP_MLX)
    477a:	0c f1       	brlt	.+66     	; 0x47be <u8g_DrawSetUp+0x9e>
    477c:	10 92 75 05 	sts	0x0575, r1
									setup_step = 0;
    4780:	1e c0       	rjmp	.+60     	; 0x47be <u8g_DrawSetUp+0x9e>
    4782:	80 91 75 05 	lds	r24, 0x0575
							break;
			case 2:
			case 3: 	setup_step ++;
    4786:	8f 5f       	subi	r24, 0xFF	; 255
    4788:	80 93 75 05 	sts	0x0575, r24
    478c:	82 30       	cpi	r24, 0x02	; 2
								if(setup_step > SETUP_STEP_TOP_BIN)
    478e:	b4 f7       	brge	.-20     	; 0x477c <u8g_DrawSetUp+0x5c>
    4790:	16 c0       	rjmp	.+44     	; 0x47be <u8g_DrawSetUp+0x9e>
    4792:	80 91 53 05 	lds	r24, 0x0553
							break;
			case 4:
			case 5:
			case 6: 	setup_step ++;
							break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.04]:DEFAULT_CASE"));}
    4796:	82 30       	cpi	r24, 0x02	; 2
    4798:	78 f0       	brcs	.+30     	; 0x47b8 <u8g_DrawSetUp+0x98>
    479a:	83 e1       	ldi	r24, 0x13	; 19
    479c:	9b e1       	ldi	r25, 0x1B	; 27
    479e:	14 dc       	rcall	.-2008   	; 0x3fc8 <bt_putStr_P>
    47a0:	60 91 47 05 	lds	r22, 0x0547
    47a4:	70 91 48 05 	lds	r23, 0x0548
    47a8:	80 91 49 05 	lds	r24, 0x0549
    47ac:	90 91 4a 05 	lds	r25, 0x054A
    47b0:	1d dc       	rcall	.-1990   	; 0x3fec <bt_putLong>
    47b2:	8d ed       	ldi	r24, 0xDD	; 221
    47b4:	9a e1       	ldi	r25, 0x1A	; 26
    47b6:	08 dc       	rcall	.-2032   	; 0x3fc8 <bt_putStr_P>
    47b8:	81 e0       	ldi	r24, 0x01	; 1
    47ba:	80 93 63 05 	sts	0x0563, r24
    47be:	84 e1       	ldi	r24, 0x14	; 20
								fatal_err = 1;
    47c0:	80 93 50 05 	sts	0x0550, r24
    47c4:	80 91 75 05 	lds	r24, 0x0575
		}

		timer_incr_entpr = TIMER_ENTPR_INCR;
    47c8:	82 30       	cpi	r24, 0x02	; 2
    47ca:	09 f1       	breq	.+66     	; 0x480e <u8g_DrawSetUp+0xee>
	}

	switch(setup_step)
    47cc:	3c f4       	brge	.+14     	; 0x47dc <u8g_DrawSetUp+0xbc>
    47ce:	88 23       	and	r24, r24
    47d0:	61 f0       	breq	.+24     	; 0x47ea <u8g_DrawSetUp+0xca>
    47d2:	81 30       	cpi	r24, 0x01	; 1
    47d4:	19 f5       	brne	.+70     	; 0x481c <u8g_DrawSetUp+0xfc>
    47d6:	88 ee       	ldi	r24, 0xE8	; 232
    47d8:	93 e0       	ldi	r25, 0x03	; 3
    47da:	1b c0       	rjmp	.+54     	; 0x4812 <u8g_DrawSetUp+0xf2>
    47dc:	83 30       	cpi	r24, 0x03	; 3
							if(setup_mode > SETUP_MODE_TOP)
								setup_mode = 0;
							else if(setup_mode < 0)
								setup_mode = SETUP_MODE_TOP;
						break;
		case 1:		setupStep_Fac(1000);
    47de:	d9 f0       	breq	.+54     	; 0x4816 <u8g_DrawSetUp+0xf6>
    47e0:	84 30       	cpi	r24, 0x04	; 4
    47e2:	e1 f4       	brne	.+56     	; 0x481c <u8g_DrawSetUp+0xfc>
		}

		timer_incr_entpr = TIMER_ENTPR_INCR;
	}

	switch(setup_step)
    47e4:	81 e0       	ldi	r24, 0x01	; 1
    47e6:	90 e0       	ldi	r25, 0x00	; 0
    47e8:	14 c0       	rjmp	.+40     	; 0x4812 <u8g_DrawSetUp+0xf2>
    47ea:	80 91 58 05 	lds	r24, 0x0558
						break;
		case 2:		setupStep_Fac(100);
						break;
		case 3:		setupStep_Fac(10);
						break;
		case 4:		setupStep_Fac(1);
    47ee:	90 91 76 05 	lds	r25, 0x0576
		timer_incr_entpr = TIMER_ENTPR_INCR;
	}

	switch(setup_step)
	{
		case 0:		setup_mode += (incremental-incremental_old_setup);
    47f2:	89 0f       	add	r24, r25
    47f4:	90 91 71 05 	lds	r25, 0x0571
    47f8:	89 1b       	sub	r24, r25
    47fa:	87 30       	cpi	r24, 0x07	; 7
    47fc:	1c f0       	brlt	.+6      	; 0x4804 <u8g_DrawSetUp+0xe4>
    47fe:	10 92 76 05 	sts	0x0576, r1
							if(setup_mode > SETUP_MODE_TOP)
    4802:	22 c0       	rjmp	.+68     	; 0x4848 <u8g_DrawSetUp+0x128>
    4804:	87 fd       	sbrc	r24, 7
								setup_mode = 0;
    4806:	86 e0       	ldi	r24, 0x06	; 6
    4808:	80 93 76 05 	sts	0x0576, r24
							else if(setup_mode < 0)
    480c:	1d c0       	rjmp	.+58     	; 0x4848 <u8g_DrawSetUp+0x128>
								setup_mode = SETUP_MODE_TOP;
    480e:	84 e6       	ldi	r24, 0x64	; 100
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	c6 de       	rcall	.-628    	; 0x45a0 <setupStep_Fac>
    4814:	19 c0       	rjmp	.+50     	; 0x4848 <u8g_DrawSetUp+0x128>
						break;
		case 1:		setupStep_Fac(1000);
						break;
		case 2:		setupStep_Fac(100);
    4816:	8a e0       	ldi	r24, 0x0A	; 10
    4818:	90 e0       	ldi	r25, 0x00	; 0
    481a:	fb cf       	rjmp	.-10     	; 0x4812 <u8g_DrawSetUp+0xf2>
    481c:	80 91 53 05 	lds	r24, 0x0553
						break;
		case 3:		setupStep_Fac(10);
    4820:	82 30       	cpi	r24, 0x02	; 2
    4822:	78 f0       	brcs	.+30     	; 0x4842 <u8g_DrawSetUp+0x122>
    4824:	8a ed       	ldi	r24, 0xDA	; 218
						break;
		case 4:		setupStep_Fac(1);
						break;
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.05]:DEFAULT_CASE"));}
    4826:	9a e1       	ldi	r25, 0x1A	; 26
    4828:	cf db       	rcall	.-2146   	; 0x3fc8 <bt_putStr_P>
    482a:	60 91 47 05 	lds	r22, 0x0547
    482e:	70 91 48 05 	lds	r23, 0x0548
    4832:	80 91 49 05 	lds	r24, 0x0549
    4836:	90 91 4a 05 	lds	r25, 0x054A
    483a:	d8 db       	rcall	.-2128   	; 0x3fec <bt_putLong>
    483c:	84 ea       	ldi	r24, 0xA4	; 164
    483e:	9a e1       	ldi	r25, 0x1A	; 26
    4840:	c3 db       	rcall	.-2170   	; 0x3fc8 <bt_putStr_P>
    4842:	81 e0       	ldi	r24, 0x01	; 1
    4844:	80 93 63 05 	sts	0x0563, r24
    4848:	80 91 58 05 	lds	r24, 0x0558
    484c:	90 91 59 05 	lds	r25, 0x0559
    4850:	a0 91 5a 05 	lds	r26, 0x055A
							fatal_err = 1;
    4854:	b0 91 5b 05 	lds	r27, 0x055B
	}
	incremental_old_setup = incremental;
    4858:	80 93 71 05 	sts	0x0571, r24
    485c:	90 93 72 05 	sts	0x0572, r25
    4860:	a0 93 73 05 	sts	0x0573, r26
    4864:	b0 93 74 05 	sts	0x0574, r27
    4868:	20 91 76 05 	lds	r18, 0x0576
    486c:	82 2f       	mov	r24, r18
    486e:	99 27       	eor	r25, r25
    4870:	87 fd       	sbrc	r24, 7
    4872:	90 95       	com	r25
    4874:	a9 2f       	mov	r26, r25
    4876:	b9 2f       	mov	r27, r25

	switch(setup_mode)
    4878:	87 30       	cpi	r24, 0x07	; 7
    487a:	91 05       	cpc	r25, r1
    487c:	e0 f4       	brcc	.+56     	; 0x48b6 <u8g_DrawSetUp+0x196>
    487e:	fc 01       	movw	r30, r24
    4880:	e2 57       	subi	r30, 0x72	; 114
    4882:	ff 4f       	sbci	r31, 0xFF	; 255
    4884:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
    4888:	00 e0       	ldi	r16, 0x00	; 0
    488a:	23 e0       	ldi	r18, 0x03	; 3
    488c:	48 e1       	ldi	r20, 0x18	; 24
    488e:	6c e3       	ldi	r22, 0x3C	; 60
    4890:	85 e0       	ldi	r24, 0x05	; 5
    4892:	eb dd       	rcall	.-1066   	; 0x446a <u8g_drawArrow>
    4894:	26 c0       	rjmp	.+76     	; 0x48e2 <u8g_DrawSetUp+0x1c2>
    4896:	47 e0       	ldi	r20, 0x07	; 7
	{
		case 0:
		case 1: 	u8g_drawArrow(5, 60, 10+(setup_mode*7), NORTH, 0);
						break;
		case 2:		u8g_drawArrow(5, 60, 10+(setup_mode*7), SOUTH, 0);
    4898:	24 9f       	mul	r18, r20
    489a:	40 2d       	mov	r20, r0
    489c:	11 24       	eor	r1, r1
    489e:	46 5f       	subi	r20, 0xF6	; 246
    48a0:	00 e0       	ldi	r16, 0x00	; 0
    48a2:	21 e0       	ldi	r18, 0x01	; 1
    48a4:	f4 cf       	rjmp	.-24     	; 0x488e <u8g_DrawSetUp+0x16e>
				break;
    48a6:	47 e0       	ldi	r20, 0x07	; 7
		case 3:
		case 6: 	u8g_drawArrow(5, 60, 10+(setup_mode*7), NORTH, 0);
    48a8:	24 9f       	mul	r18, r20
    48aa:	40 2d       	mov	r20, r0
    48ac:	11 24       	eor	r1, r1
    48ae:	46 5f       	subi	r20, 0xF6	; 246
    48b0:	00 e0       	ldi	r16, 0x00	; 0
    48b2:	23 e0       	ldi	r18, 0x03	; 3
    48b4:	ec cf       	rjmp	.-40     	; 0x488e <u8g_DrawSetUp+0x16e>
    48b6:	80 91 53 05 	lds	r24, 0x0553
						break;
		case 4:
		case 5: 	u8g_drawArrow(5, 60, 10+(setup_mode*7), SOUTH, 0);
    48ba:	82 30       	cpi	r24, 0x02	; 2
    48bc:	78 f0       	brcs	.+30     	; 0x48dc <u8g_DrawSetUp+0x1bc>
    48be:	81 ea       	ldi	r24, 0xA1	; 161
    48c0:	9a e1       	ldi	r25, 0x1A	; 26
    48c2:	82 db       	rcall	.-2300   	; 0x3fc8 <bt_putStr_P>
    48c4:	60 91 47 05 	lds	r22, 0x0547
						break;
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[disp.06]:DEFAULT_CASE"));}
    48c8:	70 91 48 05 	lds	r23, 0x0548
    48cc:	80 91 49 05 	lds	r24, 0x0549
    48d0:	90 91 4a 05 	lds	r25, 0x054A
    48d4:	8b db       	rcall	.-2282   	; 0x3fec <bt_putLong>
    48d6:	8b e6       	ldi	r24, 0x6B	; 107
    48d8:	9a e1       	ldi	r25, 0x1A	; 26
    48da:	76 db       	rcall	.-2324   	; 0x3fc8 <bt_putStr_P>
    48dc:	81 e0       	ldi	r24, 0x01	; 1
    48de:	80 93 63 05 	sts	0x0563, r24
    48e2:	2e e6       	ldi	r18, 0x6E	; 110
    48e4:	33 e0       	ldi	r19, 0x03	; 3
    48e6:	44 e1       	ldi	r20, 0x14	; 20
    48e8:	60 e0       	ldi	r22, 0x00	; 0
    48ea:	8b e1       	ldi	r24, 0x1B	; 27
    48ec:	97 e0       	ldi	r25, 0x07	; 7
    48ee:	5f d8       	rcall	.-3906   	; 0x39ae <u8g_DrawStr>
    48f0:	81 e0       	ldi	r24, 0x01	; 1
    48f2:	0e 94 46 63 	call	0xc68c	; 0xc68c <victim_BufGetMaxDiff>
							fatal_err = 1;
    48f6:	9c 01       	movw	r18, r24
    48f8:	44 27       	eor	r20, r20
	}

	//u8g_DrawStr(&u8g,		0, 	13, "IR left:");	u8g_DrawLong(35,	13, mlx90614[LEFT].is);	u8g_DrawLong(65,	13, mlx90614[LEFT].th);
	u8g_DrawStr(&u8g, 	0, 20, "IR:"); u8g_DrawLong(35, 20,victim_BufGetMaxDiff(RIGHT));		u8g_DrawLong(65, 20, mlx90614[RIGHT].th);
    48fa:	37 fd       	sbrc	r19, 7
    48fc:	40 95       	com	r20
    48fe:	54 2f       	mov	r21, r20
    4900:	64 e1       	ldi	r22, 0x14	; 20
    4902:	83 e2       	ldi	r24, 0x23	; 35
    4904:	87 db       	rcall	.-2290   	; 0x4014 <u8g_DrawLong>
    4906:	20 91 0a 08 	lds	r18, 0x080A
    490a:	30 91 0b 08 	lds	r19, 0x080B
    490e:	44 27       	eor	r20, r20
    4910:	37 fd       	sbrc	r19, 7
    4912:	40 95       	com	r20
    4914:	54 2f       	mov	r21, r20
    4916:	64 e1       	ldi	r22, 0x14	; 20
    4918:	81 e4       	ldi	r24, 0x41	; 65
    491a:	7c db       	rcall	.-2312   	; 0x4014 <u8g_DrawLong>
    491c:	22 e7       	ldi	r18, 0x72	; 114
    491e:	33 e0       	ldi	r19, 0x03	; 3
    4920:	4b e1       	ldi	r20, 0x1B	; 27
    4922:	60 e0       	ldi	r22, 0x00	; 0
    4924:	8b e1       	ldi	r24, 0x1B	; 27
    4926:	97 e0       	ldi	r25, 0x07	; 7
    4928:	42 d8       	rcall	.-3964   	; 0x39ae <u8g_DrawStr>
    492a:	29 e7       	ldi	r18, 0x79	; 121
    492c:	33 e0       	ldi	r19, 0x03	; 3
    492e:	42 e2       	ldi	r20, 0x22	; 34
    4930:	60 e0       	ldi	r22, 0x00	; 0
    4932:	8b e1       	ldi	r24, 0x1B	; 27
    4934:	97 e0       	ldi	r25, 0x07	; 7
    4936:	3b d8       	rcall	.-3978   	; 0x39ae <u8g_DrawStr>
    4938:	20 91 53 05 	lds	r18, 0x0553
	u8g_DrawStr(&u8g, 0, 	27, "Victim");
    493c:	30 e0       	ldi	r19, 0x00	; 0
    493e:	40 e0       	ldi	r20, 0x00	; 0
    4940:	50 e0       	ldi	r21, 0x00	; 0
    4942:	62 e2       	ldi	r22, 0x22	; 34
    4944:	81 e4       	ldi	r24, 0x41	; 65
    4946:	66 db       	rcall	.-2356   	; 0x4014 <u8g_DrawLong>
    4948:	20 e8       	ldi	r18, 0x80	; 128
	u8g_DrawStr(&u8g, 0, 	34, "Debug:"); u8g_DrawLong(65,	34, debug);
    494a:	33 e0       	ldi	r19, 0x03	; 3
    494c:	49 e2       	ldi	r20, 0x29	; 41
    494e:	60 e0       	ldi	r22, 0x00	; 0
    4950:	8b e1       	ldi	r24, 0x1B	; 27
    4952:	97 e0       	ldi	r25, 0x07	; 7
    4954:	2c d8       	rcall	.-4008   	; 0x39ae <u8g_DrawStr>
    4956:	25 e8       	ldi	r18, 0x85	; 133
    4958:	33 e0       	ldi	r19, 0x03	; 3
    495a:	40 e3       	ldi	r20, 0x30	; 48
    495c:	60 e0       	ldi	r22, 0x00	; 0
    495e:	8b e1       	ldi	r24, 0x1B	; 27
    4960:	97 e0       	ldi	r25, 0x07	; 7
    4962:	25 d8       	rcall	.-4022   	; 0x39ae <u8g_DrawStr>
    4964:	29 e1       	ldi	r18, 0x19	; 25
    4966:	34 e0       	ldi	r19, 0x04	; 4
    4968:	47 e3       	ldi	r20, 0x37	; 55
    496a:	61 e4       	ldi	r22, 0x41	; 65
	u8g_DrawStr(&u8g, 0, 	41, "View");
    496c:	8b e1       	ldi	r24, 0x1B	; 27
    496e:	97 e0       	ldi	r25, 0x07	; 7
    4970:	1e d8       	rcall	.-4036   	; 0x39ae <u8g_DrawStr>
    4972:	0f 91       	pop	r16
    4974:	08 95       	ret

00004976 <u8g_DrawView>:
	u8g_DrawStr(&u8g, 65, 	55, "ok");
}

/////////////////////////////
void u8g_DrawView(void)
{
    4976:	0f 93       	push	r16
    4978:	cf 93       	push	r28
    497a:	df 93       	push	r29
	if(get_incrOk() && (timer_incr_entpr == 0))
    497c:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>
    4980:	88 23       	and	r24, r24
    4982:	61 f0       	breq	.+24     	; 0x499c <u8g_DrawView+0x26>
    4984:	80 91 50 05 	lds	r24, 0x0550
    4988:	81 11       	cpse	r24, r1
    498a:	08 c0       	rjmp	.+16     	; 0x499c <u8g_DrawView+0x26>
	{
		setup = 1;
    498c:	81 e0       	ldi	r24, 0x01	; 1
    498e:	80 93 54 05 	sts	0x0554, r24
		setup_step = 0;
    4992:	10 92 75 05 	sts	0x0575, r1

		timer_incr_entpr = TIMER_ENTPR_INCR;
    4996:	84 e1       	ldi	r24, 0x14	; 20
    4998:	80 93 50 05 	sts	0x0550, r24
	}

	u8g_SetFont(&u8g, u8g_font_4x6);
    499c:	6f e8       	ldi	r22, 0x8F	; 143
    499e:	74 e1       	ldi	r23, 0x14	; 20
    49a0:	8b e1       	ldi	r24, 0x1B	; 27
    49a2:	97 e0       	ldi	r25, 0x07	; 7
    49a4:	89 d8       	rcall	.-3822   	; 0x3ab8 <u8g_SetFont>
    49a6:	0b e0       	ldi	r16, 0x0B	; 11

	int16_t sensorvar = 0;
	
	u8g_DrawFrame(&u8g, 59, 27, 11, 11); //Roboter
    49a8:	2b e0       	ldi	r18, 0x0B	; 11
    49aa:	4b e1       	ldi	r20, 0x1B	; 27
    49ac:	6b e3       	ldi	r22, 0x3B	; 59
    49ae:	8b e1       	ldi	r24, 0x1B	; 27
    49b0:	97 e0       	ldi	r25, 0x07	; 7
    49b2:	9b da       	rcall	.-2762   	; 0x3eea <u8g_DrawFrame>
    49b4:	80 91 0c 17 	lds	r24, 0x170C
	if(um6.psi > 0 && um6.psi <= 90)
    49b8:	90 91 0d 17 	lds	r25, 0x170D
    49bc:	9c 01       	movw	r18, r24
    49be:	21 50       	subi	r18, 0x01	; 1
    49c0:	31 09       	sbc	r19, r1
    49c2:	2a 35       	cpi	r18, 0x5A	; 90
    49c4:	31 05       	cpc	r19, r1
    49c6:	18 f4       	brcc	.+6      	; 0x49ce <u8g_DrawView+0x58>
    49c8:	00 e0       	ldi	r16, 0x00	; 0
    49ca:	21 e0       	ldi	r18, 0x01	; 1
		u8g_drawArrow(7, 64, 32, NORTH, 0);
    49cc:	12 c0       	rjmp	.+36     	; 0x49f2 <u8g_DrawView+0x7c>
    49ce:	9c 01       	movw	r18, r24
    49d0:	2b 55       	subi	r18, 0x5B	; 91
	else if(um6.psi > 90 && um6.psi <= 180)
    49d2:	31 09       	sbc	r19, r1
    49d4:	2a 35       	cpi	r18, 0x5A	; 90
    49d6:	31 05       	cpc	r19, r1
    49d8:	18 f4       	brcc	.+6      	; 0x49e0 <u8g_DrawView+0x6a>
    49da:	00 e0       	ldi	r16, 0x00	; 0
    49dc:	24 e0       	ldi	r18, 0x04	; 4
		u8g_drawArrow(7, 64, 32, WEST, 0);
    49de:	09 c0       	rjmp	.+18     	; 0x49f2 <u8g_DrawView+0x7c>
    49e0:	85 5b       	subi	r24, 0xB5	; 181
    49e2:	91 09       	sbc	r25, r1
	else if(um6.psi > 180 && um6.psi <= 270)
    49e4:	00 e0       	ldi	r16, 0x00	; 0
    49e6:	8a 35       	cpi	r24, 0x5A	; 90
		u8g_drawArrow(7, 64, 32, SOUTH, 0);
    49e8:	91 05       	cpc	r25, r1
	u8g_DrawFrame(&u8g, 59, 27, 11, 11); //Roboter
	if(um6.psi > 0 && um6.psi <= 90)
		u8g_drawArrow(7, 64, 32, NORTH, 0);
	else if(um6.psi > 90 && um6.psi <= 180)
		u8g_drawArrow(7, 64, 32, WEST, 0);
	else if(um6.psi > 180 && um6.psi <= 270)
    49ea:	10 f4       	brcc	.+4      	; 0x49f0 <u8g_DrawView+0x7a>
    49ec:	23 e0       	ldi	r18, 0x03	; 3
    49ee:	01 c0       	rjmp	.+2      	; 0x49f2 <u8g_DrawView+0x7c>
		u8g_drawArrow(7, 64, 32, SOUTH, 0);
    49f0:	22 e0       	ldi	r18, 0x02	; 2
    49f2:	40 e2       	ldi	r20, 0x20	; 32
	else
		u8g_drawArrow(7, 64, 32, EAST, 0);
    49f4:	60 e4       	ldi	r22, 0x40	; 64
    49f6:	87 e0       	ldi	r24, 0x07	; 7
    49f8:	38 dd       	rcall	.-1424   	; 0x446a <u8g_drawArrow>
    49fa:	80 91 ae 07 	lds	r24, 0x07AE
    49fe:	90 91 af 07 	lds	r25, 0x07AF

	sensorvar = dist[LIN][RIGHT][FRONT] / 18;
    4a02:	c2 e1       	ldi	r28, 0x12	; 18
    4a04:	d0 e0       	ldi	r29, 0x00	; 0
    4a06:	be 01       	movw	r22, r28
    4a08:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4a0c:	26 2f       	mov	r18, r22
    4a0e:	4c e1       	ldi	r20, 0x1C	; 28
    4a10:	67 e4       	ldi	r22, 0x47	; 71
    4a12:	8b e1       	ldi	r24, 0x1B	; 27
	u8g_DrawHLine(&u8g, 71, 28, sensorvar);
    4a14:	97 e0       	ldi	r25, 0x07	; 7
    4a16:	36 da       	rcall	.-2964   	; 0x3e84 <u8g_DrawHLine>
    4a18:	80 91 b0 07 	lds	r24, 0x07B0
    4a1c:	90 91 b1 07 	lds	r25, 0x07B1
	sensorvar = dist[LIN][RIGHT][BACK] / 18;
    4a20:	be 01       	movw	r22, r28
    4a22:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4a26:	26 2f       	mov	r18, r22
    4a28:	44 e2       	ldi	r20, 0x24	; 36
    4a2a:	67 e4       	ldi	r22, 0x47	; 71
    4a2c:	8b e1       	ldi	r24, 0x1B	; 27
    4a2e:	97 e0       	ldi	r25, 0x07	; 7
	u8g_DrawHLine(&u8g, 71, 36, sensorvar);
    4a30:	29 da       	rcall	.-2990   	; 0x3e84 <u8g_DrawHLine>
    4a32:	80 91 bc 07 	lds	r24, 0x07BC
    4a36:	90 91 bd 07 	lds	r25, 0x07BD
    4a3a:	be 01       	movw	r22, r28

	sensorvar = (dist[LIN][BACK][RIGHT]/18);
    4a3c:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4a40:	26 2f       	mov	r18, r22
    4a42:	47 e2       	ldi	r20, 0x27	; 39
    4a44:	64 e4       	ldi	r22, 0x44	; 68
    4a46:	8b e1       	ldi	r24, 0x1B	; 27
    4a48:	97 e0       	ldi	r25, 0x07	; 7
    4a4a:	35 da       	rcall	.-2966   	; 0x3eb6 <u8g_DrawVLine>
	u8g_DrawVLine(&u8g, 68, 39, sensorvar);
    4a4c:	80 91 c0 07 	lds	r24, 0x07C0
    4a50:	90 91 c1 07 	lds	r25, 0x07C1
    4a54:	6e e1       	ldi	r22, 0x1E	; 30
    4a56:	70 e0       	ldi	r23, 0x00	; 0
	sensorvar = (dist[LIN][BACK][BACK]/30);
    4a58:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4a5c:	26 2f       	mov	r18, r22
    4a5e:	47 e2       	ldi	r20, 0x27	; 39
    4a60:	60 e4       	ldi	r22, 0x40	; 64
    4a62:	8b e1       	ldi	r24, 0x1B	; 27
    4a64:	97 e0       	ldi	r25, 0x07	; 7
    4a66:	27 da       	rcall	.-2994   	; 0x3eb6 <u8g_DrawVLine>
    4a68:	80 91 ba 07 	lds	r24, 0x07BA
	u8g_DrawVLine(&u8g, 64, 39, sensorvar);
    4a6c:	90 91 bb 07 	lds	r25, 0x07BB
    4a70:	be 01       	movw	r22, r28
    4a72:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
	sensorvar = (dist[LIN][BACK][LEFT]/18);
    4a76:	26 2f       	mov	r18, r22
    4a78:	47 e2       	ldi	r20, 0x27	; 39
    4a7a:	6c e3       	ldi	r22, 0x3C	; 60
    4a7c:	8b e1       	ldi	r24, 0x1B	; 27
    4a7e:	97 e0       	ldi	r25, 0x07	; 7
    4a80:	1a da       	rcall	.-3020   	; 0x3eb6 <u8g_DrawVLine>
    4a82:	80 91 a6 07 	lds	r24, 0x07A6
	u8g_DrawVLine(&u8g, 60, 39, sensorvar);
    4a86:	90 91 a7 07 	lds	r25, 0x07A7
    4a8a:	ce ee       	ldi	r28, 0xEE	; 238
    4a8c:	df ef       	ldi	r29, 0xFF	; 255
    4a8e:	be 01       	movw	r22, r28
    4a90:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>

	sensorvar = 57 - (dist[LIN][LEFT][FRONT] / 18);
    4a94:	67 5c       	subi	r22, 0xC7	; 199
    4a96:	7f 4f       	sbci	r23, 0xFF	; 255
    4a98:	0c e1       	ldi	r16, 0x1C	; 28
    4a9a:	26 2f       	mov	r18, r22
    4a9c:	4c e1       	ldi	r20, 0x1C	; 28
    4a9e:	69 e3       	ldi	r22, 0x39	; 57
    4aa0:	8b e1       	ldi	r24, 0x1B	; 27
    4aa2:	97 e0       	ldi	r25, 0x07	; 7
    4aa4:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
	u8g_DrawLine(&u8g, 57, 28, sensorvar, 28);
    4aa8:	80 91 a8 07 	lds	r24, 0x07A8
    4aac:	90 91 a9 07 	lds	r25, 0x07A9
    4ab0:	be 01       	movw	r22, r28
    4ab2:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4ab6:	67 5c       	subi	r22, 0xC7	; 199
	sensorvar = 57 - (dist[LIN][LEFT][BACK] / 18);
    4ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    4aba:	04 e2       	ldi	r16, 0x24	; 36
    4abc:	26 2f       	mov	r18, r22
    4abe:	44 e2       	ldi	r20, 0x24	; 36
    4ac0:	69 e3       	ldi	r22, 0x39	; 57
    4ac2:	8b e1       	ldi	r24, 0x1B	; 27
    4ac4:	97 e0       	ldi	r25, 0x07	; 7
    4ac6:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
	u8g_DrawLine(&u8g, 57, 36, sensorvar, 36);
    4aca:	80 91 b2 07 	lds	r24, 0x07B2
    4ace:	90 91 b3 07 	lds	r25, 0x07B3
    4ad2:	be 01       	movw	r22, r28
    4ad4:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4ad8:	67 5e       	subi	r22, 0xE7	; 231

	sensorvar = 25 - (dist[LIN][FRONT][LEFT] / 18);
    4ada:	7f 4f       	sbci	r23, 0xFF	; 255
    4adc:	06 2f       	mov	r16, r22
    4ade:	2c e3       	ldi	r18, 0x3C	; 60
    4ae0:	49 e1       	ldi	r20, 0x19	; 25
    4ae2:	6c e3       	ldi	r22, 0x3C	; 60
    4ae4:	8b e1       	ldi	r24, 0x1B	; 27
    4ae6:	97 e0       	ldi	r25, 0x07	; 7
    4ae8:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
	u8g_DrawLine(&u8g, 60, 25, 60, sensorvar);
    4aec:	80 91 b6 07 	lds	r24, 0x07B6
    4af0:	90 91 b7 07 	lds	r25, 0x07B7
    4af4:	62 ee       	ldi	r22, 0xE2	; 226
    4af6:	7f ef       	ldi	r23, 0xFF	; 255
    4af8:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
	sensorvar = 25 - (dist[LIN][FRONT][FRONT] / 30);
    4afc:	67 5e       	subi	r22, 0xE7	; 231
    4afe:	7f 4f       	sbci	r23, 0xFF	; 255
    4b00:	06 2f       	mov	r16, r22
    4b02:	20 e4       	ldi	r18, 0x40	; 64
    4b04:	49 e1       	ldi	r20, 0x19	; 25
    4b06:	60 e4       	ldi	r22, 0x40	; 64
    4b08:	8b e1       	ldi	r24, 0x1B	; 27
    4b0a:	97 e0       	ldi	r25, 0x07	; 7
    4b0c:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
	u8g_DrawLine(&u8g, 64, 25, 64, sensorvar);
    4b10:	80 91 b4 07 	lds	r24, 0x07B4
    4b14:	90 91 b5 07 	lds	r25, 0x07B5
    4b18:	be 01       	movw	r22, r28
    4b1a:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4b1e:	67 5e       	subi	r22, 0xE7	; 231
	sensorvar = 25 - (dist[LIN][FRONT][RIGHT] / 18);
    4b20:	7f 4f       	sbci	r23, 0xFF	; 255
    4b22:	06 2f       	mov	r16, r22
    4b24:	24 e4       	ldi	r18, 0x44	; 68
    4b26:	49 e1       	ldi	r20, 0x19	; 25
    4b28:	64 e4       	ldi	r22, 0x44	; 68
    4b2a:	8b e1       	ldi	r24, 0x1B	; 27
    4b2c:	97 e0       	ldi	r25, 0x07	; 7
    4b2e:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
	u8g_DrawLine(&u8g, 68, 25, 68, sensorvar);
    4b32:	20 91 b2 07 	lds	r18, 0x07B2
    4b36:	30 91 b3 07 	lds	r19, 0x07B3
    4b3a:	44 27       	eor	r20, r20
    4b3c:	37 fd       	sbrc	r19, 7
    4b3e:	40 95       	com	r20
    4b40:	54 2f       	mov	r21, r20



	u8g_DrawLong(75,	13, dist[LIN][FRONT][LEFT]);
    4b42:	6d e0       	ldi	r22, 0x0D	; 13
    4b44:	8b e4       	ldi	r24, 0x4B	; 75
    4b46:	66 da       	rcall	.-2868   	; 0x4014 <u8g_DrawLong>
    4b48:	20 91 b6 07 	lds	r18, 0x07B6
    4b4c:	30 91 b7 07 	lds	r19, 0x07B7
    4b50:	44 27       	eor	r20, r20
    4b52:	37 fd       	sbrc	r19, 7
    4b54:	40 95       	com	r20
    4b56:	54 2f       	mov	r21, r20
    4b58:	64 e1       	ldi	r22, 0x14	; 20
	u8g_DrawLong(75,	20, dist[LIN][FRONT][FRONT]);
    4b5a:	8b e4       	ldi	r24, 0x4B	; 75
    4b5c:	5b da       	rcall	.-2890   	; 0x4014 <u8g_DrawLong>
    4b5e:	20 91 b4 07 	lds	r18, 0x07B4
    4b62:	30 91 b5 07 	lds	r19, 0x07B5
    4b66:	44 27       	eor	r20, r20
    4b68:	37 fd       	sbrc	r19, 7
    4b6a:	40 95       	com	r20
    4b6c:	54 2f       	mov	r21, r20
    4b6e:	6b e1       	ldi	r22, 0x1B	; 27
    4b70:	8b e4       	ldi	r24, 0x4B	; 75
	u8g_DrawLong(75,	27, dist[LIN][FRONT][RIGHT]);
    4b72:	50 da       	rcall	.-2912   	; 0x4014 <u8g_DrawLong>
    4b74:	0a e0       	ldi	r16, 0x0A	; 10
    4b76:	2a e6       	ldi	r18, 0x6A	; 106
    4b78:	44 e1       	ldi	r20, 0x14	; 20
    4b7a:	6a e5       	ldi	r22, 0x5A	; 90
    4b7c:	8b e1       	ldi	r24, 0x1B	; 27
    4b7e:	97 e0       	ldi	r25, 0x07	; 7
    4b80:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
    4b84:	20 91 ae 07 	lds	r18, 0x07AE
    4b88:	30 91 af 07 	lds	r19, 0x07AF

	u8g_DrawLine(&u8g, 90, 20, 106, 10);
    4b8c:	44 27       	eor	r20, r20
    4b8e:	37 fd       	sbrc	r19, 7
    4b90:	40 95       	com	r20
    4b92:	54 2f       	mov	r21, r20
    4b94:	6d e0       	ldi	r22, 0x0D	; 13
    4b96:	8e e6       	ldi	r24, 0x6E	; 110
    4b98:	3d da       	rcall	.-2950   	; 0x4014 <u8g_DrawLong>

	u8g_DrawLong(110,	13, dist[LIN][RIGHT][FRONT]);
    4b9a:	20 91 aa 07 	lds	r18, 0x07AA
    4b9e:	30 91 ab 07 	lds	r19, 0x07AB
    4ba2:	44 27       	eor	r20, r20
    4ba4:	37 fd       	sbrc	r19, 7
    4ba6:	40 95       	com	r20
    4ba8:	54 2f       	mov	r21, r20
    4baa:	64 e1       	ldi	r22, 0x14	; 20
    4bac:	8e e6       	ldi	r24, 0x6E	; 110
    4bae:	32 da       	rcall	.-2972   	; 0x4014 <u8g_DrawLong>
    4bb0:	20 91 b0 07 	lds	r18, 0x07B0
	u8g_DrawLong(110,	20, dist[LIN][RIGHT][LEFT]);
    4bb4:	30 91 b1 07 	lds	r19, 0x07B1
    4bb8:	44 27       	eor	r20, r20
    4bba:	37 fd       	sbrc	r19, 7
    4bbc:	40 95       	com	r20
    4bbe:	54 2f       	mov	r21, r20
    4bc0:	6b e1       	ldi	r22, 0x1B	; 27
    4bc2:	8e e6       	ldi	r24, 0x6E	; 110
    4bc4:	27 da       	rcall	.-2994   	; 0x4014 <u8g_DrawLong>
    4bc6:	20 91 a6 07 	lds	r18, 0x07A6
	u8g_DrawLong(110,	27, dist[LIN][RIGHT][BACK]);
    4bca:	30 91 a7 07 	lds	r19, 0x07A7
    4bce:	44 27       	eor	r20, r20
    4bd0:	37 fd       	sbrc	r19, 7
    4bd2:	40 95       	com	r20
    4bd4:	54 2f       	mov	r21, r20
    4bd6:	60 e3       	ldi	r22, 0x30	; 48
    4bd8:	88 e0       	ldi	r24, 0x08	; 8
    4bda:	1c da       	rcall	.-3016   	; 0x4014 <u8g_DrawLong>
    4bdc:	20 91 a2 07 	lds	r18, 0x07A2
    4be0:	30 91 a3 07 	lds	r19, 0x07A3

	u8g_DrawLong(8,	48, dist[LIN][LEFT][FRONT]);
    4be4:	44 27       	eor	r20, r20
    4be6:	37 fd       	sbrc	r19, 7
    4be8:	40 95       	com	r20
    4bea:	54 2f       	mov	r21, r20
    4bec:	67 e3       	ldi	r22, 0x37	; 55
    4bee:	88 e0       	ldi	r24, 0x08	; 8
    4bf0:	11 da       	rcall	.-3038   	; 0x4014 <u8g_DrawLong>
    4bf2:	20 91 a8 07 	lds	r18, 0x07A8
    4bf6:	30 91 a9 07 	lds	r19, 0x07A9
	u8g_DrawLong(8,	55, dist[LIN][LEFT][LEFT]);
    4bfa:	44 27       	eor	r20, r20
    4bfc:	37 fd       	sbrc	r19, 7
    4bfe:	40 95       	com	r20
    4c00:	54 2f       	mov	r21, r20
    4c02:	6e e3       	ldi	r22, 0x3E	; 62
    4c04:	88 e0       	ldi	r24, 0x08	; 8
    4c06:	06 da       	rcall	.-3060   	; 0x4014 <u8g_DrawLong>
    4c08:	02 e3       	ldi	r16, 0x32	; 50
    4c0a:	24 e2       	ldi	r18, 0x24	; 36
    4c0c:	4c e3       	ldi	r20, 0x3C	; 60
    4c0e:	64 e1       	ldi	r22, 0x14	; 20
    4c10:	8b e1       	ldi	r24, 0x1B	; 27
	u8g_DrawLong(8,	62, dist[LIN][LEFT][BACK]);
    4c12:	97 e0       	ldi	r25, 0x07	; 7
    4c14:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
    4c18:	20 91 ba 07 	lds	r18, 0x07BA
    4c1c:	30 91 bb 07 	lds	r19, 0x07BB
    4c20:	44 27       	eor	r20, r20
    4c22:	37 fd       	sbrc	r19, 7
    4c24:	40 95       	com	r20
    4c26:	54 2f       	mov	r21, r20
    4c28:	60 e3       	ldi	r22, 0x30	; 48

	u8g_DrawLine(&u8g, 20, 60, 36, 50);
    4c2a:	8b e2       	ldi	r24, 0x2B	; 43
    4c2c:	f3 d9       	rcall	.-3098   	; 0x4014 <u8g_DrawLong>
    4c2e:	20 91 c0 07 	lds	r18, 0x07C0
    4c32:	30 91 c1 07 	lds	r19, 0x07C1
    4c36:	44 27       	eor	r20, r20
    4c38:	37 fd       	sbrc	r19, 7

	u8g_DrawLong(43,	48, dist[LIN][BACK][LEFT]);
    4c3a:	40 95       	com	r20
    4c3c:	54 2f       	mov	r21, r20
    4c3e:	67 e3       	ldi	r22, 0x37	; 55
    4c40:	8b e2       	ldi	r24, 0x2B	; 43
    4c42:	e8 d9       	rcall	.-3120   	; 0x4014 <u8g_DrawLong>
    4c44:	20 91 bc 07 	lds	r18, 0x07BC
    4c48:	30 91 bd 07 	lds	r19, 0x07BD
    4c4c:	44 27       	eor	r20, r20
    4c4e:	37 fd       	sbrc	r19, 7
    4c50:	40 95       	com	r20
	u8g_DrawLong(43,	55, dist[LIN][BACK][BACK]);
    4c52:	54 2f       	mov	r21, r20
    4c54:	6e e3       	ldi	r22, 0x3E	; 62
    4c56:	8b e2       	ldi	r24, 0x2B	; 43
    4c58:	dd d9       	rcall	.-3142   	; 0x4014 <u8g_DrawLong>
    4c5a:	2c e8       	ldi	r18, 0x8C	; 140
    4c5c:	33 e0       	ldi	r19, 0x03	; 3
    4c5e:	4d e0       	ldi	r20, 0x0D	; 13
    4c60:	60 e0       	ldi	r22, 0x00	; 0
    4c62:	8b e1       	ldi	r24, 0x1B	; 27
    4c64:	97 e0       	ldi	r25, 0x07	; 7
    4c66:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
	u8g_DrawLong(43,	62, dist[LIN][BACK][RIGHT]);
    4c6a:	21 e9       	ldi	r18, 0x91	; 145
    4c6c:	33 e0       	ldi	r19, 0x03	; 3
    4c6e:	4d e0       	ldi	r20, 0x0D	; 13
    4c70:	61 e1       	ldi	r22, 0x11	; 17
    4c72:	8b e1       	ldi	r24, 0x1B	; 27
    4c74:	97 e0       	ldi	r25, 0x07	; 7
    4c76:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4c7a:	20 91 02 17 	lds	r18, 0x1702
    4c7e:	30 91 03 17 	lds	r19, 0x1703

	u8g_DrawStr(&u8g,		0, 	13, "UM6:");
    4c82:	44 27       	eor	r20, r20
    4c84:	37 fd       	sbrc	r19, 7
    4c86:	40 95       	com	r20
    4c88:	54 2f       	mov	r21, r20
    4c8a:	6d e0       	ldi	r22, 0x0D	; 13
    4c8c:	89 e1       	ldi	r24, 0x19	; 25
    4c8e:	c2 d9       	rcall	.-3196   	; 0x4014 <u8g_DrawLong>
    4c90:	24 e9       	ldi	r18, 0x94	; 148
	u8g_DrawStr(&u8g,		17, 	13, "x:"); u8g_DrawLong(25,	13, um6.phi);
    4c92:	33 e0       	ldi	r19, 0x03	; 3
    4c94:	44 e1       	ldi	r20, 0x14	; 20
    4c96:	61 e1       	ldi	r22, 0x11	; 17
    4c98:	8b e1       	ldi	r24, 0x1B	; 27
    4c9a:	97 e0       	ldi	r25, 0x07	; 7
    4c9c:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4ca0:	20 91 08 17 	lds	r18, 0x1708
    4ca4:	30 91 09 17 	lds	r19, 0x1709
    4ca8:	44 27       	eor	r20, r20
    4caa:	37 fd       	sbrc	r19, 7
    4cac:	40 95       	com	r20
    4cae:	54 2f       	mov	r21, r20
    4cb0:	64 e1       	ldi	r22, 0x14	; 20
    4cb2:	89 e1       	ldi	r24, 0x19	; 25
    4cb4:	af d9       	rcall	.-3234   	; 0x4014 <u8g_DrawLong>
    4cb6:	27 e9       	ldi	r18, 0x97	; 151
    4cb8:	33 e0       	ldi	r19, 0x03	; 3
	u8g_DrawStr(&u8g,		17, 	20, "y:"); u8g_DrawLong(25,	20, um6.theta);
    4cba:	4b e1       	ldi	r20, 0x1B	; 27
    4cbc:	61 e1       	ldi	r22, 0x11	; 17
    4cbe:	8b e1       	ldi	r24, 0x1B	; 27
    4cc0:	97 e0       	ldi	r25, 0x07	; 7
    4cc2:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4cc6:	20 91 0c 17 	lds	r18, 0x170C
    4cca:	30 91 0d 17 	lds	r19, 0x170D
    4cce:	44 27       	eor	r20, r20
    4cd0:	37 fd       	sbrc	r19, 7
    4cd2:	40 95       	com	r20
    4cd4:	54 2f       	mov	r21, r20
    4cd6:	6b e1       	ldi	r22, 0x1B	; 27
    4cd8:	89 e1       	ldi	r24, 0x19	; 25
    4cda:	9c d9       	rcall	.-3272   	; 0x4014 <u8g_DrawLong>
    4cdc:	2a e9       	ldi	r18, 0x9A	; 154
    4cde:	33 e0       	ldi	r19, 0x03	; 3
    4ce0:	40 e3       	ldi	r20, 0x30	; 48
	u8g_DrawStr(&u8g,		17, 	27, "z:"); u8g_DrawLong(25,	27, um6.psi);
    4ce2:	6b e4       	ldi	r22, 0x4B	; 75
    4ce4:	8b e1       	ldi	r24, 0x1B	; 27
    4ce6:	97 e0       	ldi	r25, 0x07	; 7
    4ce8:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4cec:	26 ed       	ldi	r18, 0xD6	; 214
    4cee:	33 e0       	ldi	r19, 0x03	; 3
    4cf0:	40 e3       	ldi	r20, 0x30	; 48
    4cf2:	6f e5       	ldi	r22, 0x5F	; 95
    4cf4:	8b e1       	ldi	r24, 0x1B	; 27
    4cf6:	97 e0       	ldi	r25, 0x07	; 7
    4cf8:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4cfc:	20 91 04 08 	lds	r18, 0x0804
    4d00:	30 91 05 08 	lds	r19, 0x0805
    4d04:	44 27       	eor	r20, r20
    4d06:	37 fd       	sbrc	r19, 7
    4d08:	40 95       	com	r20

	u8g_DrawStr(&u8g,		75, 	48, "Temp:");
    4d0a:	54 2f       	mov	r21, r20
    4d0c:	60 e3       	ldi	r22, 0x30	; 48
    4d0e:	89 e6       	ldi	r24, 0x69	; 105
    4d10:	81 d9       	rcall	.-3326   	; 0x4014 <u8g_DrawLong>
    4d12:	21 ee       	ldi	r18, 0xE1	; 225
    4d14:	33 e0       	ldi	r19, 0x03	; 3
    4d16:	47 e3       	ldi	r20, 0x37	; 55
    4d18:	6f e5       	ldi	r22, 0x5F	; 95
	u8g_DrawStr(&u8g,		95, 	48, "l:"); u8g_DrawLong(105,	48, mlx90614[LEFT].is);
    4d1a:	8b e1       	ldi	r24, 0x1B	; 27
    4d1c:	97 e0       	ldi	r25, 0x07	; 7
    4d1e:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4d22:	20 91 08 08 	lds	r18, 0x0808
    4d26:	30 91 09 08 	lds	r19, 0x0809
    4d2a:	44 27       	eor	r20, r20
    4d2c:	37 fd       	sbrc	r19, 7
    4d2e:	40 95       	com	r20
    4d30:	54 2f       	mov	r21, r20
    4d32:	67 e3       	ldi	r22, 0x37	; 55
    4d34:	89 e6       	ldi	r24, 0x69	; 105
    4d36:	6e d9       	rcall	.-3364   	; 0x4014 <u8g_DrawLong>
    4d38:	df 91       	pop	r29
    4d3a:	cf 91       	pop	r28
    4d3c:	0f 91       	pop	r16
    4d3e:	08 95       	ret

00004d40 <u8g_DrawCamRaw>:

uint8_t incrOk_pushDuration = 0; //Langer/Kurzer Tastendruck?
uint8_t pushed = 0;

void u8g_DrawCamRaw(void)
{
    4d40:	df 92       	push	r13
    4d42:	ef 92       	push	r14
    4d44:	ff 92       	push	r15
    4d46:	0f 93       	push	r16
    4d48:	1f 93       	push	r17
    4d4a:	cf 93       	push	r28
    4d4c:	df 93       	push	r29
	if(get_incrOk() && (timer_incr_entpr == 0))
    4d4e:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>
    4d52:	88 23       	and	r24, r24
    4d54:	79 f0       	breq	.+30     	; 0x4d74 <u8g_DrawCamRaw+0x34>
    4d56:	80 91 50 05 	lds	r24, 0x0550
    4d5a:	81 11       	cpse	r24, r1
    4d5c:	0b c0       	rjmp	.+22     	; 0x4d74 <u8g_DrawCamRaw+0x34>
	{
		pushed = 1;
    4d5e:	81 e0       	ldi	r24, 0x01	; 1
    4d60:	80 93 69 05 	sts	0x0569, r24
		if(incrOk_pushDuration < 0xff)
    4d64:	80 91 6a 05 	lds	r24, 0x056A
    4d68:	8f 3f       	cpi	r24, 0xFF	; 255
    4d6a:	41 f1       	breq	.+80     	; 0x4dbc <u8g_DrawCamRaw+0x7c>
			incrOk_pushDuration ++;
    4d6c:	8f 5f       	subi	r24, 0xFF	; 255
    4d6e:	80 93 6a 05 	sts	0x056A, r24
    4d72:	24 c0       	rjmp	.+72     	; 0x4dbc <u8g_DrawCamRaw+0x7c>
	}
	else
	{
		if(pushed == 1)
    4d74:	90 91 69 05 	lds	r25, 0x0569
    4d78:	91 30       	cpi	r25, 0x01	; 1
    4d7a:	01 f5       	brne	.+64     	; 0x4dbc <u8g_DrawCamRaw+0x7c>
		{
			if(incrOk_pushDuration < 100)
    4d7c:	80 91 6a 05 	lds	r24, 0x056A
    4d80:	84 36       	cpi	r24, 0x64	; 100
    4d82:	88 f4       	brcc	.+34     	; 0x4da6 <u8g_DrawCamRaw+0x66>
				timer_incr_entpr = TIMER_ENTPR_INCR;
    4d84:	84 e1       	ldi	r24, 0x14	; 20
    4d86:	80 93 50 05 	sts	0x0550, r24
	
			if((incrOk_pushDuration < 100) &&
				 (viewCam_mode == 0))
    4d8a:	80 91 70 05 	lds	r24, 0x0570
		if(pushed == 1)
		{
			if(incrOk_pushDuration < 100)
				timer_incr_entpr = TIMER_ENTPR_INCR;
	
			if((incrOk_pushDuration < 100) &&
    4d8e:	81 11       	cpse	r24, r1
    4d90:	05 c0       	rjmp	.+10     	; 0x4d9c <u8g_DrawCamRaw+0x5c>
				 (viewCam_mode == 0))
			{
				setup = 1;
    4d92:	90 93 54 05 	sts	0x0554, r25
				setup_step = 0;
    4d96:	10 92 75 05 	sts	0x0575, r1
    4d9a:	0c c0       	rjmp	.+24     	; 0x4db4 <u8g_DrawCamRaw+0x74>
			}
			else if((incrOk_pushDuration < 100) &&
    4d9c:	81 30       	cpi	r24, 0x01	; 1
    4d9e:	51 f4       	brne	.+20     	; 0x4db4 <u8g_DrawCamRaw+0x74>
							(viewCam_mode == 1))
			{
				viewCam_mode = 0;
    4da0:	10 92 70 05 	sts	0x0570, r1
    4da4:	07 c0       	rjmp	.+14     	; 0x4db4 <u8g_DrawCamRaw+0x74>
			}
		
			if(incrOk_pushDuration > 100)
    4da6:	84 36       	cpi	r24, 0x64	; 100
    4da8:	29 f0       	breq	.+10     	; 0x4db4 <u8g_DrawCamRaw+0x74>
				viewCam_sorted ^= 1;
    4daa:	80 91 6f 05 	lds	r24, 0x056F
    4dae:	89 27       	eor	r24, r25
    4db0:	80 93 6f 05 	sts	0x056F, r24
			
			incrOk_pushDuration = 0;
    4db4:	10 92 6a 05 	sts	0x056A, r1
			pushed = 0;
    4db8:	10 92 69 05 	sts	0x0569, r1
		}
	}
	
	if(viewCam_mode == 0)
    4dbc:	80 91 70 05 	lds	r24, 0x0570
    4dc0:	81 11       	cpse	r24, r1
    4dc2:	0d c0       	rjmp	.+26     	; 0x4dde <u8g_DrawCamRaw+0x9e>
	{
		viewCam_mode += (incremental-incremental_old_cam);
    4dc4:	80 91 58 05 	lds	r24, 0x0558
    4dc8:	90 91 6b 05 	lds	r25, 0x056B
    4dcc:	89 1b       	sub	r24, r25
    4dce:	80 93 70 05 	sts	0x0570, r24
		if(viewCam_mode > 1)
    4dd2:	82 30       	cpi	r24, 0x02	; 2
    4dd4:	08 f4       	brcc	.+2      	; 0x4dd8 <u8g_DrawCamRaw+0x98>
    4dd6:	4a c0       	rjmp	.+148    	; 0x4e6c <u8g_DrawCamRaw+0x12c>
			viewCam_mode = 0;
    4dd8:	10 92 70 05 	sts	0x0570, r1
    4ddc:	47 c0       	rjmp	.+142    	; 0x4e6c <u8g_DrawCamRaw+0x12c>
		if(viewCam_mode < 0)
			viewCam_mode = 1;
	}
	else if(viewCam_mode == 1)
    4dde:	81 30       	cpi	r24, 0x01	; 1
    4de0:	09 f0       	breq	.+2      	; 0x4de4 <u8g_DrawCamRaw+0xa4>
    4de2:	44 c0       	rjmp	.+136    	; 0x4e6c <u8g_DrawCamRaw+0x12c>
	{
		u8g_drawArrow(5, 125, 24, SOUTH, 0);
    4de4:	00 e0       	ldi	r16, 0x00	; 0
    4de6:	23 e0       	ldi	r18, 0x03	; 3
    4de8:	48 e1       	ldi	r20, 0x18	; 24
    4dea:	6d e7       	ldi	r22, 0x7D	; 125
    4dec:	85 e0       	ldi	r24, 0x05	; 5
    4dee:	3d db       	rcall	.-2438   	; 0x446a <u8g_drawArrow>
    4df0:	40 91 58 05 	lds	r20, 0x0558
		tsl_th += (incremental-incremental_old_cam)*10;
    4df4:	50 91 59 05 	lds	r21, 0x0559
    4df8:	60 91 5a 05 	lds	r22, 0x055A
    4dfc:	70 91 5b 05 	lds	r23, 0x055B
    4e00:	80 91 6b 05 	lds	r24, 0x056B
    4e04:	90 91 6c 05 	lds	r25, 0x056C
    4e08:	a0 91 6d 05 	lds	r26, 0x056D
    4e0c:	b0 91 6e 05 	lds	r27, 0x056E
    4e10:	8a 01       	movw	r16, r20
    4e12:	9b 01       	movw	r18, r22
    4e14:	08 1b       	sub	r16, r24
    4e16:	19 0b       	sbc	r17, r25
    4e18:	2a 0b       	sbc	r18, r26
    4e1a:	3b 0b       	sbc	r19, r27
    4e1c:	ca e0       	ldi	r28, 0x0A	; 10
    4e1e:	c0 9f       	mul	r28, r16
    4e20:	f0 01       	movw	r30, r0
    4e22:	c1 9f       	mul	r28, r17
    4e24:	f0 0d       	add	r31, r0
    4e26:	11 24       	eor	r1, r1
    4e28:	20 91 4e 16 	lds	r18, 0x164E
    4e2c:	30 91 4f 16 	lds	r19, 0x164F
    4e30:	e2 0f       	add	r30, r18
    4e32:	f3 1f       	adc	r31, r19
    4e34:	f7 fd       	sbrc	r31, 7
		if(tsl_th < 0)
    4e36:	05 c0       	rjmp	.+10     	; 0x4e42 <u8g_DrawCamRaw+0x102>
    4e38:	f0 93 4f 16 	sts	0x164F, r31
			viewCam_mode = 1;
	}
	else if(viewCam_mode == 1)
	{
		u8g_drawArrow(5, 125, 24, SOUTH, 0);
		tsl_th += (incremental-incremental_old_cam)*10;
    4e3c:	e0 93 4e 16 	sts	0x164E, r30
    4e40:	04 c0       	rjmp	.+8      	; 0x4e4a <u8g_DrawCamRaw+0x10a>
    4e42:	10 92 4f 16 	sts	0x164F, r1
		if(tsl_th < 0)
			tsl_th = 0;
    4e46:	10 92 4e 16 	sts	0x164E, r1
    4e4a:	20 91 4e 16 	lds	r18, 0x164E
		tsl_th_ground = tsl_th + TSL_GROUNDSENS_DIFF;
    4e4e:	30 91 4f 16 	lds	r19, 0x164F
    4e52:	2e 5c       	subi	r18, 0xCE	; 206
    4e54:	3f 4f       	sbci	r19, 0xFF	; 255
    4e56:	30 93 44 16 	sts	0x1644, r19
    4e5a:	20 93 43 16 	sts	0x1643, r18
    4e5e:	48 17       	cp	r20, r24
		if((int8_t)(incremental-incremental_old_cam) != 0) //etwas wurde gendert
    4e60:	29 f0       	breq	.+10     	; 0x4e6c <u8g_DrawCamRaw+0x12c>
    4e62:	80 91 73 07 	lds	r24, 0x0773
			eepr_value_changed.cam = 1;
    4e66:	80 61       	ori	r24, 0x10	; 16
    4e68:	80 93 73 07 	sts	0x0773, r24
    4e6c:	6f e8       	ldi	r22, 0x8F	; 143
	}
	
	
	u8g_SetFont(&u8g, u8g_font_4x6);
    4e6e:	74 e1       	ldi	r23, 0x14	; 20
    4e70:	8b e1       	ldi	r24, 0x1B	; 27
    4e72:	97 e0       	ldi	r25, 0x07	; 7
    4e74:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <u8g_SetFont>
    4e78:	d1 2c       	mov	r13, r1

	for(uint8_t i = 0; i < ((128/TSL_RESOLUTION)*2); i+=2)
    4e7a:	04 e1       	ldi	r16, 0x14	; 20
				u8g_DrawVLine(&u8g, i+1, 64-(tslData_med[i/2])/20, (tslData_med[i/2])/20);
			}
		}
		else
		{
			u8g_DrawVLine(&u8g, i, 64-(tslData[i/2])/20, (tslData[i/2])/20);
    4e7c:	10 e0       	ldi	r17, 0x00	; 0
    4e7e:	2c ee       	ldi	r18, 0xEC	; 236
    4e80:	e2 2e       	mov	r14, r18
    4e82:	ff 24       	eor	r15, r15
    4e84:	fa 94       	dec	r15
    4e86:	80 91 6f 05 	lds	r24, 0x056F
	
	u8g_SetFont(&u8g, u8g_font_4x6);

	for(uint8_t i = 0; i < ((128/TSL_RESOLUTION)*2); i+=2)
	{
		if(viewCam_sorted)
    4e8a:	88 23       	and	r24, r24
    4e8c:	f1 f0       	breq	.+60     	; 0x4eca <u8g_DrawCamRaw+0x18a>
    4e8e:	8b e2       	ldi	r24, 0x2B	; 43
		{
			if(i < ((128/TSL_RESOLUTION)-TSL_CNT_OFFSET_ROB)*2)
    4e90:	8d 15       	cp	r24, r13
    4e92:	08 f4       	brcc	.+2      	; 0x4e96 <u8g_DrawCamRaw+0x156>
    4e94:	49 c0       	rjmp	.+146    	; 0x4f28 <u8g_DrawCamRaw+0x1e8>
    4e96:	cd 2d       	mov	r28, r13
			{
				u8g_DrawVLine(&u8g, i, 64-(tslData_med[i/2])/20, (tslData_med[i/2])/20);
    4e98:	c6 95       	lsr	r28
    4e9a:	d0 e0       	ldi	r29, 0x00	; 0
    4e9c:	cc 0f       	add	r28, r28
    4e9e:	dd 1f       	adc	r29, r29
    4ea0:	cb 57       	subi	r28, 0x7B	; 123
    4ea2:	d9 4e       	sbci	r29, 0xE9	; 233
    4ea4:	e8 81       	ld	r30, Y
    4ea6:	f9 81       	ldd	r31, Y+1	; 0x01
    4ea8:	cf 01       	movw	r24, r30
    4eaa:	b8 01       	movw	r22, r16
    4eac:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4eb0:	26 2f       	mov	r18, r22
    4eb2:	cf 01       	movw	r24, r30
    4eb4:	b7 01       	movw	r22, r14
    4eb6:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4eba:	40 e4       	ldi	r20, 0x40	; 64
    4ebc:	46 0f       	add	r20, r22
    4ebe:	6d 2d       	mov	r22, r13
    4ec0:	8b e1       	ldi	r24, 0x1B	; 27
    4ec2:	97 e0       	ldi	r25, 0x07	; 7
    4ec4:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    4ec8:	1c c0       	rjmp	.+56     	; 0x4f02 <u8g_DrawCamRaw+0x1c2>
    4eca:	cd 2d       	mov	r28, r13
				u8g_DrawVLine(&u8g, i+1, 64-(tslData_med[i/2])/20, (tslData_med[i/2])/20);
			}
		}
		else
		{
			u8g_DrawVLine(&u8g, i, 64-(tslData[i/2])/20, (tslData[i/2])/20);
    4ecc:	c6 95       	lsr	r28
    4ece:	d0 e0       	ldi	r29, 0x00	; 0
    4ed0:	cc 0f       	add	r28, r28
    4ed2:	dd 1f       	adc	r29, r29
    4ed4:	cf 54       	subi	r28, 0x4F	; 79
    4ed6:	d9 4e       	sbci	r29, 0xE9	; 233
    4ed8:	e8 81       	ld	r30, Y
    4eda:	f9 81       	ldd	r31, Y+1	; 0x01
    4edc:	cf 01       	movw	r24, r30
    4ede:	b8 01       	movw	r22, r16
    4ee0:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4ee4:	26 2f       	mov	r18, r22
    4ee6:	cf 01       	movw	r24, r30
    4ee8:	b7 01       	movw	r22, r14
    4eea:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4eee:	40 e4       	ldi	r20, 0x40	; 64
    4ef0:	46 0f       	add	r20, r22
    4ef2:	6d 2d       	mov	r22, r13
    4ef4:	8b e1       	ldi	r24, 0x1B	; 27
    4ef6:	97 e0       	ldi	r25, 0x07	; 7
    4ef8:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    4efc:	82 e1       	ldi	r24, 0x12	; 18
			if(i > 18) u8g_DrawVLine(&u8g, i+1, 64-(tslData[i/2])/20, (tslData[i/2])/20);
    4efe:	8d 15       	cp	r24, r13
    4f00:	98 f4       	brcc	.+38     	; 0x4f28 <u8g_DrawCamRaw+0x1e8>
    4f02:	e8 81       	ld	r30, Y
    4f04:	f9 81       	ldd	r31, Y+1	; 0x01
    4f06:	cf 01       	movw	r24, r30
    4f08:	b8 01       	movw	r22, r16
    4f0a:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4f0e:	26 2f       	mov	r18, r22
    4f10:	cf 01       	movw	r24, r30
    4f12:	b7 01       	movw	r22, r14
    4f14:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    4f18:	40 e4       	ldi	r20, 0x40	; 64
    4f1a:	46 0f       	add	r20, r22
    4f1c:	61 e0       	ldi	r22, 0x01	; 1
    4f1e:	6d 0d       	add	r22, r13
    4f20:	8b e1       	ldi	r24, 0x1B	; 27
    4f22:	97 e0       	ldi	r25, 0x07	; 7
    4f24:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    4f28:	d3 94       	inc	r13
	}
	
	
	u8g_SetFont(&u8g, u8g_font_4x6);

	for(uint8_t i = 0; i < ((128/TSL_RESOLUTION)*2); i+=2)
    4f2a:	d3 94       	inc	r13
    4f2c:	80 e4       	ldi	r24, 0x40	; 64
    4f2e:	d8 12       	cpse	r13, r24
    4f30:	aa cf       	rjmp	.-172    	; 0x4e86 <u8g_DrawCamRaw+0x146>
    4f32:	20 ea       	ldi	r18, 0xA0	; 160
			u8g_DrawVLine(&u8g, i, 64-(tslData[i/2])/20, (tslData[i/2])/20);
			if(i > 18) u8g_DrawVLine(&u8g, i+1, 64-(tslData[i/2])/20, (tslData[i/2])/20);
		}
	}

	u8g_DrawStr(&u8g,		65, 	13, "Exposure:"); 	u8g_DrawLong(110,	13, tsl_exposure);
    4f34:	33 e0       	ldi	r19, 0x03	; 3
    4f36:	4d e0       	ldi	r20, 0x0D	; 13
    4f38:	61 e4       	ldi	r22, 0x41	; 65
    4f3a:	8b e1       	ldi	r24, 0x1B	; 27
    4f3c:	97 e0       	ldi	r25, 0x07	; 7
    4f3e:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4f42:	20 91 c4 02 	lds	r18, 0x02C4
    4f46:	30 91 c5 02 	lds	r19, 0x02C5
    4f4a:	44 27       	eor	r20, r20
    4f4c:	37 fd       	sbrc	r19, 7
    4f4e:	40 95       	com	r20
    4f50:	54 2f       	mov	r21, r20
    4f52:	6d e0       	ldi	r22, 0x0D	; 13
    4f54:	8e e6       	ldi	r24, 0x6E	; 110
    4f56:	5e d8       	rcall	.-3908   	; 0x4014 <u8g_DrawLong>
    4f58:	2a ea       	ldi	r18, 0xAA	; 170
    4f5a:	33 e0       	ldi	r19, 0x03	; 3
	u8g_DrawStr(&u8g,		65, 	20, "Brightness:"); u8g_DrawLong(110,	20, tsl_led_brightness);
    4f5c:	44 e1       	ldi	r20, 0x14	; 20
    4f5e:	61 e4       	ldi	r22, 0x41	; 65
    4f60:	8b e1       	ldi	r24, 0x1B	; 27
    4f62:	97 e0       	ldi	r25, 0x07	; 7
    4f64:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4f68:	20 91 dc 05 	lds	r18, 0x05DC
    4f6c:	30 e0       	ldi	r19, 0x00	; 0
    4f6e:	40 e0       	ldi	r20, 0x00	; 0
    4f70:	50 e0       	ldi	r21, 0x00	; 0
    4f72:	64 e1       	ldi	r22, 0x14	; 20
    4f74:	8e e6       	ldi	r24, 0x6E	; 110
    4f76:	4e d8       	rcall	.-3940   	; 0x4014 <u8g_DrawLong>
    4f78:	26 eb       	ldi	r18, 0xB6	; 182
    4f7a:	33 e0       	ldi	r19, 0x03	; 3
    4f7c:	4b e1       	ldi	r20, 0x1B	; 27
	u8g_DrawStr(&u8g,		65, 	27, "Result Cam:"); u8g_DrawLong(110,	27, tsl_res);
    4f7e:	61 e4       	ldi	r22, 0x41	; 65
    4f80:	8b e1       	ldi	r24, 0x1B	; 27
    4f82:	97 e0       	ldi	r25, 0x07	; 7
    4f84:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4f88:	20 91 da 05 	lds	r18, 0x05DA
    4f8c:	30 91 db 05 	lds	r19, 0x05DB
    4f90:	44 27       	eor	r20, r20
    4f92:	37 fd       	sbrc	r19, 7
    4f94:	40 95       	com	r20
    4f96:	54 2f       	mov	r21, r20
    4f98:	6b e1       	ldi	r22, 0x1B	; 27
    4f9a:	8e e6       	ldi	r24, 0x6E	; 110
    4f9c:	3b d8       	rcall	.-3978   	; 0x4014 <u8g_DrawLong>
    4f9e:	22 ec       	ldi	r18, 0xC2	; 194
    4fa0:	33 e0       	ldi	r19, 0x03	; 3
    4fa2:	42 e2       	ldi	r20, 0x22	; 34
    4fa4:	61 e4       	ldi	r22, 0x41	; 65
	u8g_DrawStr(&u8g,		65, 	34, "Groundsens:"); u8g_DrawLong(110,	34, groundsens_r);
    4fa6:	8b e1       	ldi	r24, 0x1B	; 27
    4fa8:	97 e0       	ldi	r25, 0x07	; 7
    4faa:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4fae:	20 91 7c 07 	lds	r18, 0x077C
    4fb2:	30 91 7d 07 	lds	r19, 0x077D
    4fb6:	44 27       	eor	r20, r20
    4fb8:	37 fd       	sbrc	r19, 7
    4fba:	40 95       	com	r20
    4fbc:	54 2f       	mov	r21, r20
    4fbe:	62 e2       	ldi	r22, 0x22	; 34
    4fc0:	8e e6       	ldi	r24, 0x6E	; 110
    4fc2:	28 d8       	rcall	.-4016   	; 0x4014 <u8g_DrawLong>
    4fc4:	2e ec       	ldi	r18, 0xCE	; 206
    4fc6:	33 e0       	ldi	r19, 0x03	; 3
    4fc8:	49 e2       	ldi	r20, 0x29	; 41
    4fca:	61 e4       	ldi	r22, 0x41	; 65
    4fcc:	8b e1       	ldi	r24, 0x1B	; 27
	
	u8g_DrawStr(&u8g,		65, 	41, "TH Cam_Al:"); 		u8g_DrawLong(110,	41, tsl_th);
    4fce:	97 e0       	ldi	r25, 0x07	; 7
    4fd0:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4fd4:	20 91 4e 16 	lds	r18, 0x164E
    4fd8:	30 91 4f 16 	lds	r19, 0x164F
    4fdc:	44 27       	eor	r20, r20
    4fde:	37 fd       	sbrc	r19, 7
    4fe0:	40 95       	com	r20
    4fe2:	54 2f       	mov	r21, r20
    4fe4:	69 e2       	ldi	r22, 0x29	; 41
    4fe6:	8e e6       	ldi	r24, 0x6E	; 110
    4fe8:	15 d8       	rcall	.-4054   	; 0x4014 <u8g_DrawLong>
    4fea:	29 ed       	ldi	r18, 0xD9	; 217
    4fec:	33 e0       	ldi	r19, 0x03	; 3
    4fee:	40 e3       	ldi	r20, 0x30	; 48
    4ff0:	61 e4       	ldi	r22, 0x41	; 65
    4ff2:	8b e1       	ldi	r24, 0x1B	; 27
    4ff4:	97 e0       	ldi	r25, 0x07	; 7
	u8g_DrawStr(&u8g,		65, 	48, "TH Cam_Gr:"); 		u8g_DrawLong(110,	48, tsl_th_ground);
    4ff6:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    4ffa:	20 91 43 16 	lds	r18, 0x1643
    4ffe:	30 91 44 16 	lds	r19, 0x1644
    5002:	44 27       	eor	r20, r20
    5004:	37 fd       	sbrc	r19, 7
    5006:	40 95       	com	r20
    5008:	54 2f       	mov	r21, r20
    500a:	60 e3       	ldi	r22, 0x30	; 48
    500c:	8e e6       	ldi	r24, 0x6E	; 110
    500e:	02 d8       	rcall	.-4092   	; 0x4014 <u8g_DrawLong>
    5010:	24 ee       	ldi	r18, 0xE4	; 228
    5012:	33 e0       	ldi	r19, 0x03	; 3
    5014:	47 e3       	ldi	r20, 0x37	; 55
    5016:	61 e4       	ldi	r22, 0x41	; 65
    5018:	8b e1       	ldi	r24, 0x1B	; 27
    501a:	97 e0       	ldi	r25, 0x07	; 7
    501c:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
	u8g_DrawStr(&u8g,		65, 	55, "TH Ground:"); 	u8g_DrawLong(110,	55, ground_th);
    5020:	20 91 4c 16 	lds	r18, 0x164C
    5024:	30 91 4d 16 	lds	r19, 0x164D
    5028:	44 27       	eor	r20, r20
    502a:	37 fd       	sbrc	r19, 7
    502c:	40 95       	com	r20
    502e:	54 2f       	mov	r21, r20
    5030:	67 e3       	ldi	r22, 0x37	; 55
    5032:	8e e6       	ldi	r24, 0x6E	; 110
    5034:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    5038:	2f ee       	ldi	r18, 0xEF	; 239
    503a:	33 e0       	ldi	r19, 0x03	; 3
    503c:	4e e3       	ldi	r20, 0x3E	; 62
    503e:	61 e4       	ldi	r22, 0x41	; 65
    5040:	8b e1       	ldi	r24, 0x1B	; 27
    5042:	97 e0       	ldi	r25, 0x07	; 7
    5044:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
	u8g_DrawStr(&u8g,		65, 	62, "View:"); 			if(viewCam_sorted)	u8g_DrawStr(&u8g,	110, 	62, "srt");
    5048:	80 91 6f 05 	lds	r24, 0x056F
    504c:	88 23       	and	r24, r24
    504e:	19 f0       	breq	.+6      	; 0x5056 <u8g_DrawCamRaw+0x316>
    5050:	25 ef       	ldi	r18, 0xF5	; 245
    5052:	33 e0       	ldi	r19, 0x03	; 3
    5054:	02 c0       	rjmp	.+4      	; 0x505a <u8g_DrawCamRaw+0x31a>
    5056:	29 ef       	ldi	r18, 0xF9	; 249
    5058:	33 e0       	ldi	r19, 0x03	; 3
    505a:	4e e3       	ldi	r20, 0x3E	; 62
    505c:	6e e6       	ldi	r22, 0x6E	; 110
    505e:	8b e1       	ldi	r24, 0x1B	; 27
    5060:	97 e0       	ldi	r25, 0x07	; 7
    5062:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
																								else								u8g_DrawStr(&u8g,	110, 	62, "raw");
    5066:	80 91 58 05 	lds	r24, 0x0558
    506a:	90 91 59 05 	lds	r25, 0x0559
    506e:	a0 91 5a 05 	lds	r26, 0x055A
    5072:	b0 91 5b 05 	lds	r27, 0x055B
	
	incremental_old_cam = incremental;
    5076:	80 93 6b 05 	sts	0x056B, r24
    507a:	90 93 6c 05 	sts	0x056C, r25
    507e:	a0 93 6d 05 	sts	0x056D, r26
    5082:	b0 93 6e 05 	sts	0x056E, r27
    5086:	cd b7       	in	r28, 0x3d	; 61
    5088:	de b7       	in	r29, 0x3e	; 62
    508a:	e7 e0       	ldi	r30, 0x07	; 7
    508c:	0c 94 c2 6b 	jmp	0xd784	; 0xd784 <__epilogue_restores__+0x16>

00005090 <u8g_DrawTempScan>:
}

///////////////////////////Tempscan//////////////////////////////////////////////

void u8g_DrawTempScan(uint8_t dir)
{
    5090:	a0 e0       	ldi	r26, 0x00	; 0
    5092:	b0 e0       	ldi	r27, 0x00	; 0
    5094:	ee e4       	ldi	r30, 0x4E	; 78
    5096:	f8 e2       	ldi	r31, 0x28	; 40
    5098:	0c 94 a3 6b 	jmp	0xd746	; 0xd746 <__prologue_saves__+0x10>
    509c:	95 e5       	ldi	r25, 0x55	; 85
    509e:	89 9f       	mul	r24, r25
    50a0:	80 01       	movw	r16, r0
    50a2:	11 24       	eor	r1, r1
    50a4:	0a 5d       	subi	r16, 0xDA	; 218
    50a6:	18 4e       	sbci	r17, 0xE8	; 232
    50a8:	c0 e0       	ldi	r28, 0x00	; 0
    50aa:	d0 e0       	ldi	r29, 0x00	; 0
	for(int8_t i = 0; i < VICTIMBUFFER_SIZE; i++)
		if((victimBuf[dir].value[i] != VICTIMBUF_UNUSED) && ((victimBuf[dir].value[i]-victimBuf[dir].lowest)/50 > 0))
    50ac:	a5 e5       	ldi	r26, 0x55	; 85
    50ae:	8a 9f       	mul	r24, r26
    50b0:	70 01       	movw	r14, r0
    50b2:	11 24       	eor	r1, r1
    50b4:	c7 01       	movw	r24, r14
    50b6:	89 58       	subi	r24, 0x89	; 137
    50b8:	98 4e       	sbci	r25, 0xE8	; 232
    50ba:	7c 01       	movw	r14, r24
			u8g_DrawVLine(&u8g,i,63-(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50,
									(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50);
    50bc:	62 e3       	ldi	r22, 0x32	; 50
    50be:	c6 2e       	mov	r12, r22
    50c0:	d1 2c       	mov	r13, r1

void u8g_DrawTempScan(uint8_t dir)
{
	for(int8_t i = 0; i < VICTIMBUFFER_SIZE; i++)
		if((victimBuf[dir].value[i] != VICTIMBUF_UNUSED) && ((victimBuf[dir].value[i]-victimBuf[dir].lowest)/50 > 0))
			u8g_DrawVLine(&u8g,i,63-(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50,
    50c2:	7e ec       	ldi	r23, 0xCE	; 206
    50c4:	a7 2e       	mov	r10, r23
    50c6:	bb 24       	eor	r11, r11
    50c8:	ba 94       	dec	r11
    50ca:	fe 01       	movw	r30, r28
    50cc:	ee 0f       	add	r30, r30
    50ce:	ff 1f       	adc	r31, r31
    50d0:	e0 0f       	add	r30, r16
    50d2:	f1 1f       	adc	r31, r17
///////////////////////////Tempscan//////////////////////////////////////////////

void u8g_DrawTempScan(uint8_t dir)
{
	for(int8_t i = 0; i < VICTIMBUFFER_SIZE; i++)
		if((victimBuf[dir].value[i] != VICTIMBUF_UNUSED) && ((victimBuf[dir].value[i]-victimBuf[dir].lowest)/50 > 0))
    50d4:	01 90       	ld	r0, Z+
    50d6:	f0 81       	ld	r31, Z
    50d8:	e0 2d       	mov	r30, r0
    50da:	ef 3f       	cpi	r30, 0xFF	; 255
    50dc:	9f e7       	ldi	r25, 0x7F	; 127
    50de:	f9 07       	cpc	r31, r25
    50e0:	c1 f0       	breq	.+48     	; 0x5112 <u8g_DrawTempScan+0x82>
    50e2:	d7 01       	movw	r26, r14
    50e4:	8d 91       	ld	r24, X+
    50e6:	9c 91       	ld	r25, X
    50e8:	e8 1b       	sub	r30, r24
    50ea:	f9 0b       	sbc	r31, r25
    50ec:	e2 33       	cpi	r30, 0x32	; 50
    50ee:	f1 05       	cpc	r31, r1
    50f0:	84 f0       	brlt	.+32     	; 0x5112 <u8g_DrawTempScan+0x82>
			u8g_DrawVLine(&u8g,i,63-(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50,
									(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50);
    50f2:	cf 01       	movw	r24, r30
    50f4:	b6 01       	movw	r22, r12
    50f6:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    50fa:	26 2f       	mov	r18, r22

void u8g_DrawTempScan(uint8_t dir)
{
	for(int8_t i = 0; i < VICTIMBUFFER_SIZE; i++)
		if((victimBuf[dir].value[i] != VICTIMBUF_UNUSED) && ((victimBuf[dir].value[i]-victimBuf[dir].lowest)/50 > 0))
			u8g_DrawVLine(&u8g,i,63-(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50,
    50fc:	cf 01       	movw	r24, r30
    50fe:	b5 01       	movw	r22, r10
    5100:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    5104:	4f e3       	ldi	r20, 0x3F	; 63
    5106:	46 0f       	add	r20, r22
    5108:	6c 2f       	mov	r22, r28
    510a:	8b e1       	ldi	r24, 0x1B	; 27
    510c:	97 e0       	ldi	r25, 0x07	; 7
    510e:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    5112:	21 96       	adiw	r28, 0x01	; 1

///////////////////////////Tempscan//////////////////////////////////////////////

void u8g_DrawTempScan(uint8_t dir)
{
	for(int8_t i = 0; i < VICTIMBUFFER_SIZE; i++)
    5114:	c8 32       	cpi	r28, 0x28	; 40
    5116:	d1 05       	cpc	r29, r1
    5118:	c1 f6       	brne	.-80     	; 0x50ca <u8g_DrawTempScan+0x3a>
		if((victimBuf[dir].value[i] != VICTIMBUF_UNUSED) && ((victimBuf[dir].value[i]-victimBuf[dir].lowest)/50 > 0))
			u8g_DrawVLine(&u8g,i,63-(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50,
									(victimBuf[dir].value[i] - victimBuf[dir].lowest)/50);
}
    511a:	cd b7       	in	r28, 0x3d	; 61
    511c:	de b7       	in	r29, 0x3e	; 62
    511e:	ea e0       	ldi	r30, 0x0A	; 10
    5120:	0c 94 bf 6b 	jmp	0xd77e	; 0xd77e <__epilogue_restores__+0x10>

00005124 <u8g_DrawVictim>:

/////////////////////////////Victim/////////////////////////////////////////

void u8g_DrawVictim(void)
{
	if(get_incrOk())
    5124:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>
    5128:	88 23       	and	r24, r24
    512a:	19 f0       	breq	.+6      	; 0x5132 <u8g_DrawVictim+0xe>
		setup = 1;
    512c:	81 e0       	ldi	r24, 0x01	; 1
    512e:	80 93 54 05 	sts	0x0554, r24

	u8g_DrawTempScan(RIGHT);
    5132:	81 e0       	ldi	r24, 0x01	; 1
    5134:	ad df       	rcall	.-166    	; 0x5090 <u8g_DrawTempScan>
    5136:	2d ef       	ldi	r18, 0xFD	; 253

	u8g_DrawStr(&u8g,		65, 	13, "Max Diff:"); 	u8g_DrawLong(100,	13, victim_BufGetMaxDiff(RIGHT));
    5138:	33 e0       	ldi	r19, 0x03	; 3
    513a:	4d e0       	ldi	r20, 0x0D	; 13
    513c:	61 e4       	ldi	r22, 0x41	; 65
    513e:	8b e1       	ldi	r24, 0x1B	; 27
    5140:	97 e0       	ldi	r25, 0x07	; 7
    5142:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    5146:	81 e0       	ldi	r24, 0x01	; 1
    5148:	0e 94 46 63 	call	0xc68c	; 0xc68c <victim_BufGetMaxDiff>
    514c:	9c 01       	movw	r18, r24
    514e:	44 27       	eor	r20, r20
    5150:	37 fd       	sbrc	r19, 7
    5152:	40 95       	com	r20
    5154:	54 2f       	mov	r21, r20
    5156:	6d e0       	ldi	r22, 0x0D	; 13
    5158:	84 e6       	ldi	r24, 0x64	; 100
    515a:	0c 94 0a 20 	jmp	0x4014	; 0x4014 <u8g_DrawLong>

0000515e <drive_limitSpeed>:
#include "system.h"
#include "bluetooth.h"
#include "i2cdev.h"

void drive_limitSpeed(int16_t *speed_l, int16_t *speed_r, int8_t limit)
{
    515e:	fc 01       	movw	r30, r24
    5160:	db 01       	movw	r26, r22
	if(*speed_l > limit)
    5162:	55 27       	eor	r21, r21
    5164:	47 fd       	sbrc	r20, 7
    5166:	50 95       	com	r21
    5168:	80 81       	ld	r24, Z
    516a:	91 81       	ldd	r25, Z+1	; 0x01
    516c:	48 17       	cp	r20, r24
    516e:	59 07       	cpc	r21, r25
    5170:	14 f4       	brge	.+4      	; 0x5176 <drive_limitSpeed+0x18>
	 	*speed_l = limit;
    5172:	51 83       	std	Z+1, r21	; 0x01
    5174:	40 83       	st	Z, r20
	if(*speed_l < -limit)
    5176:	88 27       	eor	r24, r24
    5178:	99 27       	eor	r25, r25
    517a:	84 1b       	sub	r24, r20
    517c:	95 0b       	sbc	r25, r21
    517e:	20 81       	ld	r18, Z
    5180:	31 81       	ldd	r19, Z+1	; 0x01
    5182:	28 17       	cp	r18, r24
    5184:	39 07       	cpc	r19, r25
    5186:	14 f4       	brge	.+4      	; 0x518c <drive_limitSpeed+0x2e>
		*speed_l  = -limit;
    5188:	91 83       	std	Z+1, r25	; 0x01
    518a:	80 83       	st	Z, r24
	
	if(*speed_r > limit)
    518c:	2d 91       	ld	r18, X+
    518e:	3c 91       	ld	r19, X
    5190:	11 97       	sbiw	r26, 0x01	; 1
    5192:	42 17       	cp	r20, r18
    5194:	53 07       	cpc	r21, r19
    5196:	1c f4       	brge	.+6      	; 0x519e <drive_limitSpeed+0x40>
		*speed_r = limit;
    5198:	11 96       	adiw	r26, 0x01	; 1
    519a:	5c 93       	st	X, r21
    519c:	4e 93       	st	-X, r20
	if(*speed_r < -limit)
    519e:	2d 91       	ld	r18, X+
    51a0:	3c 91       	ld	r19, X
    51a2:	11 97       	sbiw	r26, 0x01	; 1
    51a4:	28 17       	cp	r18, r24
    51a6:	39 07       	cpc	r19, r25
    51a8:	14 f4       	brge	.+4      	; 0x51ae <drive_limitSpeed+0x50>
		*speed_r  = -limit;
    51aa:	8d 93       	st	X+, r24
    51ac:	9c 93       	st	X, r25
    51ae:	08 95       	ret

000051b0 <drive_rotate>:
#define UM6_ROTATE_OFFSET -3 //The smaller this offset, the less the robot rotates (usually as high as drift of the UM6)

#define STEER_ROTATE_TH_TIMER 20 //Unter diesem Wert (Betrag) wird ein Timer aktivierter, in dem Zeitraum 0 erreicht werden muss, ansonsten abbruch.

uint8_t drive_rotate(int16_t angle, uint8_t maxspeed)
{
    51b0:	4f 92       	push	r4
    51b2:	5f 92       	push	r5
    51b4:	6f 92       	push	r6
    51b6:	7f 92       	push	r7
    51b8:	8f 92       	push	r8
    51ba:	9f 92       	push	r9
    51bc:	af 92       	push	r10
    51be:	bf 92       	push	r11
    51c0:	cf 92       	push	r12
    51c2:	df 92       	push	r13
    51c4:	ef 92       	push	r14
    51c6:	ff 92       	push	r15
    51c8:	0f 93       	push	r16
    51ca:	1f 93       	push	r17
    51cc:	cf 93       	push	r28
    51ce:	fc 01       	movw	r30, r24
    51d0:	c6 2f       	mov	r28, r22
	uint8_t returnvar = 1;
	
	switch(sm_rotate)
    51d2:	80 91 a1 05 	lds	r24, 0x05A1
    51d6:	81 30       	cpi	r24, 0x01	; 1
    51d8:	09 f4       	brne	.+2      	; 0x51dc <drive_rotate+0x2c>
    51da:	65 c0       	rjmp	.+202    	; 0x52a6 <drive_rotate+0xf6>
    51dc:	20 91 53 05 	lds	r18, 0x0553
    51e0:	81 30       	cpi	r24, 0x01	; 1
    51e2:	20 f0       	brcs	.+8      	; 0x51ec <drive_rotate+0x3c>
    51e4:	82 30       	cpi	r24, 0x02	; 2
    51e6:	09 f4       	brne	.+2      	; 0x51ea <drive_rotate+0x3a>
    51e8:	d2 c1       	rjmp	.+932    	; 0x558e <drive_rotate+0x3de>
    51ea:	f4 c1       	rjmp	.+1000   	; 0x55d4 <drive_rotate+0x424>
	{
		case ROTATE_INIT:
		
							um6_psi_t_start_rotate = um6.psi_t;
    51ec:	80 91 0e 17 	lds	r24, 0x170E
    51f0:	90 91 0f 17 	lds	r25, 0x170F
    51f4:	a0 91 10 17 	lds	r26, 0x1710
    51f8:	b0 91 11 17 	lds	r27, 0x1711
    51fc:	80 93 9d 05 	sts	0x059D, r24
    5200:	90 93 9e 05 	sts	0x059E, r25
    5204:	a0 93 9f 05 	sts	0x059F, r26
    5208:	b0 93 a0 05 	sts	0x05A0, r27
							enc_l_start_rotate = mot.d[LEFT].enc;
    520c:	80 91 6b 16 	lds	r24, 0x166B
    5210:	90 91 6c 16 	lds	r25, 0x166C
    5214:	a0 91 6d 16 	lds	r26, 0x166D
    5218:	b0 91 6e 16 	lds	r27, 0x166E
    521c:	80 93 99 05 	sts	0x0599, r24
    5220:	90 93 9a 05 	sts	0x059A, r25
    5224:	a0 93 9b 05 	sts	0x059B, r26
    5228:	b0 93 9c 05 	sts	0x059C, r27
							enc_r_start_rotate = mot.d[RIGHT].enc;
    522c:	80 91 77 16 	lds	r24, 0x1677
    5230:	90 91 78 16 	lds	r25, 0x1678
    5234:	a0 91 79 16 	lds	r26, 0x1679
    5238:	b0 91 7a 16 	lds	r27, 0x167A
    523c:	80 93 95 05 	sts	0x0595, r24
    5240:	90 93 96 05 	sts	0x0596, r25
    5244:	a0 93 97 05 	sts	0x0597, r26
    5248:	b0 93 98 05 	sts	0x0598, r27
							
							rotate_enc = 0;
    524c:	10 92 92 05 	sts	0x0592, r1
							timer_drive = -1;
    5250:	8f ef       	ldi	r24, 0xFF	; 255
    5252:	9f ef       	ldi	r25, 0xFF	; 255
    5254:	90 93 96 02 	sts	0x0296, r25
    5258:	80 93 95 02 	sts	0x0295, r24
							
							rotate_progress = 0;
    525c:	10 92 91 05 	sts	0x0591, r1

							sm_rotate = ROTATE;
    5260:	81 e0       	ldi	r24, 0x01	; 1
    5262:	80 93 a1 05 	sts	0x05A1, r24
							
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_rotate()::psi_start: "));bt_putLong(um6_psi_t_start_rotate);}
    5266:	22 23       	and	r18, r18
    5268:	09 f4       	brne	.+2      	; 0x526c <drive_rotate+0xbc>
    526a:	ca c1       	rjmp	.+916    	; 0x5600 <drive_rotate+0x450>
    526c:	8f ec       	ldi	r24, 0xCF	; 207
    526e:	97 e2       	ldi	r25, 0x27	; 39
    5270:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    5274:	60 91 47 05 	lds	r22, 0x0547
    5278:	70 91 48 05 	lds	r23, 0x0548
    527c:	80 91 49 05 	lds	r24, 0x0549
    5280:	90 91 4a 05 	lds	r25, 0x054A
    5284:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    5288:	81 eb       	ldi	r24, 0xB1	; 177
    528a:	97 e2       	ldi	r25, 0x27	; 39
    528c:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    5290:	60 91 9d 05 	lds	r22, 0x059D
    5294:	70 91 9e 05 	lds	r23, 0x059E
    5298:	80 91 9f 05 	lds	r24, 0x059F
    529c:	90 91 a0 05 	lds	r25, 0x05A0
    52a0:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    52a4:	ad c1       	rjmp	.+858    	; 0x5600 <drive_rotate+0x450>
    52a6:	40 91 0e 17 	lds	r20, 0x170E
    52aa:	50 91 0f 17 	lds	r21, 0x170F
    52ae:	60 91 10 17 	lds	r22, 0x1710
    52b2:	70 91 11 17 	lds	r23, 0x1711
    52b6:	80 90 9d 05 	lds	r8, 0x059D
    52ba:	90 90 9e 05 	lds	r9, 0x059E
    52be:	a0 90 9f 05 	lds	r10, 0x059F
    52c2:	b0 90 a0 05 	lds	r11, 0x05A0
    52c6:	6f 01       	movw	r12, r30
    52c8:	ee 24       	eor	r14, r14
    52ca:	d7 fc       	sbrc	r13, 7
    52cc:	e0 94       	com	r14
    52ce:	fe 2c       	mov	r15, r14
						break;
						
		case ROTATE: 
		
							if(angle > 0)
								steer_rotate = ((um6_psi_t_start_rotate + angle + UM6_ROTATE_OFFSET) - um6.psi_t) * KP_ROTATE;
    52d0:	97 01       	movw	r18, r14
    52d2:	86 01       	movw	r16, r12
    52d4:	08 0d       	add	r16, r8
    52d6:	19 1d       	adc	r17, r9
    52d8:	2a 1d       	adc	r18, r10
    52da:	3b 1d       	adc	r19, r11
							
						break;
						
		case ROTATE: 
		
							if(angle > 0)
    52dc:	1e 16       	cp	r1, r30
    52de:	1f 06       	cpc	r1, r31
    52e0:	2c f4       	brge	.+10     	; 0x52ec <drive_rotate+0x13c>
								steer_rotate = ((um6_psi_t_start_rotate + angle + UM6_ROTATE_OFFSET) - um6.psi_t) * KP_ROTATE;
    52e2:	03 50       	subi	r16, 0x03	; 3
    52e4:	11 09       	sbc	r17, r1
    52e6:	21 09       	sbc	r18, r1
    52e8:	31 09       	sbc	r19, r1
    52ea:	04 c0       	rjmp	.+8      	; 0x52f4 <drive_rotate+0x144>
							else
								steer_rotate = ((um6_psi_t_start_rotate + angle - UM6_ROTATE_OFFSET) - um6.psi_t) * KP_ROTATE;
    52ec:	0d 5f       	subi	r16, 0xFD	; 253
    52ee:	1f 4f       	sbci	r17, 0xFF	; 255
    52f0:	2f 4f       	sbci	r18, 0xFF	; 255
    52f2:	3f 4f       	sbci	r19, 0xFF	; 255
    52f4:	04 1b       	sub	r16, r20
    52f6:	15 0b       	sbc	r17, r21
    52f8:	26 0b       	sbc	r18, r22
    52fa:	37 0b       	sbc	r19, r23
    52fc:	c8 01       	movw	r24, r16
    52fe:	88 0f       	add	r24, r24
    5300:	99 1f       	adc	r25, r25
    5302:	80 0f       	add	r24, r16
    5304:	91 1f       	adc	r25, r17
    5306:	90 93 94 05 	sts	0x0594, r25
    530a:	80 93 93 05 	sts	0x0593, r24
							
							rotate_progress = abs((um6.psi_t - um6_psi_t_start_rotate)*100)/angle;
    530e:	48 19       	sub	r20, r8
    5310:	59 09       	sbc	r21, r9
    5312:	6a 09       	sbc	r22, r10
    5314:	7b 09       	sbc	r23, r11
    5316:	24 e6       	ldi	r18, 0x64	; 100
    5318:	24 9f       	mul	r18, r20
    531a:	c0 01       	movw	r24, r0
    531c:	25 9f       	mul	r18, r21
    531e:	90 0d       	add	r25, r0
    5320:	11 24       	eor	r1, r1
    5322:	97 ff       	sbrs	r25, 7
    5324:	03 c0       	rjmp	.+6      	; 0x532c <drive_rotate+0x17c>
    5326:	91 95       	neg	r25
    5328:	81 95       	neg	r24
    532a:	91 09       	sbc	r25, r1
    532c:	bf 01       	movw	r22, r30
    532e:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    5332:	60 93 91 05 	sts	0x0591, r22

							if(check_um6 != 0)
    5336:	80 91 65 05 	lds	r24, 0x0565
    533a:	88 23       	and	r24, r24
    533c:	19 f0       	breq	.+6      	; 0x5344 <drive_rotate+0x194>
							{
								rotate_enc = 1;
    533e:	81 e0       	ldi	r24, 0x01	; 1
    5340:	80 93 92 05 	sts	0x0592, r24
							}

							if(rotate_enc)
    5344:	80 91 92 05 	lds	r24, 0x0592
    5348:	88 23       	and	r24, r24
    534a:	09 f4       	brne	.+2      	; 0x534e <drive_rotate+0x19e>
    534c:	e3 c0       	rjmp	.+454    	; 0x5514 <drive_rotate+0x364>
    534e:	40 90 6b 16 	lds	r4, 0x166B
    5352:	50 90 6c 16 	lds	r5, 0x166C
    5356:	60 90 6d 16 	lds	r6, 0x166D
    535a:	70 90 6e 16 	lds	r7, 0x166E
    535e:	80 90 99 05 	lds	r8, 0x0599
    5362:	90 90 9a 05 	lds	r9, 0x059A
    5366:	a0 90 9b 05 	lds	r10, 0x059B
    536a:	b0 90 9c 05 	lds	r11, 0x059C
							{
								if(angle > 0)
								{
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));
    536e:	c7 01       	movw	r24, r14
    5370:	b6 01       	movw	r22, r12
								rotate_enc = 1;
							}

							if(rotate_enc)
							{
								if(angle > 0)
    5372:	1e 16       	cp	r1, r30
    5374:	1f 06       	cpc	r1, r31
    5376:	0c f0       	brlt	.+2      	; 0x537a <drive_rotate+0x1ca>
    5378:	61 c0       	rjmp	.+194    	; 0x543c <drive_rotate+0x28c>
								{
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));
    537a:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    537e:	2a e9       	ldi	r18, 0x9A	; 154
    5380:	39 e9       	ldi	r19, 0x99	; 153
    5382:	49 e9       	ldi	r20, 0x99	; 153
    5384:	50 e4       	ldi	r21, 0x40	; 64
    5386:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    538a:	6b 01       	movw	r12, r22
    538c:	7c 01       	movw	r14, r24
    538e:	a4 e6       	ldi	r26, 0x64	; 100
    5390:	b0 e0       	ldi	r27, 0x00	; 0
    5392:	a3 01       	movw	r20, r6
    5394:	92 01       	movw	r18, r4
    5396:	28 19       	sub	r18, r8
    5398:	39 09       	sbc	r19, r9
    539a:	4a 09       	sbc	r20, r10
    539c:	5b 09       	sbc	r21, r11
    539e:	0e 94 35 6b 	call	0xd66a	; 0xd66a <__muluhisi3>
    53a2:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    53a6:	a7 01       	movw	r20, r14
    53a8:	96 01       	movw	r18, r12
    53aa:	0e 94 7d 69 	call	0xd2fa	; 0xd2fa <__divsf3>
    53ae:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    53b2:	9b 01       	movw	r18, r22
    53b4:	77 ff       	sbrs	r23, 7
    53b6:	04 c0       	rjmp	.+8      	; 0x53c0 <drive_rotate+0x210>
    53b8:	22 27       	eor	r18, r18
    53ba:	33 27       	eor	r19, r19
    53bc:	26 1b       	sub	r18, r22
    53be:	37 0b       	sbc	r19, r23
    53c0:	20 93 91 05 	sts	0x0591, r18

									if((mot.d[LEFT].enc < (enc_l_start_rotate + (ENC_DEGROTFAC * angle))) ||
    53c4:	c3 01       	movw	r24, r6
    53c6:	b2 01       	movw	r22, r4
    53c8:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    53cc:	2b 01       	movw	r4, r22
    53ce:	3c 01       	movw	r6, r24
    53d0:	c5 01       	movw	r24, r10
    53d2:	b4 01       	movw	r22, r8
    53d4:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    53d8:	a7 01       	movw	r20, r14
    53da:	96 01       	movw	r18, r12
    53dc:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    53e0:	9b 01       	movw	r18, r22
    53e2:	ac 01       	movw	r20, r24
    53e4:	c3 01       	movw	r24, r6
    53e6:	b2 01       	movw	r22, r4
    53e8:	0e 94 79 69 	call	0xd2f2	; 0xd2f2 <__cmpsf2>
    53ec:	87 fd       	sbrc	r24, 7
    53ee:	23 c0       	rjmp	.+70     	; 0x5436 <drive_rotate+0x286>
										 (mot.d[RIGHT].enc > (enc_r_start_rotate + (ENC_DEGROTFAC * angle))))
    53f0:	60 91 77 16 	lds	r22, 0x1677
    53f4:	70 91 78 16 	lds	r23, 0x1678
    53f8:	80 91 79 16 	lds	r24, 0x1679
    53fc:	90 91 7a 16 	lds	r25, 0x167A
    5400:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5404:	4b 01       	movw	r8, r22
    5406:	5c 01       	movw	r10, r24
    5408:	60 91 95 05 	lds	r22, 0x0595
    540c:	70 91 96 05 	lds	r23, 0x0596
    5410:	80 91 97 05 	lds	r24, 0x0597
    5414:	90 91 98 05 	lds	r25, 0x0598
    5418:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    541c:	a7 01       	movw	r20, r14
    541e:	96 01       	movw	r18, r12
    5420:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5424:	9b 01       	movw	r18, r22
    5426:	ac 01       	movw	r20, r24
							{
								if(angle > 0)
								{
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));

									if((mot.d[LEFT].enc < (enc_l_start_rotate + (ENC_DEGROTFAC * angle))) ||
    5428:	c5 01       	movw	r24, r10
    542a:	b4 01       	movw	r22, r8
    542c:	0e 94 c8 6a 	call	0xd590	; 0xd590 <__gesf2>
    5430:	18 16       	cp	r1, r24
    5432:	0c f0       	brlt	.+2      	; 0x5436 <drive_rotate+0x286>
    5434:	60 c0       	rjmp	.+192    	; 0x54f6 <drive_rotate+0x346>
										 (mot.d[RIGHT].enc > (enc_r_start_rotate + (ENC_DEGROTFAC * angle))))
									{
										steer_rotate = STEER_ROTATE_ENC;
    5436:	80 e5       	ldi	r24, 0x50	; 80
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	67 c0       	rjmp	.+206    	; 0x550a <drive_rotate+0x35a>
										steer_rotate = 0;
									}
								}
								else
								{
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));
    543c:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5440:	2a e9       	ldi	r18, 0x9A	; 154
    5442:	39 e9       	ldi	r19, 0x99	; 153
    5444:	49 e9       	ldi	r20, 0x99	; 153
    5446:	50 e4       	ldi	r21, 0x40	; 64
    5448:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    544c:	6b 01       	movw	r12, r22
    544e:	7c 01       	movw	r14, r24
    5450:	a4 e6       	ldi	r26, 0x64	; 100
    5452:	b0 e0       	ldi	r27, 0x00	; 0
    5454:	a3 01       	movw	r20, r6
    5456:	92 01       	movw	r18, r4
    5458:	28 19       	sub	r18, r8
    545a:	39 09       	sbc	r19, r9
    545c:	4a 09       	sbc	r20, r10
    545e:	5b 09       	sbc	r21, r11
    5460:	0e 94 35 6b 	call	0xd66a	; 0xd66a <__muluhisi3>
    5464:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5468:	a7 01       	movw	r20, r14
    546a:	96 01       	movw	r18, r12
    546c:	0e 94 7d 69 	call	0xd2fa	; 0xd2fa <__divsf3>
    5470:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5474:	9b 01       	movw	r18, r22
    5476:	77 ff       	sbrs	r23, 7
    5478:	04 c0       	rjmp	.+8      	; 0x5482 <drive_rotate+0x2d2>
    547a:	22 27       	eor	r18, r18
    547c:	33 27       	eor	r19, r19
    547e:	26 1b       	sub	r18, r22
    5480:	37 0b       	sbc	r19, r23
    5482:	20 93 91 05 	sts	0x0591, r18

									if((mot.d[LEFT].enc > (enc_l_start_rotate + (ENC_DEGROTFAC * angle))) ||
    5486:	c3 01       	movw	r24, r6
    5488:	b2 01       	movw	r22, r4
    548a:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    548e:	2b 01       	movw	r4, r22
    5490:	3c 01       	movw	r6, r24
    5492:	c5 01       	movw	r24, r10
    5494:	b4 01       	movw	r22, r8
    5496:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    549a:	a7 01       	movw	r20, r14
    549c:	96 01       	movw	r18, r12
    549e:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    54a2:	9b 01       	movw	r18, r22
    54a4:	ac 01       	movw	r20, r24
    54a6:	c3 01       	movw	r24, r6
    54a8:	b2 01       	movw	r22, r4
    54aa:	0e 94 c8 6a 	call	0xd590	; 0xd590 <__gesf2>
    54ae:	18 16       	cp	r1, r24
    54b0:	54 f1       	brlt	.+84     	; 0x5506 <drive_rotate+0x356>
										 (mot.d[RIGHT].enc < (enc_r_start_rotate + (ENC_DEGROTFAC * angle))))
    54b2:	60 91 77 16 	lds	r22, 0x1677
    54b6:	70 91 78 16 	lds	r23, 0x1678
    54ba:	80 91 79 16 	lds	r24, 0x1679
    54be:	90 91 7a 16 	lds	r25, 0x167A
    54c2:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    54c6:	4b 01       	movw	r8, r22
    54c8:	5c 01       	movw	r10, r24
    54ca:	60 91 95 05 	lds	r22, 0x0595
    54ce:	70 91 96 05 	lds	r23, 0x0596
    54d2:	80 91 97 05 	lds	r24, 0x0597
    54d6:	90 91 98 05 	lds	r25, 0x0598
    54da:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    54de:	a7 01       	movw	r20, r14
    54e0:	96 01       	movw	r18, r12
    54e2:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    54e6:	9b 01       	movw	r18, r22
    54e8:	ac 01       	movw	r20, r24
								}
								else
								{
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));

									if((mot.d[LEFT].enc > (enc_l_start_rotate + (ENC_DEGROTFAC * angle))) ||
    54ea:	c5 01       	movw	r24, r10
    54ec:	b4 01       	movw	r22, r8
    54ee:	0e 94 79 69 	call	0xd2f2	; 0xd2f2 <__cmpsf2>
    54f2:	87 fd       	sbrc	r24, 7
    54f4:	08 c0       	rjmp	.+16     	; 0x5506 <drive_rotate+0x356>
									{
										steer_rotate = STEER_ROTATE_ENC;
									}
									else
									{
										sm_rotate = ROTATE_END;
    54f6:	82 e0       	ldi	r24, 0x02	; 2
    54f8:	80 93 a1 05 	sts	0x05A1, r24
										steer_rotate = 0;
    54fc:	10 92 94 05 	sts	0x0594, r1
    5500:	10 92 93 05 	sts	0x0593, r1
    5504:	10 c0       	rjmp	.+32     	; 0x5526 <drive_rotate+0x376>
									rotate_progress = abs(((mot.d[LEFT].enc - enc_l_start_rotate)*100)/(angle * ENC_DEGROTFAC));

									if((mot.d[LEFT].enc > (enc_l_start_rotate + (ENC_DEGROTFAC * angle))) ||
										 (mot.d[RIGHT].enc < (enc_r_start_rotate + (ENC_DEGROTFAC * angle))))
									{
										steer_rotate = -STEER_ROTATE_ENC;
    5506:	80 eb       	ldi	r24, 0xB0	; 176
    5508:	9f ef       	ldi	r25, 0xFF	; 255
    550a:	90 93 94 05 	sts	0x0594, r25
    550e:	80 93 93 05 	sts	0x0593, r24
    5512:	09 c0       	rjmp	.+18     	; 0x5526 <drive_rotate+0x376>
										sm_rotate = ROTATE_END;
										steer_rotate = 0;
									}
								}
							}
							else if(steer_rotate == 0)
    5514:	80 91 93 05 	lds	r24, 0x0593
    5518:	90 91 94 05 	lds	r25, 0x0594
    551c:	89 2b       	or	r24, r25
    551e:	19 f4       	brne	.+6      	; 0x5526 <drive_rotate+0x376>
							{
								sm_rotate = ROTATE_END;	
    5520:	82 e0       	ldi	r24, 0x02	; 2
    5522:	80 93 a1 05 	sts	0x05A1, r24
							}

							if((abs(steer_rotate) < STEER_ROTATE_TH_TIMER) && (timer_drive == -1))
    5526:	80 91 93 05 	lds	r24, 0x0593
    552a:	90 91 94 05 	lds	r25, 0x0594
    552e:	9c 01       	movw	r18, r24
    5530:	2d 5e       	subi	r18, 0xED	; 237
    5532:	3f 4f       	sbci	r19, 0xFF	; 255
    5534:	27 32       	cpi	r18, 0x27	; 39
    5536:	31 05       	cpc	r19, r1
    5538:	68 f4       	brcc	.+26     	; 0x5554 <drive_rotate+0x3a4>
    553a:	20 91 95 02 	lds	r18, 0x0295
    553e:	30 91 96 02 	lds	r19, 0x0296
    5542:	2f 3f       	cpi	r18, 0xFF	; 255
    5544:	3f 4f       	sbci	r19, 0xFF	; 255
    5546:	31 f4       	brne	.+12     	; 0x5554 <drive_rotate+0x3a4>
							{
								timer_drive = TIMER_ROTATE_DEAD;
    5548:	28 e2       	ldi	r18, 0x28	; 40
    554a:	30 e0       	ldi	r19, 0x00	; 0
    554c:	30 93 96 02 	sts	0x0296, r19
    5550:	20 93 95 02 	sts	0x0295, r18
							}
							if((timer_drive == 0) || (steer_rotate == 0))
    5554:	20 91 95 02 	lds	r18, 0x0295
    5558:	30 91 96 02 	lds	r19, 0x0296
    555c:	23 2b       	or	r18, r19
    555e:	11 f0       	breq	.+4      	; 0x5564 <drive_rotate+0x3b4>
    5560:	00 97       	sbiw	r24, 0x00	; 0
    5562:	19 f4       	brne	.+6      	; 0x556a <drive_rotate+0x3ba>
							{
								sm_rotate = ROTATE_END;
    5564:	22 e0       	ldi	r18, 0x02	; 2
    5566:	20 93 a1 05 	sts	0x05A1, r18
							}

							mot.d[LEFT].speed.to = steer_rotate;
    556a:	90 93 6a 16 	sts	0x166A, r25
    556e:	80 93 69 16 	sts	0x1669, r24
							mot.d[RIGHT].speed.to = -steer_rotate;
    5572:	91 95       	neg	r25
    5574:	81 95       	neg	r24
    5576:	91 09       	sbc	r25, r1
    5578:	90 93 76 16 	sts	0x1676, r25
    557c:	80 93 75 16 	sts	0x1675, r24
							
							drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, maxspeed);
    5580:	4c 2f       	mov	r20, r28
    5582:	65 e7       	ldi	r22, 0x75	; 117
    5584:	76 e1       	ldi	r23, 0x16	; 22
    5586:	89 e6       	ldi	r24, 0x69	; 105
    5588:	96 e1       	ldi	r25, 0x16	; 22
    558a:	e9 dd       	rcall	.-1070   	; 0x515e <drive_limitSpeed>
    558c:	39 c0       	rjmp	.+114    	; 0x5600 <drive_rotate+0x450>
    558e:	10 92 6a 16 	sts	0x166A, r1

						break;
						
		case ROTATE_END:
		
							mot.d[LEFT].speed.to = 0;
    5592:	10 92 69 16 	sts	0x1669, r1
    5596:	10 92 76 16 	sts	0x1676, r1
							mot.d[RIGHT].speed.to = 0;
    559a:	10 92 75 16 	sts	0x1675, r1
    559e:	8f ef       	ldi	r24, 0xFF	; 255
							timer_drive = -1;
    55a0:	9f ef       	ldi	r25, 0xFF	; 255
    55a2:	90 93 96 02 	sts	0x0296, r25
    55a6:	80 93 95 02 	sts	0x0295, r24
    55aa:	10 92 a1 05 	sts	0x05A1, r1
							sm_rotate = ROTATE_INIT;
    55ae:	22 23       	and	r18, r18
							returnvar = 0;
						
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_oneTile(): done. "));}
    55b0:	29 f1       	breq	.+74     	; 0x55fc <drive_rotate+0x44c>
    55b2:	8e ea       	ldi	r24, 0xAE	; 174
    55b4:	97 e2       	ldi	r25, 0x27	; 39
    55b6:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    55ba:	60 91 47 05 	lds	r22, 0x0547
    55be:	70 91 48 05 	lds	r23, 0x0548
    55c2:	80 91 49 05 	lds	r24, 0x0549
    55c6:	90 91 4a 05 	lds	r25, 0x054A
    55ca:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    55ce:	84 e9       	ldi	r24, 0x94	; 148
    55d0:	97 e2       	ldi	r25, 0x27	; 39
    55d2:	12 c0       	rjmp	.+36     	; 0x55f8 <drive_rotate+0x448>
    55d4:	22 30       	cpi	r18, 0x02	; 2
							
						break;
						
		default:	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": FATAL ERROR: WENT INTO drive_rotate():sm_rotate DEFAULT CASE!"));}
    55d6:	90 f0       	brcs	.+36     	; 0x55fc <drive_rotate+0x44c>
    55d8:	81 e9       	ldi	r24, 0x91	; 145
    55da:	97 e2       	ldi	r25, 0x27	; 39
    55dc:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    55e0:	60 91 47 05 	lds	r22, 0x0547
    55e4:	70 91 48 05 	lds	r23, 0x0548
    55e8:	80 91 49 05 	lds	r24, 0x0549
    55ec:	90 91 4a 05 	lds	r25, 0x054A
    55f0:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    55f4:	81 e5       	ldi	r24, 0x51	; 81
    55f6:	97 e2       	ldi	r25, 0x27	; 39
    55f8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    55fc:	80 e0       	ldi	r24, 0x00	; 0
						
						returnvar = 0;
    55fe:	01 c0       	rjmp	.+2      	; 0x5602 <drive_rotate+0x452>
    5600:	81 e0       	ldi	r24, 0x01	; 1

#define STEER_ROTATE_TH_TIMER 20 //Unter diesem Wert (Betrag) wird ein Timer aktivierter, in dem Zeitraum 0 erreicht werden muss, ansonsten abbruch.

uint8_t drive_rotate(int16_t angle, uint8_t maxspeed)
{
	uint8_t returnvar = 1;
    5602:	cf 91       	pop	r28
						returnvar = 0;
						break;
	}
	
	return returnvar;
}
    5604:	1f 91       	pop	r17
    5606:	0f 91       	pop	r16
    5608:	ff 90       	pop	r15
    560a:	ef 90       	pop	r14
    560c:	df 90       	pop	r13
    560e:	cf 90       	pop	r12
    5610:	bf 90       	pop	r11
    5612:	af 90       	pop	r10
    5614:	9f 90       	pop	r9
    5616:	8f 90       	pop	r8
    5618:	7f 90       	pop	r7
    561a:	6f 90       	pop	r6
    561c:	5f 90       	pop	r5
    561e:	4f 90       	pop	r4
    5620:	08 95       	ret

00005622 <drive_align>:


uint8_t sm_driveAlign = 0;

uint8_t drive_align(void)
{
    5622:	cf 93       	push	r28
	uint8_t returnvar = 1;
	
	switch(sm_driveAlign)
    5624:	80 91 8e 05 	lds	r24, 0x058E
    5628:	81 30       	cpi	r24, 0x01	; 1
    562a:	f1 f0       	breq	.+60     	; 0x5668 <drive_align+0x46>
    562c:	88 f0       	brcs	.+34     	; 0x5650 <drive_align+0x2e>
    562e:	82 30       	cpi	r24, 0x02	; 2
    5630:	09 f0       	breq	.+2      	; 0x5634 <drive_align+0x12>
    5632:	bd c0       	rjmp	.+378    	; 0x57ae <drive_align+0x18c>
						if((abs(steer_turn) <= STEER_ALIGN_DONE) || (timer_drive == 0))
							sm_driveAlign = 2;
							
					break;
					
		case 2:			steer_turn = 0;
    5634:	10 92 90 05 	sts	0x0590, r1
    5638:	10 92 8f 05 	sts	0x058F, r1
						timer_drive = -1;
    563c:	8f ef       	ldi	r24, 0xFF	; 255
    563e:	9f ef       	ldi	r25, 0xFF	; 255
    5640:	90 93 96 02 	sts	0x0296, r25
    5644:	80 93 95 02 	sts	0x0295, r24
						sm_driveAlign = 0;
    5648:	10 92 8e 05 	sts	0x058E, r1
						returnvar = 0;
    564c:	c0 e0       	ldi	r28, 0x00	; 0
					break;
    564e:	b0 c0       	rjmp	.+352    	; 0x57b0 <drive_align+0x18e>
	uint8_t returnvar = 1;
	
	switch(sm_driveAlign)
	{
		case 0:
						steer_turn = 0;
    5650:	10 92 90 05 	sts	0x0590, r1
    5654:	10 92 8f 05 	sts	0x058F, r1
						timer_drive = TIMER_ALIGN_DEAD;
    5658:	84 e1       	ldi	r24, 0x14	; 20
    565a:	90 e0       	ldi	r25, 0x00	; 0
    565c:	90 93 96 02 	sts	0x0296, r25
    5660:	80 93 95 02 	sts	0x0295, r24
						
						sm_driveAlign = 1;
    5664:	81 e0       	ldi	r24, 0x01	; 1
    5666:	a1 c0       	rjmp	.+322    	; 0x57aa <drive_align+0x188>
						
					break;
					
		case 1:
						if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    5668:	80 91 ae 07 	lds	r24, 0x07AE
    566c:	90 91 af 07 	lds	r25, 0x07AF
    5670:	84 36       	cpi	r24, 0x64	; 100
    5672:	91 05       	cpc	r25, r1
    5674:	a4 f4       	brge	.+40     	; 0x569e <drive_align+0x7c>
							 (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH) &&
    5676:	20 91 b0 07 	lds	r18, 0x07B0
    567a:	30 91 b1 07 	lds	r19, 0x07B1
						sm_driveAlign = 1;
						
					break;
					
		case 1:
						if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    567e:	24 36       	cpi	r18, 0x64	; 100
    5680:	31 05       	cpc	r19, r1
    5682:	6c f4       	brge	.+26     	; 0x569e <drive_align+0x7c>
							 (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH) &&
							 (abs(dist[LIN][RIGHT][FRONT] - dist[LIN][RIGHT][BACK]) < TURN_SENSDIFF_MAX))
    5684:	bc 01       	movw	r22, r24
    5686:	62 1b       	sub	r22, r18
    5688:	73 0b       	sbc	r23, r19
    568a:	ab 01       	movw	r20, r22
    568c:	4b 56       	subi	r20, 0x6B	; 107
    568e:	5f 4f       	sbci	r21, 0xFF	; 255
						
					break;
					
		case 1:
						if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
							 (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH) &&
    5690:	4b 32       	cpi	r20, 0x2B	; 43
    5692:	51 40       	sbci	r21, 0x01	; 1
    5694:	20 f4       	brcc	.+8      	; 0x569e <drive_align+0x7c>
							 (abs(dist[LIN][RIGHT][FRONT] - dist[LIN][RIGHT][BACK]) < TURN_SENSDIFF_MAX))
						{
							if(dist[LIN][RIGHT][FRONT] > dist[LIN][RIGHT][BACK])
    5696:	28 17       	cp	r18, r24
    5698:	39 07       	cpc	r19, r25
    569a:	fc f4       	brge	.+62     	; 0x56da <drive_align+0xb8>
    569c:	4b c0       	rjmp	.+150    	; 0x5734 <drive_align+0x112>
							else
							{
								steer_turn = (dist[LIN][RIGHT][FRONT] - (dist[LIN][RIGHT][BACK] + ALIGN_OFFSET_RIGHT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    569e:	80 91 a6 07 	lds	r24, 0x07A6
    56a2:	90 91 a7 07 	lds	r25, 0x07A7
    56a6:	84 36       	cpi	r24, 0x64	; 100
    56a8:	91 05       	cpc	r25, r1
    56aa:	54 f5       	brge	.+84     	; 0x5700 <drive_align+0xde>
										(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH) &&
    56ac:	20 91 a8 07 	lds	r18, 0x07A8
    56b0:	30 91 a9 07 	lds	r19, 0x07A9
							else
							{
								steer_turn = (dist[LIN][RIGHT][FRONT] - (dist[LIN][RIGHT][BACK] + ALIGN_OFFSET_RIGHT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    56b4:	24 36       	cpi	r18, 0x64	; 100
    56b6:	31 05       	cpc	r19, r1
    56b8:	1c f5       	brge	.+70     	; 0x5700 <drive_align+0xde>
										(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH) &&
										(abs(dist[LIN][LEFT][FRONT] - dist[LIN][LEFT][BACK]) < TURN_SENSDIFF_MAX))
    56ba:	bc 01       	movw	r22, r24
    56bc:	62 1b       	sub	r22, r18
    56be:	73 0b       	sbc	r23, r19
    56c0:	ab 01       	movw	r20, r22
    56c2:	4b 56       	subi	r20, 0x6B	; 107
    56c4:	5f 4f       	sbci	r21, 0xFF	; 255
							{
								steer_turn = (dist[LIN][RIGHT][FRONT] - (dist[LIN][RIGHT][BACK] + ALIGN_OFFSET_RIGHT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
										(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH) &&
    56c6:	4b 32       	cpi	r20, 0x2B	; 43
    56c8:	51 40       	sbci	r21, 0x01	; 1
    56ca:	d0 f4       	brcc	.+52     	; 0x5700 <drive_align+0xde>
										(abs(dist[LIN][LEFT][FRONT] - dist[LIN][LEFT][BACK]) < TURN_SENSDIFF_MAX))
						{
							if(dist[LIN][LEFT][FRONT] > dist[LIN][LEFT][BACK])
    56cc:	28 17       	cp	r18, r24
    56ce:	39 07       	cpc	r19, r25
    56d0:	0c f0       	brlt	.+2      	; 0x56d4 <drive_align+0xb2>
    56d2:	4f c0       	rjmp	.+158    	; 0x5772 <drive_align+0x150>
							{
								steer_turn = ((dist[LIN][LEFT][BACK] + ALIGN_OFFSET_LEFT) - dist[LIN][LEFT][FRONT]) * KP_ALIGN;
    56d4:	b9 01       	movw	r22, r18
    56d6:	68 1b       	sub	r22, r24
    56d8:	79 0b       	sbc	r23, r25
    56da:	88 27       	eor	r24, r24
    56dc:	77 fd       	sbrc	r23, 7
    56de:	80 95       	com	r24
    56e0:	98 2f       	mov	r25, r24
    56e2:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    56e6:	26 e6       	ldi	r18, 0x66	; 102
    56e8:	36 e6       	ldi	r19, 0x66	; 102
    56ea:	46 ee       	ldi	r20, 0xE6	; 230
    56ec:	5f e3       	ldi	r21, 0x3F	; 63
    56ee:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    56f2:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    56f6:	70 93 90 05 	sts	0x0590, r23
    56fa:	60 93 8f 05 	sts	0x058F, r22
    56fe:	47 c0       	rjmp	.+142    	; 0x578e <drive_align+0x16c>
							else
							{
								steer_turn = (dist[LIN][LEFT][FRONT] - (dist[LIN][LEFT][BACK] + ALIGN_OFFSET_LEFT)) * -KP_ALIGN;
							}
						}
						else if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    5700:	80 91 b2 07 	lds	r24, 0x07B2
    5704:	90 91 b3 07 	lds	r25, 0x07B3
    5708:	84 36       	cpi	r24, 0x64	; 100
    570a:	91 05       	cpc	r25, r1
    570c:	bc f4       	brge	.+46     	; 0x573c <drive_align+0x11a>
										(dist[LIN][FRONT][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
    570e:	20 91 b4 07 	lds	r18, 0x07B4
    5712:	30 91 b5 07 	lds	r19, 0x07B5
							else
							{
								steer_turn = (dist[LIN][LEFT][FRONT] - (dist[LIN][LEFT][BACK] + ALIGN_OFFSET_LEFT)) * -KP_ALIGN;
							}
						}
						else if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    5716:	24 36       	cpi	r18, 0x64	; 100
    5718:	31 05       	cpc	r19, r1
    571a:	84 f4       	brge	.+32     	; 0x573c <drive_align+0x11a>
										(dist[LIN][FRONT][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
										(abs(dist[LIN][FRONT][LEFT] - dist[LIN][FRONT][RIGHT]) < TURN_SENSDIFF_MAX))
    571c:	bc 01       	movw	r22, r24
    571e:	62 1b       	sub	r22, r18
    5720:	73 0b       	sbc	r23, r19
    5722:	ab 01       	movw	r20, r22
    5724:	4b 56       	subi	r20, 0x6B	; 107
    5726:	5f 4f       	sbci	r21, 0xFF	; 255
							{
								steer_turn = (dist[LIN][LEFT][FRONT] - (dist[LIN][LEFT][BACK] + ALIGN_OFFSET_LEFT)) * -KP_ALIGN;
							}
						}
						else if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
										(dist[LIN][FRONT][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
    5728:	4b 32       	cpi	r20, 0x2B	; 43
    572a:	51 40       	sbci	r21, 0x01	; 1
    572c:	38 f4       	brcc	.+14     	; 0x573c <drive_align+0x11a>
										(abs(dist[LIN][FRONT][LEFT] - dist[LIN][FRONT][RIGHT]) < TURN_SENSDIFF_MAX))
						{
							if(dist[LIN][FRONT][LEFT] < dist[LIN][FRONT][RIGHT])
    572e:	82 17       	cp	r24, r18
    5730:	93 07       	cpc	r25, r19
    5732:	9c f6       	brge	.-90     	; 0x56da <drive_align+0xb8>
							{
								steer_turn = ((dist[LIN][FRONT][RIGHT] + ALIGN_OFFSET_FRONT) - dist[LIN][FRONT][LEFT]) * -KP_ALIGN;
    5734:	b9 01       	movw	r22, r18
    5736:	68 1b       	sub	r22, r24
    5738:	79 0b       	sbc	r23, r25
    573a:	1b c0       	rjmp	.+54     	; 0x5772 <drive_align+0x150>
							else
							{
								steer_turn = (dist[LIN][FRONT][LEFT] - (dist[LIN][FRONT][RIGHT] + ALIGN_OFFSET_FRONT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][BACK][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    573c:	80 91 ba 07 	lds	r24, 0x07BA
    5740:	90 91 bb 07 	lds	r25, 0x07BB
    5744:	84 36       	cpi	r24, 0x64	; 100
    5746:	91 05       	cpc	r25, r1
    5748:	fc f4       	brge	.+62     	; 0x5788 <drive_align+0x166>
										(dist[LIN][BACK][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
    574a:	20 91 bc 07 	lds	r18, 0x07BC
    574e:	30 91 bd 07 	lds	r19, 0x07BD
							else
							{
								steer_turn = (dist[LIN][FRONT][LEFT] - (dist[LIN][FRONT][RIGHT] + ALIGN_OFFSET_FRONT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][BACK][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    5752:	24 36       	cpi	r18, 0x64	; 100
    5754:	31 05       	cpc	r19, r1
    5756:	c4 f4       	brge	.+48     	; 0x5788 <drive_align+0x166>
										(dist[LIN][BACK][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
										(abs(dist[LIN][BACK][LEFT] - dist[LIN][BACK][RIGHT]) < TURN_SENSDIFF_MAX))
    5758:	bc 01       	movw	r22, r24
    575a:	62 1b       	sub	r22, r18
    575c:	73 0b       	sbc	r23, r19
    575e:	ab 01       	movw	r20, r22
    5760:	4b 56       	subi	r20, 0x6B	; 107
    5762:	5f 4f       	sbci	r21, 0xFF	; 255
							{
								steer_turn = (dist[LIN][FRONT][LEFT] - (dist[LIN][FRONT][RIGHT] + ALIGN_OFFSET_FRONT)) * KP_ALIGN;
							}
						}
						else if((dist[LIN][BACK][LEFT] < TILE1_SIDE_ALIGN_TH) &&
										(dist[LIN][BACK][RIGHT] < TILE1_SIDE_ALIGN_TH) &&
    5764:	4b 32       	cpi	r20, 0x2B	; 43
    5766:	51 40       	sbci	r21, 0x01	; 1
    5768:	78 f4       	brcc	.+30     	; 0x5788 <drive_align+0x166>
										(abs(dist[LIN][BACK][LEFT] - dist[LIN][BACK][RIGHT]) < TURN_SENSDIFF_MAX))
						{
							if(dist[LIN][BACK][LEFT] < dist[LIN][BACK][RIGHT])
    576a:	82 17       	cp	r24, r18
    576c:	93 07       	cpc	r25, r19
    576e:	0c f4       	brge	.+2      	; 0x5772 <drive_align+0x150>
    5770:	b1 cf       	rjmp	.-158    	; 0x56d4 <drive_align+0xb2>
							{
								steer_turn = ((dist[LIN][BACK][RIGHT] + ALIGN_OFFSET_BACK) - dist[LIN][BACK][LEFT]) * KP_ALIGN;
							}
							else
							{
								steer_turn = (dist[LIN][BACK][LEFT] - (dist[LIN][BACK][RIGHT] + ALIGN_OFFSET_BACK)) * -KP_ALIGN;
    5772:	88 27       	eor	r24, r24
    5774:	77 fd       	sbrc	r23, 7
    5776:	80 95       	com	r24
    5778:	98 2f       	mov	r25, r24
    577a:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    577e:	26 e6       	ldi	r18, 0x66	; 102
    5780:	36 e6       	ldi	r19, 0x66	; 102
    5782:	46 ee       	ldi	r20, 0xE6	; 230
    5784:	5f eb       	ldi	r21, 0xBF	; 191
    5786:	b3 cf       	rjmp	.-154    	; 0x56ee <drive_align+0xcc>
							}
						}
						else
						{
							sm_driveAlign = 2;
    5788:	82 e0       	ldi	r24, 0x02	; 2
    578a:	80 93 8e 05 	sts	0x058E, r24
						}
						
						if((abs(steer_turn) <= STEER_ALIGN_DONE) || (timer_drive == 0))
    578e:	80 91 8f 05 	lds	r24, 0x058F
    5792:	90 91 90 05 	lds	r25, 0x0590
    5796:	01 96       	adiw	r24, 0x01	; 1
    5798:	03 97       	sbiw	r24, 0x03	; 3
    579a:	30 f0       	brcs	.+12     	; 0x57a8 <drive_align+0x186>
    579c:	80 91 95 02 	lds	r24, 0x0295
    57a0:	90 91 96 02 	lds	r25, 0x0296
    57a4:	89 2b       	or	r24, r25
    57a6:	19 f4       	brne	.+6      	; 0x57ae <drive_align+0x18c>
							sm_driveAlign = 2;
    57a8:	82 e0       	ldi	r24, 0x02	; 2
    57aa:	80 93 8e 05 	sts	0x058E, r24

uint8_t sm_driveAlign = 0;

uint8_t drive_align(void)
{
	uint8_t returnvar = 1;
    57ae:	c1 e0       	ldi	r28, 0x01	; 1
						sm_driveAlign = 0;
						returnvar = 0;
					break;
	}
	
	mot.d[LEFT].speed.to = steer_turn;
    57b0:	20 91 8f 05 	lds	r18, 0x058F
    57b4:	30 91 90 05 	lds	r19, 0x0590
    57b8:	30 93 6a 16 	sts	0x166A, r19
    57bc:	20 93 69 16 	sts	0x1669, r18
	mot.d[RIGHT].speed.to = -steer_turn;
    57c0:	31 95       	neg	r19
    57c2:	21 95       	neg	r18
    57c4:	31 09       	sbc	r19, r1
    57c6:	30 93 76 16 	sts	0x1676, r19
    57ca:	20 93 75 16 	sts	0x1675, r18

	drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, MAXSPEED);
    57ce:	44 e6       	ldi	r20, 0x64	; 100
    57d0:	65 e7       	ldi	r22, 0x75	; 117
    57d2:	76 e1       	ldi	r23, 0x16	; 22
    57d4:	89 e6       	ldi	r24, 0x69	; 105
    57d6:	96 e1       	ldi	r25, 0x16	; 22
    57d8:	c2 dc       	rcall	.-1660   	; 0x515e <drive_limitSpeed>
    57da:	8c 2f       	mov	r24, r28
	
	return returnvar;
}
    57dc:	cf 91       	pop	r28
    57de:	08 95       	ret

000057e0 <drive_oneTile>:
int16_t um6_phi_t_start_dot = 0; //Slow down when getting odd (Ramp etc.)

//////////////////////////////////

uint8_t drive_oneTile(uint8_t abort)
{
    57e0:	2f 92       	push	r2
    57e2:	3f 92       	push	r3
    57e4:	4f 92       	push	r4
    57e6:	5f 92       	push	r5
    57e8:	6f 92       	push	r6
    57ea:	7f 92       	push	r7
    57ec:	8f 92       	push	r8
    57ee:	9f 92       	push	r9
    57f0:	af 92       	push	r10
    57f2:	bf 92       	push	r11
    57f4:	cf 92       	push	r12
    57f6:	df 92       	push	r13
    57f8:	ef 92       	push	r14
    57fa:	ff 92       	push	r15
    57fc:	1f 93       	push	r17
    57fe:	cf 93       	push	r28
    5800:	df 93       	push	r29
    5802:	00 d0       	rcall	.+0      	; 0x5804 <drive_oneTile+0x24>
    5804:	1f 92       	push	r1
    5806:	cd b7       	in	r28, 0x3d	; 61
    5808:	de b7       	in	r29, 0x3e	; 62
    580a:	18 2f       	mov	r17, r24
	uint8_t returnvar = 0;
	int16_t maxspeed = MAXSPEED;

	int16_t rel_angle = 0;

	int16_t robot_angleToRightWall = robot_getAngleToWall(EAST);
    580c:	82 e0       	ldi	r24, 0x02	; 2
    580e:	0e 94 d9 35 	call	0x6bb2	; 0x6bb2 <robot_getAngleToWall>
    5812:	6c 01       	movw	r12, r24
	int16_t robot_angleToLeftWall = robot_getAngleToWall(WEST);
    5814:	84 e0       	ldi	r24, 0x04	; 4
    5816:	0e 94 d9 35 	call	0x6bb2	; 0x6bb2 <robot_getAngleToWall>
    581a:	7c 01       	movw	r14, r24

	switch(sm_dot)
    581c:	80 91 ad 05 	lds	r24, 0x05AD
    5820:	90 e0       	ldi	r25, 0x00	; 0
    5822:	8a 30       	cpi	r24, 0x0A	; 10
    5824:	91 05       	cpc	r25, r1
    5826:	08 f0       	brcs	.+2      	; 0x582a <drive_oneTile+0x4a>
    5828:	78 c4       	rjmp	.+2288   	; 0x611a <drive_oneTile+0x93a>
    582a:	fc 01       	movw	r30, r24
    582c:	eb 56       	subi	r30, 0x6B	; 107
    582e:	ff 4f       	sbci	r31, 0xFF	; 255
    5830:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
	{
		case DOT_INIT:
		
							enc_dot_comp[LEFT] = mot.d[LEFT].enc;
    5834:	80 91 6b 16 	lds	r24, 0x166B
    5838:	90 91 6c 16 	lds	r25, 0x166C
    583c:	a0 91 6d 16 	lds	r26, 0x166D
    5840:	b0 91 6e 16 	lds	r27, 0x166E
    5844:	80 93 74 07 	sts	0x0774, r24
    5848:	90 93 75 07 	sts	0x0775, r25
    584c:	a0 93 76 07 	sts	0x0776, r26
    5850:	b0 93 77 07 	sts	0x0777, r27
							enc_dot_comp[RIGHT] = mot.d[RIGHT].enc;
    5854:	80 91 77 16 	lds	r24, 0x1677
    5858:	90 91 78 16 	lds	r25, 0x1678
    585c:	a0 91 79 16 	lds	r26, 0x1679
    5860:	b0 91 7a 16 	lds	r27, 0x167A
    5864:	80 93 78 07 	sts	0x0778, r24
    5868:	90 93 79 07 	sts	0x0779, r25
    586c:	a0 93 7a 07 	sts	0x077A, r26
    5870:	b0 93 7b 07 	sts	0x077B, r27
							enc_lr_add_dot = 0;
    5874:	10 92 a5 05 	sts	0x05A5, r1
    5878:	10 92 a4 05 	sts	0x05A4, r1

							um6_phi_t_start_dot = um6.phi_t;
    587c:	80 91 04 17 	lds	r24, 0x1704
    5880:	90 91 05 17 	lds	r25, 0x1705
    5884:	90 93 a3 05 	sts	0x05A3, r25
    5888:	80 93 a2 05 	sts	0x05A2, r24

							dot_tile_middle = 0;
    588c:	10 92 ae 05 	sts	0x05AE, r1
							dot_aligned_turn = NONE;
    5890:	10 92 ac 05 	sts	0x05AC, r1
							timer_drive = -1;
    5894:	8f ef       	ldi	r24, 0xFF	; 255
    5896:	9f ef       	ldi	r25, 0xFF	; 255
    5898:	90 93 96 02 	sts	0x0296, r25
    589c:	80 93 95 02 	sts	0x0295, r24
							steer_dot = 0;
    58a0:	10 92 b4 05 	sts	0x05B4, r1
    58a4:	10 92 b3 05 	sts	0x05B3, r1

							if(dist[LIN][FRONT][FRONT] < TILE1_FRONT_FRONT) //weiter als hier geht nicht!
    58a8:	80 91 b6 07 	lds	r24, 0x07B6
    58ac:	90 91 b7 07 	lds	r25, 0x07B7
    58b0:	8a 35       	cpi	r24, 0x5A	; 90
    58b2:	91 05       	cpc	r25, r1
    58b4:	b4 f4       	brge	.+44     	; 0x58e2 <drive_oneTile+0x102>
							{
								returnvar = DOT_RET_READY; //SOFORT abbrechen! Nicht erst in andere Teile der SM springen lassen (Zeitverschwendung)
								if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_oneTile()::dontstart:dist"));}
    58b6:	80 91 53 05 	lds	r24, 0x0553
    58ba:	88 23       	and	r24, r24
    58bc:	09 f4       	brne	.+2      	; 0x58c0 <drive_oneTile+0xe0>
    58be:	43 c4       	rjmp	.+2182   	; 0x6146 <drive_oneTile+0x966>
    58c0:	83 e7       	ldi	r24, 0x73	; 115
    58c2:	98 e2       	ldi	r25, 0x28	; 40
    58c4:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    58c8:	60 91 47 05 	lds	r22, 0x0547
    58cc:	70 91 48 05 	lds	r23, 0x0548
    58d0:	80 91 49 05 	lds	r24, 0x0549
    58d4:	90 91 4a 05 	lds	r25, 0x054A
    58d8:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    58dc:	81 e5       	ldi	r24, 0x51	; 81
    58de:	98 e2       	ldi	r25, 0x28	; 40
    58e0:	30 c4       	rjmp	.+2144   	; 0x6142 <drive_oneTile+0x962>
							}
							else
							{
								if((dist[LIN][BACK][BACK] < TILE1_BACK_TH_BACK) &&
    58e2:	80 91 c0 07 	lds	r24, 0x07C0
    58e6:	90 91 c1 07 	lds	r25, 0x07C1
    58ea:	8a 3f       	cpi	r24, 0xFA	; 250
    58ec:	91 05       	cpc	r25, r1
    58ee:	9c f4       	brge	.+38     	; 0x5916 <drive_oneTile+0x136>
									(maze_getWall(&robot.pos, robot.dir+2) > 0))
    58f0:	60 91 4b 16 	lds	r22, 0x164B
    58f4:	6e 5f       	subi	r22, 0xFE	; 254
    58f6:	88 e4       	ldi	r24, 0x48	; 72
    58f8:	96 e1       	ldi	r25, 0x16	; 22
    58fa:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
								returnvar = DOT_RET_READY; //SOFORT abbrechen! Nicht erst in andere Teile der SM springen lassen (Zeitverschwendung)
								if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_oneTile()::dontstart:dist"));}
							}
							else
							{
								if((dist[LIN][BACK][BACK] < TILE1_BACK_TH_BACK) &&
    58fe:	18 16       	cp	r1, r24
    5900:	54 f4       	brge	.+20     	; 0x5916 <drive_oneTile+0x136>
									(maze_getWall(&robot.pos, robot.dir+2) > 0))
								{
									sm_dot = DOT_ALIGN_BACK;
    5902:	81 e0       	ldi	r24, 0x01	; 1
    5904:	80 93 ad 05 	sts	0x05AD, r24
									timer_drive = TIMER_ALIGN;
    5908:	88 e7       	ldi	r24, 0x78	; 120
    590a:	90 e0       	ldi	r25, 0x00	; 0
    590c:	90 93 96 02 	sts	0x0296, r25
    5910:	80 93 95 02 	sts	0x0295, r24
    5914:	13 c0       	rjmp	.+38     	; 0x593c <drive_oneTile+0x15c>
								}
								else
								{
									sm_dot = DOT_DRIVE;
    5916:	83 e0       	ldi	r24, 0x03	; 3
    5918:	80 93 ad 05 	sts	0x05AD, r24
									enc_lr_start_dot = mot.enc;
    591c:	80 91 81 16 	lds	r24, 0x1681
    5920:	90 91 82 16 	lds	r25, 0x1682
    5924:	a0 91 83 16 	lds	r26, 0x1683
    5928:	b0 91 84 16 	lds	r27, 0x1684
    592c:	80 93 a6 05 	sts	0x05A6, r24
    5930:	90 93 a7 05 	sts	0x05A7, r25
    5934:	a0 93 a8 05 	sts	0x05A8, r26
    5938:	b0 93 a9 05 	sts	0x05A9, r27
								}
									
								returnvar = DOT_RET_INIT;
								if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_oneTile()::enc_lr_start:"));bt_putLong(enc_lr_start_dot);}
    593c:	80 91 53 05 	lds	r24, 0x0553
    5940:	88 23       	and	r24, r24
    5942:	09 f4       	brne	.+2      	; 0x5946 <drive_oneTile+0x166>
    5944:	02 c4       	rjmp	.+2052   	; 0x614a <drive_oneTile+0x96a>
    5946:	8e e4       	ldi	r24, 0x4E	; 78
    5948:	98 e2       	ldi	r25, 0x28	; 40
    594a:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    594e:	60 91 47 05 	lds	r22, 0x0547
    5952:	70 91 48 05 	lds	r23, 0x0548
    5956:	80 91 49 05 	lds	r24, 0x0549
    595a:	90 91 4a 05 	lds	r25, 0x054A
    595e:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    5962:	8d e2       	ldi	r24, 0x2D	; 45
    5964:	98 e2       	ldi	r25, 0x28	; 40
    5966:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    596a:	60 91 a6 05 	lds	r22, 0x05A6
    596e:	70 91 a7 05 	lds	r23, 0x05A7
    5972:	80 91 a8 05 	lds	r24, 0x05A8
    5976:	90 91 a9 05 	lds	r25, 0x05A9
    597a:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    597e:	e5 c3       	rjmp	.+1994   	; 0x614a <drive_oneTile+0x96a>
							
						break;
						
		case DOT_ALIGN_BACK:
		
							steer_dot = ((TILE1_BACK_BACK - (dist[LIN][BACK][BACK])) * KP_ALIGN_BACK);
    5980:	66 e4       	ldi	r22, 0x46	; 70
    5982:	70 e0       	ldi	r23, 0x00	; 0
    5984:	80 91 c0 07 	lds	r24, 0x07C0
    5988:	90 91 c1 07 	lds	r25, 0x07C1
    598c:	68 1b       	sub	r22, r24
    598e:	79 0b       	sbc	r23, r25
    5990:	88 27       	eor	r24, r24
    5992:	77 fd       	sbrc	r23, 7
    5994:	80 95       	com	r24
    5996:	98 2f       	mov	r25, r24
    5998:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    599c:	2a e9       	ldi	r18, 0x9A	; 154
    599e:	39 e9       	ldi	r19, 0x99	; 153
    59a0:	49 e1       	ldi	r20, 0x19	; 25
    59a2:	5f e3       	ldi	r21, 0x3F	; 63
    59a4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    59a8:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    59ac:	70 93 b4 05 	sts	0x05B4, r23
    59b0:	60 93 b3 05 	sts	0x05B3, r22
							
							mot.d[LEFT].speed.to = steer_dot;
    59b4:	70 93 6a 16 	sts	0x166A, r23
    59b8:	60 93 69 16 	sts	0x1669, r22
							mot.d[RIGHT].speed.to = steer_dot;
    59bc:	70 93 76 16 	sts	0x1676, r23
    59c0:	60 93 75 16 	sts	0x1675, r22
						
							drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, maxspeed);
    59c4:	44 e6       	ldi	r20, 0x64	; 100
    59c6:	65 e7       	ldi	r22, 0x75	; 117
    59c8:	76 e1       	ldi	r23, 0x16	; 22
    59ca:	89 e6       	ldi	r24, 0x69	; 105
    59cc:	96 e1       	ldi	r25, 0x16	; 22
    59ce:	c7 db       	rcall	.-2162   	; 0x515e <drive_limitSpeed>
    59d0:	80 91 b3 05 	lds	r24, 0x05B3
						
							if((abs(steer_dot) <= STEER_ALIGN_BACK_END) || (timer_drive == 0) ||
    59d4:	90 91 b4 05 	lds	r25, 0x05B4
    59d8:	02 96       	adiw	r24, 0x02	; 2
    59da:	05 97       	sbiw	r24, 0x05	; 5
    59dc:	d8 f0       	brcs	.+54     	; 0x5a14 <drive_oneTile+0x234>
    59de:	80 91 95 02 	lds	r24, 0x0295
    59e2:	90 91 96 02 	lds	r25, 0x0296
    59e6:	89 2b       	or	r24, r25
    59e8:	a9 f0       	breq	.+42     	; 0x5a14 <drive_oneTile+0x234>
    59ea:	80 91 c0 07 	lds	r24, 0x07C0
    59ee:	90 91 c1 07 	lds	r25, 0x07C1
    59f2:	8b 3f       	cpi	r24, 0xFB	; 251
    59f4:	91 05       	cpc	r25, r1
    59f6:	3c f1       	brlt	.+78     	; 0x5a46 <drive_oneTile+0x266>
    59f8:	80 91 ba 07 	lds	r24, 0x07BA
								((dist[LIN][BACK][BACK] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][LEFT] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][RIGHT] > TILE1_BACK_TH_BACK)))
    59fc:	90 91 bb 07 	lds	r25, 0x07BB
    5a00:	8b 3f       	cpi	r24, 0xFB	; 251
    5a02:	91 05       	cpc	r25, r1
    5a04:	04 f1       	brlt	.+64     	; 0x5a46 <drive_oneTile+0x266>
    5a06:	80 91 bc 07 	lds	r24, 0x07BC
    5a0a:	90 91 bd 07 	lds	r25, 0x07BD
    5a0e:	8b 3f       	cpi	r24, 0xFB	; 251
    5a10:	91 05       	cpc	r25, r1
    5a12:	cc f0       	brlt	.+50     	; 0x5a46 <drive_oneTile+0x266>
    5a14:	82 e0       	ldi	r24, 0x02	; 2
							{
								sm_dot = DOT_ALIGN;
    5a16:	80 93 ad 05 	sts	0x05AD, r24
    5a1a:	80 91 81 16 	lds	r24, 0x1681
								enc_lr_start_dot = mot.enc;
    5a1e:	90 91 82 16 	lds	r25, 0x1682
    5a22:	a0 91 83 16 	lds	r26, 0x1683
    5a26:	b0 91 84 16 	lds	r27, 0x1684
    5a2a:	80 93 a6 05 	sts	0x05A6, r24
    5a2e:	90 93 a7 05 	sts	0x05A7, r25
    5a32:	a0 93 a8 05 	sts	0x05A8, r26
    5a36:	b0 93 a9 05 	sts	0x05A9, r27
    5a3a:	8f ef       	ldi	r24, 0xFF	; 255
								timer_drive = -1;
    5a3c:	9f ef       	ldi	r25, 0xFF	; 255
    5a3e:	90 93 96 02 	sts	0x0296, r25
    5a42:	80 93 95 02 	sts	0x0295, r24
    5a46:	84 e0       	ldi	r24, 0x04	; 4
							}
							
							returnvar = DOT_RET_ALIGN; // < 15cm gefahren
    5a48:	8d c3       	rjmp	.+1818   	; 0x6164 <drive_oneTile+0x984>
    5a4a:	eb dd       	rcall	.-1066   	; 0x5622 <drive_align>
							
						break;
		case DOT_ALIGN:
		
							if(!drive_align())
    5a4c:	81 11       	cpse	r24, r1
    5a4e:	fb cf       	rjmp	.-10     	; 0x5a46 <drive_oneTile+0x266>
    5a50:	83 e0       	ldi	r24, 0x03	; 3
    5a52:	42 c3       	rjmp	.+1668   	; 0x60d8 <drive_oneTile+0x8f8>
								sm_dot = DOT_DRIVE;
    5a54:	80 91 a2 05 	lds	r24, 0x05A2
						
		case DOT_DRIVE:

							////////////Limit maximum speed (Ramp, speed bumps...)/////////////

							rel_angle = abs((um6_phi_t_start_dot - um6.phi_t) * 2);
    5a58:	90 91 a3 05 	lds	r25, 0x05A3
    5a5c:	aa 27       	eor	r26, r26
    5a5e:	97 fd       	sbrc	r25, 7
    5a60:	a0 95       	com	r26
    5a62:	ba 2f       	mov	r27, r26
    5a64:	40 91 04 17 	lds	r20, 0x1704
    5a68:	50 91 05 17 	lds	r21, 0x1705
    5a6c:	60 91 06 17 	lds	r22, 0x1706
    5a70:	70 91 07 17 	lds	r23, 0x1707
    5a74:	84 1b       	sub	r24, r20
    5a76:	95 0b       	sbc	r25, r21
    5a78:	a6 0b       	sbc	r26, r22
    5a7a:	b7 0b       	sbc	r27, r23
    5a7c:	88 0f       	add	r24, r24
    5a7e:	99 1f       	adc	r25, r25
    5a80:	97 ff       	sbrs	r25, 7
    5a82:	03 c0       	rjmp	.+6      	; 0x5a8a <drive_oneTile+0x2aa>
    5a84:	91 95       	neg	r25
    5a86:	81 95       	neg	r24
    5a88:	91 09       	sbc	r25, r1
    5a8a:	87 34       	cpi	r24, 0x47	; 71
    5a8c:	91 05       	cpc	r25, r1
    5a8e:	14 f0       	brlt	.+4      	; 0x5a94 <drive_oneTile+0x2b4>
    5a90:	86 e4       	ldi	r24, 0x46	; 70
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	44 e6       	ldi	r20, 0x64	; 100
    5a96:	24 2e       	mov	r2, r20
							if(rel_angle > 70)
								rel_angle = 70;
							maxspeed = MAXSPEED - rel_angle;
    5a98:	31 2c       	mov	r3, r1
    5a9a:	28 1a       	sub	r2, r24
    5a9c:	39 0a       	sbc	r3, r25
    5a9e:	a0 90 a6 07 	lds	r10, 0x07A6

							/////////Regelung (Abstand links/rechts)////////

							if((abs(dist[LIN][LEFT][FRONT] - dist_l_old) < DELTADIST_MAX) &&
    5aa2:	b0 90 a7 07 	lds	r11, 0x07A7
    5aa6:	80 91 af 05 	lds	r24, 0x05AF
    5aaa:	90 91 b0 05 	lds	r25, 0x05B0
    5aae:	95 01       	movw	r18, r10
    5ab0:	28 1b       	sub	r18, r24
    5ab2:	39 0b       	sbc	r19, r25
    5ab4:	c9 01       	movw	r24, r18
    5ab6:	0e 96       	adiw	r24, 0x0e	; 14
    5ab8:	80 90 ae 07 	lds	r8, 0x07AE
    5abc:	90 90 af 07 	lds	r9, 0x07AF
    5ac0:	4d 97       	sbiw	r24, 0x1d	; 29
    5ac2:	08 f0       	brcs	.+2      	; 0x5ac6 <drive_oneTile+0x2e6>
    5ac4:	5d c0       	rjmp	.+186    	; 0x5b80 <drive_oneTile+0x3a0>
    5ac6:	97 01       	movw	r18, r14
    5ac8:	f7 fe       	sbrs	r15, 7
							   (abs(robot_angleToLeftWall) < abs(robot_angleToRightWall)))
    5aca:	04 c0       	rjmp	.+8      	; 0x5ad4 <drive_oneTile+0x2f4>
    5acc:	22 27       	eor	r18, r18
    5ace:	33 27       	eor	r19, r19
    5ad0:	2e 19       	sub	r18, r14
    5ad2:	3f 09       	sbc	r19, r15
    5ad4:	c6 01       	movw	r24, r12
    5ad6:	d7 fe       	sbrs	r13, 7
    5ad8:	04 c0       	rjmp	.+8      	; 0x5ae2 <drive_oneTile+0x302>
    5ada:	88 27       	eor	r24, r24
    5adc:	99 27       	eor	r25, r25
    5ade:	8c 19       	sub	r24, r12
    5ae0:	9d 09       	sbc	r25, r13
    5ae2:	28 17       	cp	r18, r24
    5ae4:	39 07       	cpc	r19, r25
								rel_angle = 70;
							maxspeed = MAXSPEED - rel_angle;

							/////////Regelung (Abstand links/rechts)////////

							if((abs(dist[LIN][LEFT][FRONT] - dist_l_old) < DELTADIST_MAX) &&
    5ae6:	0c f0       	brlt	.+2      	; 0x5aea <drive_oneTile+0x30a>
    5ae8:	4b c0       	rjmp	.+150    	; 0x5b80 <drive_oneTile+0x3a0>
    5aea:	80 91 c3 07 	lds	r24, 0x07C3
							   (abs(robot_angleToLeftWall) < abs(robot_angleToRightWall)))
							{
								if(sensinfo.newDat.left && sensinfo.newDat.right)
    5aee:	83 70       	andi	r24, 0x03	; 3
    5af0:	83 30       	cpi	r24, 0x03	; 3
    5af2:	09 f0       	breq	.+2      	; 0x5af6 <drive_oneTile+0x316>
    5af4:	cc c0       	rjmp	.+408    	; 0x5c8e <drive_oneTile+0x4ae>
    5af6:	60 91 a8 07 	lds	r22, 0x07A8
								{
									if(dist[LIN][LEFT][FRONT] < dist[LIN][LEFT][BACK])								
    5afa:	70 91 a9 07 	lds	r23, 0x07A9
    5afe:	a6 16       	cp	r10, r22
    5b00:	b7 06       	cpc	r11, r23
    5b02:	6c f4       	brge	.+26     	; 0x5b1e <drive_oneTile+0x33e>
    5b04:	6a 19       	sub	r22, r10
    5b06:	7b 09       	sbc	r23, r11
										steer_dot = (((int16_t)(dist[LIN][LEFT][BACK] - dist[LIN][LEFT][FRONT])) * -KP_DOT_DIR);
    5b08:	88 27       	eor	r24, r24
    5b0a:	77 fd       	sbrc	r23, 7
    5b0c:	80 95       	com	r24
    5b0e:	98 2f       	mov	r25, r24
    5b10:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5b14:	26 e6       	ldi	r18, 0x66	; 102
    5b16:	36 e6       	ldi	r19, 0x66	; 102
    5b18:	46 ea       	ldi	r20, 0xA6	; 166
    5b1a:	5f eb       	ldi	r21, 0xBF	; 191
    5b1c:	0e c0       	rjmp	.+28     	; 0x5b3a <drive_oneTile+0x35a>
    5b1e:	c5 01       	movw	r24, r10
    5b20:	86 1b       	sub	r24, r22
									else
										steer_dot = (((int16_t)(dist[LIN][LEFT][FRONT] - dist[LIN][LEFT][BACK])) * KP_DOT_DIR);
    5b22:	97 0b       	sbc	r25, r23
    5b24:	bc 01       	movw	r22, r24
    5b26:	88 27       	eor	r24, r24
    5b28:	77 fd       	sbrc	r23, 7
    5b2a:	80 95       	com	r24
    5b2c:	98 2f       	mov	r25, r24
    5b2e:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5b32:	26 e6       	ldi	r18, 0x66	; 102
    5b34:	36 e6       	ldi	r19, 0x66	; 102
    5b36:	46 ea       	ldi	r20, 0xA6	; 166
    5b38:	5f e3       	ldi	r21, 0x3F	; 63
    5b3a:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    5b3e:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5b42:	70 93 b4 05 	sts	0x05B4, r23
    5b46:	60 93 b3 05 	sts	0x05B3, r22
    5b4a:	60 91 b3 05 	lds	r22, 0x05B3
							
									steer_dot += ((int16_t)(DIST_SOLL - dist[LIN][LEFT][FRONT]) * -KP_DOT_DIST);
    5b4e:	70 91 b4 05 	lds	r23, 0x05B4
    5b52:	88 27       	eor	r24, r24
    5b54:	77 fd       	sbrc	r23, 7
    5b56:	80 95       	com	r24
    5b58:	98 2f       	mov	r25, r24
    5b5a:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5b5e:	2b 01       	movw	r4, r22
    5b60:	3c 01       	movw	r6, r24
    5b62:	68 e3       	ldi	r22, 0x38	; 56
    5b64:	70 e0       	ldi	r23, 0x00	; 0
    5b66:	6a 19       	sub	r22, r10
    5b68:	7b 09       	sbc	r23, r11
    5b6a:	88 27       	eor	r24, r24
    5b6c:	77 fd       	sbrc	r23, 7
    5b6e:	80 95       	com	r24
    5b70:	98 2f       	mov	r25, r24
    5b72:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5b76:	26 e6       	ldi	r18, 0x66	; 102
    5b78:	36 e6       	ldi	r19, 0x66	; 102
    5b7a:	46 ea       	ldi	r20, 0xA6	; 166
    5b7c:	5f eb       	ldi	r21, 0xBF	; 191
    5b7e:	68 c0       	rjmp	.+208    	; 0x5c50 <drive_oneTile+0x470>
    5b80:	80 91 b1 05 	lds	r24, 0x05B1
								
									sensinfo.newDat.left = 0;
									sensinfo.newDat.right = 0;
								}
							}
							else if((abs(dist[LIN][RIGHT][FRONT] - dist_r_old) < DELTADIST_MAX) &&
    5b84:	90 91 b2 05 	lds	r25, 0x05B2
    5b88:	f4 01       	movw	r30, r8
    5b8a:	e8 1b       	sub	r30, r24
    5b8c:	f9 0b       	sbc	r31, r25
    5b8e:	cf 01       	movw	r24, r30
    5b90:	0e 96       	adiw	r24, 0x0e	; 14
    5b92:	4d 97       	sbiw	r24, 0x1d	; 29
    5b94:	08 f0       	brcs	.+2      	; 0x5b98 <drive_oneTile+0x3b8>
    5b96:	77 c0       	rjmp	.+238    	; 0x5c86 <drive_oneTile+0x4a6>
    5b98:	97 01       	movw	r18, r14
    5b9a:	f7 fe       	sbrs	r15, 7
									(abs(robot_angleToLeftWall) > abs(robot_angleToRightWall)))
    5b9c:	04 c0       	rjmp	.+8      	; 0x5ba6 <drive_oneTile+0x3c6>
    5b9e:	22 27       	eor	r18, r18
    5ba0:	33 27       	eor	r19, r19
    5ba2:	2e 19       	sub	r18, r14
    5ba4:	3f 09       	sbc	r19, r15
    5ba6:	c6 01       	movw	r24, r12
    5ba8:	d7 fe       	sbrs	r13, 7
    5baa:	04 c0       	rjmp	.+8      	; 0x5bb4 <drive_oneTile+0x3d4>
    5bac:	88 27       	eor	r24, r24
    5bae:	99 27       	eor	r25, r25
    5bb0:	8c 19       	sub	r24, r12
    5bb2:	9d 09       	sbc	r25, r13
    5bb4:	82 17       	cp	r24, r18
    5bb6:	93 07       	cpc	r25, r19
								
									sensinfo.newDat.left = 0;
									sensinfo.newDat.right = 0;
								}
							}
							else if((abs(dist[LIN][RIGHT][FRONT] - dist_r_old) < DELTADIST_MAX) &&
    5bb8:	0c f0       	brlt	.+2      	; 0x5bbc <drive_oneTile+0x3dc>
    5bba:	65 c0       	rjmp	.+202    	; 0x5c86 <drive_oneTile+0x4a6>
    5bbc:	80 91 c3 07 	lds	r24, 0x07C3
									(abs(robot_angleToLeftWall) > abs(robot_angleToRightWall)))
							{
								if(sensinfo.newDat.left && sensinfo.newDat.right)
    5bc0:	83 70       	andi	r24, 0x03	; 3
    5bc2:	83 30       	cpi	r24, 0x03	; 3
    5bc4:	09 f0       	breq	.+2      	; 0x5bc8 <drive_oneTile+0x3e8>
    5bc6:	63 c0       	rjmp	.+198    	; 0x5c8e <drive_oneTile+0x4ae>
    5bc8:	60 91 b0 07 	lds	r22, 0x07B0
								{
									if(dist[LIN][RIGHT][FRONT] < dist[LIN][RIGHT][BACK])
    5bcc:	70 91 b1 07 	lds	r23, 0x07B1
    5bd0:	86 16       	cp	r8, r22
    5bd2:	97 06       	cpc	r9, r23
    5bd4:	6c f4       	brge	.+26     	; 0x5bf0 <drive_oneTile+0x410>
    5bd6:	68 19       	sub	r22, r8
    5bd8:	79 09       	sbc	r23, r9
										steer_dot = (((int16_t)(dist[LIN][RIGHT][BACK] - dist[LIN][RIGHT][FRONT])) * KP_DOT_DIR);
    5bda:	88 27       	eor	r24, r24
    5bdc:	77 fd       	sbrc	r23, 7
    5bde:	80 95       	com	r24
    5be0:	98 2f       	mov	r25, r24
    5be2:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5be6:	26 e6       	ldi	r18, 0x66	; 102
    5be8:	36 e6       	ldi	r19, 0x66	; 102
    5bea:	46 ea       	ldi	r20, 0xA6	; 166
    5bec:	5f e3       	ldi	r21, 0x3F	; 63
    5bee:	0e c0       	rjmp	.+28     	; 0x5c0c <drive_oneTile+0x42c>
    5bf0:	94 01       	movw	r18, r8
    5bf2:	26 1b       	sub	r18, r22
									else
										steer_dot = (((int16_t)(dist[LIN][RIGHT][FRONT] - dist[LIN][RIGHT][BACK])) * -KP_DOT_DIR);
    5bf4:	37 0b       	sbc	r19, r23
    5bf6:	b9 01       	movw	r22, r18
    5bf8:	88 27       	eor	r24, r24
    5bfa:	77 fd       	sbrc	r23, 7
    5bfc:	80 95       	com	r24
    5bfe:	98 2f       	mov	r25, r24
    5c00:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5c04:	26 e6       	ldi	r18, 0x66	; 102
    5c06:	36 e6       	ldi	r19, 0x66	; 102
    5c08:	46 ea       	ldi	r20, 0xA6	; 166
    5c0a:	5f eb       	ldi	r21, 0xBF	; 191
    5c0c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    5c10:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5c14:	70 93 b4 05 	sts	0x05B4, r23
    5c18:	60 93 b3 05 	sts	0x05B3, r22
    5c1c:	60 91 b3 05 	lds	r22, 0x05B3
							
									steer_dot += ((int16_t)(DIST_SOLL - dist[LIN][RIGHT][FRONT]) * KP_DOT_DIST);
    5c20:	70 91 b4 05 	lds	r23, 0x05B4
    5c24:	88 27       	eor	r24, r24
    5c26:	77 fd       	sbrc	r23, 7
    5c28:	80 95       	com	r24
    5c2a:	98 2f       	mov	r25, r24
    5c2c:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5c30:	2b 01       	movw	r4, r22
    5c32:	3c 01       	movw	r6, r24
    5c34:	68 e3       	ldi	r22, 0x38	; 56
    5c36:	70 e0       	ldi	r23, 0x00	; 0
    5c38:	68 19       	sub	r22, r8
    5c3a:	79 09       	sbc	r23, r9
    5c3c:	88 27       	eor	r24, r24
    5c3e:	77 fd       	sbrc	r23, 7
    5c40:	80 95       	com	r24
    5c42:	98 2f       	mov	r25, r24
    5c44:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5c48:	26 e6       	ldi	r18, 0x66	; 102
    5c4a:	36 e6       	ldi	r19, 0x66	; 102
    5c4c:	46 ea       	ldi	r20, 0xA6	; 166
    5c4e:	5f e3       	ldi	r21, 0x3F	; 63
    5c50:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    5c54:	2a e9       	ldi	r18, 0x9A	; 154
    5c56:	39 e9       	ldi	r19, 0x99	; 153
    5c58:	49 e1       	ldi	r20, 0x19	; 25
    5c5a:	5f e3       	ldi	r21, 0x3F	; 63
    5c5c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    5c60:	9b 01       	movw	r18, r22
    5c62:	ac 01       	movw	r20, r24
    5c64:	c3 01       	movw	r24, r6
    5c66:	b2 01       	movw	r22, r4
    5c68:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5c6c:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5c70:	70 93 b4 05 	sts	0x05B4, r23
    5c74:	60 93 b3 05 	sts	0x05B3, r22
    5c78:	80 91 c3 07 	lds	r24, 0x07C3
									
									sensinfo.newDat.left = 0;
    5c7c:	8e 7f       	andi	r24, 0xFE	; 254
    5c7e:	8d 7f       	andi	r24, 0xFD	; 253
									sensinfo.newDat.right = 0;
    5c80:	80 93 c3 07 	sts	0x07C3, r24
    5c84:	04 c0       	rjmp	.+8      	; 0x5c8e <drive_oneTile+0x4ae>
    5c86:	10 92 b4 05 	sts	0x05B4, r1
								}
							}
							else	steer_dot = 0;
    5c8a:	10 92 b3 05 	sts	0x05B3, r1
    5c8e:	b0 92 b0 05 	sts	0x05B0, r11
							
							dist_l_old = dist[LIN][LEFT][FRONT];
    5c92:	a0 92 af 05 	sts	0x05AF, r10
    5c96:	90 92 b2 05 	sts	0x05B2, r9
							dist_r_old = dist[LIN][RIGHT][FRONT];
    5c9a:	80 92 b1 05 	sts	0x05B1, r8
    5c9e:	35 e1       	ldi	r19, 0x15	; 21
    5ca0:	c3 16       	cp	r12, r19
							
							////////////////////////////////////////////////////////////////////////
							////////Ziel erreicht? Kollision? Sollgeschwindigkeiten berechnen///////

							if(((robot_angleToRightWall > 20) && (robot_angleToRightWall != GETANGLE_NOANGLE) &&
    5ca2:	d1 04       	cpc	r13, r1
    5ca4:	ac f0       	brlt	.+42     	; 0x5cd0 <drive_oneTile+0x4f0>
    5ca6:	40 e1       	ldi	r20, 0x10	; 16
    5ca8:	c4 16       	cp	r12, r20
    5caa:	47 e2       	ldi	r20, 0x27	; 39
    5cac:	d4 06       	cpc	r13, r20
    5cae:	81 f0       	breq	.+32     	; 0x5cd0 <drive_oneTile+0x4f0>
    5cb0:	6f e0       	ldi	r22, 0x0F	; 15
    5cb2:	86 16       	cp	r8, r22
    5cb4:	91 04       	cpc	r9, r1
    5cb6:	64 f4       	brge	.+24     	; 0x5cd0 <drive_oneTile+0x4f0>
    5cb8:	84 e0       	ldi	r24, 0x04	; 4
    5cba:	80 93 ac 05 	sts	0x05AC, r24
								(dist[LIN][RIGHT][FRONT] < 15)))
							{
								dot_aligned_turn = WEST;
    5cbe:	8c ee       	ldi	r24, 0xEC	; 236
    5cc0:	9f ef       	ldi	r25, 0xFF	; 255

								mot.d[LEFT].speed.to = -SPEED_COLLISION_AVOIDANCE;
    5cc2:	90 93 6a 16 	sts	0x166A, r25
    5cc6:	80 93 69 16 	sts	0x1669, r24
    5cca:	84 e1       	ldi	r24, 0x14	; 20
    5ccc:	90 e0       	ldi	r25, 0x00	; 0
								mot.d[RIGHT].speed.to = SPEED_COLLISION_AVOIDANCE;
    5cce:	f1 c0       	rjmp	.+482    	; 0x5eb2 <drive_oneTile+0x6d2>
    5cd0:	85 e1       	ldi	r24, 0x15	; 21
    5cd2:	e8 16       	cp	r14, r24
							}
							else if(((robot_angleToLeftWall > 20) && (robot_angleToLeftWall != GETANGLE_NOANGLE) &&
    5cd4:	f1 04       	cpc	r15, r1
    5cd6:	ac f0       	brlt	.+42     	; 0x5d02 <drive_oneTile+0x522>
    5cd8:	90 e1       	ldi	r25, 0x10	; 16
    5cda:	e9 16       	cp	r14, r25
    5cdc:	97 e2       	ldi	r25, 0x27	; 39
    5cde:	f9 06       	cpc	r15, r25
    5ce0:	81 f0       	breq	.+32     	; 0x5d02 <drive_oneTile+0x522>
    5ce2:	ef e0       	ldi	r30, 0x0F	; 15
    5ce4:	ae 16       	cp	r10, r30
    5ce6:	b1 04       	cpc	r11, r1
    5ce8:	64 f4       	brge	.+24     	; 0x5d02 <drive_oneTile+0x522>
    5cea:	82 e0       	ldi	r24, 0x02	; 2
    5cec:	80 93 ac 05 	sts	0x05AC, r24
									 (dist[LIN][LEFT][FRONT] < 15)))
							{
								dot_aligned_turn = EAST;
    5cf0:	84 e1       	ldi	r24, 0x14	; 20
    5cf2:	90 e0       	ldi	r25, 0x00	; 0

								mot.d[LEFT].speed.to = SPEED_COLLISION_AVOIDANCE;
    5cf4:	90 93 6a 16 	sts	0x166A, r25
    5cf8:	80 93 69 16 	sts	0x1669, r24
    5cfc:	8c ee       	ldi	r24, 0xEC	; 236
    5cfe:	9f ef       	ldi	r25, 0xFF	; 255
								mot.d[RIGHT].speed.to = -SPEED_COLLISION_AVOIDANCE;
    5d00:	d8 c0       	rjmp	.+432    	; 0x5eb2 <drive_oneTile+0x6d2>
    5d02:	80 91 ac 05 	lds	r24, 0x05AC
							}
							else if(dot_aligned_turn == WEST)
    5d06:	84 30       	cpi	r24, 0x04	; 4
    5d08:	71 f1       	breq	.+92     	; 0x5d66 <drive_oneTile+0x586>
    5d0a:	82 30       	cpi	r24, 0x02	; 2
    5d0c:	11 f4       	brne	.+4      	; 0x5d12 <drive_oneTile+0x532>
							{
								sm_dot = DOT_ROT_WEST;
							}
							else if(dot_aligned_turn == EAST)
    5d0e:	85 e0       	ldi	r24, 0x05	; 5
    5d10:	2a c0       	rjmp	.+84     	; 0x5d66 <drive_oneTile+0x586>
							{
								sm_dot = DOT_ROT_EAST;
    5d12:	80 91 b2 07 	lds	r24, 0x07B2
							}
							else if((dist[LIN][FRONT][LEFT] < TILE1_FRONT_TH_FRONT) &&
    5d16:	90 91 b3 07 	lds	r25, 0x07B3
    5d1a:	80 3f       	cpi	r24, 0xF0	; 240
    5d1c:	91 05       	cpc	r25, r1
    5d1e:	0c f0       	brlt	.+2      	; 0x5d22 <drive_oneTile+0x542>
    5d20:	52 c0       	rjmp	.+164    	; 0x5dc6 <drive_oneTile+0x5e6>
    5d22:	80 91 b6 07 	lds	r24, 0x07B6
									(dist[LIN][FRONT][FRONT] < TILE1_FRONT_TH_FRONT) &&
    5d26:	90 91 b7 07 	lds	r25, 0x07B7
    5d2a:	80 3f       	cpi	r24, 0xF0	; 240
    5d2c:	91 05       	cpc	r25, r1
							}
							else if(dot_aligned_turn == EAST)
							{
								sm_dot = DOT_ROT_EAST;
							}
							else if((dist[LIN][FRONT][LEFT] < TILE1_FRONT_TH_FRONT) &&
    5d2e:	0c f0       	brlt	.+2      	; 0x5d32 <drive_oneTile+0x552>
    5d30:	4a c0       	rjmp	.+148    	; 0x5dc6 <drive_oneTile+0x5e6>
    5d32:	20 91 b4 07 	lds	r18, 0x07B4
									(dist[LIN][FRONT][FRONT] < TILE1_FRONT_TH_FRONT) &&
    5d36:	30 91 b5 07 	lds	r19, 0x07B5
    5d3a:	20 3f       	cpi	r18, 0xF0	; 240
    5d3c:	31 05       	cpc	r19, r1
    5d3e:	0c f0       	brlt	.+2      	; 0x5d42 <drive_oneTile+0x562>
    5d40:	42 c0       	rjmp	.+132    	; 0x5dc6 <drive_oneTile+0x5e6>
    5d42:	20 91 95 02 	lds	r18, 0x0295
									(dist[LIN][FRONT][RIGHT] < TILE1_FRONT_TH_FRONT))
							{
								if(timer_drive == -1)
    5d46:	30 91 96 02 	lds	r19, 0x0296
    5d4a:	2f 3f       	cpi	r18, 0xFF	; 255
    5d4c:	ff ef       	ldi	r31, 0xFF	; 255
    5d4e:	3f 07       	cpc	r19, r31
    5d50:	39 f4       	brne	.+14     	; 0x5d60 <drive_oneTile+0x580>
    5d52:	88 e7       	ldi	r24, 0x78	; 120
    5d54:	90 e0       	ldi	r25, 0x00	; 0
								{
									timer_drive = TIMER_ALIGN;
    5d56:	90 93 96 02 	sts	0x0296, r25
    5d5a:	80 93 95 02 	sts	0x0295, r24
    5d5e:	ad c0       	rjmp	.+346    	; 0x5eba <drive_oneTile+0x6da>
    5d60:	23 2b       	or	r18, r19
    5d62:	21 f4       	brne	.+8      	; 0x5d6c <drive_oneTile+0x58c>
								}
								else if(timer_drive == 0)
    5d64:	86 e0       	ldi	r24, 0x06	; 6
    5d66:	80 93 ad 05 	sts	0x05AD, r24
								{
									sm_dot = DOT_COMP_ENC; //End, compare angle of the robot
    5d6a:	a7 c0       	rjmp	.+334    	; 0x5eba <drive_oneTile+0x6da>
    5d6c:	6a e5       	ldi	r22, 0x5A	; 90
    5d6e:	70 e0       	ldi	r23, 0x00	; 0
								}
								else
								{
									steer_dot = ((TILE1_FRONT_FRONT - (dist[LIN][FRONT][FRONT])) * (-KP_ALIGN_FRONT));
    5d70:	68 1b       	sub	r22, r24
    5d72:	79 0b       	sbc	r23, r25
    5d74:	88 27       	eor	r24, r24
    5d76:	77 fd       	sbrc	r23, 7
    5d78:	80 95       	com	r24
    5d7a:	98 2f       	mov	r25, r24
    5d7c:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5d80:	2a e9       	ldi	r18, 0x9A	; 154
    5d82:	39 e9       	ldi	r19, 0x99	; 153
    5d84:	49 e1       	ldi	r20, 0x19	; 25
    5d86:	5f eb       	ldi	r21, 0xBF	; 191
    5d88:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    5d8c:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5d90:	70 93 b4 05 	sts	0x05B4, r23
    5d94:	60 93 b3 05 	sts	0x05B3, r22
    5d98:	70 93 6a 16 	sts	0x166A, r23
					
									mot.d[LEFT].speed.to = steer_dot;
    5d9c:	60 93 69 16 	sts	0x1669, r22
    5da0:	70 93 76 16 	sts	0x1676, r23
									mot.d[RIGHT].speed.to = steer_dot;
    5da4:	60 93 75 16 	sts	0x1675, r22
    5da8:	42 2d       	mov	r20, r2
    5daa:	65 e7       	ldi	r22, 0x75	; 117
				
									drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, maxspeed);
    5dac:	76 e1       	ldi	r23, 0x16	; 22
    5dae:	89 e6       	ldi	r24, 0x69	; 105
    5db0:	96 e1       	ldi	r25, 0x16	; 22
    5db2:	d5 d9       	rcall	.-3158   	; 0x515e <drive_limitSpeed>
    5db4:	80 91 b3 05 	lds	r24, 0x05B3
    5db8:	90 91 b4 05 	lds	r25, 0x05B4
				
									if(abs(steer_dot) <= STEER_ALIGN_BACK_END)
    5dbc:	02 96       	adiw	r24, 0x02	; 2
    5dbe:	05 97       	sbiw	r24, 0x05	; 5
    5dc0:	08 f0       	brcs	.+2      	; 0x5dc4 <drive_oneTile+0x5e4>
    5dc2:	7b c0       	rjmp	.+246    	; 0x5eba <drive_oneTile+0x6da>
    5dc4:	48 c0       	rjmp	.+144    	; 0x5e56 <drive_oneTile+0x676>
    5dc6:	c0 90 81 16 	lds	r12, 0x1681
    5dca:	d0 90 82 16 	lds	r13, 0x1682
										mot.d[LEFT].speed.to = 0;
										mot.d[RIGHT].speed.to = 0;
									}
								}
							}
							else if((mot.enc > (enc_lr_start_dot + (TILE_LENGTH * ENC_FAC_CM_LR) + enc_lr_add_dot)) &&
    5dce:	e0 90 83 16 	lds	r14, 0x1683
    5dd2:	f0 90 84 16 	lds	r15, 0x1684
    5dd6:	80 90 a6 05 	lds	r8, 0x05A6
    5dda:	90 90 a7 05 	lds	r9, 0x05A7
    5dde:	a0 90 a8 05 	lds	r10, 0x05A8
    5de2:	b0 90 a9 05 	lds	r11, 0x05A9
    5de6:	c7 01       	movw	r24, r14
    5de8:	b6 01       	movw	r22, r12
    5dea:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5dee:	69 83       	std	Y+1, r22	; 0x01
    5df0:	7a 83       	std	Y+2, r23	; 0x02
    5df2:	8b 83       	std	Y+3, r24	; 0x03
    5df4:	9c 83       	std	Y+4, r25	; 0x04
    5df6:	c5 01       	movw	r24, r10
    5df8:	b4 01       	movw	r22, r8
    5dfa:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5dfe:	20 e0       	ldi	r18, 0x00	; 0
    5e00:	30 ec       	ldi	r19, 0xC0	; 192
    5e02:	48 e2       	ldi	r20, 0x28	; 40
    5e04:	54 e4       	ldi	r21, 0x44	; 68
    5e06:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5e0a:	2b 01       	movw	r4, r22
    5e0c:	3c 01       	movw	r6, r24
    5e0e:	60 91 a4 05 	lds	r22, 0x05A4
    5e12:	70 91 a5 05 	lds	r23, 0x05A5
    5e16:	88 27       	eor	r24, r24
    5e18:	77 fd       	sbrc	r23, 7
    5e1a:	80 95       	com	r24
    5e1c:	98 2f       	mov	r25, r24
    5e1e:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5e22:	9b 01       	movw	r18, r22
    5e24:	ac 01       	movw	r20, r24
    5e26:	c3 01       	movw	r24, r6
    5e28:	b2 01       	movw	r22, r4
    5e2a:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5e2e:	9b 01       	movw	r18, r22
    5e30:	ac 01       	movw	r20, r24
    5e32:	69 81       	ldd	r22, Y+1	; 0x01
    5e34:	7a 81       	ldd	r23, Y+2	; 0x02
    5e36:	8b 81       	ldd	r24, Y+3	; 0x03
    5e38:	9c 81       	ldd	r25, Y+4	; 0x04
    5e3a:	0e 94 c8 6a 	call	0xd590	; 0xd590 <__gesf2>
    5e3e:	18 16       	cp	r1, r24
    5e40:	1c f4       	brge	.+6      	; 0x5e48 <drive_oneTile+0x668>
    5e42:	11 11       	cpse	r17, r1
    5e44:	88 c1       	rjmp	.+784    	; 0x6156 <drive_oneTile+0x976>
    5e46:	07 c0       	rjmp	.+14     	; 0x5e56 <drive_oneTile+0x676>
    5e48:	c8 14       	cp	r12, r8
    5e4a:	d9 04       	cpc	r13, r9
    5e4c:	ea 04       	cpc	r14, r10
							{
								sm_dot = DOT_COMP_ENC; //End, compare angle of the robot
								mot.d[LEFT].speed.to = 0;
								mot.d[RIGHT].speed.to = 0;
							}
							else if((mot.enc < enc_lr_start_dot) &&
    5e4e:	fb 04       	cpc	r15, r11
    5e50:	74 f4       	brge	.+28     	; 0x5e6e <drive_oneTile+0x68e>
    5e52:	11 23       	and	r17, r17
    5e54:	09 f1       	breq	.+66     	; 0x5e98 <drive_oneTile+0x6b8>
    5e56:	86 e0       	ldi	r24, 0x06	; 6
    5e58:	80 93 ad 05 	sts	0x05AD, r24
											(abort != 0))
							{
								sm_dot = DOT_COMP_ENC; //End, compare angle of the robot
    5e5c:	10 92 6a 16 	sts	0x166A, r1
    5e60:	10 92 69 16 	sts	0x1669, r1
								mot.d[LEFT].speed.to = 0;
    5e64:	10 92 76 16 	sts	0x1676, r1
    5e68:	10 92 75 16 	sts	0x1675, r1
								mot.d[RIGHT].speed.to = 0;
    5e6c:	26 c0       	rjmp	.+76     	; 0x5eba <drive_oneTile+0x6da>
    5e6e:	11 23       	and	r17, r17
    5e70:	99 f0       	breq	.+38     	; 0x5e98 <drive_oneTile+0x6b8>
    5e72:	35 94       	asr	r3
							}
							else if(abort != 0)
    5e74:	27 94       	ror	r2
    5e76:	80 91 b3 05 	lds	r24, 0x05B3
							{
								maxspeed /= 2;
    5e7a:	90 91 b4 05 	lds	r25, 0x05B4
								mot.d[LEFT].speed.to = -(maxspeed + steer_dot);
    5e7e:	91 01       	movw	r18, r2
    5e80:	28 0f       	add	r18, r24
    5e82:	39 1f       	adc	r19, r25
    5e84:	31 95       	neg	r19
    5e86:	21 95       	neg	r18
    5e88:	31 09       	sbc	r19, r1
    5e8a:	30 93 6a 16 	sts	0x166A, r19
    5e8e:	20 93 69 16 	sts	0x1669, r18
    5e92:	82 19       	sub	r24, r2
    5e94:	93 09       	sbc	r25, r3
    5e96:	0d c0       	rjmp	.+26     	; 0x5eb2 <drive_oneTile+0x6d2>
								mot.d[RIGHT].speed.to = -(maxspeed - steer_dot);
    5e98:	80 91 b3 05 	lds	r24, 0x05B3
    5e9c:	90 91 b4 05 	lds	r25, 0x05B4
							}
							else
							{
								mot.d[LEFT].speed.to = (maxspeed - steer_dot);
    5ea0:	91 01       	movw	r18, r2
    5ea2:	28 1b       	sub	r18, r24
    5ea4:	39 0b       	sbc	r19, r25
    5ea6:	30 93 6a 16 	sts	0x166A, r19
    5eaa:	20 93 69 16 	sts	0x1669, r18
    5eae:	82 0d       	add	r24, r2
    5eb0:	93 1d       	adc	r25, r3
    5eb2:	90 93 76 16 	sts	0x1676, r25
								mot.d[RIGHT].speed.to = (maxspeed + steer_dot);
    5eb6:	80 93 75 16 	sts	0x1675, r24
    5eba:	42 2d       	mov	r20, r2
    5ebc:	65 e7       	ldi	r22, 0x75	; 117
    5ebe:	76 e1       	ldi	r23, 0x16	; 22
							}

							drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, maxspeed);
    5ec0:	89 e6       	ldi	r24, 0x69	; 105
    5ec2:	96 e1       	ldi	r25, 0x16	; 22
    5ec4:	4c d9       	rcall	.-3432   	; 0x515e <drive_limitSpeed>
    5ec6:	11 23       	and	r17, r17
    5ec8:	59 f0       	breq	.+22     	; 0x5ee0 <drive_oneTile+0x700>
    5eca:	80 91 ae 05 	lds	r24, 0x05AE
							////////////////////////////////
							if((abort != 0) && (dot_tile_middle & (1<<0)) && !((dot_tile_middle & (1<<1))>>1))
    5ece:	80 ff       	sbrs	r24, 0
    5ed0:	07 c0       	rjmp	.+14     	; 0x5ee0 <drive_oneTile+0x700>
    5ed2:	81 fd       	sbrc	r24, 1
    5ed4:	05 c0       	rjmp	.+10     	; 0x5ee0 <drive_oneTile+0x700>
    5ed6:	82 60       	ori	r24, 0x02	; 2
    5ed8:	80 93 ae 05 	sts	0x05AE, r24
    5edc:	86 e0       	ldi	r24, 0x06	; 6
							{
								returnvar = AT_15; //Ist schon 15cm gefahren (-> Position gendert), muss deshalb wieder zurckgezhlt werden
								dot_tile_middle |= (1<<1);
    5ede:	42 c1       	rjmp	.+644    	; 0x6164 <drive_oneTile+0x984>
    5ee0:	60 91 81 16 	lds	r22, 0x1681

							drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, maxspeed);
							////////////////////////////////
							if((abort != 0) && (dot_tile_middle & (1<<0)) && !((dot_tile_middle & (1<<1))>>1))
							{
								returnvar = AT_15; //Ist schon 15cm gefahren (-> Position gendert), muss deshalb wieder zurckgezhlt werden
    5ee4:	70 91 82 16 	lds	r23, 0x1682
								dot_tile_middle |= (1<<1);
							}
							else if(mot.enc > (enc_lr_start_dot + enc_lr_add_dot + (TILE_LENGTH_MIN_DRIVE * ENC_FAC_CM_LR))) // >= 16cm gefahren *GENDERT VON 15, KONSTANTE EINFHREN!!!*
    5ee8:	80 91 83 16 	lds	r24, 0x1683
    5eec:	90 91 84 16 	lds	r25, 0x1684
    5ef0:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5ef4:	6b 01       	movw	r12, r22
    5ef6:	7c 01       	movw	r14, r24
    5ef8:	80 91 a4 05 	lds	r24, 0x05A4
    5efc:	90 91 a5 05 	lds	r25, 0x05A5
    5f00:	bc 01       	movw	r22, r24
    5f02:	88 27       	eor	r24, r24
    5f04:	77 fd       	sbrc	r23, 7
    5f06:	80 95       	com	r24
    5f08:	98 2f       	mov	r25, r24
    5f0a:	80 90 a6 05 	lds	r8, 0x05A6
    5f0e:	90 90 a7 05 	lds	r9, 0x05A7
    5f12:	a0 90 a8 05 	lds	r10, 0x05A8
    5f16:	b0 90 a9 05 	lds	r11, 0x05A9
    5f1a:	68 0d       	add	r22, r8
    5f1c:	79 1d       	adc	r23, r9
    5f1e:	8a 1d       	adc	r24, r10
    5f20:	9b 1d       	adc	r25, r11
    5f22:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5f26:	20 e0       	ldi	r18, 0x00	; 0
    5f28:	30 e2       	ldi	r19, 0x20	; 32
    5f2a:	40 ed       	ldi	r20, 0xD0	; 208
    5f2c:	53 e4       	ldi	r21, 0x43	; 67
    5f2e:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5f32:	9b 01       	movw	r18, r22
    5f34:	ac 01       	movw	r20, r24
    5f36:	c7 01       	movw	r24, r14
    5f38:	b6 01       	movw	r22, r12
    5f3a:	0e 94 c8 6a 	call	0xd590	; 0xd590 <__gesf2>
    5f3e:	18 16       	cp	r1, r24
    5f40:	0c f0       	brlt	.+2      	; 0x5f44 <drive_oneTile+0x764>
    5f42:	05 c1       	rjmp	.+522    	; 0x614e <drive_oneTile+0x96e>
    5f44:	80 91 ae 05 	lds	r24, 0x05AE
    5f48:	80 fd       	sbrc	r24, 0
    5f4a:	03 c1       	rjmp	.+518    	; 0x6152 <drive_oneTile+0x972>
							{
								if((dot_tile_middle & (1<<0)) == 0)
    5f4c:	81 60       	ori	r24, 0x01	; 1
    5f4e:	80 93 ae 05 	sts	0x05AE, r24
    5f52:	82 e0       	ldi	r24, 0x02	; 2
								{
									returnvar = NOW_15; //15cm gefahren
									dot_tile_middle |= (1<<0);
    5f54:	07 c1       	rjmp	.+526    	; 0x6164 <drive_oneTile+0x984>
    5f56:	64 e6       	ldi	r22, 0x64	; 100
    5f58:	84 ef       	ldi	r24, 0xF4	; 244
							}
							else if(mot.enc > (enc_lr_start_dot + enc_lr_add_dot + (TILE_LENGTH_MIN_DRIVE * ENC_FAC_CM_LR))) // >= 16cm gefahren *GENDERT VON 15, KONSTANTE EINFHREN!!!*
							{
								if((dot_tile_middle & (1<<0)) == 0)
								{
									returnvar = NOW_15; //15cm gefahren
    5f5a:	9f ef       	ldi	r25, 0xFF	; 255
    5f5c:	29 d9       	rcall	.-3502   	; 0x51b0 <drive_rotate>

						break;

		case DOT_ROT_WEST:

							if(!drive_rotate(-TURN_ANGLE_COLLISION_AVOIDED, MAXSPEED))
    5f5e:	81 11       	cpse	r24, r1
    5f60:	72 cd       	rjmp	.-1308   	; 0x5a46 <drive_oneTile+0x266>
    5f62:	83 e0       	ldi	r24, 0x03	; 3
    5f64:	80 93 ad 05 	sts	0x05AD, r24
    5f68:	10 92 ac 05 	sts	0x05AC, r1
							{
								sm_dot = DOT_DRIVE;
    5f6c:	60 91 a4 05 	lds	r22, 0x05A4
    5f70:	70 91 a5 05 	lds	r23, 0x05A5
								dot_aligned_turn = NONE;
    5f74:	88 27       	eor	r24, r24

								if(enc_lr_add_dot < (DIST_ADD_COLLISION_MAX * ENC_FAC_CM_LR))
    5f76:	77 fd       	sbrc	r23, 7
    5f78:	80 95       	com	r24
    5f7a:	98 2f       	mov	r25, r24
    5f7c:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5f80:	6b 01       	movw	r12, r22
    5f82:	7c 01       	movw	r14, r24
    5f84:	20 e0       	ldi	r18, 0x00	; 0
    5f86:	30 e0       	ldi	r19, 0x00	; 0
    5f88:	41 ee       	ldi	r20, 0xE1	; 225
    5f8a:	52 e4       	ldi	r21, 0x42	; 66
    5f8c:	0e 94 79 69 	call	0xd2f2	; 0xd2f2 <__cmpsf2>
    5f90:	87 ff       	sbrs	r24, 7
    5f92:	59 cd       	rjmp	.-1358   	; 0x5a46 <drive_oneTile+0x266>
    5f94:	20 e0       	ldi	r18, 0x00	; 0
    5f96:	30 e0       	ldi	r19, 0x00	; 0
    5f98:	44 eb       	ldi	r20, 0xB4	; 180
    5f9a:	51 e4       	ldi	r21, 0x41	; 65
    5f9c:	c7 01       	movw	r24, r14
								{
									enc_lr_add_dot += DIST_ADD_COLLISION * ENC_FAC_CM_LR;
    5f9e:	b6 01       	movw	r22, r12
    5fa0:	19 c0       	rjmp	.+50     	; 0x5fd4 <drive_oneTile+0x7f4>
    5fa2:	64 e6       	ldi	r22, 0x64	; 100
    5fa4:	8c e0       	ldi	r24, 0x0C	; 12
    5fa6:	90 e0       	ldi	r25, 0x00	; 0
    5fa8:	03 d9       	rcall	.-3578   	; 0x51b0 <drive_rotate>
    5faa:	81 11       	cpse	r24, r1
							returnvar = DOT_RET_ALIGN;

						break;

		case DOT_ROT_EAST:
							if(!drive_rotate(TURN_ANGLE_COLLISION_AVOIDED, MAXSPEED))
    5fac:	4c cd       	rjmp	.-1384   	; 0x5a46 <drive_oneTile+0x266>
    5fae:	83 e0       	ldi	r24, 0x03	; 3
    5fb0:	80 93 ad 05 	sts	0x05AD, r24
    5fb4:	10 92 ac 05 	sts	0x05AC, r1
    5fb8:	60 91 a4 05 	lds	r22, 0x05A4
							{
								sm_dot = DOT_DRIVE;
    5fbc:	70 91 a5 05 	lds	r23, 0x05A5
								dot_aligned_turn = NONE;
    5fc0:	88 27       	eor	r24, r24
    5fc2:	77 fd       	sbrc	r23, 7

								enc_lr_add_dot += DIST_ADD_COLLISION * ENC_FAC_CM_LR;
    5fc4:	80 95       	com	r24
    5fc6:	98 2f       	mov	r25, r24
    5fc8:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    5fcc:	20 e0       	ldi	r18, 0x00	; 0
    5fce:	30 e0       	ldi	r19, 0x00	; 0
    5fd0:	44 eb       	ldi	r20, 0xB4	; 180
    5fd2:	51 e4       	ldi	r21, 0x41	; 65
    5fd4:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    5fd8:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    5fdc:	70 93 a5 05 	sts	0x05A5, r23
    5fe0:	60 93 a4 05 	sts	0x05A4, r22
    5fe4:	30 cd       	rjmp	.-1440   	; 0x5a46 <drive_oneTile+0x266>
    5fe6:	80 91 74 07 	lds	r24, 0x0774
    5fea:	90 91 75 07 	lds	r25, 0x0775
    5fee:	20 91 77 16 	lds	r18, 0x1677

						break;

		case DOT_COMP_ENC:

							if(abs((mot.d[RIGHT].enc - enc_dot_comp[RIGHT]) - (mot.d[LEFT].enc - enc_dot_comp[LEFT])) > 100)
    5ff2:	30 91 78 16 	lds	r19, 0x1678
    5ff6:	82 0f       	add	r24, r18
    5ff8:	93 1f       	adc	r25, r19
    5ffa:	20 91 78 07 	lds	r18, 0x0778
    5ffe:	30 91 79 07 	lds	r19, 0x0779
    6002:	82 1b       	sub	r24, r18
    6004:	93 0b       	sbc	r25, r19
    6006:	20 91 6b 16 	lds	r18, 0x166B
    600a:	30 91 6c 16 	lds	r19, 0x166C
    600e:	82 1b       	sub	r24, r18
    6010:	93 0b       	sbc	r25, r19
    6012:	97 ff       	sbrs	r25, 7
    6014:	03 c0       	rjmp	.+6      	; 0x601c <drive_oneTile+0x83c>
    6016:	91 95       	neg	r25
    6018:	81 95       	neg	r24
    601a:	91 09       	sbc	r25, r1
    601c:	85 36       	cpi	r24, 0x65	; 101
    601e:	91 05       	cpc	r25, r1
    6020:	0c f4       	brge	.+2      	; 0x6024 <drive_oneTile+0x844>
    6022:	59 c0       	rjmp	.+178    	; 0x60d6 <drive_oneTile+0x8f6>
    6024:	80 e0       	ldi	r24, 0x00	; 0
    6026:	c5 d5       	rcall	.+2954   	; 0x6bb2 <robot_getAngleToWall>
    6028:	80 31       	cpi	r24, 0x10	; 16
    602a:	97 42       	sbci	r25, 0x27	; 39
    602c:	09 f0       	breq	.+2      	; 0x6030 <drive_oneTile+0x850>
    602e:	49 c0       	rjmp	.+146    	; 0x60c2 <drive_oneTile+0x8e2>
							{
								if(robot_getAngleToWall(NONE) == GETANGLE_NOANGLE)
    6030:	60 91 77 16 	lds	r22, 0x1677
    6034:	70 91 78 16 	lds	r23, 0x1678
    6038:	80 91 79 16 	lds	r24, 0x1679
    603c:	90 91 7a 16 	lds	r25, 0x167A
								{
									dot_corr_angle = ((mot.d[RIGHT].enc - enc_dot_comp[RIGHT]) - (mot.d[LEFT].enc - enc_dot_comp[LEFT]))/13;
    6040:	c0 90 78 07 	lds	r12, 0x0778
    6044:	d0 90 79 07 	lds	r13, 0x0779
    6048:	e0 90 7a 07 	lds	r14, 0x077A
    604c:	f0 90 7b 07 	lds	r15, 0x077B
    6050:	6c 19       	sub	r22, r12
    6052:	7d 09       	sbc	r23, r13
    6054:	8e 09       	sbc	r24, r14
    6056:	9f 09       	sbc	r25, r15
    6058:	c0 90 74 07 	lds	r12, 0x0774
    605c:	d0 90 75 07 	lds	r13, 0x0775
    6060:	e0 90 76 07 	lds	r14, 0x0776
    6064:	f0 90 77 07 	lds	r15, 0x0777
    6068:	80 90 6b 16 	lds	r8, 0x166B
    606c:	90 90 6c 16 	lds	r9, 0x166C
    6070:	a0 90 6d 16 	lds	r10, 0x166D
    6074:	b0 90 6e 16 	lds	r11, 0x166E
    6078:	c8 18       	sub	r12, r8
    607a:	d9 08       	sbc	r13, r9
    607c:	ea 08       	sbc	r14, r10
    607e:	fb 08       	sbc	r15, r11
    6080:	6c 0d       	add	r22, r12
    6082:	7d 1d       	adc	r23, r13
    6084:	8e 1d       	adc	r24, r14
    6086:	9f 1d       	adc	r25, r15
    6088:	2d e0       	ldi	r18, 0x0D	; 13
    608a:	30 e0       	ldi	r19, 0x00	; 0
    608c:	40 e0       	ldi	r20, 0x00	; 0
    608e:	50 e0       	ldi	r21, 0x00	; 0
    6090:	0e 94 7f 6b 	call	0xd6fe	; 0xd6fe <__divmodsi4>
    6094:	2f 31       	cpi	r18, 0x1F	; 31
    6096:	31 05       	cpc	r19, r1
    6098:	1c f0       	brlt	.+6      	; 0x60a0 <drive_oneTile+0x8c0>
    609a:	8e e1       	ldi	r24, 0x1E	; 30
    609c:	90 e0       	ldi	r25, 0x00	; 0
    609e:	0b c0       	rjmp	.+22     	; 0x60b6 <drive_oneTile+0x8d6>
    60a0:	22 3e       	cpi	r18, 0xE2	; 226

									if(dot_corr_angle > 30)
    60a2:	6f ef       	ldi	r22, 0xFF	; 255
    60a4:	36 07       	cpc	r19, r22
    60a6:	2c f0       	brlt	.+10     	; 0x60b2 <drive_oneTile+0x8d2>
										dot_corr_angle = 30;
    60a8:	30 93 ab 05 	sts	0x05AB, r19
    60ac:	20 93 aa 05 	sts	0x05AA, r18
									else if(dot_corr_angle < -30)
    60b0:	06 c0       	rjmp	.+12     	; 0x60be <drive_oneTile+0x8de>
    60b2:	82 ee       	ldi	r24, 0xE2	; 226
    60b4:	9f ef       	ldi	r25, 0xFF	; 255

							if(abs((mot.d[RIGHT].enc - enc_dot_comp[RIGHT]) - (mot.d[LEFT].enc - enc_dot_comp[LEFT])) > 100)
							{
								if(robot_getAngleToWall(NONE) == GETANGLE_NOANGLE)
								{
									dot_corr_angle = ((mot.d[RIGHT].enc - enc_dot_comp[RIGHT]) - (mot.d[LEFT].enc - enc_dot_comp[LEFT]))/13;
    60b6:	90 93 ab 05 	sts	0x05AB, r25
    60ba:	80 93 aa 05 	sts	0x05AA, r24
    60be:	87 e0       	ldi	r24, 0x07	; 7

									if(dot_corr_angle > 30)
										dot_corr_angle = 30;
									else if(dot_corr_angle < -30)
										dot_corr_angle = -30;
    60c0:	0b c0       	rjmp	.+22     	; 0x60d8 <drive_oneTile+0x8f8>
    60c2:	88 e0       	ldi	r24, 0x08	; 8
    60c4:	09 c0       	rjmp	.+18     	; 0x60d8 <drive_oneTile+0x8f8>
    60c6:	64 e6       	ldi	r22, 0x64	; 100
    60c8:	80 91 aa 05 	lds	r24, 0x05AA

									sm_dot = DOT_CORR;
    60cc:	90 91 ab 05 	lds	r25, 0x05AB
								}
								else
								{
									sm_dot = DOT_ALIGN_WALL;
    60d0:	6f d8       	rcall	.-3874   	; 0x51b0 <drive_rotate>
    60d2:	81 11       	cpse	r24, r1
							returnvar = DOT_RET_ALIGN;

						break;

		case DOT_CORR:
							if(!drive_rotate(dot_corr_angle, MAXSPEED))
    60d4:	b8 cc       	rjmp	.-1680   	; 0x5a46 <drive_oneTile+0x266>
    60d6:	89 e0       	ldi	r24, 0x09	; 9
    60d8:	80 93 ad 05 	sts	0x05AD, r24
    60dc:	b4 cc       	rjmp	.-1688   	; 0x5a46 <drive_oneTile+0x266>
    60de:	a1 da       	rcall	.-2750   	; 0x5622 <drive_align>
    60e0:	81 11       	cpse	r24, r1
    60e2:	31 c0       	rjmp	.+98     	; 0x6146 <drive_oneTile+0x966>
    60e4:	89 e0       	ldi	r24, 0x09	; 9
								sm_dot = DOT_END;
    60e6:	80 93 ad 05 	sts	0x05AD, r24
    60ea:	2d c0       	rjmp	.+90     	; 0x6146 <drive_oneTile+0x966>
    60ec:	10 92 ad 05 	sts	0x05AD, r1
							returnvar = DOT_RET_ALIGN;
						break;

		case DOT_ALIGN_WALL:

							if(!drive_align())
    60f0:	80 91 53 05 	lds	r24, 0x0553
    60f4:	88 23       	and	r24, r24
							{
								sm_dot = DOT_END;
    60f6:	39 f1       	breq	.+78     	; 0x6146 <drive_oneTile+0x966>
    60f8:	8a e2       	ldi	r24, 0x2A	; 42
    60fa:	98 e2       	ldi	r25, 0x28	; 40
    60fc:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>

						break;

		case DOT_END:
							
							sm_dot = DOT_INIT;
    6100:	60 91 47 05 	lds	r22, 0x0547
							returnvar = DOT_RET_READY;
							
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_oneTile():done"));}
    6104:	70 91 48 05 	lds	r23, 0x0548
    6108:	80 91 49 05 	lds	r24, 0x0549
    610c:	90 91 4a 05 	lds	r25, 0x054A
    6110:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    6114:	83 e1       	ldi	r24, 0x13	; 19
    6116:	98 e2       	ldi	r25, 0x28	; 40
    6118:	14 c0       	rjmp	.+40     	; 0x6142 <drive_oneTile+0x962>
    611a:	80 91 53 05 	lds	r24, 0x0553
    611e:	82 30       	cpi	r24, 0x02	; 2
    6120:	90 f0       	brcs	.+36     	; 0x6146 <drive_oneTile+0x966>
    6122:	80 e1       	ldi	r24, 0x10	; 16
    6124:	98 e2       	ldi	r25, 0x28	; 40
    6126:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    612a:	60 91 47 05 	lds	r22, 0x0547
							
						break;
						
		default:	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL: went into drive_oneTile():sm_dot:DEFAULT_CASE"));}
    612e:	70 91 48 05 	lds	r23, 0x0548
    6132:	80 91 49 05 	lds	r24, 0x0549
    6136:	90 91 4a 05 	lds	r25, 0x054A
    613a:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    613e:	82 ed       	ldi	r24, 0xD2	; 210
    6140:	97 e2       	ldi	r25, 0x27	; 39
    6142:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    6146:	80 e0       	ldi	r24, 0x00	; 0
    6148:	0d c0       	rjmp	.+26     	; 0x6164 <drive_oneTile+0x984>
    614a:	85 e0       	ldi	r24, 0x05	; 5
    614c:	0b c0       	rjmp	.+22     	; 0x6164 <drive_oneTile+0x984>
    614e:	83 e0       	ldi	r24, 0x03	; 3
    6150:	09 c0       	rjmp	.+18     	; 0x6164 <drive_oneTile+0x984>
    6152:	81 e0       	ldi	r24, 0x01	; 1
    6154:	07 c0       	rjmp	.+14     	; 0x6164 <drive_oneTile+0x984>
    6156:	c8 14       	cp	r12, r8
							timer_drive = -1;
							steer_dot = 0;

							if(dist[LIN][FRONT][FRONT] < TILE1_FRONT_FRONT) //weiter als hier geht nicht!
							{
								returnvar = DOT_RET_READY; //SOFORT abbrechen! Nicht erst in andere Teile der SM springen lassen (Zeitverschwendung)
    6158:	d9 04       	cpc	r13, r9
    615a:	ea 04       	cpc	r14, r10
								{
									sm_dot = DOT_DRIVE;
									enc_lr_start_dot = mot.enc;
								}
									
								returnvar = DOT_RET_INIT;
    615c:	fb 04       	cpc	r15, r11
    615e:	0c f4       	brge	.+2      	; 0x6162 <drive_oneTile+0x982>
									returnvar = AB_15; // > 15cm gefahren
								}
							}
							else
							{
								returnvar = UD_15; // < 15cm gefahren
    6160:	7a ce       	rjmp	.-780    	; 0x5e56 <drive_oneTile+0x676>
    6162:	87 ce       	rjmp	.-754    	; 0x5e72 <drive_oneTile+0x692>
									returnvar = NOW_15; //15cm gefahren
									dot_tile_middle |= (1<<0);
								}
								else
								{
									returnvar = AB_15; // > 15cm gefahren
    6164:	0f 90       	pop	r0
    6166:	0f 90       	pop	r0
							{
								sm_dot = DOT_COMP_ENC; //End, compare angle of the robot
								mot.d[LEFT].speed.to = 0;
								mot.d[RIGHT].speed.to = 0;
							}
							else if((mot.enc < enc_lr_start_dot) &&
    6168:	0f 90       	pop	r0
    616a:	0f 90       	pop	r0
    616c:	df 91       	pop	r29
    616e:	cf 91       	pop	r28
    6170:	1f 91       	pop	r17
    6172:	ff 90       	pop	r15
    6174:	ef 90       	pop	r14
							returnvar = 0;
						break;
							
	}
	return returnvar;
}
    6176:	df 90       	pop	r13
    6178:	cf 90       	pop	r12
    617a:	bf 90       	pop	r11
    617c:	af 90       	pop	r10
    617e:	9f 90       	pop	r9
    6180:	8f 90       	pop	r8
    6182:	7f 90       	pop	r7
    6184:	6f 90       	pop	r6
    6186:	5f 90       	pop	r5
    6188:	4f 90       	pop	r4
    618a:	3f 90       	pop	r3
    618c:	2f 90       	pop	r2
    618e:	08 95       	ret

00006190 <drive_align_back>:

uint8_t drive_align_back(uint8_t dist_to) //Distance to the back
{
	uint8_t returnvar = 1;

	switch(sm_dab)
    6190:	90 91 8d 05 	lds	r25, 0x058D
    6194:	91 30       	cpi	r25, 0x01	; 1
    6196:	29 f1       	breq	.+74     	; 0x61e2 <drive_align_back+0x52>
    6198:	78 f0       	brcs	.+30     	; 0x61b8 <drive_align_back+0x28>
    619a:	92 30       	cpi	r25, 0x02	; 2
    619c:	09 f0       	breq	.+2      	; 0x61a0 <drive_align_back+0x10>
    619e:	75 c0       	rjmp	.+234    	; 0x628a <drive_align_back+0xfa>
				}

			break;

		case 2:
				mot.d[LEFT].speed.to = 0;
    61a0:	10 92 6a 16 	sts	0x166A, r1
    61a4:	10 92 69 16 	sts	0x1669, r1
				mot.d[RIGHT].speed.to = 0;
    61a8:	10 92 76 16 	sts	0x1676, r1
    61ac:	10 92 75 16 	sts	0x1675, r1

				sm_dab = 0;
    61b0:	10 92 8d 05 	sts	0x058D, r1
				returnvar = 0;
    61b4:	80 e0       	ldi	r24, 0x00	; 0
    61b6:	08 95       	ret

	switch(sm_dab)
	{
		case 0:

				if(dist[LIN][BACK][BACK] < TILE1_BACK_TH_BACK)
    61b8:	80 91 c0 07 	lds	r24, 0x07C0
    61bc:	90 91 c1 07 	lds	r25, 0x07C1
    61c0:	8a 3f       	cpi	r24, 0xFA	; 250
    61c2:	91 05       	cpc	r25, r1
    61c4:	54 f4       	brge	.+20     	; 0x61da <drive_align_back+0x4a>
				{
					timer_drive = TIMER_ALIGN;
    61c6:	88 e7       	ldi	r24, 0x78	; 120
    61c8:	90 e0       	ldi	r25, 0x00	; 0
    61ca:	90 93 96 02 	sts	0x0296, r25
    61ce:	80 93 95 02 	sts	0x0295, r24
					sm_dab = 1;
    61d2:	81 e0       	ldi	r24, 0x01	; 1
    61d4:	80 93 8d 05 	sts	0x058D, r24
    61d8:	08 95       	ret
				}
				else
					sm_dab = 2;
    61da:	82 e0       	ldi	r24, 0x02	; 2
    61dc:	80 93 8d 05 	sts	0x058D, r24
    61e0:	54 c0       	rjmp	.+168    	; 0x628a <drive_align_back+0xfa>

			break;

		case 1:

				steer_dab = ((dist_to - (dist[LIN][BACK][BACK])) * KP_ALIGN_BACK);
    61e2:	68 2f       	mov	r22, r24
    61e4:	70 e0       	ldi	r23, 0x00	; 0
    61e6:	80 91 c0 07 	lds	r24, 0x07C0
    61ea:	90 91 c1 07 	lds	r25, 0x07C1
    61ee:	68 1b       	sub	r22, r24
    61f0:	79 0b       	sbc	r23, r25
    61f2:	88 27       	eor	r24, r24
    61f4:	77 fd       	sbrc	r23, 7
    61f6:	80 95       	com	r24
    61f8:	98 2f       	mov	r25, r24
    61fa:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    61fe:	2a e9       	ldi	r18, 0x9A	; 154
    6200:	39 e9       	ldi	r19, 0x99	; 153
    6202:	49 e1       	ldi	r20, 0x19	; 25
    6204:	5f e3       	ldi	r21, 0x3F	; 63
    6206:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    620a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    620e:	70 93 8c 05 	sts	0x058C, r23
    6212:	60 93 8b 05 	sts	0x058B, r22

				mot.d[LEFT].speed.to = steer_dab;
    6216:	70 93 6a 16 	sts	0x166A, r23
    621a:	60 93 69 16 	sts	0x1669, r22
				mot.d[RIGHT].speed.to = steer_dab;
    621e:	70 93 76 16 	sts	0x1676, r23
    6222:	60 93 75 16 	sts	0x1675, r22

				drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, MAXSPEED);
    6226:	44 e6       	ldi	r20, 0x64	; 100
    6228:	65 e7       	ldi	r22, 0x75	; 117
    622a:	76 e1       	ldi	r23, 0x16	; 22
    622c:	89 e6       	ldi	r24, 0x69	; 105
    622e:	96 e1       	ldi	r25, 0x16	; 22
    6230:	0e 94 af 28 	call	0x515e	; 0x515e <drive_limitSpeed>

				if((abs(steer_dab) <= STEER_ALIGN_BACK_END) || (timer_drive == 0) ||
    6234:	80 91 8b 05 	lds	r24, 0x058B
    6238:	90 91 8c 05 	lds	r25, 0x058C
    623c:	02 96       	adiw	r24, 0x02	; 2
    623e:	05 97       	sbiw	r24, 0x05	; 5
    6240:	d8 f0       	brcs	.+54     	; 0x6278 <drive_align_back+0xe8>
    6242:	80 91 95 02 	lds	r24, 0x0295
    6246:	90 91 96 02 	lds	r25, 0x0296
    624a:	89 2b       	or	r24, r25
    624c:	a9 f0       	breq	.+42     	; 0x6278 <drive_align_back+0xe8>
    624e:	80 91 c0 07 	lds	r24, 0x07C0
    6252:	90 91 c1 07 	lds	r25, 0x07C1
    6256:	8b 3f       	cpi	r24, 0xFB	; 251
    6258:	91 05       	cpc	r25, r1
    625a:	bc f0       	brlt	.+46     	; 0x628a <drive_align_back+0xfa>
					((dist[LIN][BACK][BACK] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][LEFT] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][RIGHT] > TILE1_BACK_TH_BACK)))
    625c:	80 91 ba 07 	lds	r24, 0x07BA
    6260:	90 91 bb 07 	lds	r25, 0x07BB
    6264:	8b 3f       	cpi	r24, 0xFB	; 251
    6266:	91 05       	cpc	r25, r1
    6268:	84 f0       	brlt	.+32     	; 0x628a <drive_align_back+0xfa>
    626a:	80 91 bc 07 	lds	r24, 0x07BC
    626e:	90 91 bd 07 	lds	r25, 0x07BD
    6272:	8b 3f       	cpi	r24, 0xFB	; 251
    6274:	91 05       	cpc	r25, r1
    6276:	4c f0       	brlt	.+18     	; 0x628a <drive_align_back+0xfa>
				{
					sm_dab = 2;
    6278:	82 e0       	ldi	r24, 0x02	; 2
    627a:	80 93 8d 05 	sts	0x058D, r24
					timer_drive = -1;
    627e:	8f ef       	ldi	r24, 0xFF	; 255
    6280:	9f ef       	ldi	r25, 0xFF	; 255
    6282:	90 93 96 02 	sts	0x0296, r25
    6286:	80 93 95 02 	sts	0x0295, r24
				mot.d[RIGHT].speed.to = steer_dab;

				drive_limitSpeed(&mot.d[LEFT].speed.to, &mot.d[RIGHT].speed.to, MAXSPEED);

				if((abs(steer_dab) <= STEER_ALIGN_BACK_END) || (timer_drive == 0) ||
					((dist[LIN][BACK][BACK] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][LEFT] > TILE1_BACK_TH_BACK) && (dist[LIN][BACK][RIGHT] > TILE1_BACK_TH_BACK)))
    628a:	81 e0       	ldi	r24, 0x01	; 1
				returnvar = 0;

	}

	return returnvar;
}
    628c:	08 95       	ret

0000628e <drive_turn>:
enum DRIVE_TURN {TURN_INIT, TURN, TURN_ALIGN, TURN_ALIGN_BACK, TURN_END};

uint8_t sm_turn = TURN_INIT;

uint8_t drive_turn(int16_t angle, uint8_t align) //angle > 0 == turn right
{
    628e:	cf 93       	push	r28
    6290:	c6 2f       	mov	r28, r22
	uint8_t returnvar = 1;
	
	switch(sm_turn)
    6292:	20 91 8a 05 	lds	r18, 0x058A
    6296:	22 30       	cpi	r18, 0x02	; 2
    6298:	91 f1       	breq	.+100    	; 0x62fe <drive_turn+0x70>
    629a:	28 f4       	brcc	.+10     	; 0x62a6 <drive_turn+0x18>
    629c:	22 23       	and	r18, r18
    629e:	51 f0       	breq	.+20     	; 0x62b4 <drive_turn+0x26>
    62a0:	21 30       	cpi	r18, 0x01	; 1
    62a2:	59 f0       	breq	.+22     	; 0x62ba <drive_turn+0x2c>
    62a4:	7b c0       	rjmp	.+246    	; 0x639c <drive_turn+0x10e>
    62a6:	23 30       	cpi	r18, 0x03	; 3
    62a8:	09 f4       	brne	.+2      	; 0x62ac <drive_turn+0x1e>
    62aa:	58 c0       	rjmp	.+176    	; 0x635c <drive_turn+0xce>
    62ac:	24 30       	cpi	r18, 0x04	; 4
    62ae:	09 f4       	brne	.+2      	; 0x62b2 <drive_turn+0x24>
    62b0:	5e c0       	rjmp	.+188    	; 0x636e <drive_turn+0xe0>
    62b2:	74 c0       	rjmp	.+232    	; 0x639c <drive_turn+0x10e>
	{
		case TURN_INIT:
		
						sm_turn = TURN;
    62b4:	21 e0       	ldi	r18, 0x01	; 1
    62b6:	20 93 8a 05 	sts	0x058A, r18
						
		case TURN:
						if(!drive_rotate(angle, MAXSPEED))
    62ba:	64 e6       	ldi	r22, 0x64	; 100
    62bc:	0e 94 d8 28 	call	0x51b0	; 0x51b0 <drive_rotate>
    62c0:	81 11       	cpse	r24, r1
    62c2:	53 c0       	rjmp	.+166    	; 0x636a <drive_turn+0xdc>
						{
							if(align)
    62c4:	cc 23       	and	r28, r28
    62c6:	11 f0       	breq	.+4      	; 0x62cc <drive_turn+0x3e>
								sm_turn = TURN_ALIGN;
    62c8:	82 e0       	ldi	r24, 0x02	; 2
    62ca:	01 c0       	rjmp	.+2      	; 0x62ce <drive_turn+0x40>
							else
								sm_turn = TURN_END;
    62cc:	84 e0       	ldi	r24, 0x04	; 4
    62ce:	80 93 8a 05 	sts	0x058A, r24
							
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_turn()"));}
    62d2:	80 91 53 05 	lds	r24, 0x0553
    62d6:	88 23       	and	r24, r24
    62d8:	09 f4       	brne	.+2      	; 0x62dc <drive_turn+0x4e>
    62da:	47 c0       	rjmp	.+142    	; 0x636a <drive_turn+0xdc>
    62dc:	8e e4       	ldi	r24, 0x4E	; 78
    62de:	97 e2       	ldi	r25, 0x27	; 39
    62e0:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    62e4:	60 91 47 05 	lds	r22, 0x0547
    62e8:	70 91 48 05 	lds	r23, 0x0548
    62ec:	80 91 49 05 	lds	r24, 0x0549
    62f0:	90 91 4a 05 	lds	r25, 0x054A
    62f4:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    62f8:	8f e3       	ldi	r24, 0x3F	; 63
    62fa:	97 e2       	ldi	r25, 0x27	; 39
    62fc:	2c c0       	rjmp	.+88     	; 0x6356 <drive_turn+0xc8>
					break;
					
		case TURN_ALIGN:
		
						//GGf. Ausrichtung an Wand
						if(!drive_align())
    62fe:	91 d9       	rcall	.-3294   	; 0x5622 <drive_align>
    6300:	81 11       	cpse	r24, r1
    6302:	33 c0       	rjmp	.+102    	; 0x636a <drive_turn+0xdc>
    6304:	80 91 c0 07 	lds	r24, 0x07C0
						{
							if((dist[LIN][BACK][BACK] < TILE1_BACK_TH_BACK) &&
    6308:	90 91 c1 07 	lds	r25, 0x07C1
    630c:	8a 3f       	cpi	r24, 0xFA	; 250
    630e:	91 05       	cpc	r25, r1
    6310:	5c f4       	brge	.+22     	; 0x6328 <drive_turn+0x9a>
    6312:	60 91 4b 16 	lds	r22, 0x164B
								(maze_getWall(&robot.pos, robot.dir+2) > 0))
    6316:	6e 5f       	subi	r22, 0xFE	; 254
    6318:	88 e4       	ldi	r24, 0x48	; 72
    631a:	96 e1       	ldi	r25, 0x16	; 22
    631c:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    6320:	18 16       	cp	r1, r24
		case TURN_ALIGN:
		
						//GGf. Ausrichtung an Wand
						if(!drive_align())
						{
							if((dist[LIN][BACK][BACK] < TILE1_BACK_TH_BACK) &&
    6322:	14 f4       	brge	.+4      	; 0x6328 <drive_turn+0x9a>
    6324:	83 e0       	ldi	r24, 0x03	; 3
								(maze_getWall(&robot.pos, robot.dir+2) > 0))
							{
								sm_turn = TURN_ALIGN_BACK;
    6326:	01 c0       	rjmp	.+2      	; 0x632a <drive_turn+0x9c>
    6328:	84 e0       	ldi	r24, 0x04	; 4
							}
							else
							{
								sm_turn = TURN_END;
    632a:	80 93 8a 05 	sts	0x058A, r24
    632e:	80 91 53 05 	lds	r24, 0x0553
							}

							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_turn(): aligned"));}
    6332:	88 23       	and	r24, r24
    6334:	d1 f0       	breq	.+52     	; 0x636a <drive_turn+0xdc>
    6336:	8c e3       	ldi	r24, 0x3C	; 60
    6338:	97 e2       	ldi	r25, 0x27	; 39
    633a:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    633e:	60 91 47 05 	lds	r22, 0x0547
    6342:	70 91 48 05 	lds	r23, 0x0548
    6346:	80 91 49 05 	lds	r24, 0x0549
    634a:	90 91 4a 05 	lds	r25, 0x054A
    634e:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    6352:	84 e2       	ldi	r24, 0x24	; 36
    6354:	97 e2       	ldi	r25, 0x27	; 39
    6356:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    635a:	07 c0       	rjmp	.+14     	; 0x636a <drive_turn+0xdc>
    635c:	86 e4       	ldi	r24, 0x46	; 70

					break;

		case TURN_ALIGN_BACK:

							if(!drive_align_back(TILE1_BACK_BACK))
    635e:	18 df       	rcall	.-464    	; 0x6190 <drive_align_back>
    6360:	81 11       	cpse	r24, r1
    6362:	03 c0       	rjmp	.+6      	; 0x636a <drive_turn+0xdc>
    6364:	84 e0       	ldi	r24, 0x04	; 4
    6366:	80 93 8a 05 	sts	0x058A, r24
							{
								sm_turn = TURN_END;
    636a:	81 e0       	ldi	r24, 0x01	; 1
    636c:	2e c0       	rjmp	.+92     	; 0x63ca <drive_turn+0x13c>

uint8_t sm_turn = TURN_INIT;

uint8_t drive_turn(int16_t angle, uint8_t align) //angle > 0 == turn right
{
	uint8_t returnvar = 1;
    636e:	10 92 8a 05 	sts	0x058A, r1

					break;
					
		case TURN_END:
		
						sm_turn = TURN_INIT;
    6372:	80 91 53 05 	lds	r24, 0x0553
						returnvar = 0;
						
						if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_turn(): done. "));}
    6376:	88 23       	and	r24, r24
    6378:	39 f1       	breq	.+78     	; 0x63c8 <drive_turn+0x13a>
    637a:	81 e2       	ldi	r24, 0x21	; 33
    637c:	97 e2       	ldi	r25, 0x27	; 39
    637e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    6382:	60 91 47 05 	lds	r22, 0x0547
    6386:	70 91 48 05 	lds	r23, 0x0548
    638a:	80 91 49 05 	lds	r24, 0x0549
    638e:	90 91 4a 05 	lds	r25, 0x054A
    6392:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    6396:	8a e0       	ldi	r24, 0x0A	; 10
    6398:	97 e2       	ldi	r25, 0x27	; 39
    639a:	14 c0       	rjmp	.+40     	; 0x63c4 <drive_turn+0x136>
    639c:	80 91 53 05 	lds	r24, 0x0553
						
					break;
		default:	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": FATAL ERROR: WENT INTO drive_turn():sm_turn DEFAULT CASE!"));}
    63a0:	82 30       	cpi	r24, 0x02	; 2
    63a2:	90 f0       	brcs	.+36     	; 0x63c8 <drive_turn+0x13a>
    63a4:	87 e0       	ldi	r24, 0x07	; 7
    63a6:	97 e2       	ldi	r25, 0x27	; 39
    63a8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    63ac:	60 91 47 05 	lds	r22, 0x0547
    63b0:	70 91 48 05 	lds	r23, 0x0548
    63b4:	80 91 49 05 	lds	r24, 0x0549
    63b8:	90 91 4a 05 	lds	r25, 0x054A
    63bc:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    63c0:	8b ec       	ldi	r24, 0xCB	; 203
    63c2:	96 e2       	ldi	r25, 0x26	; 38
    63c4:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    63c8:	80 e0       	ldi	r24, 0x00	; 0
    63ca:	cf 91       	pop	r28
							returnvar = 0;
    63cc:	08 95       	ret

000063ce <drive_neutralPos>:

uint8_t drive_neutralPos(void)
{
	uint8_t returnvar = 1;

	switch(sm_nP)
    63ce:	80 91 87 05 	lds	r24, 0x0587
    63d2:	82 30       	cpi	r24, 0x02	; 2
    63d4:	29 f1       	breq	.+74     	; 0x6420 <drive_neutralPos+0x52>
    63d6:	28 f4       	brcc	.+10     	; 0x63e2 <drive_neutralPos+0x14>
    63d8:	88 23       	and	r24, r24
    63da:	61 f0       	breq	.+24     	; 0x63f4 <drive_neutralPos+0x26>
    63dc:	81 30       	cpi	r24, 0x01	; 1
    63de:	a1 f0       	breq	.+40     	; 0x6408 <drive_neutralPos+0x3a>
    63e0:	39 c0       	rjmp	.+114    	; 0x6454 <drive_neutralPos+0x86>
    63e2:	84 30       	cpi	r24, 0x04	; 4
    63e4:	71 f1       	breq	.+92     	; 0x6442 <drive_neutralPos+0x74>
    63e6:	20 f1       	brcs	.+72     	; 0x6430 <drive_neutralPos+0x62>
    63e8:	85 30       	cpi	r24, 0x05	; 5
    63ea:	a1 f5       	brne	.+104    	; 0x6454 <drive_neutralPos+0x86>
				}
				
			break;
			
		case 5:
				sm_nP = 0;
    63ec:	10 92 87 05 	sts	0x0587, r1
				returnvar = 0;
    63f0:	80 e0       	ldi	r24, 0x00	; 0
			break;
    63f2:	08 95       	ret
	uint8_t returnvar = 1;

	switch(sm_nP)
	{
		case 0:
				if(!drive_turn(90, 1))
    63f4:	61 e0       	ldi	r22, 0x01	; 1
    63f6:	8a e5       	ldi	r24, 0x5A	; 90
    63f8:	90 e0       	ldi	r25, 0x00	; 0
    63fa:	49 df       	rcall	.-366    	; 0x628e <drive_turn>
    63fc:	81 11       	cpse	r24, r1
    63fe:	2a c0       	rjmp	.+84     	; 0x6454 <drive_neutralPos+0x86>
    6400:	81 e0       	ldi	r24, 0x01	; 1
				{
					sm_nP = 1;
    6402:	80 93 87 05 	sts	0x0587, r24
    6406:	08 95       	ret
    6408:	80 91 b6 07 	lds	r24, 0x07B6
				}
				
			break;
		
		case 1:
				if(dist[LIN][FRONT][FRONT] > TILE1_FRONT_FRONT+10)
    640c:	90 91 b7 07 	lds	r25, 0x07B7
    6410:	85 36       	cpi	r24, 0x65	; 101
    6412:	91 05       	cpc	r25, r1
    6414:	1c f0       	brlt	.+6      	; 0x641c <drive_neutralPos+0x4e>
    6416:	80 e0       	ldi	r24, 0x00	; 0
				{
					drive_oneTile(0);
    6418:	e3 d9       	rcall	.-3130   	; 0x57e0 <drive_oneTile>
    641a:	1c c0       	rjmp	.+56     	; 0x6454 <drive_neutralPos+0x86>
    641c:	82 e0       	ldi	r24, 0x02	; 2
    641e:	18 c0       	rjmp	.+48     	; 0x6450 <drive_neutralPos+0x82>
				}
				else
					sm_nP = 2;
    6420:	61 e0       	ldi	r22, 0x01	; 1
    6422:	8a e5       	ldi	r24, 0x5A	; 90
			
			break;
			
		case 2:
				if(!drive_turn(90, 1))
    6424:	90 e0       	ldi	r25, 0x00	; 0
    6426:	33 df       	rcall	.-410    	; 0x628e <drive_turn>
    6428:	81 11       	cpse	r24, r1
    642a:	14 c0       	rjmp	.+40     	; 0x6454 <drive_neutralPos+0x86>
    642c:	83 e0       	ldi	r24, 0x03	; 3
    642e:	10 c0       	rjmp	.+32     	; 0x6450 <drive_neutralPos+0x82>
    6430:	80 91 b6 07 	lds	r24, 0x07B6
				{
					sm_nP = 3;
    6434:	90 91 b7 07 	lds	r25, 0x07B7
				}
			
			break;
		
		case 3:
				if(dist[LIN][FRONT][FRONT] > TILE1_FRONT_FRONT+10)
    6438:	85 36       	cpi	r24, 0x65	; 101
    643a:	91 05       	cpc	r25, r1
    643c:	64 f7       	brge	.-40     	; 0x6416 <drive_neutralPos+0x48>
    643e:	84 e0       	ldi	r24, 0x04	; 4
    6440:	07 c0       	rjmp	.+14     	; 0x6450 <drive_neutralPos+0x82>
    6442:	61 e0       	ldi	r22, 0x01	; 1
				{
					drive_oneTile(0);
				}
				else	sm_nP = 4;
    6444:	8a e5       	ldi	r24, 0x5A	; 90
    6446:	90 e0       	ldi	r25, 0x00	; 0
				
			break;
			
		case 4:
				if(!drive_turn(90, 1))
    6448:	22 df       	rcall	.-444    	; 0x628e <drive_turn>
    644a:	81 11       	cpse	r24, r1
    644c:	03 c0       	rjmp	.+6      	; 0x6454 <drive_neutralPos+0x86>
    644e:	85 e0       	ldi	r24, 0x05	; 5
    6450:	80 93 87 05 	sts	0x0587, r24
    6454:	81 e0       	ldi	r24, 0x01	; 1
				{
					sm_nP = 5;
    6456:	08 95       	ret

00006458 <drive_dist>:

int32_t enc_l_start_ddist = 0;
int32_t enc_r_start_ddist = 0;

uint8_t drive_dist(int8_t motor, int8_t speed, int8_t dist_cm) //which @motor to move: < 0 ~ left, 0 ~ both, > 0 ~ right
{
    6458:	0f 93       	push	r16
    645a:	1f 93       	push	r17
    645c:	28 2f       	mov	r18, r24
    645e:	e6 2f       	mov	r30, r22
	uint8_t returnvar = 1;

	switch(sm_ddist)
    6460:	80 91 83 05 	lds	r24, 0x0583
    6464:	81 30       	cpi	r24, 0x01	; 1
    6466:	09 f4       	brne	.+2      	; 0x646a <drive_dist+0x12>
    6468:	41 c0       	rjmp	.+130    	; 0x64ec <drive_dist+0x94>
    646a:	20 91 53 05 	lds	r18, 0x0553
    646e:	81 30       	cpi	r24, 0x01	; 1
    6470:	20 f0       	brcs	.+8      	; 0x647a <drive_dist+0x22>
    6472:	82 30       	cpi	r24, 0x02	; 2
    6474:	09 f4       	brne	.+2      	; 0x6478 <drive_dist+0x20>
    6476:	65 c1       	rjmp	.+714    	; 0x6742 <drive_dist+0x2ea>
    6478:	81 c1       	rjmp	.+770    	; 0x677c <drive_dist+0x324>
	{
		case 0: 	enc_l_start_ddist = mot.d[LEFT].enc;
    647a:	80 91 6b 16 	lds	r24, 0x166B
    647e:	90 91 6c 16 	lds	r25, 0x166C
    6482:	a0 91 6d 16 	lds	r26, 0x166D
    6486:	b0 91 6e 16 	lds	r27, 0x166E
    648a:	80 93 7f 05 	sts	0x057F, r24
    648e:	90 93 80 05 	sts	0x0580, r25
    6492:	a0 93 81 05 	sts	0x0581, r26
    6496:	b0 93 82 05 	sts	0x0582, r27
							enc_r_start_ddist = mot.d[RIGHT].enc;
    649a:	80 91 77 16 	lds	r24, 0x1677
    649e:	90 91 78 16 	lds	r25, 0x1678
    64a2:	a0 91 79 16 	lds	r26, 0x1679
    64a6:	b0 91 7a 16 	lds	r27, 0x167A
    64aa:	80 93 7b 05 	sts	0x057B, r24
    64ae:	90 93 7c 05 	sts	0x057C, r25
    64b2:	a0 93 7d 05 	sts	0x057D, r26
    64b6:	b0 93 7e 05 	sts	0x057E, r27

							sm_ddist = 1;
    64ba:	81 e0       	ldi	r24, 0x01	; 1
    64bc:	80 93 83 05 	sts	0x0583, r24
							
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_dist()"));}
    64c0:	22 23       	and	r18, r18
    64c2:	09 f4       	brne	.+2      	; 0x64c6 <drive_dist+0x6e>
    64c4:	71 c1       	rjmp	.+738    	; 0x67a8 <drive_dist+0x350>
    64c6:	88 ec       	ldi	r24, 0xC8	; 200
    64c8:	96 e2       	ldi	r25, 0x26	; 38
    64ca:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    64ce:	60 91 47 05 	lds	r22, 0x0547
    64d2:	70 91 48 05 	lds	r23, 0x0548
    64d6:	80 91 49 05 	lds	r24, 0x0549
    64da:	90 91 4a 05 	lds	r25, 0x054A
    64de:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    64e2:	89 eb       	ldi	r24, 0xB9	; 185
    64e4:	96 e2       	ldi	r25, 0x26	; 38
    64e6:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    64ea:	5e c1       	rjmp	.+700    	; 0x67a8 <drive_dist+0x350>
    64ec:	36 e1       	ldi	r19, 0x16	; 22
    64ee:	43 02       	muls	r20, r19
    64f0:	c0 01       	movw	r24, r0
    64f2:	11 24       	eor	r1, r1
						break;
		case 1: 	if(dist_cm < 0)
    64f4:	47 ff       	sbrs	r20, 7
    64f6:	97 c0       	rjmp	.+302    	; 0x6626 <drive_dist+0x1ce>
							{
								if(motor < 0)
    64f8:	27 ff       	sbrs	r18, 7
    64fa:	25 c0       	rjmp	.+74     	; 0x6546 <drive_dist+0xee>
								{
									if(mot.d[LEFT].enc > (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) //Ziel erreicht?
    64fc:	aa 27       	eor	r26, r26
    64fe:	97 fd       	sbrc	r25, 7
    6500:	a0 95       	com	r26
    6502:	ba 2f       	mov	r27, r26
    6504:	40 91 7f 05 	lds	r20, 0x057F
    6508:	50 91 80 05 	lds	r21, 0x0580
    650c:	60 91 81 05 	lds	r22, 0x0581
    6510:	70 91 82 05 	lds	r23, 0x0582
    6514:	84 0f       	add	r24, r20
    6516:	95 1f       	adc	r25, r21
    6518:	a6 1f       	adc	r26, r22
    651a:	b7 1f       	adc	r27, r23
    651c:	40 91 6b 16 	lds	r20, 0x166B
    6520:	50 91 6c 16 	lds	r21, 0x166C
    6524:	60 91 6d 16 	lds	r22, 0x166D
    6528:	70 91 6e 16 	lds	r23, 0x166E
    652c:	84 17       	cp	r24, r20
    652e:	95 07       	cpc	r25, r21
    6530:	a6 07       	cpc	r26, r22
    6532:	b7 07       	cpc	r27, r23
    6534:	0c f0       	brlt	.+2      	; 0x6538 <drive_dist+0xe0>
    6536:	40 c0       	rjmp	.+128    	; 0x65b8 <drive_dist+0x160>
									{
										mot.d[LEFT].speed.to = -speed;
    6538:	8e 2f       	mov	r24, r30
    653a:	99 27       	eor	r25, r25
    653c:	81 95       	neg	r24
    653e:	0c f4       	brge	.+2      	; 0x6542 <drive_dist+0xea>
    6540:	90 95       	com	r25
    6542:	bc 01       	movw	r22, r24
    6544:	94 c0       	rjmp	.+296    	; 0x666e <drive_dist+0x216>
									else
									{
										sm_ddist = 2;
									}
								}
								else if(motor == 0)
    6546:	21 11       	cpse	r18, r1
    6548:	42 c0       	rjmp	.+132    	; 0x65ce <drive_dist+0x176>
								{
									if((mot.d[LEFT].enc > (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) || //Ziel erreicht?
    654a:	8c 01       	movw	r16, r24
    654c:	22 27       	eor	r18, r18
    654e:	17 fd       	sbrc	r17, 7
    6550:	20 95       	com	r18
    6552:	32 2f       	mov	r19, r18
    6554:	40 91 7f 05 	lds	r20, 0x057F
    6558:	50 91 80 05 	lds	r21, 0x0580
    655c:	60 91 81 05 	lds	r22, 0x0581
    6560:	70 91 82 05 	lds	r23, 0x0582
    6564:	40 0f       	add	r20, r16
    6566:	51 1f       	adc	r21, r17
    6568:	62 1f       	adc	r22, r18
    656a:	73 1f       	adc	r23, r19
    656c:	80 91 6b 16 	lds	r24, 0x166B
    6570:	90 91 6c 16 	lds	r25, 0x166C
    6574:	a0 91 6d 16 	lds	r26, 0x166D
    6578:	b0 91 6e 16 	lds	r27, 0x166E
    657c:	48 17       	cp	r20, r24
    657e:	59 07       	cpc	r21, r25
    6580:	6a 07       	cpc	r22, r26
    6582:	7b 07       	cpc	r23, r27
    6584:	ec f0       	brlt	.+58     	; 0x65c0 <drive_dist+0x168>
										 (mot.d[RIGHT].enc > (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))))
    6586:	40 91 7b 05 	lds	r20, 0x057B
    658a:	50 91 7c 05 	lds	r21, 0x057C
    658e:	60 91 7d 05 	lds	r22, 0x057D
    6592:	70 91 7e 05 	lds	r23, 0x057E
    6596:	40 0f       	add	r20, r16
    6598:	51 1f       	adc	r21, r17
    659a:	62 1f       	adc	r22, r18
    659c:	73 1f       	adc	r23, r19
										sm_ddist = 2;
									}
								}
								else if(motor == 0)
								{
									if((mot.d[LEFT].enc > (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) || //Ziel erreicht?
    659e:	80 91 77 16 	lds	r24, 0x1677
    65a2:	90 91 78 16 	lds	r25, 0x1678
    65a6:	a0 91 79 16 	lds	r26, 0x1679
    65aa:	b0 91 7a 16 	lds	r27, 0x167A
    65ae:	48 17       	cp	r20, r24
    65b0:	59 07       	cpc	r21, r25
    65b2:	6a 07       	cpc	r22, r26
    65b4:	7b 07       	cpc	r23, r27
    65b6:	24 f0       	brlt	.+8      	; 0x65c0 <drive_dist+0x168>
										mot.d[LEFT].speed.to = -speed;
										mot.d[RIGHT].speed.to = 0;
									}
									else
									{
										sm_ddist = 2;
    65b8:	82 e0       	ldi	r24, 0x02	; 2
    65ba:	80 93 83 05 	sts	0x0583, r24
    65be:	f4 c0       	rjmp	.+488    	; 0x67a8 <drive_dist+0x350>
								else if(motor == 0)
								{
									if((mot.d[LEFT].enc > (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) || //Ziel erreicht?
										 (mot.d[RIGHT].enc > (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))))
									{
										mot.d[LEFT].speed.to = -speed;
    65c0:	8e 2f       	mov	r24, r30
    65c2:	99 27       	eor	r25, r25
    65c4:	81 95       	neg	r24
    65c6:	0c f4       	brge	.+2      	; 0x65ca <drive_dist+0x172>
    65c8:	90 95       	com	r25
    65ca:	bc 01       	movw	r22, r24
    65cc:	92 c0       	rjmp	.+292    	; 0x66f2 <drive_dist+0x29a>
										sm_ddist = 2;
									}
								}
								else if(motor > 0)
								{
									if(mot.d[RIGHT].enc > (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))) //Ziel erreicht?
    65ce:	aa 27       	eor	r26, r26
    65d0:	97 fd       	sbrc	r25, 7
    65d2:	a0 95       	com	r26
    65d4:	ba 2f       	mov	r27, r26
    65d6:	40 91 7b 05 	lds	r20, 0x057B
    65da:	50 91 7c 05 	lds	r21, 0x057C
    65de:	60 91 7d 05 	lds	r22, 0x057D
    65e2:	70 91 7e 05 	lds	r23, 0x057E
    65e6:	84 0f       	add	r24, r20
    65e8:	95 1f       	adc	r25, r21
    65ea:	a6 1f       	adc	r26, r22
    65ec:	b7 1f       	adc	r27, r23
    65ee:	40 91 77 16 	lds	r20, 0x1677
    65f2:	50 91 78 16 	lds	r21, 0x1678
    65f6:	60 91 79 16 	lds	r22, 0x1679
    65fa:	70 91 7a 16 	lds	r23, 0x167A
    65fe:	84 17       	cp	r24, r20
    6600:	95 07       	cpc	r25, r21
    6602:	a6 07       	cpc	r26, r22
    6604:	b7 07       	cpc	r27, r23
    6606:	c4 f6       	brge	.-80     	; 0x65b8 <drive_dist+0x160>
									{
										mot.d[LEFT].speed.to = 0;
    6608:	10 92 6a 16 	sts	0x166A, r1
    660c:	10 92 69 16 	sts	0x1669, r1
										mot.d[RIGHT].speed.to = -speed;
    6610:	8e 2f       	mov	r24, r30
    6612:	99 27       	eor	r25, r25
    6614:	81 95       	neg	r24
    6616:	0c f4       	brge	.+2      	; 0x661a <drive_dist+0x1c2>
    6618:	90 95       	com	r25
    661a:	bc 01       	movw	r22, r24
    661c:	70 93 76 16 	sts	0x1676, r23
    6620:	60 93 75 16 	sts	0x1675, r22
    6624:	c1 c0       	rjmp	.+386    	; 0x67a8 <drive_dist+0x350>
							}
							else
							{
								if(motor < 0)
								{
									if(mot.d[LEFT].enc < (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) //Ziel erreicht?
    6626:	aa 27       	eor	r26, r26
    6628:	97 fd       	sbrc	r25, 7
    662a:	a0 95       	com	r26
    662c:	ba 2f       	mov	r27, r26
									}
								}
							}
							else
							{
								if(motor < 0)
    662e:	27 ff       	sbrs	r18, 7
    6630:	27 c0       	rjmp	.+78     	; 0x6680 <drive_dist+0x228>
								{
									if(mot.d[LEFT].enc < (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) //Ziel erreicht?
    6632:	40 91 7f 05 	lds	r20, 0x057F
    6636:	50 91 80 05 	lds	r21, 0x0580
    663a:	60 91 81 05 	lds	r22, 0x0581
    663e:	70 91 82 05 	lds	r23, 0x0582
    6642:	84 0f       	add	r24, r20
    6644:	95 1f       	adc	r25, r21
    6646:	a6 1f       	adc	r26, r22
    6648:	b7 1f       	adc	r27, r23
    664a:	40 91 6b 16 	lds	r20, 0x166B
    664e:	50 91 6c 16 	lds	r21, 0x166C
    6652:	60 91 6d 16 	lds	r22, 0x166D
    6656:	70 91 6e 16 	lds	r23, 0x166E
    665a:	48 17       	cp	r20, r24
    665c:	59 07       	cpc	r21, r25
    665e:	6a 07       	cpc	r22, r26
    6660:	7b 07       	cpc	r23, r27
    6662:	0c f0       	brlt	.+2      	; 0x6666 <drive_dist+0x20e>
    6664:	a9 cf       	rjmp	.-174    	; 0x65b8 <drive_dist+0x160>
									{
										mot.d[LEFT].speed.to = speed;
    6666:	6e 2f       	mov	r22, r30
    6668:	77 27       	eor	r23, r23
    666a:	67 fd       	sbrc	r22, 7
    666c:	70 95       	com	r23
    666e:	70 93 6a 16 	sts	0x166A, r23
    6672:	60 93 69 16 	sts	0x1669, r22
										mot.d[RIGHT].speed.to = 0;
    6676:	10 92 76 16 	sts	0x1676, r1
    667a:	10 92 75 16 	sts	0x1675, r1
    667e:	94 c0       	rjmp	.+296    	; 0x67a8 <drive_dist+0x350>
									else
									{
										sm_ddist = 2;
									}
								}
								else if(motor == 0)
    6680:	21 11       	cpse	r18, r1
    6682:	3c c0       	rjmp	.+120    	; 0x66fc <drive_dist+0x2a4>
								{
									if((mot.d[LEFT].enc < (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) || //Ziel erreicht?
    6684:	40 91 7f 05 	lds	r20, 0x057F
    6688:	50 91 80 05 	lds	r21, 0x0580
    668c:	60 91 81 05 	lds	r22, 0x0581
    6690:	70 91 82 05 	lds	r23, 0x0582
    6694:	48 0f       	add	r20, r24
    6696:	59 1f       	adc	r21, r25
    6698:	6a 1f       	adc	r22, r26
    669a:	7b 1f       	adc	r23, r27
    669c:	00 91 6b 16 	lds	r16, 0x166B
    66a0:	10 91 6c 16 	lds	r17, 0x166C
    66a4:	20 91 6d 16 	lds	r18, 0x166D
    66a8:	30 91 6e 16 	lds	r19, 0x166E
    66ac:	04 17       	cp	r16, r20
    66ae:	15 07       	cpc	r17, r21
    66b0:	26 07       	cpc	r18, r22
    66b2:	37 07       	cpc	r19, r23
    66b4:	d4 f0       	brlt	.+52     	; 0x66ea <drive_dist+0x292>
										 (mot.d[RIGHT].enc < (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))))
    66b6:	40 91 7b 05 	lds	r20, 0x057B
    66ba:	50 91 7c 05 	lds	r21, 0x057C
    66be:	60 91 7d 05 	lds	r22, 0x057D
    66c2:	70 91 7e 05 	lds	r23, 0x057E
    66c6:	48 0f       	add	r20, r24
    66c8:	59 1f       	adc	r21, r25
    66ca:	6a 1f       	adc	r22, r26
    66cc:	7b 1f       	adc	r23, r27
										sm_ddist = 2;
									}
								}
								else if(motor == 0)
								{
									if((mot.d[LEFT].enc < (enc_l_start_ddist + (dist_cm*ENC_FAC_CM_L))) || //Ziel erreicht?
    66ce:	80 91 77 16 	lds	r24, 0x1677
    66d2:	90 91 78 16 	lds	r25, 0x1678
    66d6:	a0 91 79 16 	lds	r26, 0x1679
    66da:	b0 91 7a 16 	lds	r27, 0x167A
    66de:	84 17       	cp	r24, r20
    66e0:	95 07       	cpc	r25, r21
    66e2:	a6 07       	cpc	r26, r22
    66e4:	b7 07       	cpc	r27, r23
    66e6:	0c f0       	brlt	.+2      	; 0x66ea <drive_dist+0x292>
    66e8:	67 cf       	rjmp	.-306    	; 0x65b8 <drive_dist+0x160>
										 (mot.d[RIGHT].enc < (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))))
									{
										mot.d[LEFT].speed.to = speed;
    66ea:	6e 2f       	mov	r22, r30
    66ec:	77 27       	eor	r23, r23
    66ee:	67 fd       	sbrc	r22, 7
    66f0:	70 95       	com	r23
    66f2:	70 93 6a 16 	sts	0x166A, r23
    66f6:	60 93 69 16 	sts	0x1669, r22
    66fa:	90 cf       	rjmp	.-224    	; 0x661c <drive_dist+0x1c4>
										sm_ddist = 2;
									}
								}
								else if(motor > 0)
								{
									if(mot.d[RIGHT].enc < (enc_r_start_ddist + (dist_cm*ENC_FAC_CM_R))) //Ziel erreicht?
    66fc:	40 91 7b 05 	lds	r20, 0x057B
    6700:	50 91 7c 05 	lds	r21, 0x057C
    6704:	60 91 7d 05 	lds	r22, 0x057D
    6708:	70 91 7e 05 	lds	r23, 0x057E
    670c:	84 0f       	add	r24, r20
    670e:	95 1f       	adc	r25, r21
    6710:	a6 1f       	adc	r26, r22
    6712:	b7 1f       	adc	r27, r23
    6714:	40 91 77 16 	lds	r20, 0x1677
    6718:	50 91 78 16 	lds	r21, 0x1678
    671c:	60 91 79 16 	lds	r22, 0x1679
    6720:	70 91 7a 16 	lds	r23, 0x167A
    6724:	48 17       	cp	r20, r24
    6726:	59 07       	cpc	r21, r25
    6728:	6a 07       	cpc	r22, r26
    672a:	7b 07       	cpc	r23, r27
    672c:	0c f0       	brlt	.+2      	; 0x6730 <drive_dist+0x2d8>
    672e:	44 cf       	rjmp	.-376    	; 0x65b8 <drive_dist+0x160>
									{
										mot.d[LEFT].speed.to = 0;
    6730:	10 92 6a 16 	sts	0x166A, r1
    6734:	10 92 69 16 	sts	0x1669, r1
										mot.d[RIGHT].speed.to = speed;
    6738:	6e 2f       	mov	r22, r30
    673a:	77 27       	eor	r23, r23
    673c:	67 fd       	sbrc	r22, 7
    673e:	70 95       	com	r23
    6740:	6d cf       	rjmp	.-294    	; 0x661c <drive_dist+0x1c4>
									}
								}
							}
						break;
		case 2:
							sm_ddist = 0;
    6742:	10 92 83 05 	sts	0x0583, r1

							mot.d[LEFT].speed.to = 0;
    6746:	10 92 6a 16 	sts	0x166A, r1
    674a:	10 92 69 16 	sts	0x1669, r1
							mot.d[RIGHT].speed.to = 0;
    674e:	10 92 76 16 	sts	0x1676, r1
    6752:	10 92 75 16 	sts	0x1675, r1

							returnvar = 0;
							
							if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": drive_dist(): done. "));}
    6756:	22 23       	and	r18, r18
    6758:	29 f1       	breq	.+74     	; 0x67a4 <drive_dist+0x34c>
    675a:	86 eb       	ldi	r24, 0xB6	; 182
    675c:	96 e2       	ldi	r25, 0x26	; 38
    675e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    6762:	60 91 47 05 	lds	r22, 0x0547
    6766:	70 91 48 05 	lds	r23, 0x0548
    676a:	80 91 49 05 	lds	r24, 0x0549
    676e:	90 91 4a 05 	lds	r25, 0x054A
    6772:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    6776:	8f e9       	ldi	r24, 0x9F	; 159
    6778:	96 e2       	ldi	r25, 0x26	; 38
    677a:	12 c0       	rjmp	.+36     	; 0x67a0 <drive_dist+0x348>
						break;
		default:	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": FATAL ERROR: WENT INTO drive_dist():sm_ddist DEFAULT CASE!"));}
    677c:	22 30       	cpi	r18, 0x02	; 2
    677e:	90 f0       	brcs	.+36     	; 0x67a4 <drive_dist+0x34c>
    6780:	8c e9       	ldi	r24, 0x9C	; 156
    6782:	96 e2       	ldi	r25, 0x26	; 38
    6784:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    6788:	60 91 47 05 	lds	r22, 0x0547
    678c:	70 91 48 05 	lds	r23, 0x0548
    6790:	80 91 49 05 	lds	r24, 0x0549
    6794:	90 91 4a 05 	lds	r25, 0x054A
    6798:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    679c:	8f e5       	ldi	r24, 0x5F	; 95
    679e:	96 e2       	ldi	r25, 0x26	; 38
    67a0:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
							returnvar = 0;
    67a4:	80 e0       	ldi	r24, 0x00	; 0
    67a6:	01 c0       	rjmp	.+2      	; 0x67aa <drive_dist+0x352>
int32_t enc_l_start_ddist = 0;
int32_t enc_r_start_ddist = 0;

uint8_t drive_dist(int8_t motor, int8_t speed, int8_t dist_cm) //which @motor to move: < 0 ~ left, 0 ~ both, > 0 ~ right
{
	uint8_t returnvar = 1;
    67a8:	81 e0       	ldi	r24, 0x01	; 1
		default:	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": FATAL ERROR: WENT INTO drive_dist():sm_ddist DEFAULT CASE!"));}
							returnvar = 0;
						break;
	}
	return returnvar;
}
    67aa:	1f 91       	pop	r17
    67ac:	0f 91       	pop	r16
    67ae:	08 95       	ret

000067b0 <drive_getBall>:

uint8_t drive_getBall(void)
{
	uint8_t returnvar = 1;

	switch (sm_drive_getBall) {
    67b0:	80 91 89 05 	lds	r24, 0x0589
    67b4:	81 30       	cpi	r24, 0x01	; 1
    67b6:	71 f0       	breq	.+28     	; 0x67d4 <drive_getBall+0x24>
    67b8:	18 f0       	brcs	.+6      	; 0x67c0 <drive_getBall+0x10>
    67ba:	82 30       	cpi	r24, 0x02	; 2
    67bc:	b9 f0       	breq	.+46     	; 0x67ec <drive_getBall+0x3c>
    67be:	1f c0       	rjmp	.+62     	; 0x67fe <drive_getBall+0x4e>
	case 0: if(!drive_dist(0,30,25))
    67c0:	49 e1       	ldi	r20, 0x19	; 25
    67c2:	6e e1       	ldi	r22, 0x1E	; 30
    67c4:	80 e0       	ldi	r24, 0x00	; 0
    67c6:	48 de       	rcall	.-880    	; 0x6458 <drive_dist>
    67c8:	81 11       	cpse	r24, r1
    67ca:	19 c0       	rjmp	.+50     	; 0x67fe <drive_getBall+0x4e>
    67cc:	84 e6       	ldi	r24, 0x64	; 100
			{
				servo_setPos(100);
    67ce:	0e 94 5d 5b 	call	0xb6ba	; 0xb6ba <servo_setPos>
    67d2:	06 c0       	rjmp	.+12     	; 0x67e0 <drive_getBall+0x30>
    67d4:	45 e0       	ldi	r20, 0x05	; 5
				sm_drive_getBall ++;
			}
		break;
	case 1: if(!drive_dist(0,30,5))
    67d6:	6e e1       	ldi	r22, 0x1E	; 30
    67d8:	80 e0       	ldi	r24, 0x00	; 0
    67da:	3e de       	rcall	.-900    	; 0x6458 <drive_dist>
    67dc:	81 11       	cpse	r24, r1
    67de:	0f c0       	rjmp	.+30     	; 0x67fe <drive_getBall+0x4e>
    67e0:	80 91 89 05 	lds	r24, 0x0589
			{
				sm_drive_getBall ++;
    67e4:	8f 5f       	subi	r24, 0xFF	; 255
    67e6:	80 93 89 05 	sts	0x0589, r24
    67ea:	09 c0       	rjmp	.+18     	; 0x67fe <drive_getBall+0x4e>
    67ec:	42 ee       	ldi	r20, 0xE2	; 226
    67ee:	6e e1       	ldi	r22, 0x1E	; 30
			}
		break;
	case 2: if(!drive_dist(0,30,-30))
    67f0:	80 e0       	ldi	r24, 0x00	; 0
    67f2:	32 de       	rcall	.-924    	; 0x6458 <drive_dist>
    67f4:	81 11       	cpse	r24, r1
    67f6:	03 c0       	rjmp	.+6      	; 0x67fe <drive_getBall+0x4e>
    67f8:	10 92 89 05 	sts	0x0589, r1
    67fc:	08 95       	ret
			{
				sm_drive_getBall = 0;
    67fe:	81 e0       	ldi	r24, 0x01	; 1
    6800:	08 95       	ret

00006802 <drive_releaseBall>:

uint8_t drive_releaseBall(void)
{
	uint8_t returnvar = 1;

	switch (sm_drive_getBall) {
    6802:	80 91 89 05 	lds	r24, 0x0589
    6806:	88 23       	and	r24, r24
    6808:	19 f0       	breq	.+6      	; 0x6810 <drive_releaseBall+0xe>
    680a:	81 30       	cpi	r24, 0x01	; 1
    680c:	81 f0       	breq	.+32     	; 0x682e <drive_releaseBall+0x2c>
    680e:	18 c0       	rjmp	.+48     	; 0x6840 <drive_releaseBall+0x3e>
	case 0: if(!drive_dist(0,30,20))
    6810:	44 e1       	ldi	r20, 0x14	; 20
    6812:	6e e1       	ldi	r22, 0x1E	; 30
    6814:	80 e0       	ldi	r24, 0x00	; 0
    6816:	20 de       	rcall	.-960    	; 0x6458 <drive_dist>
    6818:	81 11       	cpse	r24, r1
    681a:	12 c0       	rjmp	.+36     	; 0x6840 <drive_releaseBall+0x3e>
    681c:	8e e1       	ldi	r24, 0x1E	; 30
			{
				servo_setPos(30);
    681e:	0e 94 5d 5b 	call	0xb6ba	; 0xb6ba <servo_setPos>
    6822:	80 91 89 05 	lds	r24, 0x0589
				sm_drive_getBall ++;
    6826:	8f 5f       	subi	r24, 0xFF	; 255
    6828:	80 93 89 05 	sts	0x0589, r24
    682c:	09 c0       	rjmp	.+18     	; 0x6840 <drive_releaseBall+0x3e>
    682e:	4c ee       	ldi	r20, 0xEC	; 236
			}
		break;
	case 1: if(!drive_dist(0,30,-20))
    6830:	6e e1       	ldi	r22, 0x1E	; 30
    6832:	80 e0       	ldi	r24, 0x00	; 0
    6834:	11 de       	rcall	.-990    	; 0x6458 <drive_dist>
    6836:	81 11       	cpse	r24, r1
    6838:	03 c0       	rjmp	.+6      	; 0x6840 <drive_releaseBall+0x3e>
    683a:	10 92 89 05 	sts	0x0589, r1
			{
				sm_drive_getBall = 0;
    683e:	08 95       	ret
    6840:	81 e0       	ldi	r24, 0x01	; 1
    6842:	08 95       	ret

00006844 <drive_instructions>:

uint8_t drive_instr_sm = 0;

uint8_t drive_instructions(char *instructions, uint8_t amount)
{
	if(drive_instr_sm < amount)
    6844:	20 91 88 05 	lds	r18, 0x0588
    6848:	26 17       	cp	r18, r22
    684a:	60 f5       	brcc	.+88     	; 0x68a4 <drive_instructions+0x60>
	{
		switch (instructions[drive_instr_sm]) {
    684c:	fc 01       	movw	r30, r24
    684e:	e2 0f       	add	r30, r18
    6850:	f1 1d       	adc	r31, r1
    6852:	80 81       	ld	r24, Z
    6854:	8c 36       	cpi	r24, 0x6C	; 108
    6856:	79 f0       	breq	.+30     	; 0x6876 <drive_instructions+0x32>
    6858:	40 f4       	brcc	.+16     	; 0x686a <drive_instructions+0x26>
    685a:	84 36       	cpi	r24, 0x64	; 100
    685c:	a9 f0       	breq	.+42     	; 0x6888 <drive_instructions+0x44>
    685e:	86 36       	cpi	r24, 0x66	; 102
    6860:	e1 f4       	brne	.+56     	; 0x689a <drive_instructions+0x56>
		case 'f':	if(!drive_oneTile(0))	drive_instr_sm ++; break;
    6862:	80 e0       	ldi	r24, 0x00	; 0
    6864:	0e 94 f0 2b 	call	0x57e0	; 0x57e0 <drive_oneTile>
    6868:	10 c0       	rjmp	.+32     	; 0x688a <drive_instructions+0x46>

uint8_t drive_instructions(char *instructions, uint8_t amount)
{
	if(drive_instr_sm < amount)
	{
		switch (instructions[drive_instr_sm]) {
    686a:	82 37       	cpi	r24, 0x72	; 114
    686c:	41 f0       	breq	.+16     	; 0x687e <drive_instructions+0x3a>
    686e:	85 37       	cpi	r24, 0x75	; 117
    6870:	a1 f4       	brne	.+40     	; 0x689a <drive_instructions+0x56>
		case 'f':	if(!drive_oneTile(0))	drive_instr_sm ++; break;
		case 'l':	if(!drive_turn(-90,1))	drive_instr_sm ++; break;
		case 'r':	if(!drive_turn(90, 1))	drive_instr_sm ++; break;
		case 'd':	if(!drive_getBall())	drive_instr_sm ++;	break;
		case 'u':	if(!drive_releaseBall())	drive_instr_sm ++;	break;
    6872:	c7 df       	rcall	.-114    	; 0x6802 <drive_releaseBall>
    6874:	0a c0       	rjmp	.+20     	; 0x688a <drive_instructions+0x46>
    6876:	61 e0       	ldi	r22, 0x01	; 1
{
	if(drive_instr_sm < amount)
	{
		switch (instructions[drive_instr_sm]) {
		case 'f':	if(!drive_oneTile(0))	drive_instr_sm ++; break;
		case 'l':	if(!drive_turn(-90,1))	drive_instr_sm ++; break;
    6878:	86 ea       	ldi	r24, 0xA6	; 166
    687a:	9f ef       	ldi	r25, 0xFF	; 255
    687c:	03 c0       	rjmp	.+6      	; 0x6884 <drive_instructions+0x40>
    687e:	61 e0       	ldi	r22, 0x01	; 1
		case 'r':	if(!drive_turn(90, 1))	drive_instr_sm ++; break;
    6880:	8a e5       	ldi	r24, 0x5A	; 90
    6882:	90 e0       	ldi	r25, 0x00	; 0
    6884:	04 dd       	rcall	.-1528   	; 0x628e <drive_turn>
    6886:	01 c0       	rjmp	.+2      	; 0x688a <drive_instructions+0x46>
    6888:	93 df       	rcall	.-218    	; 0x67b0 <drive_getBall>
    688a:	81 11       	cpse	r24, r1
		case 'd':	if(!drive_getBall())	drive_instr_sm ++;	break;
    688c:	09 c0       	rjmp	.+18     	; 0x68a0 <drive_instructions+0x5c>
    688e:	80 91 88 05 	lds	r24, 0x0588
		case 'u':	if(!drive_releaseBall())	drive_instr_sm ++;	break;
    6892:	8f 5f       	subi	r24, 0xFF	; 255
    6894:	80 93 88 05 	sts	0x0588, r24
    6898:	03 c0       	rjmp	.+6      	; 0x68a0 <drive_instructions+0x5c>
    689a:	2f 5f       	subi	r18, 0xFF	; 255
    689c:	20 93 88 05 	sts	0x0588, r18
		default:	drive_instr_sm ++; break;
    68a0:	81 e0       	ldi	r24, 0x01	; 1
    68a2:	08 95       	ret
    68a4:	10 92 88 05 	sts	0x0588, r1
    68a8:	80 e0       	ldi	r24, 0x00	; 0
		}
		return 1;
	}
	else
	{
		drive_instr_sm = 0;
    68aa:	08 95       	ret

000068ac <drive_deployResKit>:

uint8_t drive_deployResKit(int8_t dir, uint8_t amount)
{
	uint8_t returnvar = 1;

	dir --;
    68ac:	81 50       	subi	r24, 0x01	; 1
	if(!dir)
    68ae:	09 f4       	brne	.+2      	; 0x68b2 <drive_deployResKit+0x6>
		dir = 1;
    68b0:	81 e0       	ldi	r24, 0x01	; 1
	//Now: dir: LEFT = -1, RIGHT = 1;

	switch(sm_d_deplKit)
    68b2:	90 91 86 05 	lds	r25, 0x0586
    68b6:	92 30       	cpi	r25, 0x02	; 2
    68b8:	f1 f0       	breq	.+60     	; 0x68f6 <drive_deployResKit+0x4a>
    68ba:	28 f4       	brcc	.+10     	; 0x68c6 <drive_deployResKit+0x1a>
    68bc:	99 23       	and	r25, r25
    68be:	59 f0       	breq	.+22     	; 0x68d6 <drive_deployResKit+0x2a>
    68c0:	91 30       	cpi	r25, 0x01	; 1
    68c2:	79 f0       	breq	.+30     	; 0x68e2 <drive_deployResKit+0x36>
    68c4:	5e c0       	rjmp	.+188    	; 0x6982 <drive_deployResKit+0xd6>
    68c6:	94 30       	cpi	r25, 0x04	; 4
    68c8:	09 f4       	brne	.+2      	; 0x68cc <drive_deployResKit+0x20>
    68ca:	3c c0       	rjmp	.+120    	; 0x6944 <drive_deployResKit+0x98>
    68cc:	18 f1       	brcs	.+70     	; 0x6914 <drive_deployResKit+0x68>
    68ce:	95 30       	cpi	r25, 0x05	; 5
    68d0:	09 f4       	brne	.+2      	; 0x68d4 <drive_deployResKit+0x28>
    68d2:	4c c0       	rjmp	.+152    	; 0x696c <drive_deployResKit+0xc0>
    68d4:	56 c0       	rjmp	.+172    	; 0x6982 <drive_deployResKit+0xd6>
	{
		case 0:
				d_deplKit_amount = amount;
    68d6:	60 93 85 05 	sts	0x0585, r22

				sm_d_deplKit = 1;
    68da:	81 e0       	ldi	r24, 0x01	; 1
    68dc:	80 93 86 05 	sts	0x0586, r24

				break;
    68e0:	08 95       	ret
		case 1:
				if(!drive_turn(90 * (-dir), 1))
    68e2:	61 e0       	ldi	r22, 0x01	; 1
    68e4:	26 ea       	ldi	r18, 0xA6	; 166
    68e6:	82 02       	muls	r24, r18
    68e8:	c0 01       	movw	r24, r0
    68ea:	11 24       	eor	r1, r1
    68ec:	d0 dc       	rcall	.-1632   	; 0x628e <drive_turn>
    68ee:	81 11       	cpse	r24, r1
    68f0:	48 c0       	rjmp	.+144    	; 0x6982 <drive_deployResKit+0xd6>
    68f2:	82 e0       	ldi	r24, 0x02	; 2
				{
					sm_d_deplKit = 2;
    68f4:	38 c0       	rjmp	.+112    	; 0x6966 <drive_deployResKit+0xba>
    68f6:	80 91 c0 07 	lds	r24, 0x07C0
				}
			break;

		case 2:

				if(dist[LIN][BACK][BACK] > 70)
    68fa:	90 91 c1 07 	lds	r25, 0x07C1
    68fe:	87 34       	cpi	r24, 0x47	; 71
    6900:	91 05       	cpc	r25, r1
    6902:	34 f0       	brlt	.+12     	; 0x6910 <drive_deployResKit+0x64>
    6904:	4c ef       	ldi	r20, 0xFC	; 252
				{
					if(!drive_dist(0,30,-4))
    6906:	6e e1       	ldi	r22, 0x1E	; 30
    6908:	80 e0       	ldi	r24, 0x00	; 0
    690a:	a6 dd       	rcall	.-1204   	; 0x6458 <drive_dist>
    690c:	81 11       	cpse	r24, r1
    690e:	39 c0       	rjmp	.+114    	; 0x6982 <drive_deployResKit+0xd6>
    6910:	83 e0       	ldi	r24, 0x03	; 3
    6912:	29 c0       	rjmp	.+82     	; 0x6966 <drive_deployResKit+0xba>
					{
						sm_d_deplKit = 3;
					}
				}
				else
					sm_d_deplKit = 3;
    6914:	10 92 6a 16 	sts	0x166A, r1

			break;

		case 3:

				mot.d[LEFT].speed.to = 0;
    6918:	10 92 69 16 	sts	0x1669, r1
    691c:	10 92 76 16 	sts	0x1676, r1
				mot.d[RIGHT].speed.to = 0;
    6920:	10 92 75 16 	sts	0x1675, r1
    6924:	80 91 85 05 	lds	r24, 0x0585

				if(d_deplKit_amount > 0)
    6928:	18 16       	cp	r1, r24
    692a:	54 f4       	brge	.+20     	; 0x6940 <drive_deployResKit+0x94>
    692c:	82 e0       	ldi	r24, 0x02	; 2
    692e:	c4 d0       	rcall	.+392    	; 0x6ab8 <rescueKit_drop>
				{
					if(!rescueKit_drop(2))
    6930:	81 11       	cpse	r24, r1
    6932:	27 c0       	rjmp	.+78     	; 0x6982 <drive_deployResKit+0xd6>
    6934:	80 91 85 05 	lds	r24, 0x0585
    6938:	81 50       	subi	r24, 0x01	; 1
					{
						d_deplKit_amount --;
    693a:	80 93 85 05 	sts	0x0585, r24
    693e:	21 c0       	rjmp	.+66     	; 0x6982 <drive_deployResKit+0xd6>
    6940:	84 e0       	ldi	r24, 0x04	; 4
    6942:	11 c0       	rjmp	.+34     	; 0x6966 <drive_deployResKit+0xba>
    6944:	80 91 c0 07 	lds	r24, 0x07C0
					}
				}
				else
				{
					sm_d_deplKit = 4;
    6948:	90 91 c1 07 	lds	r25, 0x07C1

			break;

		case 4:

				if(dist[LIN][BACK][BACK] > TILE1_BACK_TH_BACK)
    694c:	8b 3f       	cpi	r24, 0xFB	; 251
    694e:	91 05       	cpc	r25, r1
    6950:	2c f0       	brlt	.+10     	; 0x695c <drive_deployResKit+0xb0>
    6952:	44 e0       	ldi	r20, 0x04	; 4
    6954:	6e e1       	ldi	r22, 0x1E	; 30
    6956:	80 e0       	ldi	r24, 0x00	; 0
				{
					if(!drive_dist(0,30,4))
    6958:	7f dd       	rcall	.-1282   	; 0x6458 <drive_dist>
    695a:	02 c0       	rjmp	.+4      	; 0x6960 <drive_deployResKit+0xb4>
    695c:	82 e3       	ldi	r24, 0x32	; 50
    695e:	18 dc       	rcall	.-2000   	; 0x6190 <drive_align_back>
    6960:	81 11       	cpse	r24, r1
    6962:	0f c0       	rjmp	.+30     	; 0x6982 <drive_deployResKit+0xd6>
					{
						sm_d_deplKit = 5;
					}
				}
				else if(!drive_align_back(50))
    6964:	85 e0       	ldi	r24, 0x05	; 5
    6966:	80 93 86 05 	sts	0x0586, r24
    696a:	0b c0       	rjmp	.+22     	; 0x6982 <drive_deployResKit+0xd6>
    696c:	61 e0       	ldi	r22, 0x01	; 1
				{
					sm_d_deplKit = 5;
    696e:	2a e5       	ldi	r18, 0x5A	; 90
    6970:	82 02       	muls	r24, r18
    6972:	c0 01       	movw	r24, r0
    6974:	11 24       	eor	r1, r1
				}

			break;

		case 5:
				if(!drive_turn(90 * dir, 1))
    6976:	8b dc       	rcall	.-1770   	; 0x628e <drive_turn>
    6978:	81 11       	cpse	r24, r1
    697a:	03 c0       	rjmp	.+6      	; 0x6982 <drive_deployResKit+0xd6>
    697c:	10 92 86 05 	sts	0x0586, r1
    6980:	08 95       	ret
    6982:	81 e0       	ldi	r24, 0x01	; 1
    6984:	08 95       	ret

00006986 <drive_reset>:

////////////////////////////////////////////////////
//Alle Fahrfunktionen zurcksetzen (fr Eingriff bzw. Positionsnderung)
void drive_reset(void)
{
	sm_dot = 0;
    6986:	10 92 ad 05 	sts	0x05AD, r1
		dot_tile_middle = 0;
    698a:	10 92 ae 05 	sts	0x05AE, r1
	sm_rotate = 0;
    698e:	10 92 a1 05 	sts	0x05A1, r1
	sm_turn = 0;
    6992:	10 92 8a 05 	sts	0x058A, r1
	sm_d_lr = 0;	
    6996:	10 92 84 05 	sts	0x0584, r1
	sm_ddist = 0;
    699a:	10 92 83 05 	sts	0x0583, r1
	
	if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": Reset::sm_dot:dot_tile_middle:sm_rotate:sm_turn:ramp_ready:sm_d_lr:sm_ddist"));}
    699e:	80 91 53 05 	lds	r24, 0x0553
    69a2:	88 23       	and	r24, r24
    69a4:	91 f0       	breq	.+36     	; 0x69ca <drive_reset+0x44>
    69a6:	8c e5       	ldi	r24, 0x5C	; 92
    69a8:	96 e2       	ldi	r25, 0x26	; 38
    69aa:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    69ae:	60 91 47 05 	lds	r22, 0x0547
    69b2:	70 91 48 05 	lds	r23, 0x0548
    69b6:	80 91 49 05 	lds	r24, 0x0549
    69ba:	90 91 4a 05 	lds	r25, 0x054A
    69be:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    69c2:	8e e0       	ldi	r24, 0x0E	; 14
    69c4:	96 e2       	ldi	r25, 0x26	; 38
    69c6:	0c 94 e4 1f 	jmp	0x3fc8	; 0x3fc8 <bt_putStr_P>
    69ca:	08 95       	ret

000069cc <dist_setSensors.part.0>:
									SENS_ACTIVE_PORT &= ~(1<<SENS_RIGHT_PIN);
								}
						break;
		case MID:		if(set)
								{
									SENS_ACTIVE_PORT |= (1<<SENS_MID_PIN);
    69cc:	12 9a       	sbi	0x02, 2	; 2
    69ce:	08 95       	ret

000069d0 <abs_ptr>:
}
////////////////////////////////////////////////////////////////////////////////
//Amount via pointer
void abs_ptr(int16_t *var)
{
	if(*var < 0)
    69d0:	fc 01       	movw	r30, r24
    69d2:	20 81       	ld	r18, Z
    69d4:	31 81       	ldd	r19, Z+1	; 0x01
    69d6:	37 ff       	sbrs	r19, 7
    69d8:	05 c0       	rjmp	.+10     	; 0x69e4 <abs_ptr+0x14>
		*var = -(*var);
    69da:	31 95       	neg	r19
    69dc:	21 95       	neg	r18
    69de:	31 09       	sbc	r19, r1
    69e0:	31 83       	std	Z+1, r19	; 0x01
    69e2:	20 83       	st	Z, r18
    69e4:	08 95       	ret

000069e6 <led_hsvToRgb>:

//RGB LED:
//Source: http://www.mikrocontroller.net/topic/158185

void led_hsvToRgb (uint8_t h, uint8_t  s, uint8_t v) //Farbe, Sttigung, Helligkeit
{
    69e6:	cf 92       	push	r12
    69e8:	df 92       	push	r13
    69ea:	ef 92       	push	r14
    69ec:	ff 92       	push	r15
    69ee:	cf 93       	push	r28
    69f0:	df 93       	push	r29
	uint16_t vs = v * s, h6 = 6 * h, f;
    69f2:	46 9f       	mul	r20, r22
    69f4:	d0 01       	movw	r26, r0
    69f6:	11 24       	eor	r1, r1
    69f8:	26 e0       	ldi	r18, 0x06	; 6
    69fa:	82 9f       	mul	r24, r18
    69fc:	c0 01       	movw	r24, r0
    69fe:	11 24       	eor	r1, r1
    6a00:	c4 2f       	mov	r28, r20
    6a02:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i, p, u, r = v, g = v, b = v;

	p = ((v<<8) - vs) >> 8;
    6a04:	dc 2f       	mov	r29, r28
    6a06:	cc 27       	eor	r28, r28
    6a08:	ca 1b       	sub	r28, r26
    6a0a:	db 0b       	sbc	r29, r27
    6a0c:	5d 2f       	mov	r21, r29
	i = h6 >> 8;
	f = ((i|1) << 8) - h6;
    6a0e:	29 2f       	mov	r18, r25
    6a10:	21 60       	ori	r18, 0x01	; 1
    6a12:	30 e0       	ldi	r19, 0x00	; 0
    6a14:	32 2f       	mov	r19, r18
    6a16:	22 27       	eor	r18, r18
    6a18:	28 1b       	sub	r18, r24
    6a1a:	39 0b       	sbc	r19, r25
	if(i & 1)
    6a1c:	e9 2f       	mov	r30, r25
    6a1e:	f0 e0       	ldi	r31, 0x00	; 0
    6a20:	90 ff       	sbrs	r25, 0
    6a22:	03 c0       	rjmp	.+6      	; 0x6a2a <led_hsvToRgb+0x44>
		f = -f;
    6a24:	31 95       	neg	r19
    6a26:	21 95       	neg	r18
    6a28:	31 09       	sbc	r19, r1
	u = (((uint32_t) v << 16) - (uint32_t) vs * f) >> 16;
    6a2a:	c4 2e       	mov	r12, r20
    6a2c:	d1 2c       	mov	r13, r1
    6a2e:	e1 2c       	mov	r14, r1
    6a30:	f1 2c       	mov	r15, r1
    6a32:	76 01       	movw	r14, r12
    6a34:	dd 24       	eor	r13, r13
    6a36:	cc 24       	eor	r12, r12
    6a38:	0e 94 2f 6b 	call	0xd65e	; 0xd65e <__usmulhisi3>
    6a3c:	c6 1a       	sub	r12, r22
    6a3e:	d7 0a       	sbc	r13, r23
    6a40:	e8 0a       	sbc	r14, r24
    6a42:	f9 0a       	sbc	r15, r25
    6a44:	c7 01       	movw	r24, r14
    6a46:	aa 27       	eor	r26, r26
    6a48:	bb 27       	eor	r27, r27
    6a4a:	28 2f       	mov	r18, r24

	switch(i)
    6a4c:	e3 30       	cpi	r30, 0x03	; 3
    6a4e:	f1 05       	cpc	r31, r1
    6a50:	81 f0       	breq	.+32     	; 0x6a72 <led_hsvToRgb+0x8c>
    6a52:	34 f4       	brge	.+12     	; 0x6a60 <led_hsvToRgb+0x7a>
    6a54:	e1 30       	cpi	r30, 0x01	; 1
    6a56:	f1 05       	cpc	r31, r1
    6a58:	b1 f0       	breq	.+44     	; 0x6a86 <led_hsvToRgb+0xa0>
    6a5a:	32 97       	sbiw	r30, 0x02	; 2
    6a5c:	41 f0       	breq	.+16     	; 0x6a6e <led_hsvToRgb+0x88>
    6a5e:	05 c0       	rjmp	.+10     	; 0x6a6a <led_hsvToRgb+0x84>
    6a60:	e4 30       	cpi	r30, 0x04	; 4
    6a62:	f1 05       	cpc	r31, r1
    6a64:	51 f0       	breq	.+20     	; 0x6a7a <led_hsvToRgb+0x94>
    6a66:	35 97       	sbiw	r30, 0x05	; 5
    6a68:	59 f0       	breq	.+22     	; 0x6a80 <led_hsvToRgb+0x9a>
//Source: http://www.mikrocontroller.net/topic/158185

void led_hsvToRgb (uint8_t h, uint8_t  s, uint8_t v) //Farbe, Sttigung, Helligkeit
{
	uint16_t vs = v * s, h6 = 6 * h, f;
	uint8_t i, p, u, r = v, g = v, b = v;
    6a6a:	24 2f       	mov	r18, r20
    6a6c:	04 c0       	rjmp	.+8      	; 0x6a76 <led_hsvToRgb+0x90>

	switch(i)
	{
		case 0: g = u;	b = p;	break;
		case 1: r = u;	b = p;	break;
		case 2: r = p;	b = u;	break;
    6a6e:	2d 2f       	mov	r18, r29
    6a70:	09 c0       	rjmp	.+18     	; 0x6a84 <led_hsvToRgb+0x9e>
		case 3: r = p;	g = u;	break;
    6a72:	2d 2f       	mov	r18, r29
//Source: http://www.mikrocontroller.net/topic/158185

void led_hsvToRgb (uint8_t h, uint8_t  s, uint8_t v) //Farbe, Sttigung, Helligkeit
{
	uint16_t vs = v * s, h6 = 6 * h, f;
	uint8_t i, p, u, r = v, g = v, b = v;
    6a74:	54 2f       	mov	r21, r20
	switch(i)
	{
		case 0: g = u;	b = p;	break;
		case 1: r = u;	b = p;	break;
		case 2: r = p;	b = u;	break;
		case 3: r = p;	g = u;	break;
    6a76:	48 2f       	mov	r20, r24
    6a78:	06 c0       	rjmp	.+12     	; 0x6a86 <led_hsvToRgb+0xa0>
		case 4: r = u;	g = p;	break;
    6a7a:	54 2f       	mov	r21, r20
    6a7c:	4d 2f       	mov	r20, r29
    6a7e:	03 c0       	rjmp	.+6      	; 0x6a86 <led_hsvToRgb+0xa0>
//Source: http://www.mikrocontroller.net/topic/158185

void led_hsvToRgb (uint8_t h, uint8_t  s, uint8_t v) //Farbe, Sttigung, Helligkeit
{
	uint16_t vs = v * s, h6 = 6 * h, f;
	uint8_t i, p, u, r = v, g = v, b = v;
    6a80:	24 2f       	mov	r18, r20
		case 0: g = u;	b = p;	break;
		case 1: r = u;	b = p;	break;
		case 2: r = p;	b = u;	break;
		case 3: r = p;	g = u;	break;
		case 4: r = u;	g = p;	break;
		case 5: g = p;	b = u;	break;
    6a82:	4d 2f       	mov	r20, r29
    6a84:	58 2f       	mov	r21, r24
	}

	OCR4A = r; OCR4C = g; OCR4B = b;
    6a86:	82 2f       	mov	r24, r18
    6a88:	90 e0       	ldi	r25, 0x00	; 0
    6a8a:	90 93 a9 00 	sts	0x00A9, r25
    6a8e:	80 93 a8 00 	sts	0x00A8, r24
    6a92:	84 2f       	mov	r24, r20
    6a94:	90 e0       	ldi	r25, 0x00	; 0
    6a96:	90 93 ad 00 	sts	0x00AD, r25
    6a9a:	80 93 ac 00 	sts	0x00AC, r24
    6a9e:	85 2f       	mov	r24, r21
    6aa0:	90 e0       	ldi	r25, 0x00	; 0
    6aa2:	90 93 ab 00 	sts	0x00AB, r25
    6aa6:	80 93 aa 00 	sts	0x00AA, r24
}
    6aaa:	df 91       	pop	r29
    6aac:	cf 91       	pop	r28
    6aae:	ff 90       	pop	r15
    6ab0:	ef 90       	pop	r14
    6ab2:	df 90       	pop	r13
    6ab4:	cf 90       	pop	r12
    6ab6:	08 95       	ret

00006ab8 <rescueKit_drop>:
#define DEPLKIT_TIME_WAIT		70
uint8_t sm_dropKit = 0;
uint16_t servo_dropKitAngle = 0;

uint8_t rescueKit_drop(uint8_t speed)
{
    6ab8:	cf 93       	push	r28
	uint8_t returnvar = 1;

	switch(sm_dropKit)
    6aba:	90 91 ba 05 	lds	r25, 0x05BA
    6abe:	9f 31       	cpi	r25, 0x1F	; 31
    6ac0:	f9 f0       	breq	.+62     	; 0x6b00 <rescueKit_drop+0x48>
    6ac2:	18 f4       	brcc	.+6      	; 0x6aca <rescueKit_drop+0x12>
    6ac4:	91 11       	cpse	r25, r1
    6ac6:	25 c0       	rjmp	.+74     	; 0x6b12 <rescueKit_drop+0x5a>
    6ac8:	08 c0       	rjmp	.+16     	; 0x6ada <rescueKit_drop+0x22>
    6aca:	95 36       	cpi	r25, 0x65	; 101
    6acc:	00 f1       	brcs	.+64     	; 0x6b0e <rescueKit_drop+0x56>
    6ace:	95 36       	cpi	r25, 0x65	; 101
    6ad0:	19 f5       	brne	.+70     	; 0x6b18 <rescueKit_drop+0x60>
				sm_dropKit = (DEPLKIT_TIME_DEPLOYING+2);
		case (DEPLKIT_TIME_DEPLOYING+2) ... (DEPLKIT_TIME_DEPLOYING + DEPLKIT_TIME_WAIT):
				sm_dropKit ++;
				break;
		case (DEPLKIT_TIME_DEPLOYING + DEPLKIT_TIME_WAIT + 1):
				sm_dropKit = 0;
    6ad2:	10 92 ba 05 	sts	0x05BA, r1
				returnvar = 0;
    6ad6:	c0 e0       	ldi	r28, 0x00	; 0
			break;
    6ad8:	20 c0       	rjmp	.+64     	; 0x6b1a <rescueKit_drop+0x62>
	uint8_t returnvar = 1;

	switch(sm_dropKit)
	{
		case 0:
				servo_dropKitAngle ++;
    6ada:	20 91 b8 05 	lds	r18, 0x05B8
    6ade:	30 91 b9 05 	lds	r19, 0x05B9
    6ae2:	2f 5f       	subi	r18, 0xFF	; 255
    6ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    6ae6:	30 93 b9 05 	sts	0x05B9, r19
    6aea:	20 93 b8 05 	sts	0x05B8, r18
				if(servo_dropKitAngle == 90*speed)
    6aee:	9a e5       	ldi	r25, 0x5A	; 90
    6af0:	89 9f       	mul	r24, r25
    6af2:	a0 01       	movw	r20, r0
    6af4:	11 24       	eor	r1, r1
    6af6:	24 17       	cp	r18, r20
    6af8:	35 07       	cpc	r19, r21
    6afa:	71 f4       	brne	.+28     	; 0x6b18 <rescueKit_drop+0x60>
					sm_dropKit = 1;
    6afc:	91 e0       	ldi	r25, 0x01	; 1
    6afe:	0a c0       	rjmp	.+20     	; 0x6b14 <rescueKit_drop+0x5c>
			break;
		case 1 ... DEPLKIT_TIME_DEPLOYING:
				sm_dropKit ++;
				break;
		case (DEPLKIT_TIME_DEPLOYING+1):
				servo_dropKitAngle = 0;
    6b00:	10 92 b9 05 	sts	0x05B9, r1
    6b04:	10 92 b8 05 	sts	0x05B8, r1
				sm_dropKit = (DEPLKIT_TIME_DEPLOYING+2);
    6b08:	90 e2       	ldi	r25, 0x20	; 32
    6b0a:	90 93 ba 05 	sts	0x05BA, r25
		case (DEPLKIT_TIME_DEPLOYING+2) ... (DEPLKIT_TIME_DEPLOYING + DEPLKIT_TIME_WAIT):
				sm_dropKit ++;
    6b0e:	90 91 ba 05 	lds	r25, 0x05BA
    6b12:	9f 5f       	subi	r25, 0xFF	; 255
    6b14:	90 93 ba 05 	sts	0x05BA, r25
uint8_t sm_dropKit = 0;
uint16_t servo_dropKitAngle = 0;

uint8_t rescueKit_drop(uint8_t speed)
{
	uint8_t returnvar = 1;
    6b18:	c1 e0       	ldi	r28, 0x01	; 1
		case (DEPLKIT_TIME_DEPLOYING + DEPLKIT_TIME_WAIT + 1):
				sm_dropKit = 0;
				returnvar = 0;
			break;
	}
	servo_setPos(servo_dropKitAngle/speed);
    6b1a:	68 2f       	mov	r22, r24
    6b1c:	70 e0       	ldi	r23, 0x00	; 0
    6b1e:	80 91 b8 05 	lds	r24, 0x05B8
    6b22:	90 91 b9 05 	lds	r25, 0x05B9
    6b26:	0e 94 58 6b 	call	0xd6b0	; 0xd6b0 <__udivmodhi4>
    6b2a:	86 2f       	mov	r24, r22
    6b2c:	0e 94 5d 5b 	call	0xb6ba	; 0xb6ba <servo_setPos>

	return returnvar;
}
    6b30:	8c 2f       	mov	r24, r28
    6b32:	cf 91       	pop	r28
    6b34:	08 95       	ret

00006b36 <led_rgb>:
////////////////////////////LED///////////////////////////////////////////////
uint8_t led_heartbeat = 0; //Helligkeit (schwellt auf und ab als ,,Lebenszeichen")
uint8_t led_heartbeatDir = 0; //Aufschwellen oder abschwellen?

void led_rgb(uint16_t heartbeat_color, uint16_t led_error, uint8_t led_top)
{
    6b36:	cf 93       	push	r28
    6b38:	df 93       	push	r29
    6b3a:	ec 01       	movw	r28, r24
    6b3c:	9b 01       	movw	r18, r22
	if(heartbeat_color > 0)
    6b3e:	00 97       	sbiw	r24, 0x00	; 0
    6b40:	a9 f1       	breq	.+106    	; 0x6bac <led_rgb+0x76>
	{
		if(led_heartbeat == led_top)
    6b42:	80 91 b7 05 	lds	r24, 0x05B7
    6b46:	84 13       	cpse	r24, r20
    6b48:	04 c0       	rjmp	.+8      	; 0x6b52 <led_rgb+0x1c>
			led_heartbeatDir = 1;
    6b4a:	91 e0       	ldi	r25, 0x01	; 1
    6b4c:	90 93 b6 05 	sts	0x05B6, r25
    6b50:	04 c0       	rjmp	.+8      	; 0x6b5a <led_rgb+0x24>
		else if(led_heartbeat == 0)
    6b52:	81 11       	cpse	r24, r1
    6b54:	02 c0       	rjmp	.+4      	; 0x6b5a <led_rgb+0x24>
			led_heartbeatDir = 0;
    6b56:	10 92 b6 05 	sts	0x05B6, r1
		
		if(led_heartbeatDir == 1)
    6b5a:	90 91 b6 05 	lds	r25, 0x05B6
    6b5e:	91 30       	cpi	r25, 0x01	; 1
    6b60:	11 f4       	brne	.+4      	; 0x6b66 <led_rgb+0x30>
			led_heartbeat --;
    6b62:	81 50       	subi	r24, 0x01	; 1
    6b64:	01 c0       	rjmp	.+2      	; 0x6b68 <led_rgb+0x32>
		else
			led_heartbeat ++;
    6b66:	8f 5f       	subi	r24, 0xFF	; 255
    6b68:	80 93 b7 05 	sts	0x05B7, r24
		
		if(led_error == 0)
    6b6c:	21 15       	cp	r18, r1
    6b6e:	31 05       	cpc	r19, r1
    6b70:	59 f4       	brne	.+22     	; 0x6b88 <led_rgb+0x52>
		{
			display_setBGLED(1);
    6b72:	81 e0       	ldi	r24, 0x01	; 1
    6b74:	0e 94 32 5c 	call	0xb864	; 0xb864 <display_setBGLED>
			if(led_heartbeat > 1) //Nicht ganz aus
    6b78:	40 91 b7 05 	lds	r20, 0x05B7
    6b7c:	42 30       	cpi	r20, 0x02	; 2
    6b7e:	b0 f0       	brcs	.+44     	; 0x6bac <led_rgb+0x76>
				led_hsvToRgb(heartbeat_color, 255, led_heartbeat);
    6b80:	6f ef       	ldi	r22, 0xFF	; 255
    6b82:	8c 2f       	mov	r24, r28
    6b84:	30 df       	rcall	.-416    	; 0x69e6 <led_hsvToRgb>
    6b86:	12 c0       	rjmp	.+36     	; 0x6bac <led_rgb+0x76>
    6b88:	80 91 b7 05 	lds	r24, 0x05B7
		}
		else
		{
			if(led_heartbeat == led_top)
    6b8c:	84 13       	cpse	r24, r20
    6b8e:	05 c0       	rjmp	.+10     	; 0x6b9a <led_rgb+0x64>
    6b90:	6f ef       	ldi	r22, 0xFF	; 255
			{
				led_hsvToRgb(led_error, 255, led_top);
    6b92:	82 2f       	mov	r24, r18
    6b94:	28 df       	rcall	.-432    	; 0x69e6 <led_hsvToRgb>
    6b96:	80 e0       	ldi	r24, 0x00	; 0
    6b98:	07 c0       	rjmp	.+14     	; 0x6ba8 <led_rgb+0x72>
				display_setBGLED(0);
    6b9a:	81 11       	cpse	r24, r1
    6b9c:	07 c0       	rjmp	.+14     	; 0x6bac <led_rgb+0x76>
			}
			else if(led_heartbeat == 0)
    6b9e:	40 e0       	ldi	r20, 0x00	; 0
    6ba0:	6f ef       	ldi	r22, 0xFF	; 255
			{
				led_hsvToRgb(led_error, 255, 0);
    6ba2:	82 2f       	mov	r24, r18
    6ba4:	20 df       	rcall	.-448    	; 0x69e6 <led_hsvToRgb>
    6ba6:	81 e0       	ldi	r24, 0x01	; 1
    6ba8:	0e 94 32 5c 	call	0xb864	; 0xb864 <display_setBGLED>
				display_setBGLED(1);
    6bac:	df 91       	pop	r29
    6bae:	cf 91       	pop	r28
    6bb0:	08 95       	ret

00006bb2 <robot_getAngleToWall>:
//////////////////////////////////////////////////////////////////////////////////

int16_t robot_getAngleToWall(uint8_t dir)
{
	int16_t returnvar = GETANGLE_NOANGLE;
	dir = maze_alignDir(dir);
    6bb2:	0e 94 aa 47 	call	0x8f54	; 0x8f54 <maze_alignDir>

	switch(dir)
    6bb6:	82 30       	cpi	r24, 0x02	; 2
    6bb8:	09 f4       	brne	.+2      	; 0x6bbc <robot_getAngleToWall+0xa>
    6bba:	46 c0       	rjmp	.+140    	; 0x6c48 <robot_getAngleToWall+0x96>
    6bbc:	28 f4       	brcc	.+10     	; 0x6bc8 <robot_getAngleToWall+0x16>
    6bbe:	88 23       	and	r24, r24
    6bc0:	51 f0       	breq	.+20     	; 0x6bd6 <robot_getAngleToWall+0x24>
    6bc2:	81 30       	cpi	r24, 0x01	; 1
    6bc4:	a9 f1       	breq	.+106    	; 0x6c30 <robot_getAngleToWall+0x7e>
    6bc6:	69 c0       	rjmp	.+210    	; 0x6c9a <robot_getAngleToWall+0xe8>
    6bc8:	83 30       	cpi	r24, 0x03	; 3
    6bca:	09 f4       	brne	.+2      	; 0x6bce <robot_getAngleToWall+0x1c>
    6bcc:	49 c0       	rjmp	.+146    	; 0x6c60 <robot_getAngleToWall+0xae>
    6bce:	84 30       	cpi	r24, 0x04	; 4
    6bd0:	09 f4       	brne	.+2      	; 0x6bd4 <robot_getAngleToWall+0x22>
    6bd2:	52 c0       	rjmp	.+164    	; 0x6c78 <robot_getAngleToWall+0xc6>
    6bd4:	62 c0       	rjmp	.+196    	; 0x6c9a <robot_getAngleToWall+0xe8>
	{
		case NONE:

				if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6bd6:	20 91 ae 07 	lds	r18, 0x07AE
    6bda:	30 91 af 07 	lds	r19, 0x07AF
    6bde:	24 36       	cpi	r18, 0x64	; 100
    6be0:	31 05       	cpc	r19, r1
    6be2:	44 f4       	brge	.+16     	; 0x6bf4 <robot_getAngleToWall+0x42>
				   (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH))
    6be4:	80 91 b0 07 	lds	r24, 0x07B0
    6be8:	90 91 b1 07 	lds	r25, 0x07B1

	switch(dir)
	{
		case NONE:

				if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6bec:	84 36       	cpi	r24, 0x64	; 100
    6bee:	91 05       	cpc	r25, r1
    6bf0:	0c f4       	brge	.+2      	; 0x6bf4 <robot_getAngleToWall+0x42>
    6bf2:	50 c0       	rjmp	.+160    	; 0x6c94 <robot_getAngleToWall+0xe2>
				   (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH))
				{
					returnvar = (dist[LIN][RIGHT][BACK] - dist[LIN][RIGHT][FRONT]);
				}
				else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6bf4:	20 91 a6 07 	lds	r18, 0x07A6
    6bf8:	30 91 a7 07 	lds	r19, 0x07A7
    6bfc:	24 36       	cpi	r18, 0x64	; 100
    6bfe:	31 05       	cpc	r19, r1
    6c00:	44 f4       	brge	.+16     	; 0x6c12 <robot_getAngleToWall+0x60>
						(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH))
    6c02:	80 91 a8 07 	lds	r24, 0x07A8
    6c06:	90 91 a9 07 	lds	r25, 0x07A9
				if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
				   (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH))
				{
					returnvar = (dist[LIN][RIGHT][BACK] - dist[LIN][RIGHT][FRONT]);
				}
				else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6c0a:	84 36       	cpi	r24, 0x64	; 100
    6c0c:	91 05       	cpc	r25, r1
    6c0e:	0c f4       	brge	.+2      	; 0x6c12 <robot_getAngleToWall+0x60>
    6c10:	41 c0       	rjmp	.+130    	; 0x6c94 <robot_getAngleToWall+0xe2>
						(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH))
				{
					returnvar = (dist[LIN][LEFT][BACK] - dist[LIN][LEFT][FRONT]);
				}
				else if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    6c12:	20 91 b2 07 	lds	r18, 0x07B2
    6c16:	30 91 b3 07 	lds	r19, 0x07B3
    6c1a:	24 36       	cpi	r18, 0x64	; 100
    6c1c:	31 05       	cpc	r19, r1
    6c1e:	04 f5       	brge	.+64     	; 0x6c60 <robot_getAngleToWall+0xae>
						(dist[LIN][FRONT][RIGHT] < TILE1_SIDE_ALIGN_TH))
    6c20:	80 91 b4 07 	lds	r24, 0x07B4
    6c24:	90 91 b5 07 	lds	r25, 0x07B5
				else if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
						(dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH))
				{
					returnvar = (dist[LIN][LEFT][BACK] - dist[LIN][LEFT][FRONT]);
				}
				else if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    6c28:	84 36       	cpi	r24, 0x64	; 100
    6c2a:	91 05       	cpc	r25, r1
    6c2c:	cc f4       	brge	.+50     	; 0x6c60 <robot_getAngleToWall+0xae>
    6c2e:	32 c0       	rjmp	.+100    	; 0x6c94 <robot_getAngleToWall+0xe2>

			break;

		case NORTH:

				if((dist[LIN][FRONT][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    6c30:	20 91 b2 07 	lds	r18, 0x07B2
    6c34:	30 91 b3 07 	lds	r19, 0x07B3
    6c38:	24 36       	cpi	r18, 0x64	; 100
    6c3a:	31 05       	cpc	r19, r1
    6c3c:	74 f5       	brge	.+92     	; 0x6c9a <robot_getAngleToWall+0xe8>
				   (dist[LIN][FRONT][RIGHT] < TILE1_SIDE_ALIGN_TH))
    6c3e:	80 91 b4 07 	lds	r24, 0x07B4
    6c42:	90 91 b5 07 	lds	r25, 0x07B5
    6c46:	23 c0       	rjmp	.+70     	; 0x6c8e <robot_getAngleToWall+0xdc>

			break;

		case EAST:

				if((dist[LIN][RIGHT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6c48:	20 91 ae 07 	lds	r18, 0x07AE
    6c4c:	30 91 af 07 	lds	r19, 0x07AF
    6c50:	24 36       	cpi	r18, 0x64	; 100
    6c52:	31 05       	cpc	r19, r1
    6c54:	14 f5       	brge	.+68     	; 0x6c9a <robot_getAngleToWall+0xe8>
				   (dist[LIN][RIGHT][BACK] < TILE1_SIDE_ALIGN_TH))
    6c56:	80 91 b0 07 	lds	r24, 0x07B0
    6c5a:	90 91 b1 07 	lds	r25, 0x07B1
    6c5e:	17 c0       	rjmp	.+46     	; 0x6c8e <robot_getAngleToWall+0xdc>

			break;

		case SOUTH:

				if((dist[LIN][BACK][LEFT] < TILE1_SIDE_ALIGN_TH) &&
    6c60:	20 91 ba 07 	lds	r18, 0x07BA
    6c64:	30 91 bb 07 	lds	r19, 0x07BB
    6c68:	24 36       	cpi	r18, 0x64	; 100
    6c6a:	31 05       	cpc	r19, r1
    6c6c:	b4 f4       	brge	.+44     	; 0x6c9a <robot_getAngleToWall+0xe8>
				   (dist[LIN][BACK][RIGHT] < TILE1_SIDE_ALIGN_TH))
    6c6e:	80 91 bc 07 	lds	r24, 0x07BC
    6c72:	90 91 bd 07 	lds	r25, 0x07BD
    6c76:	0b c0       	rjmp	.+22     	; 0x6c8e <robot_getAngleToWall+0xdc>
				}
			break;

		case WEST:

				if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6c78:	20 91 a6 07 	lds	r18, 0x07A6
    6c7c:	30 91 a7 07 	lds	r19, 0x07A7
    6c80:	24 36       	cpi	r18, 0x64	; 100
    6c82:	31 05       	cpc	r19, r1
    6c84:	54 f4       	brge	.+20     	; 0x6c9a <robot_getAngleToWall+0xe8>
				   (dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH))
    6c86:	80 91 a8 07 	lds	r24, 0x07A8
    6c8a:	90 91 a9 07 	lds	r25, 0x07A9
				}
			break;

		case WEST:

				if((dist[LIN][LEFT][FRONT] < TILE1_SIDE_ALIGN_TH) &&
    6c8e:	84 36       	cpi	r24, 0x64	; 100
    6c90:	91 05       	cpc	r25, r1
    6c92:	1c f4       	brge	.+6      	; 0x6c9a <robot_getAngleToWall+0xe8>
				   (dist[LIN][LEFT][BACK] < TILE1_SIDE_ALIGN_TH))
				{
					returnvar = (dist[LIN][LEFT][BACK] - dist[LIN][LEFT][FRONT]);
    6c94:	82 1b       	sub	r24, r18
    6c96:	93 0b       	sbc	r25, r19
    6c98:	08 95       	ret
///		angle
//////////////////////////////////////////////////////////////////////////////////

int16_t robot_getAngleToWall(uint8_t dir)
{
	int16_t returnvar = GETANGLE_NOANGLE;
    6c9a:	80 e1       	ldi	r24, 0x10	; 16
    6c9c:	97 e2       	ldi	r25, 0x27	; 39

			break;
	}

	return returnvar;
}
    6c9e:	08 95       	ret

00006ca0 <get_sorted>:
///
/// @return: Adress of the element at @get int the given, sorted array
////////////////////////////////////////////////////////////////////////////////

int16_t *get_sorted(uint8_t cnt, int16_t *data, uint8_t get)
{
    6ca0:	0f 93       	push	r16
    6ca2:	1f 93       	push	r17
    6ca4:	cf 93       	push	r28
    6ca6:	df 93       	push	r29
	for(uint8_t i = 0; i <= cnt-1; i ++)
    6ca8:	90 e0       	ldi	r25, 0x00	; 0
    6caa:	08 2f       	mov	r16, r24
    6cac:	10 e0       	ldi	r17, 0x00	; 0
    6cae:	a9 2f       	mov	r26, r25
    6cb0:	b0 e0       	ldi	r27, 0x00	; 0
    6cb2:	a0 17       	cp	r26, r16
    6cb4:	b1 07       	cpc	r27, r17
    6cb6:	fc f4       	brge	.+62     	; 0x6cf6 <get_sorted+0x56>
		for(uint8_t j = i+1; j < cnt; j ++)
    6cb8:	51 e0       	ldi	r21, 0x01	; 1
    6cba:	59 0f       	add	r21, r25
			if(data[i] > data[j]) 
    6cbc:	aa 0f       	add	r26, r26
    6cbe:	bb 1f       	adc	r27, r27
    6cc0:	a6 0f       	add	r26, r22
    6cc2:	b7 1f       	adc	r27, r23
////////////////////////////////////////////////////////////////////////////////

int16_t *get_sorted(uint8_t cnt, int16_t *data, uint8_t get)
{
	for(uint8_t i = 0; i <= cnt-1; i ++)
		for(uint8_t j = i+1; j < cnt; j ++)
    6cc4:	95 2f       	mov	r25, r21
    6cc6:	98 17       	cp	r25, r24
    6cc8:	a0 f4       	brcc	.+40     	; 0x6cf2 <get_sorted+0x52>
			if(data[i] > data[j]) 
    6cca:	2d 91       	ld	r18, X+
    6ccc:	3c 91       	ld	r19, X
    6cce:	11 97       	sbiw	r26, 0x01	; 1
    6cd0:	fb 01       	movw	r30, r22
    6cd2:	e9 0f       	add	r30, r25
    6cd4:	f1 1d       	adc	r31, r1
    6cd6:	e9 0f       	add	r30, r25
    6cd8:	f1 1d       	adc	r31, r1
    6cda:	c0 81       	ld	r28, Z
    6cdc:	d1 81       	ldd	r29, Z+1	; 0x01
    6cde:	c2 17       	cp	r28, r18
    6ce0:	d3 07       	cpc	r29, r19
    6ce2:	2c f4       	brge	.+10     	; 0x6cee <get_sorted+0x4e>
   		{ 
	 			uint16_t data_temp = data[i]; 
   			data[i] = data[j]; 
    6ce4:	11 96       	adiw	r26, 0x01	; 1
    6ce6:	dc 93       	st	X, r29
    6ce8:	ce 93       	st	-X, r28
   			data[j] = data_temp; 
    6cea:	31 83       	std	Z+1, r19	; 0x01
    6cec:	20 83       	st	Z, r18
////////////////////////////////////////////////////////////////////////////////

int16_t *get_sorted(uint8_t cnt, int16_t *data, uint8_t get)
{
	for(uint8_t i = 0; i <= cnt-1; i ++)
		for(uint8_t j = i+1; j < cnt; j ++)
    6cee:	9f 5f       	subi	r25, 0xFF	; 255
    6cf0:	ea cf       	rjmp	.-44     	; 0x6cc6 <get_sorted+0x26>
/// @return: Adress of the element at @get int the given, sorted array
////////////////////////////////////////////////////////////////////////////////

int16_t *get_sorted(uint8_t cnt, int16_t *data, uint8_t get)
{
	for(uint8_t i = 0; i <= cnt-1; i ++)
    6cf2:	95 2f       	mov	r25, r21
    6cf4:	dc cf       	rjmp	.-72     	; 0x6cae <get_sorted+0xe>
   			data[i] = data[j]; 
   			data[j] = data_temp; 
   		}
   		
	return &data[get];
}
    6cf6:	cb 01       	movw	r24, r22
    6cf8:	84 0f       	add	r24, r20
    6cfa:	91 1d       	adc	r25, r1
    6cfc:	84 0f       	add	r24, r20
    6cfe:	91 1d       	adc	r25, r1
    6d00:	df 91       	pop	r29
    6d02:	cf 91       	pop	r28
    6d04:	1f 91       	pop	r17
    6d06:	0f 91       	pop	r16
    6d08:	08 95       	ret

00006d0a <dist_init>:

int8_t sm_anaSens = 0;

void dist_init(void)
{
	SENS_ACTIVE_PORTDIR |= (1<<SENS_MID_PIN);
    6d0a:	0a 9a       	sbi	0x01, 2	; 1
	SENS_ACTIVE_PORTDIR |= (1<<SENS_LEFT_PIN);
    6d0c:	0b 9a       	sbi	0x01, 3	; 1
	SENS_ACTIVE_PORTDIR |= (1<<SENS_RIGHT_PIN);
    6d0e:	0c 9a       	sbi	0x01, 4	; 1
	
	sensinfo.request.left = 1;
    6d10:	e2 ec       	ldi	r30, 0xC2	; 194
    6d12:	f7 e0       	ldi	r31, 0x07	; 7
    6d14:	80 81       	ld	r24, Z
	sensinfo.request.right = 1;
	sensinfo.request.mid = 1;
    6d16:	83 60       	ori	r24, 0x03	; 3
    6d18:	84 60       	ori	r24, 0x04	; 4
    6d1a:	80 83       	st	Z, r24
	sensinfo.newDat.left = 0;
    6d1c:	e3 ec       	ldi	r30, 0xC3	; 195
    6d1e:	f7 e0       	ldi	r31, 0x07	; 7
    6d20:	80 81       	ld	r24, Z
	sensinfo.newDat.right = 0;
	sensinfo.newDat.mid = 0;
    6d22:	8c 7f       	andi	r24, 0xFC	; 252
    6d24:	8b 7f       	andi	r24, 0xFB	; 251
    6d26:	80 83       	st	Z, r24
{
	switch(block)
	{
		case LEFT:	if(set)
								{
									SENS_ACTIVE_PORT |= (1<<SENS_LEFT_PIN);
    6d28:	13 9a       	sbi	0x02, 3	; 2
    6d2a:	08 95       	ret

00006d2c <get_adc>:
	}
}

int16_t get_adc(uint8_t channel)
{
	if(tsl_adc_state == 0)
    6d2c:	90 91 d8 05 	lds	r25, 0x05D8
    6d30:	91 11       	cpse	r25, r1
    6d32:	1d c0       	rjmp	.+58     	; 0x6d6e <get_adc+0x42>
	{
		ADMUX &= 0xE0;							//Clear bits MUX0-4
    6d34:	90 91 7c 00 	lds	r25, 0x007C
    6d38:	90 7e       	andi	r25, 0xE0	; 224
    6d3a:	90 93 7c 00 	sts	0x007C, r25
		ADMUX |= channel&0x07;			//Defines the new ADC channel to be read by setting bits MUX0-2
    6d3e:	20 91 7c 00 	lds	r18, 0x007C
    6d42:	98 2f       	mov	r25, r24
    6d44:	97 70       	andi	r25, 0x07	; 7
    6d46:	92 2b       	or	r25, r18
    6d48:	90 93 7c 00 	sts	0x007C, r25
		ADCSRB = channel&(1<<3);		//Set MUX5
    6d4c:	88 70       	andi	r24, 0x08	; 8
    6d4e:	80 93 7b 00 	sts	0x007B, r24
		ADCSRA |= (1<<ADSC);				//Starts a new conversion
    6d52:	80 91 7a 00 	lds	r24, 0x007A
    6d56:	80 64       	ori	r24, 0x40	; 64
    6d58:	80 93 7a 00 	sts	0x007A, r24
		while(ADCSRA & (1<<ADSC));	//Wait until the conversion is done
    6d5c:	80 91 7a 00 	lds	r24, 0x007A
    6d60:	86 fd       	sbrc	r24, 6
    6d62:	fc cf       	rjmp	.-8      	; 0x6d5c <get_adc+0x30>
		return ADCW;
    6d64:	80 91 78 00 	lds	r24, 0x0078
    6d68:	90 91 79 00 	lds	r25, 0x0079
    6d6c:	08 95       	ret
	}
	else	return -1;
    6d6e:	8f ef       	ldi	r24, 0xFF	; 255
    6d70:	9f ef       	ldi	r25, 0xFF	; 255
}
    6d72:	08 95       	ret

00006d74 <check_tsl_state>:

void check_tsl_state(void)
{
	if(tsl_state == TSL_WAIT_GET)
    6d74:	80 91 d9 05 	lds	r24, 0x05D9
    6d78:	82 30       	cpi	r24, 0x02	; 2
    6d7a:	31 f4       	brne	.+12     	; 0x6d88 <check_tsl_state+0x14>
	{
		tsl_state = TSL_GET;
    6d7c:	83 e0       	ldi	r24, 0x03	; 3
    6d7e:	80 93 d9 05 	sts	0x05D9, r24
		tsl_adc_state = ADC_CAM_INIT;
    6d82:	81 e0       	ldi	r24, 0x01	; 1
    6d84:	80 93 d8 05 	sts	0x05D8, r24
    6d88:	08 95       	ret

00006d8a <get_otherSens>:
	}
}

void get_otherSens(void)
{
	batt_raw = get_adc(ADC_BATTERY);
    6d8a:	89 e0       	ldi	r24, 0x09	; 9
    6d8c:	cf df       	rcall	.-98     	; 0x6d2c <get_adc>
    6d8e:	90 93 fd 07 	sts	0x07FD, r25
    6d92:	80 93 fc 07 	sts	0x07FC, r24
    6d96:	87 e0       	ldi	r24, 0x07	; 7
	dist_down = get_adc(SHARP_DOWN);
    6d98:	c9 df       	rcall	.-110    	; 0x6d2c <get_adc>
    6d9a:	90 93 7f 07 	sts	0x077F, r25
    6d9e:	80 93 7e 07 	sts	0x077E, r24
    6da2:	08 95       	ret

00006da4 <get_groundSens>:
		groundSens_setLED(0);
		sm_groundSens = 0;
	default:
		break;
	}*/
	groundSens_setLED(0);
    6da4:	80 e0       	ldi	r24, 0x00	; 0
    6da6:	0c 94 4d 5c 	jmp	0xb89a	; 0xb89a <groundSens_setLED>

00006daa <get_analogSensors>:

}

void get_analogSensors(void)
{
    6daa:	8f 92       	push	r8
    6dac:	9f 92       	push	r9
    6dae:	af 92       	push	r10
    6db0:	bf 92       	push	r11
    6db2:	cf 92       	push	r12
    6db4:	df 92       	push	r13
    6db6:	ef 92       	push	r14
    6db8:	ff 92       	push	r15
	switch(sm_anaSens)
    6dba:	80 91 b5 05 	lds	r24, 0x05B5
    6dbe:	81 30       	cpi	r24, 0x01	; 1
    6dc0:	09 f4       	brne	.+2      	; 0x6dc4 <get_analogSensors+0x1a>
    6dc2:	df c1       	rjmp	.+958    	; 0x7182 <get_analogSensors+0x3d8>
    6dc4:	82 30       	cpi	r24, 0x02	; 2
    6dc6:	09 f4       	brne	.+2      	; 0x6dca <get_analogSensors+0x20>
    6dc8:	ad c3       	rjmp	.+1882   	; 0x7524 <get_analogSensors+0x77a>
    6dca:	81 11       	cpse	r24, r1
    6dcc:	1e c4       	rjmp	.+2108   	; 0x760a <get_analogSensors+0x860>
	{
		case LEFT:
						dist[RAW][FRONT][LEFT] = get_adc(SHARP_FRONT_LEFT);
    6dce:	8a e0       	ldi	r24, 0x0A	; 10
    6dd0:	ad df       	rcall	.-166    	; 0x6d2c <get_adc>
    6dd2:	90 93 93 07 	sts	0x0793, r25
    6dd6:	80 93 92 07 	sts	0x0792, r24
    6dda:	81 36       	cpi	r24, 0x61	; 97
						if(dist[RAW][FRONT][LEFT] > 96)
    6ddc:	91 05       	cpc	r25, r1
    6dde:	0c f4       	brge	.+2      	; 0x6de2 <get_analogSensors+0x38>
    6de0:	62 c0       	rjmp	.+196    	; 0x6ea6 <get_analogSensors+0xfc>
    6de2:	bc 01       	movw	r22, r24
						{
							dist[LIN][FRONT][LEFT]	= 	(uint16_t)(1.7853218E-8 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
    6de4:	88 27       	eor	r24, r24
    6de6:	77 fd       	sbrc	r23, 7
    6de8:	80 95       	com	r24
    6dea:	98 2f       	mov	r25, r24
    6dec:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    6df0:	6b 01       	movw	r12, r22
    6df2:	7c 01       	movw	r14, r24
    6df4:	2a e0       	ldi	r18, 0x0A	; 10
																		(uint16_t)(2.770541E-5 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) +
																		(uint16_t)(0.016060371 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
    6df6:	31 e9       	ldi	r19, 0x91	; 145
    6df8:	43 e8       	ldi	r20, 0x83	; 131
    6dfa:	5c e3       	ldi	r21, 0x3C	; 60
    6dfc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e00:	a7 01       	movw	r20, r14
    6e02:	96 01       	movw	r18, r12
    6e04:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e08:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6e0c:	4b 01       	movw	r8, r22
    6e0e:	5c 01       	movw	r10, r24
    6e10:	2f eb       	ldi	r18, 0xBF	; 191
																		(uint16_t)(4.317962105 * dist[RAW][FRONT][LEFT]) +
    6e12:	3c e2       	ldi	r19, 0x2C	; 44
    6e14:	4a e8       	ldi	r20, 0x8A	; 138
    6e16:	50 e4       	ldi	r21, 0x40	; 64
    6e18:	c7 01       	movw	r24, r14
    6e1a:	b6 01       	movw	r22, r12
    6e1c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e20:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6e24:	86 1a       	sub	r8, r22
	{
		case LEFT:
						dist[RAW][FRONT][LEFT] = get_adc(SHARP_FRONT_LEFT);
						if(dist[RAW][FRONT][LEFT] > 96)
						{
							dist[LIN][FRONT][LEFT]	= 	(uint16_t)(1.7853218E-8 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
    6e26:	97 0a       	sbc	r9, r23
    6e28:	24 ea       	ldi	r18, 0xA4	; 164
    6e2a:	3b e5       	ldi	r19, 0x5B	; 91
    6e2c:	49 e9       	ldi	r20, 0x99	; 153
    6e2e:	52 e3       	ldi	r21, 0x32	; 50
    6e30:	c7 01       	movw	r24, r14
    6e32:	b6 01       	movw	r22, r12
    6e34:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e38:	a7 01       	movw	r20, r14
    6e3a:	96 01       	movw	r18, r12
    6e3c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e40:	a7 01       	movw	r20, r14
    6e42:	96 01       	movw	r18, r12
    6e44:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e48:	a7 01       	movw	r20, r14
    6e4a:	96 01       	movw	r18, r12
    6e4c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e50:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6e54:	86 0e       	add	r8, r22
																		(uint16_t)(2.770541E-5 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) +
    6e56:	97 1e       	adc	r9, r23
    6e58:	2a ee       	ldi	r18, 0xEA	; 234
    6e5a:	38 e6       	ldi	r19, 0x68	; 104
    6e5c:	48 ee       	ldi	r20, 0xE8	; 232
    6e5e:	57 e3       	ldi	r21, 0x37	; 55
    6e60:	c7 01       	movw	r24, r14
    6e62:	b6 01       	movw	r22, r12
    6e64:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e68:	a7 01       	movw	r20, r14
    6e6a:	96 01       	movw	r18, r12
    6e6c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e70:	a7 01       	movw	r20, r14
    6e72:	96 01       	movw	r18, r12
    6e74:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6e78:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6e7c:	94 01       	movw	r18, r8
																		(uint16_t)(0.016060371 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
    6e7e:	26 1b       	sub	r18, r22
    6e80:	37 0b       	sbc	r19, r23
    6e82:	b9 01       	movw	r22, r18
    6e84:	80 e0       	ldi	r24, 0x00	; 0
																		(uint16_t)(4.317962105 * dist[RAW][FRONT][LEFT]) +
    6e86:	90 e0       	ldi	r25, 0x00	; 0
    6e88:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    6e8c:	20 e0       	ldi	r18, 0x00	; 0
    6e8e:	30 ea       	ldi	r19, 0xA0	; 160
    6e90:	44 ef       	ldi	r20, 0xF4	; 244
    6e92:	53 e4       	ldi	r21, 0x43	; 67
    6e94:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    6e98:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
	{
		case LEFT:
						dist[RAW][FRONT][LEFT] = get_adc(SHARP_FRONT_LEFT);
						if(dist[RAW][FRONT][LEFT] > 96)
						{
							dist[LIN][FRONT][LEFT]	= 	(uint16_t)(1.7853218E-8 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
    6e9c:	70 93 b3 07 	sts	0x07B3, r23
    6ea0:	60 93 b2 07 	sts	0x07B2, r22
    6ea4:	06 c0       	rjmp	.+12     	; 0x6eb2 <get_analogSensors+0x108>
    6ea6:	88 ec       	ldi	r24, 0xC8	; 200
																		(uint16_t)(2.770541E-5 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) +
																		(uint16_t)(0.016060371 * dist[RAW][FRONT][LEFT] * dist[RAW][FRONT][LEFT]) -
																		(uint16_t)(4.317962105 * dist[RAW][FRONT][LEFT]) +
																		489.25;
						}
						else dist[LIN][FRONT][LEFT] = DIST_MAX_SRP_OLD;
    6ea8:	90 e0       	ldi	r25, 0x00	; 0
    6eaa:	90 93 b3 07 	sts	0x07B3, r25
    6eae:	80 93 b2 07 	sts	0x07B2, r24
    6eb2:	8e e0       	ldi	r24, 0x0E	; 14
						
						dist[RAW][RIGHT][FRONT] = get_adc(SHARP_RIGHT_FRONT);
    6eb4:	3b df       	rcall	.-394    	; 0x6d2c <get_adc>
    6eb6:	90 93 8f 07 	sts	0x078F, r25
    6eba:	80 93 8e 07 	sts	0x078E, r24
    6ebe:	89 36       	cpi	r24, 0x69	; 105
    6ec0:	91 05       	cpc	r25, r1
						if(dist[RAW][RIGHT][FRONT] > 104)
    6ec2:	0c f4       	brge	.+2      	; 0x6ec6 <get_analogSensors+0x11c>
    6ec4:	62 c0       	rjmp	.+196    	; 0x6f8a <get_analogSensors+0x1e0>
    6ec6:	bc 01       	movw	r22, r24
    6ec8:	88 27       	eor	r24, r24
						{
							dist[LIN][RIGHT][FRONT]	= (uint16_t)(2.268745E-8 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
    6eca:	77 fd       	sbrc	r23, 7
    6ecc:	80 95       	com	r24
    6ece:	98 2f       	mov	r25, r24
    6ed0:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    6ed4:	6b 01       	movw	r12, r22
    6ed6:	7c 01       	movw	r14, r24
    6ed8:	21 e8       	ldi	r18, 0x81	; 129
    6eda:	39 e9       	ldi	r19, 0x99	; 153
																		(uint16_t)(3.321157E-5 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) +
																		(uint16_t)(0.0182616737 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
    6edc:	45 e9       	ldi	r20, 0x95	; 149
    6ede:	5c e3       	ldi	r21, 0x3C	; 60
    6ee0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6ee4:	a7 01       	movw	r20, r14
    6ee6:	96 01       	movw	r18, r12
    6ee8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6eec:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6ef0:	4b 01       	movw	r8, r22
    6ef2:	5c 01       	movw	r10, r24
    6ef4:	23 ed       	ldi	r18, 0xD3	; 211
    6ef6:	3d e6       	ldi	r19, 0x6D	; 109
																		(uint16_t)(4.700906244 * dist[RAW][RIGHT][FRONT]) +
    6ef8:	46 e9       	ldi	r20, 0x96	; 150
    6efa:	50 e4       	ldi	r21, 0x40	; 64
    6efc:	c7 01       	movw	r24, r14
    6efe:	b6 01       	movw	r22, r12
    6f00:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f04:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6f08:	86 1a       	sub	r8, r22
    6f0a:	97 0a       	sbc	r9, r23
						else dist[LIN][FRONT][LEFT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][RIGHT][FRONT] = get_adc(SHARP_RIGHT_FRONT);
						if(dist[RAW][RIGHT][FRONT] > 104)
						{
							dist[LIN][RIGHT][FRONT]	= (uint16_t)(2.268745E-8 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
    6f0c:	2b e3       	ldi	r18, 0x3B	; 59
    6f0e:	32 ee       	ldi	r19, 0xE2	; 226
    6f10:	42 ec       	ldi	r20, 0xC2	; 194
    6f12:	52 e3       	ldi	r21, 0x32	; 50
    6f14:	c7 01       	movw	r24, r14
    6f16:	b6 01       	movw	r22, r12
    6f18:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f1c:	a7 01       	movw	r20, r14
    6f1e:	96 01       	movw	r18, r12
    6f20:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f24:	a7 01       	movw	r20, r14
    6f26:	96 01       	movw	r18, r12
    6f28:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f2c:	a7 01       	movw	r20, r14
    6f2e:	96 01       	movw	r18, r12
    6f30:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f34:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6f38:	86 0e       	add	r8, r22
    6f3a:	97 1e       	adc	r9, r23
																		(uint16_t)(3.321157E-5 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) +
    6f3c:	27 ea       	ldi	r18, 0xA7	; 167
    6f3e:	3c e4       	ldi	r19, 0x4C	; 76
    6f40:	4b e0       	ldi	r20, 0x0B	; 11
    6f42:	58 e3       	ldi	r21, 0x38	; 56
    6f44:	c7 01       	movw	r24, r14
    6f46:	b6 01       	movw	r22, r12
    6f48:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f4c:	a7 01       	movw	r20, r14
    6f4e:	96 01       	movw	r18, r12
    6f50:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f54:	a7 01       	movw	r20, r14
    6f56:	96 01       	movw	r18, r12
    6f58:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6f5c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6f60:	94 01       	movw	r18, r8
    6f62:	26 1b       	sub	r18, r22
																		(uint16_t)(0.0182616737 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
    6f64:	37 0b       	sbc	r19, r23
    6f66:	b9 01       	movw	r22, r18
    6f68:	80 e0       	ldi	r24, 0x00	; 0
    6f6a:	90 e0       	ldi	r25, 0x00	; 0
																		(uint16_t)(4.700906244 * dist[RAW][RIGHT][FRONT]) +
    6f6c:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    6f70:	23 e3       	ldi	r18, 0x33	; 51
    6f72:	33 eb       	ldi	r19, 0xB3	; 179
    6f74:	41 e0       	ldi	r20, 0x01	; 1
    6f76:	54 e4       	ldi	r21, 0x44	; 68
    6f78:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    6f7c:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
						else dist[LIN][FRONT][LEFT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][RIGHT][FRONT] = get_adc(SHARP_RIGHT_FRONT);
						if(dist[RAW][RIGHT][FRONT] > 104)
						{
							dist[LIN][RIGHT][FRONT]	= (uint16_t)(2.268745E-8 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
    6f80:	70 93 af 07 	sts	0x07AF, r23
    6f84:	60 93 ae 07 	sts	0x07AE, r22
    6f88:	06 c0       	rjmp	.+12     	; 0x6f96 <get_analogSensors+0x1ec>
    6f8a:	88 ec       	ldi	r24, 0xC8	; 200
    6f8c:	90 e0       	ldi	r25, 0x00	; 0
																		(uint16_t)(3.321157E-5 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) +
																		(uint16_t)(0.0182616737 * dist[RAW][RIGHT][FRONT] * dist[RAW][RIGHT][FRONT]) -
																		(uint16_t)(4.700906244 * dist[RAW][RIGHT][FRONT]) +
																		518.8;
						}
						else dist[LIN][RIGHT][FRONT] = DIST_MAX_SRP_OLD;
    6f8e:	90 93 af 07 	sts	0x07AF, r25
    6f92:	80 93 ae 07 	sts	0x07AE, r24
    6f96:	80 e0       	ldi	r24, 0x00	; 0
    6f98:	c9 de       	rcall	.-622    	; 0x6d2c <get_adc>
						
						dist[RAW][BACK][RIGHT] = get_adc(SHARP_BACK_RIGHT);
    6f9a:	90 93 9d 07 	sts	0x079D, r25
    6f9e:	80 93 9c 07 	sts	0x079C, r24
    6fa2:	89 37       	cpi	r24, 0x79	; 121
    6fa4:	91 05       	cpc	r25, r1
    6fa6:	0c f4       	brge	.+2      	; 0x6faa <get_analogSensors+0x200>
						if(dist[RAW][BACK][RIGHT] > 120)
    6fa8:	62 c0       	rjmp	.+196    	; 0x706e <get_analogSensors+0x2c4>
    6faa:	bc 01       	movw	r22, r24
    6fac:	88 27       	eor	r24, r24
    6fae:	77 fd       	sbrc	r23, 7
						{
							dist[LIN][BACK][RIGHT]	= 	(uint16_t)(1.9709952E-8 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
    6fb0:	80 95       	com	r24
    6fb2:	98 2f       	mov	r25, r24
    6fb4:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    6fb8:	6b 01       	movw	r12, r22
    6fba:	7c 01       	movw	r14, r24
    6fbc:	23 e6       	ldi	r18, 0x63	; 99
    6fbe:	3d e4       	ldi	r19, 0x4D	; 77
    6fc0:	4b e9       	ldi	r20, 0x9B	; 155
																		(uint16_t)(3.146821E-5 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) +
																		(uint16_t)(0.0189577999 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
    6fc2:	5c e3       	ldi	r21, 0x3C	; 60
    6fc4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6fc8:	a7 01       	movw	r20, r14
    6fca:	96 01       	movw	r18, r12
    6fcc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6fd0:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6fd4:	4b 01       	movw	r8, r22
    6fd6:	5c 01       	movw	r10, r24
    6fd8:	29 ea       	ldi	r18, 0xA9	; 169
    6fda:	3a eb       	ldi	r19, 0xBA	; 186
    6fdc:	4a ea       	ldi	r20, 0xAA	; 170
																		(uint16_t)(5.335285586 * dist[RAW][BACK][RIGHT]) +
    6fde:	50 e4       	ldi	r21, 0x40	; 64
    6fe0:	c7 01       	movw	r24, r14
    6fe2:	b6 01       	movw	r22, r12
    6fe4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    6fe8:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    6fec:	86 1a       	sub	r8, r22
    6fee:	97 0a       	sbc	r9, r23
    6ff0:	25 ea       	ldi	r18, 0xA5	; 165
						else dist[LIN][RIGHT][FRONT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][BACK][RIGHT] = get_adc(SHARP_BACK_RIGHT);
						if(dist[RAW][BACK][RIGHT] > 120)
						{
							dist[LIN][BACK][RIGHT]	= 	(uint16_t)(1.9709952E-8 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
    6ff2:	3e e4       	ldi	r19, 0x4E	; 78
    6ff4:	49 ea       	ldi	r20, 0xA9	; 169
    6ff6:	52 e3       	ldi	r21, 0x32	; 50
    6ff8:	c7 01       	movw	r24, r14
    6ffa:	b6 01       	movw	r22, r12
    6ffc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7000:	a7 01       	movw	r20, r14
    7002:	96 01       	movw	r18, r12
    7004:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7008:	a7 01       	movw	r20, r14
    700a:	96 01       	movw	r18, r12
    700c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7010:	a7 01       	movw	r20, r14
    7012:	96 01       	movw	r18, r12
    7014:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7018:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    701c:	86 0e       	add	r8, r22
    701e:	97 1e       	adc	r9, r23
    7020:	2c eb       	ldi	r18, 0xBC	; 188
																		(uint16_t)(3.146821E-5 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) +
    7022:	3c ef       	ldi	r19, 0xFC	; 252
    7024:	43 e0       	ldi	r20, 0x03	; 3
    7026:	58 e3       	ldi	r21, 0x38	; 56
    7028:	c7 01       	movw	r24, r14
    702a:	b6 01       	movw	r22, r12
    702c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7030:	a7 01       	movw	r20, r14
    7032:	96 01       	movw	r18, r12
    7034:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7038:	a7 01       	movw	r20, r14
    703a:	96 01       	movw	r18, r12
    703c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7040:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7044:	94 01       	movw	r18, r8
    7046:	26 1b       	sub	r18, r22
    7048:	37 0b       	sbc	r19, r23
																		(uint16_t)(0.0189577999 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
    704a:	b9 01       	movw	r22, r18
    704c:	80 e0       	ldi	r24, 0x00	; 0
    704e:	90 e0       	ldi	r25, 0x00	; 0
    7050:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
																		(uint16_t)(5.335285586 * dist[RAW][BACK][RIGHT]) +
    7054:	25 e8       	ldi	r18, 0x85	; 133
    7056:	3b e4       	ldi	r19, 0x4B	; 75
    7058:	4e e1       	ldi	r20, 0x1E	; 30
    705a:	54 e4       	ldi	r21, 0x44	; 68
    705c:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    7060:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    7064:	70 93 bd 07 	sts	0x07BD, r23
						else dist[LIN][RIGHT][FRONT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][BACK][RIGHT] = get_adc(SHARP_BACK_RIGHT);
						if(dist[RAW][BACK][RIGHT] > 120)
						{
							dist[LIN][BACK][RIGHT]	= 	(uint16_t)(1.9709952E-8 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
    7068:	60 93 bc 07 	sts	0x07BC, r22
    706c:	06 c0       	rjmp	.+12     	; 0x707a <get_analogSensors+0x2d0>
    706e:	88 ec       	ldi	r24, 0xC8	; 200
    7070:	90 e0       	ldi	r25, 0x00	; 0
    7072:	90 93 bd 07 	sts	0x07BD, r25
																		(uint16_t)(3.146821E-5 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) +
																		(uint16_t)(0.0189577999 * dist[RAW][BACK][RIGHT] * dist[RAW][BACK][RIGHT]) -
																		(uint16_t)(5.335285586 * dist[RAW][BACK][RIGHT]) +
																		633.18;
						}
						else dist[LIN][BACK][RIGHT] = DIST_MAX_SRP_OLD;
    7076:	80 93 bc 07 	sts	0x07BC, r24
    707a:	82 e0       	ldi	r24, 0x02	; 2
    707c:	57 de       	rcall	.-850    	; 0x6d2c <get_adc>
    707e:	90 93 89 07 	sts	0x0789, r25

						dist[RAW][LEFT][BACK] = get_adc(SHARP_LEFT_BACK);
    7082:	80 93 88 07 	sts	0x0788, r24
    7086:	81 36       	cpi	r24, 0x61	; 97
    7088:	91 05       	cpc	r25, r1
    708a:	0c f4       	brge	.+2      	; 0x708e <get_analogSensors+0x2e4>
    708c:	62 c0       	rjmp	.+196    	; 0x7152 <get_analogSensors+0x3a8>
						if(dist[RAW][LEFT][BACK] > 96)
    708e:	bc 01       	movw	r22, r24
    7090:	88 27       	eor	r24, r24
    7092:	77 fd       	sbrc	r23, 7
    7094:	80 95       	com	r24
						{
							dist[LIN][LEFT][BACK]		= (uint16_t)(4.0632806E-8 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
    7096:	98 2f       	mov	r25, r24
    7098:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    709c:	6b 01       	movw	r12, r22
    709e:	7c 01       	movw	r14, r24
    70a0:	26 ee       	ldi	r18, 0xE6	; 230
    70a2:	34 ea       	ldi	r19, 0xA4	; 164
    70a4:	4a ed       	ldi	r20, 0xDA	; 218
    70a6:	5c e3       	ldi	r21, 0x3C	; 60
									(uint16_t)(5.436834E-5 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) +
									(uint16_t)(0.026689958 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
    70a8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70ac:	a7 01       	movw	r20, r14
    70ae:	96 01       	movw	r18, r12
    70b0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70b4:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    70b8:	4b 01       	movw	r8, r22
    70ba:	5c 01       	movw	r10, r24
    70bc:	29 e5       	ldi	r18, 0x59	; 89
    70be:	3a ee       	ldi	r19, 0xEA	; 234
    70c0:	4f eb       	ldi	r20, 0xBF	; 191
    70c2:	50 e4       	ldi	r21, 0x40	; 64
									(uint16_t)(5.997356831 * dist[RAW][LEFT][BACK]) +
    70c4:	c7 01       	movw	r24, r14
    70c6:	b6 01       	movw	r22, r12
    70c8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70cc:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    70d0:	86 1a       	sub	r8, r22
    70d2:	97 0a       	sbc	r9, r23
    70d4:	2e e3       	ldi	r18, 0x3E	; 62
    70d6:	34 e8       	ldi	r19, 0x84	; 132
						else dist[LIN][BACK][RIGHT] = DIST_MAX_SRP_OLD;

						dist[RAW][LEFT][BACK] = get_adc(SHARP_LEFT_BACK);
						if(dist[RAW][LEFT][BACK] > 96)
						{
							dist[LIN][LEFT][BACK]		= (uint16_t)(4.0632806E-8 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
    70d8:	4e e2       	ldi	r20, 0x2E	; 46
    70da:	53 e3       	ldi	r21, 0x33	; 51
    70dc:	c7 01       	movw	r24, r14
    70de:	b6 01       	movw	r22, r12
    70e0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70e4:	a7 01       	movw	r20, r14
    70e6:	96 01       	movw	r18, r12
    70e8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70ec:	a7 01       	movw	r20, r14
    70ee:	96 01       	movw	r18, r12
    70f0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70f4:	a7 01       	movw	r20, r14
    70f6:	96 01       	movw	r18, r12
    70f8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    70fc:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7100:	86 0e       	add	r8, r22
    7102:	97 1e       	adc	r9, r23
    7104:	20 e9       	ldi	r18, 0x90	; 144
    7106:	39 e0       	ldi	r19, 0x09	; 9
									(uint16_t)(5.436834E-5 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) +
    7108:	44 e6       	ldi	r20, 0x64	; 100
    710a:	58 e3       	ldi	r21, 0x38	; 56
    710c:	c7 01       	movw	r24, r14
    710e:	b6 01       	movw	r22, r12
    7110:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7114:	a7 01       	movw	r20, r14
    7116:	96 01       	movw	r18, r12
    7118:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    711c:	a7 01       	movw	r20, r14
    711e:	96 01       	movw	r18, r12
    7120:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7124:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7128:	94 01       	movw	r18, r8
    712a:	26 1b       	sub	r18, r22
    712c:	37 0b       	sbc	r19, r23
    712e:	b9 01       	movw	r22, r18
									(uint16_t)(0.026689958 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
    7130:	80 e0       	ldi	r24, 0x00	; 0
    7132:	90 e0       	ldi	r25, 0x00	; 0
    7134:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
									(uint16_t)(5.997356831 * dist[RAW][LEFT][BACK]) +
    7138:	23 e3       	ldi	r18, 0x33	; 51
    713a:	33 ee       	ldi	r19, 0xE3	; 227
    713c:	4e e0       	ldi	r20, 0x0E	; 14
    713e:	54 e4       	ldi	r21, 0x44	; 68
    7140:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    7144:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    7148:	70 93 a9 07 	sts	0x07A9, r23
						else dist[LIN][BACK][RIGHT] = DIST_MAX_SRP_OLD;

						dist[RAW][LEFT][BACK] = get_adc(SHARP_LEFT_BACK);
						if(dist[RAW][LEFT][BACK] > 96)
						{
							dist[LIN][LEFT][BACK]		= (uint16_t)(4.0632806E-8 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
    714c:	60 93 a8 07 	sts	0x07A8, r22
    7150:	06 c0       	rjmp	.+12     	; 0x715e <get_analogSensors+0x3b4>
    7152:	88 ec       	ldi	r24, 0xC8	; 200
    7154:	90 e0       	ldi	r25, 0x00	; 0
    7156:	90 93 a9 07 	sts	0x07A9, r25
									(uint16_t)(5.436834E-5 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) +
									(uint16_t)(0.026689958 * dist[RAW][LEFT][BACK] * dist[RAW][LEFT][BACK]) -
									(uint16_t)(5.997356831 * dist[RAW][LEFT][BACK]) +
									571.55;
						}
						else dist[LIN][LEFT][BACK] = DIST_MAX_SRP_OLD;
    715a:	80 93 a8 07 	sts	0x07A8, r24
    715e:	15 de       	rcall	.-982    	; 0x6d8a <get_otherSens>
    7160:	09 de       	rcall	.-1006   	; 0x6d74 <check_tsl_state>
    7162:	80 91 c3 07 	lds	r24, 0x07C3

						get_otherSens();
    7166:	81 60       	ori	r24, 0x01	; 1
    7168:	80 93 c3 07 	sts	0x07C3, r24
						check_tsl_state();
    716c:	80 91 c2 07 	lds	r24, 0x07C2
						sensinfo.newDat.left = 1;
    7170:	81 ff       	sbrs	r24, 1
    7172:	02 c0       	rjmp	.+4      	; 0x7178 <get_analogSensors+0x3ce>
    7174:	13 98       	cbi	0x02, 3	; 2
    7176:	45 c2       	rjmp	.+1162   	; 0x7602 <get_analogSensors+0x858>
						
						if(sensinfo.request.right)
    7178:	82 ff       	sbrs	r24, 2
    717a:	47 c2       	rjmp	.+1166   	; 0x760a <get_analogSensors+0x860>
    717c:	13 98       	cbi	0x02, 3	; 2
    717e:	26 dc       	rcall	.-1972   	; 0x69cc <dist_setSensors.part.0>
								{
									SENS_ACTIVE_PORT |= (1<<SENS_LEFT_PIN);
								}
								else
								{
									SENS_ACTIVE_PORT &= ~(1<<SENS_LEFT_PIN);
    7180:	41 c2       	rjmp	.+1154   	; 0x7604 <get_analogSensors+0x85a>
    7182:	8f e0       	ldi	r24, 0x0F	; 15
						{
							dist_setSensors(LEFT, FALSE);
							dist_setSensors(RIGHT, TRUE);
							sm_anaSens = RIGHT;
						}
						else if(sensinfo.request.mid)
    7184:	d3 dd       	rcall	.-1114   	; 0x6d2c <get_adc>
    7186:	90 93 95 07 	sts	0x0795, r25
								{
									SENS_ACTIVE_PORT |= (1<<SENS_LEFT_PIN);
								}
								else
								{
									SENS_ACTIVE_PORT &= ~(1<<SENS_LEFT_PIN);
    718a:	80 93 94 07 	sts	0x0794, r24
    718e:	8a 36       	cpi	r24, 0x6A	; 106
							sm_anaSens = RIGHT;
						}
					break;
				
		case RIGHT:
						dist[RAW][FRONT][RIGHT] = get_adc(SHARP_FRONT_RIGHT);
    7190:	91 05       	cpc	r25, r1
    7192:	0c f4       	brge	.+2      	; 0x7196 <get_analogSensors+0x3ec>
    7194:	58 c0       	rjmp	.+176    	; 0x7246 <get_analogSensors+0x49c>
    7196:	bc 01       	movw	r22, r24
    7198:	88 27       	eor	r24, r24
    719a:	77 fd       	sbrc	r23, 7
    719c:	80 95       	com	r24
						if(dist[RAW][FRONT][RIGHT] > 105)
    719e:	98 2f       	mov	r25, r24
    71a0:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    71a4:	6b 01       	movw	r12, r22
						{
							dist[LIN][FRONT][RIGHT]	= (uint16_t)(1.9738502E-8 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    71a6:	7c 01       	movw	r14, r24
    71a8:	2e e0       	ldi	r18, 0x0E	; 14
    71aa:	32 e5       	ldi	r19, 0x52	; 82
    71ac:	4c e8       	ldi	r20, 0x8C	; 140
    71ae:	5c e3       	ldi	r21, 0x3C	; 60
    71b0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    71b4:	a7 01       	movw	r20, r14
    71b6:	96 01       	movw	r18, r12
																		(uint16_t)(2.997331E-5 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) +
																		(uint16_t)(0.0171289705 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    71b8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    71bc:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    71c0:	4b 01       	movw	r8, r22
    71c2:	5c 01       	movw	r10, r24
    71c4:	26 e7       	ldi	r18, 0x76	; 118
    71c6:	30 e0       	ldi	r19, 0x00	; 0
    71c8:	43 e9       	ldi	r20, 0x93	; 147
    71ca:	50 e4       	ldi	r21, 0x40	; 64
    71cc:	c7 01       	movw	r24, r14
    71ce:	b6 01       	movw	r22, r12
    71d0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
																		(uint16_t)(4.593806035 * dist[RAW][FRONT][RIGHT]) +
    71d4:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    71d8:	86 1a       	sub	r8, r22
    71da:	97 0a       	sbc	r9, r23
    71dc:	30 ef       	ldi	r19, 0xF0	; 240
    71de:	83 1a       	sub	r8, r19
    71e0:	3d ef       	ldi	r19, 0xFD	; 253
    71e2:	93 0a       	sbc	r9, r19
    71e4:	2d e6       	ldi	r18, 0x6D	; 109
    71e6:	3d e8       	ldi	r19, 0x8D	; 141
				
		case RIGHT:
						dist[RAW][FRONT][RIGHT] = get_adc(SHARP_FRONT_RIGHT);
						if(dist[RAW][FRONT][RIGHT] > 105)
						{
							dist[LIN][FRONT][RIGHT]	= (uint16_t)(1.9738502E-8 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    71e8:	49 ea       	ldi	r20, 0xA9	; 169
    71ea:	52 e3       	ldi	r21, 0x32	; 50
																		(uint16_t)(2.997331E-5 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) +
    71ec:	c7 01       	movw	r24, r14
    71ee:	b6 01       	movw	r22, r12
    71f0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
				
		case RIGHT:
						dist[RAW][FRONT][RIGHT] = get_adc(SHARP_FRONT_RIGHT);
						if(dist[RAW][FRONT][RIGHT] > 105)
						{
							dist[LIN][FRONT][RIGHT]	= (uint16_t)(1.9738502E-8 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    71f4:	a7 01       	movw	r20, r14
    71f6:	96 01       	movw	r18, r12
    71f8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    71fc:	a7 01       	movw	r20, r14
    71fe:	96 01       	movw	r18, r12
    7200:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7204:	a7 01       	movw	r20, r14
    7206:	96 01       	movw	r18, r12
    7208:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    720c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7210:	86 0e       	add	r8, r22
    7212:	97 1e       	adc	r9, r23
    7214:	21 e3       	ldi	r18, 0x31	; 49
    7216:	3f e6       	ldi	r19, 0x6F	; 111
    7218:	4b ef       	ldi	r20, 0xFB	; 251
    721a:	57 e3       	ldi	r21, 0x37	; 55
    721c:	c7 01       	movw	r24, r14
    721e:	b6 01       	movw	r22, r12
																		(uint16_t)(2.997331E-5 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) +
																		(uint16_t)(0.0171289705 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    7220:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
		case RIGHT:
						dist[RAW][FRONT][RIGHT] = get_adc(SHARP_FRONT_RIGHT);
						if(dist[RAW][FRONT][RIGHT] > 105)
						{
							dist[LIN][FRONT][RIGHT]	= (uint16_t)(1.9738502E-8 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
																		(uint16_t)(2.997331E-5 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) +
    7224:	a7 01       	movw	r20, r14
    7226:	96 01       	movw	r18, r12
    7228:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    722c:	a7 01       	movw	r20, r14
    722e:	96 01       	movw	r18, r12
    7230:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7234:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7238:	86 1a       	sub	r8, r22
    723a:	97 0a       	sbc	r9, r23
    723c:	90 92 b5 07 	sts	0x07B5, r9
    7240:	80 92 b4 07 	sts	0x07B4, r8
    7244:	06 c0       	rjmp	.+12     	; 0x7252 <get_analogSensors+0x4a8>
    7246:	88 ec       	ldi	r24, 0xC8	; 200
																		(uint16_t)(0.0171289705 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
																		(uint16_t)(4.593806035 * dist[RAW][FRONT][RIGHT]) +
    7248:	90 e0       	ldi	r25, 0x00	; 0
    724a:	90 93 b5 07 	sts	0x07B5, r25
				
		case RIGHT:
						dist[RAW][FRONT][RIGHT] = get_adc(SHARP_FRONT_RIGHT);
						if(dist[RAW][FRONT][RIGHT] > 105)
						{
							dist[LIN][FRONT][RIGHT]	= (uint16_t)(1.9738502E-8 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
    724e:	80 93 b4 07 	sts	0x07B4, r24
    7252:	81 e0       	ldi	r24, 0x01	; 1
    7254:	6b dd       	rcall	.-1322   	; 0x6d2c <get_adc>
																		(uint16_t)(2.997331E-5 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) +
																		(uint16_t)(0.0171289705 * dist[RAW][FRONT][RIGHT] * dist[RAW][FRONT][RIGHT]) -
																		(uint16_t)(4.593806035 * dist[RAW][FRONT][RIGHT]) +
																		528;
						}
						else dist[LIN][FRONT][RIGHT] = DIST_MAX_SRP_OLD;
    7256:	90 93 91 07 	sts	0x0791, r25
    725a:	80 93 90 07 	sts	0x0790, r24
    725e:	89 36       	cpi	r24, 0x69	; 105
    7260:	91 05       	cpc	r25, r1
						
						dist[RAW][RIGHT][BACK] = get_adc(SHARP_RIGHT_BACK);
    7262:	0c f4       	brge	.+2      	; 0x7266 <get_analogSensors+0x4bc>
    7264:	62 c0       	rjmp	.+196    	; 0x732a <get_analogSensors+0x580>
    7266:	bc 01       	movw	r22, r24
    7268:	88 27       	eor	r24, r24
    726a:	77 fd       	sbrc	r23, 7
    726c:	80 95       	com	r24
    726e:	98 2f       	mov	r25, r24
						if(dist[RAW][RIGHT][BACK] > 104)
    7270:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    7274:	6b 01       	movw	r12, r22
    7276:	7c 01       	movw	r14, r24
						{
							dist[LIN][RIGHT][BACK]	= 	(uint16_t)(2.1739906E-8 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
    7278:	2d ef       	ldi	r18, 0xFD	; 253
    727a:	37 e7       	ldi	r19, 0x77	; 119
    727c:	41 e9       	ldi	r20, 0x91	; 145
    727e:	5c e3       	ldi	r21, 0x3C	; 60
    7280:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7284:	a7 01       	movw	r20, r14
    7286:	96 01       	movw	r18, r12
    7288:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
																		(uint16_t)(3.207395E-5 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) +
																		(uint16_t)(0.0177574108 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
    728c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7290:	4b 01       	movw	r8, r22
    7292:	5c 01       	movw	r10, r24
    7294:	2c e2       	ldi	r18, 0x2C	; 44
    7296:	30 e9       	ldi	r19, 0x90	; 144
    7298:	43 e9       	ldi	r20, 0x93	; 147
    729a:	50 e4       	ldi	r21, 0x40	; 64
    729c:	c7 01       	movw	r24, r14
    729e:	b6 01       	movw	r22, r12
    72a0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72a4:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
																		(uint16_t)(4.611348918 * dist[RAW][RIGHT][BACK]) +
    72a8:	86 1a       	sub	r8, r22
    72aa:	97 0a       	sbc	r9, r23
    72ac:	2f e8       	ldi	r18, 0x8F	; 143
    72ae:	3e eb       	ldi	r19, 0xBE	; 190
    72b0:	4a eb       	ldi	r20, 0xBA	; 186
    72b2:	52 e3       	ldi	r21, 0x32	; 50
    72b4:	c7 01       	movw	r24, r14
    72b6:	b6 01       	movw	r22, r12
    72b8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
						else dist[LIN][FRONT][RIGHT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][RIGHT][BACK] = get_adc(SHARP_RIGHT_BACK);
						if(dist[RAW][RIGHT][BACK] > 104)
						{
							dist[LIN][RIGHT][BACK]	= 	(uint16_t)(2.1739906E-8 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
    72bc:	a7 01       	movw	r20, r14
    72be:	96 01       	movw	r18, r12
    72c0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72c4:	a7 01       	movw	r20, r14
    72c6:	96 01       	movw	r18, r12
    72c8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72cc:	a7 01       	movw	r20, r14
    72ce:	96 01       	movw	r18, r12
    72d0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72d4:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    72d8:	86 0e       	add	r8, r22
    72da:	97 1e       	adc	r9, r23
    72dc:	24 e2       	ldi	r18, 0x24	; 36
    72de:	37 e8       	ldi	r19, 0x87	; 135
    72e0:	46 e0       	ldi	r20, 0x06	; 6
    72e2:	58 e3       	ldi	r21, 0x38	; 56
    72e4:	c7 01       	movw	r24, r14
    72e6:	b6 01       	movw	r22, r12
    72e8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
																		(uint16_t)(3.207395E-5 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) +
    72ec:	a7 01       	movw	r20, r14
    72ee:	96 01       	movw	r18, r12
    72f0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72f4:	a7 01       	movw	r20, r14
    72f6:	96 01       	movw	r18, r12
    72f8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    72fc:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7300:	94 01       	movw	r18, r8
    7302:	26 1b       	sub	r18, r22
    7304:	37 0b       	sbc	r19, r23
    7306:	b9 01       	movw	r22, r18
    7308:	80 e0       	ldi	r24, 0x00	; 0
    730a:	90 e0       	ldi	r25, 0x00	; 0
    730c:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    7310:	23 e3       	ldi	r18, 0x33	; 51
																		(uint16_t)(0.0177574108 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
    7312:	33 ed       	ldi	r19, 0xD3	; 211
    7314:	40 e0       	ldi	r20, 0x00	; 0
    7316:	54 e4       	ldi	r21, 0x44	; 68
    7318:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
																		(uint16_t)(4.611348918 * dist[RAW][RIGHT][BACK]) +
    731c:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    7320:	70 93 b1 07 	sts	0x07B1, r23
    7324:	60 93 b0 07 	sts	0x07B0, r22
    7328:	06 c0       	rjmp	.+12     	; 0x7336 <get_analogSensors+0x58c>
    732a:	88 ec       	ldi	r24, 0xC8	; 200
    732c:	90 e0       	ldi	r25, 0x00	; 0
						else dist[LIN][FRONT][RIGHT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][RIGHT][BACK] = get_adc(SHARP_RIGHT_BACK);
						if(dist[RAW][RIGHT][BACK] > 104)
						{
							dist[LIN][RIGHT][BACK]	= 	(uint16_t)(2.1739906E-8 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
    732e:	90 93 b1 07 	sts	0x07B1, r25
    7332:	80 93 b0 07 	sts	0x07B0, r24
    7336:	83 e0       	ldi	r24, 0x03	; 3
    7338:	f9 dc       	rcall	.-1550   	; 0x6d2c <get_adc>
    733a:	90 93 9b 07 	sts	0x079B, r25
																		(uint16_t)(3.207395E-5 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) +
																		(uint16_t)(0.0177574108 * dist[RAW][RIGHT][BACK] * dist[RAW][RIGHT][BACK]) -
																		(uint16_t)(4.611348918 * dist[RAW][RIGHT][BACK]) +
																		515.3;
						}
						else dist[LIN][RIGHT][BACK] = DIST_MAX_SRP_OLD;
    733e:	80 93 9a 07 	sts	0x079A, r24
    7342:	85 36       	cpi	r24, 0x65	; 101
    7344:	91 05       	cpc	r25, r1
    7346:	0c f4       	brge	.+2      	; 0x734a <get_analogSensors+0x5a0>
						
						dist[RAW][BACK][LEFT] = get_adc(SHARP_BACK_LEFT);
    7348:	62 c0       	rjmp	.+196    	; 0x740e <get_analogSensors+0x664>
    734a:	bc 01       	movw	r22, r24
    734c:	88 27       	eor	r24, r24
    734e:	77 fd       	sbrc	r23, 7
    7350:	80 95       	com	r24
    7352:	98 2f       	mov	r25, r24
    7354:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
						if(dist[RAW][BACK][LEFT] > 100)
    7358:	6b 01       	movw	r12, r22
    735a:	7c 01       	movw	r14, r24
    735c:	29 ec       	ldi	r18, 0xC9	; 201
						{
							dist[LIN][BACK][LEFT]	= 	(uint16_t)(2.3960353E-8 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
    735e:	37 ef       	ldi	r19, 0xF7	; 247
    7360:	47 e9       	ldi	r20, 0x97	; 151
    7362:	5c e3       	ldi	r21, 0x3C	; 60
    7364:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7368:	a7 01       	movw	r20, r14
    736a:	96 01       	movw	r18, r12
    736c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
																		(uint16_t)(3.446703E-5 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) +
																		(uint16_t)(0.0185507698 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
    7370:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7374:	4b 01       	movw	r8, r22
    7376:	5c 01       	movw	r10, r24
    7378:	24 e1       	ldi	r18, 0x14	; 20
    737a:	31 ed       	ldi	r19, 0xD1	; 209
    737c:	45 e9       	ldi	r20, 0x95	; 149
    737e:	50 e4       	ldi	r21, 0x40	; 64
    7380:	c7 01       	movw	r24, r14
    7382:	b6 01       	movw	r22, r12
    7384:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7388:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
																		(uint16_t)(4.681772179 * dist[RAW][BACK][LEFT]) +
    738c:	86 1a       	sub	r8, r22
    738e:	97 0a       	sbc	r9, r23
    7390:	20 e6       	ldi	r18, 0x60	; 96
    7392:	31 ed       	ldi	r19, 0xD1	; 209
    7394:	4d ec       	ldi	r20, 0xCD	; 205
    7396:	52 e3       	ldi	r21, 0x32	; 50
    7398:	c7 01       	movw	r24, r14
    739a:	b6 01       	movw	r22, r12
    739c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
						else dist[LIN][RIGHT][BACK] = DIST_MAX_SRP_OLD;
						
						dist[RAW][BACK][LEFT] = get_adc(SHARP_BACK_LEFT);
						if(dist[RAW][BACK][LEFT] > 100)
						{
							dist[LIN][BACK][LEFT]	= 	(uint16_t)(2.3960353E-8 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
    73a0:	a7 01       	movw	r20, r14
    73a2:	96 01       	movw	r18, r12
    73a4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    73a8:	a7 01       	movw	r20, r14
    73aa:	96 01       	movw	r18, r12
    73ac:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    73b0:	a7 01       	movw	r20, r14
    73b2:	96 01       	movw	r18, r12
    73b4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    73b8:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    73bc:	86 0e       	add	r8, r22
    73be:	97 1e       	adc	r9, r23
    73c0:	21 eb       	ldi	r18, 0xB1	; 177
    73c2:	30 e9       	ldi	r19, 0x90	; 144
    73c4:	40 e1       	ldi	r20, 0x10	; 16
    73c6:	58 e3       	ldi	r21, 0x38	; 56
    73c8:	c7 01       	movw	r24, r14
    73ca:	b6 01       	movw	r22, r12
    73cc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
																		(uint16_t)(3.446703E-5 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) +
    73d0:	a7 01       	movw	r20, r14
    73d2:	96 01       	movw	r18, r12
    73d4:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    73d8:	a7 01       	movw	r20, r14
    73da:	96 01       	movw	r18, r12
    73dc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    73e0:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    73e4:	94 01       	movw	r18, r8
    73e6:	26 1b       	sub	r18, r22
    73e8:	37 0b       	sbc	r19, r23
    73ea:	b9 01       	movw	r22, r18
    73ec:	80 e0       	ldi	r24, 0x00	; 0
    73ee:	90 e0       	ldi	r25, 0x00	; 0
    73f0:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    73f4:	2c e5       	ldi	r18, 0x5C	; 92
    73f6:	3f ea       	ldi	r19, 0xAF	; 175
																		(uint16_t)(0.0185507698 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
    73f8:	4f ef       	ldi	r20, 0xFF	; 255
    73fa:	53 e4       	ldi	r21, 0x43	; 67
    73fc:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
																		(uint16_t)(4.681772179 * dist[RAW][BACK][LEFT]) +
    7400:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    7404:	70 93 bb 07 	sts	0x07BB, r23
    7408:	60 93 ba 07 	sts	0x07BA, r22
    740c:	06 c0       	rjmp	.+12     	; 0x741a <get_analogSensors+0x670>
    740e:	88 ec       	ldi	r24, 0xC8	; 200
    7410:	90 e0       	ldi	r25, 0x00	; 0
    7412:	90 93 bb 07 	sts	0x07BB, r25
						else dist[LIN][RIGHT][BACK] = DIST_MAX_SRP_OLD;
						
						dist[RAW][BACK][LEFT] = get_adc(SHARP_BACK_LEFT);
						if(dist[RAW][BACK][LEFT] > 100)
						{
							dist[LIN][BACK][LEFT]	= 	(uint16_t)(2.3960353E-8 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
    7416:	80 93 ba 07 	sts	0x07BA, r24
    741a:	8b e0       	ldi	r24, 0x0B	; 11
    741c:	87 dc       	rcall	.-1778   	; 0x6d2c <get_adc>
    741e:	90 93 87 07 	sts	0x0787, r25
																		(uint16_t)(3.446703E-5 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) +
																		(uint16_t)(0.0185507698 * dist[RAW][BACK][LEFT] * dist[RAW][BACK][LEFT]) -
																		(uint16_t)(4.681772179 * dist[RAW][BACK][LEFT]) +
																		511.37;
						}
						else dist[LIN][BACK][LEFT] = DIST_MAX_SRP_OLD;
    7422:	80 93 86 07 	sts	0x0786, r24
    7426:	81 36       	cpi	r24, 0x61	; 97
    7428:	91 05       	cpc	r25, r1
    742a:	0c f4       	brge	.+2      	; 0x742e <get_analogSensors+0x684>
    742c:	62 c0       	rjmp	.+196    	; 0x74f2 <get_analogSensors+0x748>
						
						dist[RAW][LEFT][FRONT] = get_adc(SHARP_LEFT_FRONT);
    742e:	bc 01       	movw	r22, r24
    7430:	88 27       	eor	r24, r24
    7432:	77 fd       	sbrc	r23, 7
    7434:	80 95       	com	r24
    7436:	98 2f       	mov	r25, r24
    7438:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
						if(dist[RAW][LEFT][FRONT] > 96)
    743c:	6b 01       	movw	r12, r22
    743e:	7c 01       	movw	r14, r24
    7440:	2d ee       	ldi	r18, 0xED	; 237
    7442:	3a e0       	ldi	r19, 0x0A	; 10
						{
							dist[LIN][LEFT][FRONT]	= 	(uint16_t)(2.5373381E-8 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
    7444:	4c e9       	ldi	r20, 0x9C	; 156
    7446:	5c e3       	ldi	r21, 0x3C	; 60
    7448:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    744c:	a7 01       	movw	r20, r14
    744e:	96 01       	movw	r18, r12
    7450:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7454:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
									(uint16_t)(3.589565E-5 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) +
									(uint16_t)(0.0190481789 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
    7458:	4b 01       	movw	r8, r22
    745a:	5c 01       	movw	r10, r24
    745c:	2a ef       	ldi	r18, 0xFA	; 250
    745e:	36 e5       	ldi	r19, 0x56	; 86
    7460:	47 e9       	ldi	r20, 0x97	; 151
    7462:	50 e4       	ldi	r21, 0x40	; 64
    7464:	c7 01       	movw	r24, r14
    7466:	b6 01       	movw	r22, r12
    7468:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    746c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    7470:	86 1a       	sub	r8, r22
									(uint16_t)(4.729367296 * dist[RAW][LEFT][FRONT]) +
    7472:	97 0a       	sbc	r9, r23
    7474:	28 ea       	ldi	r18, 0xA8	; 168
    7476:	34 ef       	ldi	r19, 0xF4	; 244
    7478:	49 ed       	ldi	r20, 0xD9	; 217
    747a:	52 e3       	ldi	r21, 0x32	; 50
    747c:	c7 01       	movw	r24, r14
    747e:	b6 01       	movw	r22, r12
    7480:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7484:	a7 01       	movw	r20, r14
						else dist[LIN][BACK][LEFT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][LEFT][FRONT] = get_adc(SHARP_LEFT_FRONT);
						if(dist[RAW][LEFT][FRONT] > 96)
						{
							dist[LIN][LEFT][FRONT]	= 	(uint16_t)(2.5373381E-8 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
    7486:	96 01       	movw	r18, r12
    7488:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    748c:	a7 01       	movw	r20, r14
    748e:	96 01       	movw	r18, r12
    7490:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    7494:	a7 01       	movw	r20, r14
    7496:	96 01       	movw	r18, r12
    7498:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    749c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    74a0:	86 0e       	add	r8, r22
    74a2:	97 1e       	adc	r9, r23
    74a4:	29 ea       	ldi	r18, 0xA9	; 169
    74a6:	3e e8       	ldi	r19, 0x8E	; 142
    74a8:	46 e1       	ldi	r20, 0x16	; 22
    74aa:	58 e3       	ldi	r21, 0x38	; 56
    74ac:	c7 01       	movw	r24, r14
    74ae:	b6 01       	movw	r22, r12
    74b0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    74b4:	a7 01       	movw	r20, r14
									(uint16_t)(3.589565E-5 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) +
    74b6:	96 01       	movw	r18, r12
    74b8:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    74bc:	a7 01       	movw	r20, r14
    74be:	96 01       	movw	r18, r12
    74c0:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    74c4:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    74c8:	94 01       	movw	r18, r8
    74ca:	26 1b       	sub	r18, r22
    74cc:	37 0b       	sbc	r19, r23
    74ce:	b9 01       	movw	r22, r18
    74d0:	80 e0       	ldi	r24, 0x00	; 0
    74d2:	90 e0       	ldi	r25, 0x00	; 0
    74d4:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    74d8:	2d ec       	ldi	r18, 0xCD	; 205
    74da:	3c e6       	ldi	r19, 0x6C	; 108
    74dc:	4c ef       	ldi	r20, 0xFC	; 252
									(uint16_t)(0.0190481789 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
    74de:	53 e4       	ldi	r21, 0x43	; 67
    74e0:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    74e4:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
									(uint16_t)(4.729367296 * dist[RAW][LEFT][FRONT]) +
    74e8:	70 93 a7 07 	sts	0x07A7, r23
    74ec:	60 93 a6 07 	sts	0x07A6, r22
    74f0:	06 c0       	rjmp	.+12     	; 0x74fe <get_analogSensors+0x754>
    74f2:	88 ec       	ldi	r24, 0xC8	; 200
    74f4:	90 e0       	ldi	r25, 0x00	; 0
    74f6:	90 93 a7 07 	sts	0x07A7, r25
						else dist[LIN][BACK][LEFT] = DIST_MAX_SRP_OLD;
						
						dist[RAW][LEFT][FRONT] = get_adc(SHARP_LEFT_FRONT);
						if(dist[RAW][LEFT][FRONT] > 96)
						{
							dist[LIN][LEFT][FRONT]	= 	(uint16_t)(2.5373381E-8 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
    74fa:	80 93 a6 07 	sts	0x07A6, r24
    74fe:	45 dc       	rcall	.-1910   	; 0x6d8a <get_otherSens>
    7500:	39 dc       	rcall	.-1934   	; 0x6d74 <check_tsl_state>
    7502:	80 91 c3 07 	lds	r24, 0x07C3
    7506:	82 60       	ori	r24, 0x02	; 2
									(uint16_t)(3.589565E-5 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) +
									(uint16_t)(0.0190481789 * dist[RAW][LEFT][FRONT] * dist[RAW][LEFT][FRONT]) -
									(uint16_t)(4.729367296 * dist[RAW][LEFT][FRONT]) +
									504.85;
						}
						else dist[LIN][LEFT][FRONT] = DIST_MAX_SRP_OLD;
    7508:	80 93 c3 07 	sts	0x07C3, r24
    750c:	80 91 c2 07 	lds	r24, 0x07C2
    7510:	82 ff       	sbrs	r24, 2
    7512:	04 c0       	rjmp	.+8      	; 0x751c <get_analogSensors+0x772>
						
						get_otherSens();
    7514:	14 98       	cbi	0x02, 4	; 2
    7516:	5a da       	rcall	.-2892   	; 0x69cc <dist_setSensors.part.0>
						check_tsl_state();
    7518:	82 e0       	ldi	r24, 0x02	; 2
    751a:	75 c0       	rjmp	.+234    	; 0x7606 <get_analogSensors+0x85c>
						sensinfo.newDat.right = 1;
    751c:	80 ff       	sbrs	r24, 0
    751e:	75 c0       	rjmp	.+234    	; 0x760a <get_analogSensors+0x860>
    7520:	14 98       	cbi	0x02, 4	; 2
    7522:	68 c0       	rjmp	.+208    	; 0x75f4 <get_analogSensors+0x84a>
    7524:	84 e0       	ldi	r24, 0x04	; 4
							
						if(sensinfo.request.mid)
    7526:	02 dc       	rcall	.-2044   	; 0x6d2c <get_adc>
    7528:	90 93 97 07 	sts	0x0797, r25
    752c:	80 93 96 07 	sts	0x0796, r24
								{
									SENS_ACTIVE_PORT |= (1<<SENS_RIGHT_PIN);
								}
								else
								{
									SENS_ACTIVE_PORT &= ~(1<<SENS_RIGHT_PIN);
    7530:	8d 34       	cpi	r24, 0x4D	; 77
    7532:	91 05       	cpc	r25, r1
							
						if(sensinfo.request.mid)
						{
							dist_setSensors(RIGHT, FALSE);
							dist_setSensors(MID, TRUE);
							sm_anaSens = MID;
    7534:	04 f1       	brlt	.+64     	; 0x7576 <get_analogSensors+0x7cc>
    7536:	bc 01       	movw	r22, r24
						}
						else if(sensinfo.request.left)
    7538:	88 27       	eor	r24, r24
    753a:	77 fd       	sbrc	r23, 7
								{
									SENS_ACTIVE_PORT |= (1<<SENS_RIGHT_PIN);
								}
								else
								{
									SENS_ACTIVE_PORT &= ~(1<<SENS_RIGHT_PIN);
    753c:	80 95       	com	r24
    753e:	98 2f       	mov	r25, r24
						}
					
						break;
					
		case MID:
						dist[RAW][FRONT][FRONT] = get_adc(SHARP_FRONT_FRONT);
    7540:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    7544:	26 e3       	ldi	r18, 0x36	; 54
    7546:	3d ee       	ldi	r19, 0xED	; 237
    7548:	43 eb       	ldi	r20, 0xB3	; 179
    754a:	5f eb       	ldi	r21, 0xBF	; 191
    754c:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
						if(dist[RAW][FRONT][FRONT] > 76)
    7550:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
						{
							dist[LIN][FRONT][FRONT]	= (uint16_t)(-1.40567659875 * dist[RAW][FRONT][FRONT]) +
    7554:	80 e0       	ldi	r24, 0x00	; 0
    7556:	90 e0       	ldi	r25, 0x00	; 0
    7558:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    755c:	27 e3       	ldi	r18, 0x37	; 55
    755e:	39 ec       	ldi	r19, 0xC9	; 201
    7560:	47 e1       	ldi	r20, 0x17	; 23
    7562:	54 e4       	ldi	r21, 0x44	; 68
    7564:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    7568:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    756c:	70 93 b7 07 	sts	0x07B7, r23
    7570:	60 93 b6 07 	sts	0x07B6, r22
    7574:	06 c0       	rjmp	.+12     	; 0x7582 <get_analogSensors+0x7d8>
    7576:	80 e9       	ldi	r24, 0x90	; 144
    7578:	91 e0       	ldi	r25, 0x01	; 1
    757a:	90 93 b7 07 	sts	0x07B7, r25
    757e:	80 93 b6 07 	sts	0x07B6, r24
    7582:	85 e0       	ldi	r24, 0x05	; 5
    7584:	d3 db       	rcall	.-2138   	; 0x6d2c <get_adc>
    7586:	90 93 a1 07 	sts	0x07A1, r25
    758a:	80 93 a0 07 	sts	0x07A0, r24
    758e:	8a 36       	cpi	r24, 0x6A	; 106
    7590:	91 05       	cpc	r25, r1
    7592:	04 f1       	brlt	.+64     	; 0x75d4 <get_analogSensors+0x82a>
																		607.144;
						}
						else dist[LIN][FRONT][FRONT] = DIST_MAX_SRP_NEW;
    7594:	bc 01       	movw	r22, r24
    7596:	88 27       	eor	r24, r24
    7598:	77 fd       	sbrc	r23, 7
    759a:	80 95       	com	r24
    759c:	98 2f       	mov	r25, r24
    759e:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
						
						dist[RAW][BACK][BACK] = get_adc(SHARP_BACK_BACK);
    75a2:	22 e1       	ldi	r18, 0x12	; 18
    75a4:	3b ef       	ldi	r19, 0xFB	; 251
    75a6:	41 eb       	ldi	r20, 0xB1	; 177
    75a8:	5f eb       	ldi	r21, 0xBF	; 191
    75aa:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
						if(dist[RAW][BACK][BACK] > 105)
    75ae:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    75b2:	80 e0       	ldi	r24, 0x00	; 0
						{
							dist[LIN][BACK][BACK]	= (uint16_t)(-1.390474576 * dist[RAW][BACK][BACK]) +
    75b4:	90 e0       	ldi	r25, 0x00	; 0
    75b6:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    75ba:	20 ef       	ldi	r18, 0xF0	; 240
    75bc:	37 eb       	ldi	r19, 0xB7	; 183
    75be:	45 e2       	ldi	r20, 0x25	; 37
    75c0:	54 e4       	ldi	r21, 0x44	; 68
    75c2:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    75c6:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    75ca:	70 93 c1 07 	sts	0x07C1, r23
    75ce:	60 93 c0 07 	sts	0x07C0, r22
    75d2:	06 c0       	rjmp	.+12     	; 0x75e0 <get_analogSensors+0x836>
    75d4:	80 e9       	ldi	r24, 0x90	; 144
    75d6:	91 e0       	ldi	r25, 0x01	; 1
    75d8:	90 93 c1 07 	sts	0x07C1, r25
    75dc:	80 93 c0 07 	sts	0x07C0, r24
    75e0:	80 91 c3 07 	lds	r24, 0x07C3
    75e4:	84 60       	ori	r24, 0x04	; 4
    75e6:	80 93 c3 07 	sts	0x07C3, r24
    75ea:	80 91 c2 07 	lds	r24, 0x07C2
    75ee:	80 ff       	sbrs	r24, 0
    75f0:	05 c0       	rjmp	.+10     	; 0x75fc <get_analogSensors+0x852>
    75f2:	12 98       	cbi	0x02, 2	; 2
																		662.874;
						}
						else dist[LIN][BACK][BACK] = DIST_MAX_SRP_NEW;
    75f4:	13 9a       	sbi	0x02, 3	; 2
    75f6:	10 92 b5 05 	sts	0x05B5, r1
    75fa:	07 c0       	rjmp	.+14     	; 0x760a <get_analogSensors+0x860>
    75fc:	81 ff       	sbrs	r24, 1
    75fe:	05 c0       	rjmp	.+10     	; 0x760a <get_analogSensors+0x860>

						//check_tsl_state();

						sensinfo.newDat.mid = 1;
    7600:	12 98       	cbi	0x02, 2	; 2
    7602:	14 9a       	sbi	0x02, 4	; 2
    7604:	81 e0       	ldi	r24, 0x01	; 1
    7606:	80 93 b5 05 	sts	0x05B5, r24
						
						if(sensinfo.request.left)
    760a:	bf db       	rcall	.-2178   	; 0x6d8a <get_otherSens>
    760c:	cb db       	rcall	.-2154   	; 0x6da4 <get_groundSens>
    760e:	ff 90       	pop	r15
    7610:	ef 90       	pop	r14
								{
									SENS_ACTIVE_PORT |= (1<<SENS_MID_PIN);
								}
								else
								{
									SENS_ACTIVE_PORT &= ~(1<<SENS_MID_PIN);
    7612:	df 90       	pop	r13
{
	switch(block)
	{
		case LEFT:	if(set)
								{
									SENS_ACTIVE_PORT |= (1<<SENS_LEFT_PIN);
    7614:	cf 90       	pop	r12
						
						if(sensinfo.request.left)
						{
							dist_setSensors(MID, FALSE);
							dist_setSensors(LEFT, TRUE);
							sm_anaSens = LEFT;
    7616:	bf 90       	pop	r11
    7618:	af 90       	pop	r10
    761a:	9f 90       	pop	r9
						}
						else if(sensinfo.request.right)
    761c:	8f 90       	pop	r8
    761e:	08 95       	ret

00007620 <getIR>:
};

struct MLX_INFO mlx90614[NUMBER_OF_MLX];

uint8_t getIR(void)
{
    7620:	a0 e0       	ldi	r26, 0x00	; 0
    7622:	b0 e0       	ldi	r27, 0x00	; 0
    7624:	e6 e1       	ldi	r30, 0x16	; 22
    7626:	fb e3       	ldi	r31, 0x3B	; 59
    7628:	0c 94 a4 6b 	jmp	0xd748	; 0xd748 <__prologue_saves__+0x12>
    762c:	04 e0       	ldi	r16, 0x04	; 4
    762e:	18 e0       	ldi	r17, 0x08	; 8
    7630:	c0 e0       	ldi	r28, 0x00	; 0
    7632:	d0 e0       	ldi	r29, 0x00	; 0
	uint16_t tempdata = 0;
	uint8_t returnvar = 0;
    7634:	d1 2c       	mov	r13, r1
			// This masks off the error bit of the high byte, then moves it left 8 bits and adds the low byte.
			tempdata = (((i2cbuf[1] & 0x007F) << 8) + i2cbuf[0]);
			tempdata = ((tempdata * 2)-1);
			mlx90614[i].is = (tempdata - 27315);
		}
		else returnvar |= (1<<i);
    7636:	ee 24       	eor	r14, r14
    7638:	e3 94       	inc	r14
    763a:	f1 2c       	mov	r15, r1
	uint16_t tempdata = 0;
	uint8_t returnvar = 0;
	
	for(uint8_t i = 0; i < NUMBER_OF_MLX; i++)
	{
		if((i2c_start(pgm_read_byte(&mlx90614_i2c_addresses[i])) == 0) &&
    763c:	cc 2e       	mov	r12, r28
    763e:	fe 01       	movw	r30, r28
    7640:	ea 58       	subi	r30, 0x8A	; 138
    7642:	f7 4d       	sbci	r31, 0xD7	; 215
    7644:	b4 90       	lpm	r11, Z
    7646:	8b 2d       	mov	r24, r11
    7648:	0e 94 6d 5d 	call	0xbada	; 0xbada <i2c_start>
    764c:	81 11       	cpse	r24, r1
    764e:	37 c0       	rjmp	.+110    	; 0x76be <getIR+0x9e>
		   (i2c_write(I2C_REG_MLX90614) == 0) &&
    7650:	87 e0       	ldi	r24, 0x07	; 7
    7652:	0e 94 e5 5d 	call	0xbbca	; 0xbbca <i2c_write>
	uint16_t tempdata = 0;
	uint8_t returnvar = 0;
	
	for(uint8_t i = 0; i < NUMBER_OF_MLX; i++)
	{
		if((i2c_start(pgm_read_byte(&mlx90614_i2c_addresses[i])) == 0) &&
    7656:	81 11       	cpse	r24, r1
    7658:	32 c0       	rjmp	.+100    	; 0x76be <getIR+0x9e>
		   (i2c_write(I2C_REG_MLX90614) == 0) &&
		   (i2c_rep_start(pgm_read_byte(&mlx90614_i2c_addresses[i]) + I2C_READ) == 0))
    765a:	81 e0       	ldi	r24, 0x01	; 1
    765c:	8b 0d       	add	r24, r11
    765e:	0e 94 ca 5d 	call	0xbb94	; 0xbb94 <i2c_rep_start>
	uint8_t returnvar = 0;
	
	for(uint8_t i = 0; i < NUMBER_OF_MLX; i++)
	{
		if((i2c_start(pgm_read_byte(&mlx90614_i2c_addresses[i])) == 0) &&
		   (i2c_write(I2C_REG_MLX90614) == 0) &&
    7662:	81 11       	cpse	r24, r1
    7664:	2c c0       	rjmp	.+88     	; 0x76be <getIR+0x9e>
		   (i2c_rep_start(pgm_read_byte(&mlx90614_i2c_addresses[i]) + I2C_READ) == 0))
		{
			for(uint8_t i = 0; i<2; i++)
				i2cbuf[i] = i2c_readAck();
    7666:	0e 94 12 5e 	call	0xbc24	; 0xbc24 <i2c_readAck>
    766a:	80 93 0c 08 	sts	0x080C, r24
    766e:	0e 94 12 5e 	call	0xbc24	; 0xbc24 <i2c_readAck>
    7672:	80 93 0d 08 	sts	0x080D, r24
			i2cbuf[2] = i2c_readNak();
    7676:	0e 94 39 5e 	call	0xbc72	; 0xbc72 <i2c_readNak>
    767a:	80 93 0e 08 	sts	0x080E, r24

			if(i2c_stop() != 0)
    767e:	0e 94 cc 5d 	call	0xbb98	; 0xbb98 <i2c_stop>
				returnvar |= (1<<i);
    7682:	97 01       	movw	r18, r14
    7684:	0c 2e       	mov	r0, r28
    7686:	01 c0       	rjmp	.+2      	; 0x768a <getIR+0x6a>
    7688:	22 0f       	add	r18, r18
    768a:	0a 94       	dec	r0
    768c:	ea f7       	brpl	.-6      	; 0x7688 <getIR+0x68>
		{
			for(uint8_t i = 0; i<2; i++)
				i2cbuf[i] = i2c_readAck();
			i2cbuf[2] = i2c_readNak();

			if(i2c_stop() != 0)
    768e:	88 23       	and	r24, r24
    7690:	11 f0       	breq	.+4      	; 0x7696 <getIR+0x76>
				returnvar |= (1<<i);
    7692:	d2 2a       	or	r13, r18
    7694:	02 c0       	rjmp	.+4      	; 0x769a <getIR+0x7a>
			else
				returnvar &= ~(1<<i);
    7696:	20 95       	com	r18
    7698:	d2 22       	and	r13, r18

			// This masks off the error bit of the high byte, then moves it left 8 bits and adds the low byte.
			tempdata = (((i2cbuf[1] & 0x007F) << 8) + i2cbuf[0]);
    769a:	20 91 0d 08 	lds	r18, 0x080D
    769e:	2f 77       	andi	r18, 0x7F	; 127
    76a0:	30 e0       	ldi	r19, 0x00	; 0
    76a2:	32 2f       	mov	r19, r18
    76a4:	22 27       	eor	r18, r18
    76a6:	80 91 0c 08 	lds	r24, 0x080C
    76aa:	28 0f       	add	r18, r24
    76ac:	31 1d       	adc	r19, r1
			tempdata = ((tempdata * 2)-1);
    76ae:	22 0f       	add	r18, r18
    76b0:	33 1f       	adc	r19, r19
			mlx90614[i].is = (tempdata - 27315);
    76b2:	24 5b       	subi	r18, 0xB4	; 180
    76b4:	3a 46       	sbci	r19, 0x6A	; 106
    76b6:	f8 01       	movw	r30, r16
    76b8:	31 83       	std	Z+1, r19	; 0x01
    76ba:	20 83       	st	Z, r18
    76bc:	07 c0       	rjmp	.+14     	; 0x76cc <getIR+0xac>
		}
		else returnvar |= (1<<i);
    76be:	97 01       	movw	r18, r14
    76c0:	0c 2c       	mov	r0, r12
    76c2:	01 c0       	rjmp	.+2      	; 0x76c6 <getIR+0xa6>
    76c4:	22 0f       	add	r18, r18
    76c6:	0a 94       	dec	r0
    76c8:	ea f7       	brpl	.-6      	; 0x76c4 <getIR+0xa4>
    76ca:	d2 2a       	or	r13, r18
    76cc:	21 96       	adiw	r28, 0x01	; 1
    76ce:	0c 5f       	subi	r16, 0xFC	; 252
    76d0:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t getIR(void)
{
	uint16_t tempdata = 0;
	uint8_t returnvar = 0;
	
	for(uint8_t i = 0; i < NUMBER_OF_MLX; i++)
    76d2:	c2 30       	cpi	r28, 0x02	; 2
    76d4:	d1 05       	cpc	r29, r1
    76d6:	09 f0       	breq	.+2      	; 0x76da <getIR+0xba>
    76d8:	b1 cf       	rjmp	.-158    	; 0x763c <getIR+0x1c>
		}
		else returnvar |= (1<<i);
	}

	return returnvar;
}
    76da:	8d 2d       	mov	r24, r13
    76dc:	cd b7       	in	r28, 0x3d	; 61
    76de:	de b7       	in	r29, 0x3e	; 62
    76e0:	e9 e0       	ldi	r30, 0x09	; 9
    76e2:	0c 94 c0 6b 	jmp	0xd780	; 0xd780 <__epilogue_restores__+0x12>

000076e6 <srf_writeByte>:
	srf_writeByte(I2C_SRF10_L, 2, 6); //Maximum reach (Register 2); 0..16: 43mm + 6*43mm = 301mm
	srf_writeByte(I2C_SRF10_R, 2, 6); //"
}

uint8_t srf_writeByte(uint8_t adr, uint8_t reg, uint8_t val)
{
    76e6:	a1 e0       	ldi	r26, 0x01	; 1
    76e8:	b0 e0       	ldi	r27, 0x00	; 0
    76ea:	e9 e7       	ldi	r30, 0x79	; 121
    76ec:	fb e3       	ldi	r31, 0x3B	; 59
    76ee:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
    76f2:	14 2f       	mov	r17, r20
	uint8_t returnvar;

	if((i2c_start(adr+I2C_WRITE) == 0) &&
    76f4:	69 83       	std	Y+1, r22	; 0x01
    76f6:	0e 94 6d 5d 	call	0xbada	; 0xbada <i2c_start>
    76fa:	69 81       	ldd	r22, Y+1	; 0x01
    76fc:	81 11       	cpse	r24, r1
    76fe:	0e c0       	rjmp	.+28     	; 0x771c <srf_writeByte+0x36>
	   (i2c_write(reg) == 0) &&
    7700:	86 2f       	mov	r24, r22
    7702:	0e 94 e5 5d 	call	0xbbca	; 0xbbca <i2c_write>

uint8_t srf_writeByte(uint8_t adr, uint8_t reg, uint8_t val)
{
	uint8_t returnvar;

	if((i2c_start(adr+I2C_WRITE) == 0) &&
    7706:	81 11       	cpse	r24, r1
    7708:	09 c0       	rjmp	.+18     	; 0x771c <srf_writeByte+0x36>
	   (i2c_write(reg) == 0) &&
	   (i2c_write(val) == 0) &&
    770a:	81 2f       	mov	r24, r17
    770c:	0e 94 e5 5d 	call	0xbbca	; 0xbbca <i2c_write>
uint8_t srf_writeByte(uint8_t adr, uint8_t reg, uint8_t val)
{
	uint8_t returnvar;

	if((i2c_start(adr+I2C_WRITE) == 0) &&
	   (i2c_write(reg) == 0) &&
    7710:	81 11       	cpse	r24, r1
    7712:	04 c0       	rjmp	.+8      	; 0x771c <srf_writeByte+0x36>
	   (i2c_write(val) == 0) &&
	   (i2c_stop() == 0))
    7714:	0e 94 cc 5d 	call	0xbb98	; 0xbb98 <i2c_stop>
{
	uint8_t returnvar;

	if((i2c_start(adr+I2C_WRITE) == 0) &&
	   (i2c_write(reg) == 0) &&
	   (i2c_write(val) == 0) &&
    7718:	91 e0       	ldi	r25, 0x01	; 1
    771a:	81 11       	cpse	r24, r1
    771c:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
		returnvar = 0;

	return returnvar;
}
    771e:	89 2f       	mov	r24, r25
    7720:	21 96       	adiw	r28, 0x01	; 1
    7722:	e3 e0       	ldi	r30, 0x03	; 3
    7724:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

00007728 <init_srf10>:
	//I2C_SRF10_F
};

void init_srf10(void)
{
	srf_writeByte(I2C_SRF10_L, 1, 50); //Reinforcement (Register 1); 0..255 (max. reinforcement)
    7728:	42 e3       	ldi	r20, 0x32	; 50
    772a:	61 e0       	ldi	r22, 0x01	; 1
    772c:	82 ef       	ldi	r24, 0xF2	; 242
    772e:	db df       	rcall	.-74     	; 0x76e6 <srf_writeByte>
    7730:	42 e3       	ldi	r20, 0x32	; 50
	srf_writeByte(I2C_SRF10_R, 1, 50); //"
    7732:	61 e0       	ldi	r22, 0x01	; 1
    7734:	84 ee       	ldi	r24, 0xE4	; 228
    7736:	d7 df       	rcall	.-82     	; 0x76e6 <srf_writeByte>
    7738:	46 e0       	ldi	r20, 0x06	; 6
    773a:	62 e0       	ldi	r22, 0x02	; 2

	srf_writeByte(I2C_SRF10_L, 2, 6); //Maximum reach (Register 2); 0..16: 43mm + 6*43mm = 301mm
    773c:	82 ef       	ldi	r24, 0xF2	; 242
    773e:	d3 df       	rcall	.-90     	; 0x76e6 <srf_writeByte>
    7740:	46 e0       	ldi	r20, 0x06	; 6
    7742:	62 e0       	ldi	r22, 0x02	; 2
    7744:	84 ee       	ldi	r24, 0xE4	; 228
	srf_writeByte(I2C_SRF10_R, 2, 6); //"
    7746:	cf cf       	rjmp	.-98     	; 0x76e6 <srf_writeByte>

00007748 <maze_solveRoutes>:

void maze_solveRoutes(void) //called from main-loop (time-intensive route calculations)
{
	int16_t tileRes = 0;
	
	switch(routeRequest)
    7748:	80 91 c6 05 	lds	r24, 0x05C6
    774c:	82 30       	cpi	r24, 0x02	; 2
    774e:	09 f1       	breq	.+66     	; 0x7792 <maze_solveRoutes+0x4a>
    7750:	30 f4       	brcc	.+12     	; 0x775e <maze_solveRoutes+0x16>
    7752:	88 23       	and	r24, r24
    7754:	09 f4       	brne	.+2      	; 0x7758 <maze_solveRoutes+0x10>
    7756:	4f c0       	rjmp	.+158    	; 0x77f6 <maze_solveRoutes+0xae>
    7758:	81 30       	cpi	r24, 0x01	; 1
    775a:	21 f0       	breq	.+8      	; 0x7764 <maze_solveRoutes+0x1c>
    775c:	31 c0       	rjmp	.+98     	; 0x77c0 <maze_solveRoutes+0x78>
    775e:	89 30       	cpi	r24, 0x09	; 9
    7760:	78 f5       	brcc	.+94     	; 0x77c0 <maze_solveRoutes+0x78>
    7762:	08 95       	ret
	{
		case RR_WAIT:					break; //Has to be checked in maze_solve().
		
		case RR_CALCNEARESTTILE:
		
						bt_putStr_P(PSTR("clcnear, tileres:")); 
    7764:	83 e2       	ldi	r24, 0x23	; 35
    7766:	99 e2       	ldi	r25, 0x29	; 41
    7768:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
						
						tileRes = maze_findNearestTile(&robot.pos, &rr_result);
    776c:	68 e5       	ldi	r22, 0x58	; 88
    776e:	78 e0       	ldi	r23, 0x08	; 8
    7770:	88 e4       	ldi	r24, 0x48	; 72
    7772:	96 e1       	ldi	r25, 0x16	; 22
    7774:	0e 94 c9 57 	call	0xaf92	; 0xaf92 <maze_findNearestTile>
																	 
						if(tileRes == -1)			routeRequest = RR_NEARNOPOSS; //Driven over every visitable tile -> Drive back to start
    7778:	8f 3f       	cpi	r24, 0xFF	; 255
    777a:	2f ef       	ldi	r18, 0xFF	; 255
    777c:	92 07       	cpc	r25, r18
    777e:	11 f4       	brne	.+4      	; 0x7784 <maze_solveRoutes+0x3c>
    7780:	84 e0       	ldi	r24, 0x04	; 4
    7782:	1b c0       	rjmp	.+54     	; 0x77ba <maze_solveRoutes+0x72>
						else if(tileRes < 4000)		routeRequest = RR_CALCROUTE;
    7784:	80 3a       	cpi	r24, 0xA0	; 160
    7786:	9f 40       	sbci	r25, 0x0F	; 15
    7788:	14 f4       	brge	.+4      	; 0x778e <maze_solveRoutes+0x46>
    778a:	82 e0       	ldi	r24, 0x02	; 2
    778c:	16 c0       	rjmp	.+44     	; 0x77ba <maze_solveRoutes+0x72>
						else						routeRequest = RR_NEARTIMEOUT;
    778e:	85 e0       	ldi	r24, 0x05	; 5
    7790:	14 c0       	rjmp	.+40     	; 0x77ba <maze_solveRoutes+0x72>
						
					break;
						
		case RR_CALCROUTE:

						maze_clearDepthsearch();
    7792:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
						
						tileRes = maze_findPath(&robot.pos, &rr_result);
    7796:	68 e5       	ldi	r22, 0x58	; 88
    7798:	78 e0       	ldi	r23, 0x08	; 8
    779a:	88 e4       	ldi	r24, 0x48	; 72
    779c:	96 e1       	ldi	r25, 0x16	; 22
    779e:	0e 94 a4 58 	call	0xb148	; 0xb148 <maze_findPath>
						
						if(tileRes == -1)			routeRequest = RR_RTNOPOSS; //No possible route
    77a2:	8f 3f       	cpi	r24, 0xFF	; 255
    77a4:	2f ef       	ldi	r18, 0xFF	; 255
    77a6:	92 07       	cpc	r25, r18
    77a8:	11 f4       	brne	.+4      	; 0x77ae <maze_solveRoutes+0x66>
    77aa:	87 e0       	ldi	r24, 0x07	; 7
    77ac:	06 c0       	rjmp	.+12     	; 0x77ba <maze_solveRoutes+0x72>
						else if(tileRes < 4000)		routeRequest = RR_RTDONE;
    77ae:	80 3a       	cpi	r24, 0xA0	; 160
    77b0:	9f 40       	sbci	r25, 0x0F	; 15
    77b2:	14 f4       	brge	.+4      	; 0x77b8 <maze_solveRoutes+0x70>
    77b4:	86 e0       	ldi	r24, 0x06	; 6
    77b6:	01 c0       	rjmp	.+2      	; 0x77ba <maze_solveRoutes+0x72>
						else						routeRequest = RR_RTTIMEOUT;
    77b8:	88 e0       	ldi	r24, 0x08	; 8
    77ba:	80 93 c6 05 	sts	0x05C6, r24
    77be:	08 95       	ret
		case RR_RTDONE:			break; //"
		case RR_RTNOPOSS:		break; //"
		case RR_RTTIMEOUT:		break; //"
		
		default:
						if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.06]:DEFAULT_CASE"));}
    77c0:	80 91 53 05 	lds	r24, 0x0553
    77c4:	82 30       	cpi	r24, 0x02	; 2
    77c6:	90 f0       	brcs	.+36     	; 0x77ec <maze_solveRoutes+0xa4>
    77c8:	80 e2       	ldi	r24, 0x20	; 32
    77ca:	99 e2       	ldi	r25, 0x29	; 41
    77cc:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    77d0:	60 91 47 05 	lds	r22, 0x0547
    77d4:	70 91 48 05 	lds	r23, 0x0548
    77d8:	80 91 49 05 	lds	r24, 0x0549
    77dc:	90 91 4a 05 	lds	r25, 0x054A
    77e0:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    77e4:	8a ee       	ldi	r24, 0xEA	; 234
    77e6:	98 e2       	ldi	r25, 0x28	; 40
    77e8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
						fatal_err = 1;
    77ec:	81 e0       	ldi	r24, 0x01	; 1
    77ee:	80 93 63 05 	sts	0x0563, r24
						routeRequest = RR_WAIT;
    77f2:	10 92 c6 05 	sts	0x05C6, r1
    77f6:	08 95       	ret

000077f8 <maze_checkCorrWall>:
// Returns 1 if the walls were updated.
////////////////////////////////////////////////////////////////////////////////

//Helperfunction for correcting the walls with sensors in the desired direction
void maze_checkCorrWall(COORD *_coord, uint8_t sensinfoA, uint8_t sensinfoB, uint8_t dir, int16_t threshold, uint8_t updateFac_wall)
{
    77f8:	ef 92       	push	r14
    77fa:	0f 93       	push	r16
    77fc:	1f 93       	push	r17
	if(dist[LIN][sensinfoA][sensinfoB] < threshold) //Is wall
    77fe:	34 e0       	ldi	r19, 0x04	; 4
    7800:	63 9f       	mul	r22, r19
    7802:	f0 01       	movw	r30, r0
    7804:	11 24       	eor	r1, r1
    7806:	e4 0f       	add	r30, r20
    7808:	f1 1d       	adc	r31, r1
    780a:	ee 0f       	add	r30, r30
    780c:	ff 1f       	adc	r31, r31
    780e:	ee 55       	subi	r30, 0x5E	; 94
    7810:	f8 4f       	sbci	r31, 0xF8	; 248
    7812:	01 90       	ld	r0, Z+
    7814:	f0 81       	ld	r31, Z
    7816:	e0 2d       	mov	r30, r0
		maze_corrWall(_coord, dir, updateFac_wall);
    7818:	4e 2d       	mov	r20, r14
////////////////////////////////////////////////////////////////////////////////

//Helperfunction for correcting the walls with sensors in the desired direction
void maze_checkCorrWall(COORD *_coord, uint8_t sensinfoA, uint8_t sensinfoB, uint8_t dir, int16_t threshold, uint8_t updateFac_wall)
{
	if(dist[LIN][sensinfoA][sensinfoB] < threshold) //Is wall
    781a:	e0 17       	cp	r30, r16
    781c:	f1 07       	cpc	r31, r17
    781e:	0c f0       	brlt	.+2      	; 0x7822 <maze_checkCorrWall+0x2a>
		maze_corrWall(_coord, dir, updateFac_wall);
	else
		maze_corrWall(_coord, dir, -updateFac_wall);
    7820:	41 95       	neg	r20
    7822:	62 2f       	mov	r22, r18
    7824:	0e 94 79 4c 	call	0x98f2	; 0x98f2 <maze_corrWall>
}
    7828:	1f 91       	pop	r17
    782a:	0f 91       	pop	r16
    782c:	ef 90       	pop	r14
    782e:	08 95       	ret

00007830 <maze_updateWalls>:
#define DIST_BABA_FAC 7 //Mitlerer Sensor hinten

uint8_t sm_updateWalls = 0;

uint8_t maze_updateWalls(void)
{
    7830:	ef 92       	push	r14
    7832:	0f 93       	push	r16
    7834:	1f 93       	push	r17
	uint8_t returnvar = 0;

	switch(sm_updateWalls)
    7836:	80 91 c5 05 	lds	r24, 0x05C5
    783a:	88 23       	and	r24, r24
    783c:	19 f0       	breq	.+6      	; 0x7844 <maze_updateWalls+0x14>
    783e:	81 30       	cpi	r24, 0x01	; 1
    7840:	59 f0       	breq	.+22     	; 0x7858 <maze_updateWalls+0x28>
    7842:	b4 c0       	rjmp	.+360    	; 0x79ac <maze_updateWalls+0x17c>
	{
		case 0:
				sensinfo.newDat.left = 0;
    7844:	80 91 c3 07 	lds	r24, 0x07C3
				sensinfo.newDat.right = 0;
				sensinfo.newDat.mid = 0;
    7848:	8c 7f       	andi	r24, 0xFC	; 252
    784a:	8b 7f       	andi	r24, 0xFB	; 251
    784c:	80 93 c3 07 	sts	0x07C3, r24

				sm_updateWalls = 1;
    7850:	81 e0       	ldi	r24, 0x01	; 1
    7852:	80 93 c5 05 	sts	0x05C5, r24
    7856:	aa c0       	rjmp	.+340    	; 0x79ac <maze_updateWalls+0x17c>
			break;

		case 1:

				if(sensinfo.newDat.left &&
				   sensinfo.newDat.right &&
    7858:	80 91 c3 07 	lds	r24, 0x07C3
    785c:	87 70       	andi	r24, 0x07	; 7

			break;

		case 1:

				if(sensinfo.newDat.left &&
    785e:	87 30       	cpi	r24, 0x07	; 7
    7860:	09 f0       	breq	.+2      	; 0x7864 <maze_updateWalls+0x34>
    7862:	a4 c0       	rjmp	.+328    	; 0x79ac <maze_updateWalls+0x17c>
				   sensinfo.newDat.right &&
				   sensinfo.newDat.mid)
				{
					if((abs(maze_getWall(&robot_save.pos, NORTH)) <= MAZE_ISWALL) ||
    7864:	61 e0       	ldi	r22, 0x01	; 1
    7866:	8f e0       	ldi	r24, 0x0F	; 15
    7868:	98 e0       	ldi	r25, 0x08	; 8
    786a:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    786e:	99 27       	eor	r25, r25
    7870:	87 fd       	sbrc	r24, 7
    7872:	90 95       	com	r25
    7874:	97 ff       	sbrs	r25, 7
    7876:	03 c0       	rjmp	.+6      	; 0x787e <maze_updateWalls+0x4e>
    7878:	91 95       	neg	r25
    787a:	81 95       	neg	r24
    787c:	91 09       	sbc	r25, r1
    787e:	05 97       	sbiw	r24, 0x05	; 5
    7880:	0c f0       	brlt	.+2      	; 0x7884 <maze_updateWalls+0x54>
    7882:	60 c0       	rjmp	.+192    	; 0x7944 <maze_updateWalls+0x114>
						 (abs(maze_getWall(&robot_save.pos, EAST)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, SOUTH)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, WEST)) <= MAZE_ISWALL))
					{
						//////////Wand rechts/////////////
						maze_checkCorrWall(&robot_save.pos, RIGHT, FRONT, robot_save.dir+1, SIDE_TH, DIST_FR_FAC);
    7884:	20 91 12 08 	lds	r18, 0x0812
    7888:	2f 5f       	subi	r18, 0xFF	; 255
    788a:	44 e0       	ldi	r20, 0x04	; 4
    788c:	e4 2e       	mov	r14, r20
    788e:	0a ea       	ldi	r16, 0xAA	; 170
    7890:	10 e0       	ldi	r17, 0x00	; 0
    7892:	42 e0       	ldi	r20, 0x02	; 2
    7894:	61 e0       	ldi	r22, 0x01	; 1
    7896:	8f e0       	ldi	r24, 0x0F	; 15
    7898:	98 e0       	ldi	r25, 0x08	; 8
    789a:	ae df       	rcall	.-164    	; 0x77f8 <maze_checkCorrWall>
    789c:	20 91 12 08 	lds	r18, 0x0812
						maze_checkCorrWall(&robot_save.pos, RIGHT, BACK, robot_save.dir+1, SIDE_TH, DIST_BA_FAC);
    78a0:	2f 5f       	subi	r18, 0xFF	; 255
    78a2:	52 e0       	ldi	r21, 0x02	; 2
    78a4:	e5 2e       	mov	r14, r21
    78a6:	43 e0       	ldi	r20, 0x03	; 3
    78a8:	61 e0       	ldi	r22, 0x01	; 1
    78aa:	8f e0       	ldi	r24, 0x0F	; 15
    78ac:	98 e0       	ldi	r25, 0x08	; 8
    78ae:	a4 df       	rcall	.-184    	; 0x77f8 <maze_checkCorrWall>
    78b0:	20 91 12 08 	lds	r18, 0x0812

						//////////Wand links/////////////

						maze_checkCorrWall(&robot_save.pos, LEFT, FRONT, robot_save.dir+3, SIDE_TH, DIST_FR_FAC);
    78b4:	2d 5f       	subi	r18, 0xFD	; 253
    78b6:	64 e0       	ldi	r22, 0x04	; 4
    78b8:	e6 2e       	mov	r14, r22
    78ba:	42 e0       	ldi	r20, 0x02	; 2
    78bc:	60 e0       	ldi	r22, 0x00	; 0
    78be:	8f e0       	ldi	r24, 0x0F	; 15
    78c0:	98 e0       	ldi	r25, 0x08	; 8
    78c2:	9a df       	rcall	.-204    	; 0x77f8 <maze_checkCorrWall>
    78c4:	20 91 12 08 	lds	r18, 0x0812
    78c8:	2d 5f       	subi	r18, 0xFD	; 253
						maze_checkCorrWall(&robot_save.pos, LEFT, BACK, robot_save.dir+3, SIDE_TH, DIST_BA_FAC);
    78ca:	72 e0       	ldi	r23, 0x02	; 2
    78cc:	e7 2e       	mov	r14, r23
    78ce:	43 e0       	ldi	r20, 0x03	; 3
    78d0:	60 e0       	ldi	r22, 0x00	; 0
    78d2:	8f e0       	ldi	r24, 0x0F	; 15
    78d4:	98 e0       	ldi	r25, 0x08	; 8
    78d6:	90 df       	rcall	.-224    	; 0x77f8 <maze_checkCorrWall>
    78d8:	ee 24       	eor	r14, r14
    78da:	e3 94       	inc	r14
    78dc:	20 91 12 08 	lds	r18, 0x0812

						//////////Wand vorne/////////////
						maze_checkCorrWall(&robot_save.pos, FRONT, LEFT, robot_save.dir, FRONT_TH, DIST_FRBA_FAC);
    78e0:	40 e0       	ldi	r20, 0x00	; 0
    78e2:	62 e0       	ldi	r22, 0x02	; 2
    78e4:	8f e0       	ldi	r24, 0x0F	; 15
    78e6:	98 e0       	ldi	r25, 0x08	; 8
    78e8:	87 df       	rcall	.-242    	; 0x77f8 <maze_checkCorrWall>
    78ea:	20 91 12 08 	lds	r18, 0x0812
    78ee:	41 e0       	ldi	r20, 0x01	; 1
    78f0:	62 e0       	ldi	r22, 0x02	; 2
    78f2:	8f e0       	ldi	r24, 0x0F	; 15
						maze_checkCorrWall(&robot_save.pos, FRONT, RIGHT, robot_save.dir, FRONT_TH, DIST_FRBA_FAC);
    78f4:	98 e0       	ldi	r25, 0x08	; 8
    78f6:	80 df       	rcall	.-256    	; 0x77f8 <maze_checkCorrWall>
    78f8:	e7 e0       	ldi	r30, 0x07	; 7
    78fa:	ee 2e       	mov	r14, r30
    78fc:	20 91 12 08 	lds	r18, 0x0812
    7900:	42 e0       	ldi	r20, 0x02	; 2
    7902:	62 e0       	ldi	r22, 0x02	; 2
						maze_checkCorrWall(&robot_save.pos, FRONT, FRONT, robot_save.dir, FRONT_FRONT_TH, DIST_FRFR_FAC);
    7904:	8f e0       	ldi	r24, 0x0F	; 15
    7906:	98 e0       	ldi	r25, 0x08	; 8
    7908:	77 df       	rcall	.-274    	; 0x77f8 <maze_checkCorrWall>
    790a:	20 91 12 08 	lds	r18, 0x0812
    790e:	2e 5f       	subi	r18, 0xFE	; 254
    7910:	ee 24       	eor	r14, r14
    7912:	e3 94       	inc	r14
    7914:	40 e0       	ldi	r20, 0x00	; 0
    7916:	63 e0       	ldi	r22, 0x03	; 3

						//////////Wand hinten/////////////
						maze_checkCorrWall(&robot_save.pos, BACK, LEFT, robot_save.dir+2, BACK_TH, DIST_FRBA_FAC);
    7918:	8f e0       	ldi	r24, 0x0F	; 15
    791a:	98 e0       	ldi	r25, 0x08	; 8
    791c:	6d df       	rcall	.-294    	; 0x77f8 <maze_checkCorrWall>
    791e:	20 91 12 08 	lds	r18, 0x0812
    7922:	2e 5f       	subi	r18, 0xFE	; 254
    7924:	41 e0       	ldi	r20, 0x01	; 1
    7926:	63 e0       	ldi	r22, 0x03	; 3
    7928:	8f e0       	ldi	r24, 0x0F	; 15
    792a:	98 e0       	ldi	r25, 0x08	; 8
    792c:	65 df       	rcall	.-310    	; 0x77f8 <maze_checkCorrWall>
						maze_checkCorrWall(&robot_save.pos, BACK, RIGHT, robot_save.dir+2, BACK_TH, DIST_FRBA_FAC);
    792e:	20 91 12 08 	lds	r18, 0x0812
    7932:	2e 5f       	subi	r18, 0xFE	; 254
    7934:	f7 e0       	ldi	r31, 0x07	; 7
    7936:	ef 2e       	mov	r14, r31
    7938:	43 e0       	ldi	r20, 0x03	; 3
    793a:	63 e0       	ldi	r22, 0x03	; 3
    793c:	8f e0       	ldi	r24, 0x0F	; 15
    793e:	98 e0       	ldi	r25, 0x08	; 8
						maze_checkCorrWall(&robot_save.pos, BACK, BACK, robot_save.dir+2, BACK_BACK_TH, DIST_BABA_FAC);
    7940:	5b df       	rcall	.-330    	; 0x77f8 <maze_checkCorrWall>
    7942:	34 c0       	rjmp	.+104    	; 0x79ac <maze_updateWalls+0x17c>
    7944:	62 e0       	ldi	r22, 0x02	; 2
    7946:	8f e0       	ldi	r24, 0x0F	; 15
    7948:	98 e0       	ldi	r25, 0x08	; 8
    794a:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    794e:	99 27       	eor	r25, r25
    7950:	87 fd       	sbrc	r24, 7
    7952:	90 95       	com	r25
    7954:	97 ff       	sbrs	r25, 7
    7956:	03 c0       	rjmp	.+6      	; 0x795e <maze_updateWalls+0x12e>
				if(sensinfo.newDat.left &&
				   sensinfo.newDat.right &&
				   sensinfo.newDat.mid)
				{
					if((abs(maze_getWall(&robot_save.pos, NORTH)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, EAST)) <= MAZE_ISWALL) ||
    7958:	91 95       	neg	r25
    795a:	81 95       	neg	r24
    795c:	91 09       	sbc	r25, r1
    795e:	05 97       	sbiw	r24, 0x05	; 5
    7960:	0c f4       	brge	.+2      	; 0x7964 <maze_updateWalls+0x134>
    7962:	90 cf       	rjmp	.-224    	; 0x7884 <maze_updateWalls+0x54>
    7964:	63 e0       	ldi	r22, 0x03	; 3
    7966:	8f e0       	ldi	r24, 0x0F	; 15
    7968:	98 e0       	ldi	r25, 0x08	; 8
    796a:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    796e:	99 27       	eor	r25, r25
    7970:	87 fd       	sbrc	r24, 7

				if(sensinfo.newDat.left &&
				   sensinfo.newDat.right &&
				   sensinfo.newDat.mid)
				{
					if((abs(maze_getWall(&robot_save.pos, NORTH)) <= MAZE_ISWALL) ||
    7972:	90 95       	com	r25
    7974:	97 ff       	sbrs	r25, 7
    7976:	03 c0       	rjmp	.+6      	; 0x797e <maze_updateWalls+0x14e>
						 (abs(maze_getWall(&robot_save.pos, EAST)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, SOUTH)) <= MAZE_ISWALL) ||
    7978:	91 95       	neg	r25
    797a:	81 95       	neg	r24
    797c:	91 09       	sbc	r25, r1
    797e:	05 97       	sbiw	r24, 0x05	; 5
    7980:	0c f4       	brge	.+2      	; 0x7984 <maze_updateWalls+0x154>
    7982:	80 cf       	rjmp	.-256    	; 0x7884 <maze_updateWalls+0x54>
    7984:	64 e0       	ldi	r22, 0x04	; 4
    7986:	8f e0       	ldi	r24, 0x0F	; 15
    7988:	98 e0       	ldi	r25, 0x08	; 8
    798a:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    798e:	99 27       	eor	r25, r25
    7990:	87 fd       	sbrc	r24, 7
				if(sensinfo.newDat.left &&
				   sensinfo.newDat.right &&
				   sensinfo.newDat.mid)
				{
					if((abs(maze_getWall(&robot_save.pos, NORTH)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, EAST)) <= MAZE_ISWALL) ||
    7992:	90 95       	com	r25
    7994:	97 ff       	sbrs	r25, 7
    7996:	03 c0       	rjmp	.+6      	; 0x799e <maze_updateWalls+0x16e>
						 (abs(maze_getWall(&robot_save.pos, SOUTH)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, WEST)) <= MAZE_ISWALL))
    7998:	91 95       	neg	r25
    799a:	81 95       	neg	r24
    799c:	91 09       	sbc	r25, r1
    799e:	05 97       	sbiw	r24, 0x05	; 5
    79a0:	0c f4       	brge	.+2      	; 0x79a4 <maze_updateWalls+0x174>
    79a2:	70 cf       	rjmp	.-288    	; 0x7884 <maze_updateWalls+0x54>
    79a4:	10 92 c5 05 	sts	0x05C5, r1
    79a8:	81 e0       	ldi	r24, 0x01	; 1
    79aa:	01 c0       	rjmp	.+2      	; 0x79ae <maze_updateWalls+0x17e>
    79ac:	80 e0       	ldi	r24, 0x00	; 0
    79ae:	1f 91       	pop	r17
    79b0:	0f 91       	pop	r16
				   sensinfo.newDat.right &&
				   sensinfo.newDat.mid)
				{
					if((abs(maze_getWall(&robot_save.pos, NORTH)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, EAST)) <= MAZE_ISWALL) ||
						 (abs(maze_getWall(&robot_save.pos, SOUTH)) <= MAZE_ISWALL) ||
    79b2:	ef 90       	pop	r14
    79b4:	08 95       	ret

000079b6 <maze_solve>:

MATCHINGWALLS matchingWalls;
TILE cleartiles;

uint8_t maze_solve(void) //called from RIOS periodical task
{		
    79b6:	a3 e0       	ldi	r26, 0x03	; 3
    79b8:	b0 e0       	ldi	r27, 0x00	; 0
    79ba:	e1 ee       	ldi	r30, 0xE1	; 225
    79bc:	fc e3       	ldi	r31, 0x3C	; 60
    79be:	0c 94 a6 6b 	jmp	0xd74c	; 0xd74c <__prologue_saves__+0x16>
	uint8_t returnvar = 1;
	
	if((timer_rdy_restart == 0) && !mot.off) //Neustart
    79c2:	80 91 93 02 	lds	r24, 0x0293
    79c6:	90 91 94 02 	lds	r25, 0x0294
    79ca:	89 2b       	or	r24, r25
    79cc:	61 f4       	brne	.+24     	; 0x79e6 <maze_solve+0x30>
    79ce:	80 91 7f 16 	lds	r24, 0x167F
    79d2:	81 11       	cpse	r24, r1
    79d4:	08 c0       	rjmp	.+16     	; 0x79e6 <maze_solve+0x30>
	{
		timer_rdy_restart = -1;
    79d6:	8f ef       	ldi	r24, 0xFF	; 255
    79d8:	9f ef       	ldi	r25, 0xFF	; 255
    79da:	90 93 94 02 	sts	0x0294, r25
    79de:	80 93 93 02 	sts	0x0293, r24
		maze_init();
    79e2:	0e 94 24 50 	call	0xa048	; 0xa048 <maze_init>
	}

	if((!mot.off) && (incr_ok_mode == 4)) //If the robot does not moves, there is no input and no victim identification
    79e6:	80 91 7f 16 	lds	r24, 0x167F
    79ea:	81 11       	cpse	r24, r1
    79ec:	00 c5       	rjmp	.+2560   	; 0x83ee <maze_solve+0xa38>
    79ee:	80 91 c3 02 	lds	r24, 0x02C3
    79f2:	84 30       	cpi	r24, 0x04	; 4
    79f4:	09 f0       	breq	.+2      	; 0x79f8 <maze_solve+0x42>
    79f6:	fb c4       	rjmp	.+2550   	; 0x83ee <maze_solve+0xa38>
		uint8_t depthsearchNum = 0;
		uint8_t driveVar = 0;

		//////////////////////////////LOP//////////////////////////////////////

		if((maze_solve_state_path != LOP_INIT) && (maze_solve_state_path != LOP_WAIT))
    79f8:	80 91 cd 05 	lds	r24, 0x05CD
    79fc:	85 50       	subi	r24, 0x05	; 5
    79fe:	82 30       	cpi	r24, 0x02	; 2
    7a00:	40 f1       	brcs	.+80     	; 0x7a52 <maze_solve+0x9c>
		{
			if(dist_down < GROUNDDIST_TH_LOP) //Robot lifted up -> Lack of Progress
    7a02:	80 91 7e 07 	lds	r24, 0x077E
    7a06:	90 91 7f 07 	lds	r25, 0x077F
    7a0a:	c2 97       	sbiw	r24, 0x32	; 50
    7a0c:	9c f4       	brge	.+38     	; 0x7a34 <maze_solve+0x7e>
			{
				if(timer_lop == -1)
    7a0e:	80 91 91 02 	lds	r24, 0x0291
    7a12:	90 91 92 02 	lds	r25, 0x0292
    7a16:	01 96       	adiw	r24, 0x01	; 1
    7a18:	31 f4       	brne	.+12     	; 0x7a26 <maze_solve+0x70>
					timer_lop = TIMER_LOP_SENSOR;
    7a1a:	88 e2       	ldi	r24, 0x28	; 40
    7a1c:	90 e0       	ldi	r25, 0x00	; 0
    7a1e:	90 93 92 02 	sts	0x0292, r25
    7a22:	80 93 91 02 	sts	0x0291, r24

				timer_rdy_restart = -1;
    7a26:	8f ef       	ldi	r24, 0xFF	; 255
    7a28:	9f ef       	ldi	r25, 0xFF	; 255
    7a2a:	90 93 94 02 	sts	0x0294, r25
    7a2e:	80 93 93 02 	sts	0x0293, r24
    7a32:	06 c0       	rjmp	.+12     	; 0x7a40 <maze_solve+0x8a>
			}
			else
			{
				timer_lop = -1;
    7a34:	8f ef       	ldi	r24, 0xFF	; 255
    7a36:	9f ef       	ldi	r25, 0xFF	; 255
    7a38:	90 93 92 02 	sts	0x0292, r25
    7a3c:	80 93 91 02 	sts	0x0291, r24
			}

			if(timer_lop == 0)
    7a40:	80 91 91 02 	lds	r24, 0x0291
    7a44:	90 91 92 02 	lds	r25, 0x0292
    7a48:	89 2b       	or	r24, r25
    7a4a:	19 f4       	brne	.+6      	; 0x7a52 <maze_solve+0x9c>
			{
				maze_solve_state_path = LOP_INIT;
    7a4c:	85 e0       	ldi	r24, 0x05	; 5
    7a4e:	80 93 cd 05 	sts	0x05CD, r24
			}
		}

		//////////////////////Statemachine///////////////////////////////////////

		switch(maze_solve_state_path)
    7a52:	80 91 cd 05 	lds	r24, 0x05CD
    7a56:	90 e0       	ldi	r25, 0x00	; 0
    7a58:	81 31       	cpi	r24, 0x11	; 17
    7a5a:	91 05       	cpc	r25, r1
    7a5c:	08 f0       	brcs	.+2      	; 0x7a60 <maze_solve+0xaa>
    7a5e:	ab c4       	rjmp	.+2390   	; 0x83b6 <maze_solve+0xa00>
    7a60:	fc 01       	movw	r30, r24
    7a62:	e1 56       	subi	r30, 0x61	; 97
    7a64:	ff 4f       	sbci	r31, 0xFF	; 255
    7a66:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
		{
			case DRIVE_READY:
									switch(maze_solve_state_ready)
    7a6a:	80 91 cc 05 	lds	r24, 0x05CC
    7a6e:	81 30       	cpi	r24, 0x01	; 1
    7a70:	d1 f0       	breq	.+52     	; 0x7aa6 <maze_solve+0xf0>
    7a72:	28 f0       	brcs	.+10     	; 0x7a7e <maze_solve+0xc8>
    7a74:	82 30       	cpi	r24, 0x02	; 2
    7a76:	c9 f0       	breq	.+50     	; 0x7aaa <maze_solve+0xf4>
    7a78:	83 30       	cpi	r24, 0x03	; 3
    7a7a:	d1 f0       	breq	.+52     	; 0x7ab0 <maze_solve+0xfa>
    7a7c:	b8 c4       	rjmp	.+2416   	; 0x83ee <maze_solve+0xa38>
									{
										case DR_INIT:

													mot.d[LEFT].speed.to = 0;
    7a7e:	10 92 6a 16 	sts	0x166A, r1
    7a82:	10 92 69 16 	sts	0x1669, r1
													mot.d[RIGHT].speed.to = 0;
    7a86:	10 92 76 16 	sts	0x1676, r1
    7a8a:	10 92 75 16 	sts	0x1675, r1

													robot_save.dir = robot.dir; //Has to be robot.dir to compare it with robot.pos!!!
    7a8e:	80 91 4b 16 	lds	r24, 0x164B
    7a92:	80 93 12 08 	sts	0x0812, r24
													robot_save.pos.x = MAZE_SIZE_X_USABLE-1; //Upper right tile, the size  has to be dimensioned so that the robot will never reach this tile!
    7a96:	8b e0       	ldi	r24, 0x0B	; 11
    7a98:	80 93 0f 08 	sts	0x080F, r24
													robot_save.pos.y = MAZE_SIZE_Y_USABLE-1;
    7a9c:	80 93 10 08 	sts	0x0810, r24
													robot_save.pos.z = MAZE_SAVESTAGE;
    7aa0:	82 e0       	ldi	r24, 0x02	; 2
    7aa2:	80 93 11 08 	sts	0x0811, r24

										case DR_UPDATEWALLS:

													//if(maze_updateWalls()) //Save the walls around the robot in the MAZE_SAVESTAGE to compare it later with the environment
													//{
														maze_solve_state_ready = DR_UPDATEVICTIMS;
    7aa6:	82 e0       	ldi	r24, 0x02	; 2
    7aa8:	b1 c0       	rjmp	.+354    	; 0x7c0c <maze_solve+0x256>

										case DR_UPDATEVICTIMS:

													/*if(victim_check())
													{*/
														maze_solve_state_ready = DR_CHECK;
    7aaa:	83 e0       	ldi	r24, 0x03	; 3
    7aac:	80 93 cc 05 	sts	0x05CC, r24

												//break;

										case DR_CHECK:

													matchingWalls.buffer[matchingWalls.next] = 0;
    7ab0:	e0 91 40 16 	lds	r30, 0x1640
    7ab4:	f0 e0       	ldi	r31, 0x00	; 0
    7ab6:	e8 5c       	subi	r30, 0xC8	; 200
    7ab8:	f9 4e       	sbci	r31, 0xE9	; 233
    7aba:	10 82       	st	Z, r1
													for(uint8_t dir = NORTH; dir <= WEST; dir++)
    7abc:	11 e0       	ldi	r17, 0x01	; 1
													{
														if(((maze_getWall(&robot.pos, dir) >= 0) && (maze_getWall(&robot_save.pos, dir) >= 0)) ||
    7abe:	61 2f       	mov	r22, r17
    7ac0:	88 e4       	ldi	r24, 0x48	; 72
    7ac2:	96 e1       	ldi	r25, 0x16	; 22
    7ac4:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    7ac8:	87 ff       	sbrs	r24, 7
    7aca:	08 c0       	rjmp	.+16     	; 0x7adc <maze_solve+0x126>
															 ((maze_getWall(&robot.pos, dir) <= 0) && (maze_getWall(&robot_save.pos, dir) <= 0)))
    7acc:	61 2f       	mov	r22, r17
    7ace:	88 e4       	ldi	r24, 0x48	; 72
    7ad0:	96 e1       	ldi	r25, 0x16	; 22
    7ad2:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
										case DR_CHECK:

													matchingWalls.buffer[matchingWalls.next] = 0;
													for(uint8_t dir = NORTH; dir <= WEST; dir++)
													{
														if(((maze_getWall(&robot.pos, dir) >= 0) && (maze_getWall(&robot_save.pos, dir) >= 0)) ||
    7ad6:	18 16       	cp	r1, r24
    7ad8:	c4 f0       	brlt	.+48     	; 0x7b0a <maze_solve+0x154>
    7ada:	10 c0       	rjmp	.+32     	; 0x7afc <maze_solve+0x146>
    7adc:	61 2f       	mov	r22, r17
    7ade:	8f e0       	ldi	r24, 0x0F	; 15
    7ae0:	98 e0       	ldi	r25, 0x08	; 8
    7ae2:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    7ae6:	87 fd       	sbrc	r24, 7
    7ae8:	f1 cf       	rjmp	.-30     	; 0x7acc <maze_solve+0x116>
															 ((maze_getWall(&robot.pos, dir) <= 0) && (maze_getWall(&robot_save.pos, dir) <= 0)))
														{
															matchingWalls.buffer[matchingWalls.next] ++;
    7aea:	e0 91 40 16 	lds	r30, 0x1640
    7aee:	f0 e0       	ldi	r31, 0x00	; 0
    7af0:	e8 5c       	subi	r30, 0xC8	; 200
    7af2:	f9 4e       	sbci	r31, 0xE9	; 233
    7af4:	80 81       	ld	r24, Z
    7af6:	8f 5f       	subi	r24, 0xFF	; 255
    7af8:	80 83       	st	Z, r24
    7afa:	07 c0       	rjmp	.+14     	; 0x7b0a <maze_solve+0x154>

													matchingWalls.buffer[matchingWalls.next] = 0;
													for(uint8_t dir = NORTH; dir <= WEST; dir++)
													{
														if(((maze_getWall(&robot.pos, dir) >= 0) && (maze_getWall(&robot_save.pos, dir) >= 0)) ||
															 ((maze_getWall(&robot.pos, dir) <= 0) && (maze_getWall(&robot_save.pos, dir) <= 0)))
    7afc:	61 2f       	mov	r22, r17
    7afe:	8f e0       	ldi	r24, 0x0F	; 15
    7b00:	98 e0       	ldi	r25, 0x08	; 8
    7b02:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    7b06:	18 16       	cp	r1, r24
    7b08:	84 f7       	brge	.-32     	; 0x7aea <maze_solve+0x134>
												//break;

										case DR_CHECK:

													matchingWalls.buffer[matchingWalls.next] = 0;
													for(uint8_t dir = NORTH; dir <= WEST; dir++)
    7b0a:	1f 5f       	subi	r17, 0xFF	; 255
    7b0c:	15 30       	cpi	r17, 0x05	; 5
    7b0e:	b9 f6       	brne	.-82     	; 0x7abe <maze_solve+0x108>
														}
													}

													//displayvar[0] = matchingWalls.buffer[matchingWalls.next];

													matchingWalls.lowmatches = 0;
    7b10:	10 92 41 16 	sts	0x1641, r1
    7b14:	e8 e3       	ldi	r30, 0x38	; 56
    7b16:	f6 e1       	ldi	r31, 0x16	; 22
    7b18:	80 e0       	ldi	r24, 0x00	; 0
													for(uint8_t i = 0; i < MATCHINGWALLS_BUFF; i++)
													{
														if((matchingWalls.buffer[i] > 0) &&
    7b1a:	91 91       	ld	r25, Z+
    7b1c:	91 50       	subi	r25, 0x01	; 1
    7b1e:	93 30       	cpi	r25, 0x03	; 3
    7b20:	08 f4       	brcc	.+2      	; 0x7b24 <maze_solve+0x16e>
																(matchingWalls.buffer[i] < 4))
															matchingWalls.lowmatches ++;
    7b22:	8f 5f       	subi	r24, 0xFF	; 255
													}

													//displayvar[0] = matchingWalls.buffer[matchingWalls.next];

													matchingWalls.lowmatches = 0;
													for(uint8_t i = 0; i < MATCHINGWALLS_BUFF; i++)
    7b24:	46 e1       	ldi	r20, 0x16	; 22
    7b26:	e0 34       	cpi	r30, 0x40	; 64
    7b28:	f4 07       	cpc	r31, r20
    7b2a:	b9 f7       	brne	.-18     	; 0x7b1a <maze_solve+0x164>
    7b2c:	80 93 41 16 	sts	0x1641, r24
													//displayvar[1] = matchingWalls.lowmatches;

													if(1)//(matchingWalls.buffer[matchingWalls.next] > 2) &&  //The last buffer entry shows us enough matches
													   //(matchingWalls.lowmatches < 4)) //In the last few tiles were not too many unsure mathces
													{
														maze_corrTile(&robot_save.pos, &robot.pos); //Copy the information of the savetile into the robots tile
    7b30:	68 e4       	ldi	r22, 0x48	; 72
    7b32:	76 e1       	ldi	r23, 0x16	; 22
    7b34:	8f e0       	ldi	r24, 0x0F	; 15
    7b36:	98 e0       	ldi	r25, 0x08	; 8
    7b38:	0e 94 a2 4c 	call	0x9944	; 0x9944 <maze_corrTile>

														for(uint8_t dir = NORTH; dir <= WEST; dir++)
    7b3c:	11 e0       	ldi	r17, 0x01	; 1
															maze_corrWall(&robot_save.pos, dir, -maze_getWall(&robot_save.pos, dir)); //and delete the information on the savetile
    7b3e:	61 2f       	mov	r22, r17
    7b40:	8f e0       	ldi	r24, 0x0F	; 15
    7b42:	98 e0       	ldi	r25, 0x08	; 8
    7b44:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    7b48:	48 2f       	mov	r20, r24
    7b4a:	41 95       	neg	r20
    7b4c:	61 2f       	mov	r22, r17
    7b4e:	8f e0       	ldi	r24, 0x0F	; 15
    7b50:	98 e0       	ldi	r25, 0x08	; 8
    7b52:	0e 94 79 4c 	call	0x98f2	; 0x98f2 <maze_corrWall>
													if(1)//(matchingWalls.buffer[matchingWalls.next] > 2) &&  //The last buffer entry shows us enough matches
													   //(matchingWalls.lowmatches < 4)) //In the last few tiles were not too many unsure mathces
													{
														maze_corrTile(&robot_save.pos, &robot.pos); //Copy the information of the savetile into the robots tile

														for(uint8_t dir = NORTH; dir <= WEST; dir++)
    7b56:	1f 5f       	subi	r17, 0xFF	; 255
    7b58:	15 30       	cpi	r17, 0x05	; 5
    7b5a:	89 f7       	brne	.-30     	; 0x7b3e <maze_solve+0x188>
															maze_corrWall(&robot_save.pos, dir, -maze_getWall(&robot_save.pos, dir)); //and delete the information on the savetile

														maze_setBeenthere(&robot.pos, NONE, TRUE);
    7b5c:	41 e0       	ldi	r20, 0x01	; 1
    7b5e:	60 e0       	ldi	r22, 0x00	; 0
    7b60:	88 e4       	ldi	r24, 0x48	; 72
    7b62:	96 e1       	ldi	r25, 0x16	; 22
    7b64:	0e 94 71 4e 	call	0x9ce2	; 0x9ce2 <maze_setBeenthere>

														if(((!maze_getBeenthere(&robot.pos, NORTH)) && maze_tileIsVisitable(&robot.pos, NORTH)) ||
    7b68:	61 e0       	ldi	r22, 0x01	; 1
    7b6a:	88 e4       	ldi	r24, 0x48	; 72
    7b6c:	96 e1       	ldi	r25, 0x16	; 22
    7b6e:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
    7b72:	88 23       	and	r24, r24
    7b74:	41 f0       	breq	.+16     	; 0x7b86 <maze_solve+0x1d0>
															 ((!maze_getBeenthere(&robot.pos, EAST)) && maze_tileIsVisitable(&robot.pos, EAST)) ||
    7b76:	62 e0       	ldi	r22, 0x02	; 2
    7b78:	88 e4       	ldi	r24, 0x48	; 72
    7b7a:	96 e1       	ldi	r25, 0x16	; 22
    7b7c:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
														for(uint8_t dir = NORTH; dir <= WEST; dir++)
															maze_corrWall(&robot_save.pos, dir, -maze_getWall(&robot_save.pos, dir)); //and delete the information on the savetile

														maze_setBeenthere(&robot.pos, NONE, TRUE);

														if(((!maze_getBeenthere(&robot.pos, NORTH)) && maze_tileIsVisitable(&robot.pos, NORTH)) ||
    7b80:	88 23       	and	r24, r24
    7b82:	61 f0       	breq	.+24     	; 0x7b9c <maze_solve+0x1e6>
    7b84:	12 c0       	rjmp	.+36     	; 0x7baa <maze_solve+0x1f4>
    7b86:	61 e0       	ldi	r22, 0x01	; 1
    7b88:	88 e4       	ldi	r24, 0x48	; 72
    7b8a:	96 e1       	ldi	r25, 0x16	; 22
    7b8c:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7b90:	88 23       	and	r24, r24
    7b92:	89 f3       	breq	.-30     	; 0x7b76 <maze_solve+0x1c0>
															 ((!maze_getBeenthere(&robot.pos, EAST)) && maze_tileIsVisitable(&robot.pos, EAST)) ||
															 ((!maze_getBeenthere(&robot.pos, SOUTH)) && maze_tileIsVisitable(&robot.pos, SOUTH)) ||
															 ((!maze_getBeenthere(&robot.pos, WEST)) && maze_tileIsVisitable(&robot.pos, WEST)))
														{
															maze_clearDepthsearch();
    7b94:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
															maze_solve_state_path = FOLLOW_RIGHTWALL; //When the program came into RESTART by RR_RTNOPOSS and there is suddenly an option (Wall wrong detected?) proceed!
    7b98:	81 e0       	ldi	r24, 0x01	; 1
    7b9a:	24 c0       	rjmp	.+72     	; 0x7be4 <maze_solve+0x22e>
															maze_corrWall(&robot_save.pos, dir, -maze_getWall(&robot_save.pos, dir)); //and delete the information on the savetile

														maze_setBeenthere(&robot.pos, NONE, TRUE);

														if(((!maze_getBeenthere(&robot.pos, NORTH)) && maze_tileIsVisitable(&robot.pos, NORTH)) ||
															 ((!maze_getBeenthere(&robot.pos, EAST)) && maze_tileIsVisitable(&robot.pos, EAST)) ||
    7b9c:	62 e0       	ldi	r22, 0x02	; 2
    7b9e:	88 e4       	ldi	r24, 0x48	; 72
    7ba0:	96 e1       	ldi	r25, 0x16	; 22
    7ba2:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7ba6:	81 11       	cpse	r24, r1
    7ba8:	f5 cf       	rjmp	.-22     	; 0x7b94 <maze_solve+0x1de>
															 ((!maze_getBeenthere(&robot.pos, SOUTH)) && maze_tileIsVisitable(&robot.pos, SOUTH)) ||
    7baa:	63 e0       	ldi	r22, 0x03	; 3
    7bac:	88 e4       	ldi	r24, 0x48	; 72
    7bae:	96 e1       	ldi	r25, 0x16	; 22
    7bb0:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
															maze_corrWall(&robot_save.pos, dir, -maze_getWall(&robot_save.pos, dir)); //and delete the information on the savetile

														maze_setBeenthere(&robot.pos, NONE, TRUE);

														if(((!maze_getBeenthere(&robot.pos, NORTH)) && maze_tileIsVisitable(&robot.pos, NORTH)) ||
															 ((!maze_getBeenthere(&robot.pos, EAST)) && maze_tileIsVisitable(&robot.pos, EAST)) ||
    7bb4:	81 11       	cpse	r24, r1
    7bb6:	07 c0       	rjmp	.+14     	; 0x7bc6 <maze_solve+0x210>
															 ((!maze_getBeenthere(&robot.pos, SOUTH)) && maze_tileIsVisitable(&robot.pos, SOUTH)) ||
    7bb8:	63 e0       	ldi	r22, 0x03	; 3
    7bba:	88 e4       	ldi	r24, 0x48	; 72
    7bbc:	96 e1       	ldi	r25, 0x16	; 22
    7bbe:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7bc2:	81 11       	cpse	r24, r1
    7bc4:	e7 cf       	rjmp	.-50     	; 0x7b94 <maze_solve+0x1de>
															 ((!maze_getBeenthere(&robot.pos, WEST)) && maze_tileIsVisitable(&robot.pos, WEST)))
    7bc6:	64 e0       	ldi	r22, 0x04	; 4
    7bc8:	88 e4       	ldi	r24, 0x48	; 72
    7bca:	96 e1       	ldi	r25, 0x16	; 22
    7bcc:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>

														maze_setBeenthere(&robot.pos, NONE, TRUE);

														if(((!maze_getBeenthere(&robot.pos, NORTH)) && maze_tileIsVisitable(&robot.pos, NORTH)) ||
															 ((!maze_getBeenthere(&robot.pos, EAST)) && maze_tileIsVisitable(&robot.pos, EAST)) ||
															 ((!maze_getBeenthere(&robot.pos, SOUTH)) && maze_tileIsVisitable(&robot.pos, SOUTH)) ||
    7bd0:	81 11       	cpse	r24, r1
    7bd2:	07 c0       	rjmp	.+14     	; 0x7be2 <maze_solve+0x22c>
															 ((!maze_getBeenthere(&robot.pos, WEST)) && maze_tileIsVisitable(&robot.pos, WEST)))
    7bd4:	64 e0       	ldi	r22, 0x04	; 4
    7bd6:	88 e4       	ldi	r24, 0x48	; 72
    7bd8:	96 e1       	ldi	r25, 0x16	; 22
    7bda:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7bde:	81 11       	cpse	r24, r1
    7be0:	d9 cf       	rjmp	.-78     	; 0x7b94 <maze_solve+0x1de>
															maze_clearDepthsearch();
															maze_solve_state_path = FOLLOW_RIGHTWALL; //When the program came into RESTART by RR_RTNOPOSS and there is suddenly an option (Wall wrong detected?) proceed!
														}
														else
														{
															maze_solve_state_path = FOLLOW_DFS; //Statemachine automatically jumps into FOLLOW_RIGHTWALL when there is no path possibility
    7be2:	82 e0       	ldi	r24, 0x02	; 2
    7be4:	80 93 cd 05 	sts	0x05CD, r24
														robot.pos.y = ROB_POS_Y_MIN;

														maze_solve_state_path = DRIVE_NEUTRPOS;
													}

													matchingWalls.next ++; //FIFO
    7be8:	80 91 40 16 	lds	r24, 0x1640
    7bec:	8f 5f       	subi	r24, 0xFF	; 255
													if(matchingWalls.next >= MATCHINGWALLS_BUFF)
    7bee:	88 30       	cpi	r24, 0x08	; 8
    7bf0:	18 f4       	brcc	.+6      	; 0x7bf8 <maze_solve+0x242>
														robot.pos.y = ROB_POS_Y_MIN;

														maze_solve_state_path = DRIVE_NEUTRPOS;
													}

													matchingWalls.next ++; //FIFO
    7bf2:	80 93 40 16 	sts	0x1640, r24
    7bf6:	02 c0       	rjmp	.+4      	; 0x7bfc <maze_solve+0x246>
													if(matchingWalls.next >= MATCHINGWALLS_BUFF)
														matchingWalls.next = 0;
    7bf8:	10 92 40 16 	sts	0x1640, r1

													if(robot.pos.z == MAZE_SAVESTAGE)
    7bfc:	80 91 4a 16 	lds	r24, 0x164A
    7c00:	82 30       	cpi	r24, 0x02	; 2
    7c02:	39 f4       	brne	.+14     	; 0x7c12 <maze_solve+0x25c>
													{
														locRequest = LR_MATCH;
    7c04:	81 e0       	ldi	r24, 0x01	; 1
    7c06:	80 93 c4 05 	sts	0x05C4, r24
														maze_solve_state_ready = DR_MATCH;
    7c0a:	84 e0       	ldi	r24, 0x04	; 4
    7c0c:	80 93 cc 05 	sts	0x05CC, r24
    7c10:	ee c3       	rjmp	.+2012   	; 0x83ee <maze_solve+0xa38>
													}
													else
													{
														maze_solve_state_ready = DR_INIT;
    7c12:	10 92 cc 05 	sts	0x05CC, r1
    7c16:	eb c3       	rjmp	.+2006   	; 0x83ee <maze_solve+0xa38>

								break;
						
			case FOLLOW_RIGHTWALL:
							
									if(maze_tileIsVisitable(&robot.pos, robot.dir+1) &&
    7c18:	60 91 4b 16 	lds	r22, 0x164B
    7c1c:	6f 5f       	subi	r22, 0xFF	; 255
    7c1e:	88 e4       	ldi	r24, 0x48	; 72
    7c20:	96 e1       	ldi	r25, 0x16	; 22
    7c22:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7c26:	88 23       	and	r24, r24
    7c28:	51 f0       	breq	.+20     	; 0x7c3e <maze_solve+0x288>
					 					(!maze_getBeenthere(&robot.pos, robot.dir+1)))
    7c2a:	60 91 4b 16 	lds	r22, 0x164B
    7c2e:	6f 5f       	subi	r22, 0xFF	; 255
    7c30:	88 e4       	ldi	r24, 0x48	; 72
    7c32:	96 e1       	ldi	r25, 0x16	; 22
    7c34:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>

								break;
						
			case FOLLOW_RIGHTWALL:
							
									if(maze_tileIsVisitable(&robot.pos, robot.dir+1) &&
    7c38:	88 23       	and	r24, r24
    7c3a:	09 f4       	brne	.+2      	; 0x7c3e <maze_solve+0x288>
    7c3c:	0a c1       	rjmp	.+532    	; 0x7e52 <maze_solve+0x49c>
					 					(!maze_getBeenthere(&robot.pos, robot.dir+1)))
									{
										maze_solve_state_path = TURN_RIGHT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir) &&
    7c3e:	60 91 4b 16 	lds	r22, 0x164B
    7c42:	88 e4       	ldi	r24, 0x48	; 72
    7c44:	96 e1       	ldi	r25, 0x16	; 22
    7c46:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7c4a:	88 23       	and	r24, r24
    7c4c:	49 f0       	breq	.+18     	; 0x7c60 <maze_solve+0x2aa>
					 							 (!maze_getBeenthere(&robot.pos, robot.dir)))
    7c4e:	60 91 4b 16 	lds	r22, 0x164B
    7c52:	88 e4       	ldi	r24, 0x48	; 72
    7c54:	96 e1       	ldi	r25, 0x16	; 22
    7c56:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
									if(maze_tileIsVisitable(&robot.pos, robot.dir+1) &&
					 					(!maze_getBeenthere(&robot.pos, robot.dir+1)))
									{
										maze_solve_state_path = TURN_RIGHT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir) &&
    7c5a:	88 23       	and	r24, r24
    7c5c:	09 f4       	brne	.+2      	; 0x7c60 <maze_solve+0x2aa>
    7c5e:	ed c2       	rjmp	.+1498   	; 0x823a <maze_solve+0x884>
					 							 (!maze_getBeenthere(&robot.pos, robot.dir)))
									{
										maze_solve_state_path = DRIVE_DOT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir+3) &&
    7c60:	60 91 4b 16 	lds	r22, 0x164B
    7c64:	6d 5f       	subi	r22, 0xFD	; 253
    7c66:	88 e4       	ldi	r24, 0x48	; 72
    7c68:	96 e1       	ldi	r25, 0x16	; 22
    7c6a:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7c6e:	88 23       	and	r24, r24
    7c70:	51 f0       	breq	.+20     	; 0x7c86 <maze_solve+0x2d0>
					 							 (!maze_getBeenthere(&robot.pos, robot.dir+3)))
    7c72:	60 91 4b 16 	lds	r22, 0x164B
    7c76:	6d 5f       	subi	r22, 0xFD	; 253
    7c78:	88 e4       	ldi	r24, 0x48	; 72
    7c7a:	96 e1       	ldi	r25, 0x16	; 22
    7c7c:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
									else if(maze_tileIsVisitable(&robot.pos, robot.dir) &&
					 							 (!maze_getBeenthere(&robot.pos, robot.dir)))
									{
										maze_solve_state_path = DRIVE_DOT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir+3) &&
    7c80:	88 23       	and	r24, r24
    7c82:	09 f4       	brne	.+2      	; 0x7c86 <maze_solve+0x2d0>
    7c84:	0c c1       	rjmp	.+536    	; 0x7e9e <maze_solve+0x4e8>
					 							 (!maze_getBeenthere(&robot.pos, robot.dir+3)))
									{
										maze_solve_state_path = TURN_LEFT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir+2) &&
    7c86:	60 91 4b 16 	lds	r22, 0x164B
    7c8a:	6e 5f       	subi	r22, 0xFE	; 254
    7c8c:	88 e4       	ldi	r24, 0x48	; 72
    7c8e:	96 e1       	ldi	r25, 0x16	; 22
    7c90:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
    7c94:	88 23       	and	r24, r24
    7c96:	51 f0       	breq	.+20     	; 0x7cac <maze_solve+0x2f6>
					 							 (!maze_getBeenthere(&robot.pos, robot.dir+2)))
    7c98:	60 91 4b 16 	lds	r22, 0x164B
    7c9c:	6e 5f       	subi	r22, 0xFE	; 254
    7c9e:	88 e4       	ldi	r24, 0x48	; 72
    7ca0:	96 e1       	ldi	r25, 0x16	; 22
    7ca2:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
									else if(maze_tileIsVisitable(&robot.pos, robot.dir+3) &&
					 							 (!maze_getBeenthere(&robot.pos, robot.dir+3)))
									{
										maze_solve_state_path = TURN_LEFT;
									}
									else if(maze_tileIsVisitable(&robot.pos, robot.dir+2) &&
    7ca6:	88 23       	and	r24, r24
    7ca8:	09 f4       	brne	.+2      	; 0x7cac <maze_solve+0x2f6>
    7caa:	f9 c0       	rjmp	.+498    	; 0x7e9e <maze_solve+0x4e8>
									{
										maze_solve_state_path = TURN_LEFT;
									}
									else //No more possibilitys! Calculate Route to nearest, unvisited tile.
									{
										switch(routeRequest)
    7cac:	80 91 c6 05 	lds	r24, 0x05C6
    7cb0:	90 e0       	ldi	r25, 0x00	; 0
    7cb2:	89 30       	cpi	r24, 0x09	; 9
    7cb4:	91 05       	cpc	r25, r1
    7cb6:	08 f0       	brcs	.+2      	; 0x7cba <maze_solve+0x304>
    7cb8:	81 c0       	rjmp	.+258    	; 0x7dbc <maze_solve+0x406>
    7cba:	fc 01       	movw	r30, r24
    7cbc:	e0 55       	subi	r30, 0x50	; 80
    7cbe:	ff 4f       	sbci	r31, 0xFF	; 255
    7cc0:	0c 94 d2 6b 	jmp	0xd7a4	; 0xd7a4 <__tablejump2__>
										{
											case RR_WAIT:					routeRequest = RR_CALCNEARESTTILE;	break;
    7cc4:	81 e0       	ldi	r24, 0x01	; 1
    7cc6:	77 c0       	rjmp	.+238    	; 0x7db6 <maze_solve+0x400>
						
											case RR_RTTIMEOUT:													break; //To do... Restart?
											case RR_NEARTIMEOUT:												break; //"

											case RR_NEARDONE:
											case RR_RTDONE:					rt_noposs_radius = 0;
    7cc8:	10 92 c9 05 	sts	0x05C9, r1
																			routeRequest = RR_WAIT;
    7ccc:	10 92 c6 05 	sts	0x05C6, r1
																			maze_solve_state_path = FOLLOW_DFS;
    7cd0:	82 e0       	ldi	r24, 0x02	; 2
    7cd2:	b4 c2       	rjmp	.+1384   	; 0x823c <maze_solve+0x886>
																											break; //Drive via path
											case RR_NEARNOPOSS: //No unvisited tiles in the maze
						
																			rr_result = *maze_getStartPos(); //Request start position, save it in the vars for the route calculation
    7cd4:	0e 94 2a 48 	call	0x9054	; 0x9054 <maze_getStartPos>
    7cd8:	fc 01       	movw	r30, r24
    7cda:	80 81       	ld	r24, Z
    7cdc:	91 81       	ldd	r25, Z+1	; 0x01
    7cde:	a2 81       	ldd	r26, Z+2	; 0x02
    7ce0:	80 93 58 08 	sts	0x0858, r24
    7ce4:	90 93 59 08 	sts	0x0859, r25
    7ce8:	a0 93 5a 08 	sts	0x085A, r26

																			if(!maze_cmpCoords(&robot.pos, &rr_result))
    7cec:	68 e5       	ldi	r22, 0x58	; 88
    7cee:	78 e0       	ldi	r23, 0x08	; 8
    7cf0:	88 e4       	ldi	r24, 0x48	; 72
    7cf2:	96 e1       	ldi	r25, 0x16	; 22
    7cf4:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    7cf8:	81 11       	cpse	r24, r1
    7cfa:	02 c0       	rjmp	.+4      	; 0x7d00 <maze_solve+0x34a>
																			{
																				routeRequest = RR_CALCROUTE;
    7cfc:	82 e0       	ldi	r24, 0x02	; 2
    7cfe:	5b c0       	rjmp	.+182    	; 0x7db6 <maze_solve+0x400>
																			}
																			else
																			{
																				maze_solve_state_path = RESTART; //Robot is at start Position -> Restart
    7d00:	84 e0       	ldi	r24, 0x04	; 4
    7d02:	9c c2       	rjmp	.+1336   	; 0x823c <maze_solve+0x886>
																		break;
						
											case RR_RTNOPOSS:	//Thats bad. The robot detected a wall wrong and cant find the way or someone put the walls from their places. ;)

																			cleartiles.beenthere = 0;
																			cleartiles.depthsearch = 1;
    7d04:	21 e0       	ldi	r18, 0x01	; 1
    7d06:	20 93 49 08 	sts	0x0849, r18
																			cleartiles.ground = 1;
    7d0a:	82 e0       	ldi	r24, 0x02	; 2
    7d0c:	80 93 43 08 	sts	0x0843, r24
																			cleartiles.wall_s = 1;
    7d10:	20 93 44 08 	sts	0x0844, r18
																			cleartiles.wall_w = 1;
    7d14:	20 93 45 08 	sts	0x0845, r18

																			COORD c = robot.pos;
    7d18:	80 91 48 16 	lds	r24, 0x1648
    7d1c:	90 91 49 16 	lds	r25, 0x1649
    7d20:	a0 91 4a 16 	lds	r26, 0x164A
    7d24:	89 83       	std	Y+1, r24	; 0x01
    7d26:	9a 83       	std	Y+2, r25	; 0x02
    7d28:	ab 83       	std	Y+3, r26	; 0x03

																			rt_noposs_radius = 1;
    7d2a:	20 93 c9 05 	sts	0x05C9, r18

																			if((rt_noposs_radius < (MAZE_SIZE_X_USABLE)/2) &&
																				(rt_noposs_radius < (MAZE_SIZE_Y_USABLE)/2))
																			{
																				for(c.y = robot.pos.y-rt_noposs_radius; c.y <= robot.pos.y+rt_noposs_radius; c.y++)
    7d2e:	80 91 49 16 	lds	r24, 0x1649
    7d32:	81 50       	subi	r24, 0x01	; 1
    7d34:	8a 83       	std	Y+2, r24	; 0x02
    7d36:	40 91 c9 05 	lds	r20, 0x05C9
    7d3a:	2a 81       	ldd	r18, Y+2	; 0x02
    7d3c:	33 27       	eor	r19, r19
    7d3e:	27 fd       	sbrc	r18, 7
    7d40:	30 95       	com	r19
    7d42:	50 91 49 16 	lds	r21, 0x1649
    7d46:	84 2f       	mov	r24, r20
    7d48:	90 e0       	ldi	r25, 0x00	; 0
    7d4a:	85 0f       	add	r24, r21
    7d4c:	91 1d       	adc	r25, r1
    7d4e:	57 fd       	sbrc	r21, 7
    7d50:	9a 95       	dec	r25
    7d52:	82 17       	cp	r24, r18
    7d54:	93 07       	cpc	r25, r19
    7d56:	44 f1       	brlt	.+80     	; 0x7da8 <maze_solve+0x3f2>
																				{
																					for(c.x = robot.pos.x-rt_noposs_radius; c.x <= robot.pos.x+rt_noposs_radius; c.x++)
    7d58:	80 91 48 16 	lds	r24, 0x1648
    7d5c:	84 1b       	sub	r24, r20
    7d5e:	89 83       	std	Y+1, r24	; 0x01
    7d60:	49 81       	ldd	r20, Y+1	; 0x01
    7d62:	24 2f       	mov	r18, r20
    7d64:	33 27       	eor	r19, r19
    7d66:	27 fd       	sbrc	r18, 7
    7d68:	30 95       	com	r19
    7d6a:	50 91 48 16 	lds	r21, 0x1648
    7d6e:	80 91 c9 05 	lds	r24, 0x05C9
    7d72:	90 e0       	ldi	r25, 0x00	; 0
    7d74:	85 0f       	add	r24, r21
    7d76:	91 1d       	adc	r25, r1
    7d78:	57 fd       	sbrc	r21, 7
    7d7a:	9a 95       	dec	r25
    7d7c:	82 17       	cp	r24, r18
    7d7e:	93 07       	cpc	r25, r19
    7d80:	84 f0       	brlt	.+32     	; 0x7da2 <maze_solve+0x3ec>
																					{
																						if((c.x >= ROB_POS_X_MIN) && (c.x <= MAZE_SIZE_X_USABLE) &&
    7d82:	41 50       	subi	r20, 0x01	; 1
    7d84:	4c 30       	cpi	r20, 0x0C	; 12
    7d86:	50 f4       	brcc	.+20     	; 0x7d9c <maze_solve+0x3e6>
    7d88:	8a 81       	ldd	r24, Y+2	; 0x02
    7d8a:	81 50       	subi	r24, 0x01	; 1
    7d8c:	8c 30       	cpi	r24, 0x0C	; 12
    7d8e:	30 f4       	brcc	.+12     	; 0x7d9c <maze_solve+0x3e6>
																						   (c.y >= ROB_POS_Y_MIN) && (c.y <= MAZE_SIZE_Y_USABLE))
																								maze_clearTile(&c, &cleartiles);
    7d90:	63 e4       	ldi	r22, 0x43	; 67
    7d92:	78 e0       	ldi	r23, 0x08	; 8
    7d94:	ce 01       	movw	r24, r28
    7d96:	01 96       	adiw	r24, 0x01	; 1
    7d98:	0e 94 01 49 	call	0x9202	; 0x9202 <maze_clearTile>
																			if((rt_noposs_radius < (MAZE_SIZE_X_USABLE)/2) &&
																				(rt_noposs_radius < (MAZE_SIZE_Y_USABLE)/2))
																			{
																				for(c.y = robot.pos.y-rt_noposs_radius; c.y <= robot.pos.y+rt_noposs_radius; c.y++)
																				{
																					for(c.x = robot.pos.x-rt_noposs_radius; c.x <= robot.pos.x+rt_noposs_radius; c.x++)
    7d9c:	89 81       	ldd	r24, Y+1	; 0x01
    7d9e:	8f 5f       	subi	r24, 0xFF	; 255
    7da0:	de cf       	rjmp	.-68     	; 0x7d5e <maze_solve+0x3a8>
																			rt_noposs_radius = 1;

																			if((rt_noposs_radius < (MAZE_SIZE_X_USABLE)/2) &&
																				(rt_noposs_radius < (MAZE_SIZE_Y_USABLE)/2))
																			{
																				for(c.y = robot.pos.y-rt_noposs_radius; c.y <= robot.pos.y+rt_noposs_radius; c.y++)
    7da2:	8a 81       	ldd	r24, Y+2	; 0x02
    7da4:	8f 5f       	subi	r24, 0xFF	; 255
    7da6:	c6 cf       	rjmp	.-116    	; 0x7d34 <maze_solve+0x37e>
																						   (c.y >= ROB_POS_Y_MIN) && (c.y <= MAZE_SIZE_Y_USABLE))
																								maze_clearTile(&c, &cleartiles);
																					}
																				}

																				rt_noposs_radius ++;
    7da8:	4f 5f       	subi	r20, 0xFF	; 255
    7daa:	40 93 c9 05 	sts	0x05C9, r20
																			else
																			{
																				maze_clear(&cleartiles);
																			}

																			maze_solve_state_path = FOLLOW_RIGHTWALL;
    7dae:	81 e0       	ldi	r24, 0x01	; 1
    7db0:	80 93 cd 05 	sts	0x05CD, r24
																			routeRequest = RR_NEARNOPOSS;
    7db4:	84 e0       	ldi	r24, 0x04	; 4
    7db6:	80 93 c6 05 	sts	0x05C6, r24

																		break;
    7dba:	19 c3       	rjmp	.+1586   	; 0x83ee <maze_solve+0xa38>
											default:
																if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.03]:DEFAULT_CASE"));}
    7dbc:	80 91 53 05 	lds	r24, 0x0553
    7dc0:	82 30       	cpi	r24, 0x02	; 2
    7dc2:	08 f4       	brcc	.+2      	; 0x7dc6 <maze_solve+0x410>
    7dc4:	0e c3       	rjmp	.+1564   	; 0x83e2 <maze_solve+0xa2c>
    7dc6:	8e e8       	ldi	r24, 0x8E	; 142
    7dc8:	9a e2       	ldi	r25, 0x2A	; 42
    7dca:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    7dce:	60 91 47 05 	lds	r22, 0x0547
    7dd2:	70 91 48 05 	lds	r23, 0x0548
    7dd6:	80 91 49 05 	lds	r24, 0x0549
    7dda:	90 91 4a 05 	lds	r25, 0x054A
    7dde:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    7de2:	88 e5       	ldi	r24, 0x58	; 88
    7de4:	9a e2       	ldi	r25, 0x2A	; 42
    7de6:	fb c2       	rjmp	.+1526   	; 0x83de <maze_solve+0xa28>
				
						break;
				
			case FOLLOW_DFS:
	
									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
    7de8:	60 e0       	ldi	r22, 0x00	; 0
    7dea:	88 e4       	ldi	r24, 0x48	; 72
    7dec:	96 e1       	ldi	r25, 0x16	; 22
    7dee:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7df2:	18 2f       	mov	r17, r24

									if((maze_getDepthsearch(&robot.pos, robot.dir) < depthsearchNum) &&
    7df4:	60 91 4b 16 	lds	r22, 0x164B
    7df8:	88 e4       	ldi	r24, 0x48	; 72
    7dfa:	96 e1       	ldi	r25, 0x16	; 22
    7dfc:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7e00:	81 17       	cp	r24, r17
    7e02:	40 f4       	brcc	.+16     	; 0x7e14 <maze_solve+0x45e>
													 maze_tileIsVisitable(&robot.pos, robot.dir))
    7e04:	60 91 4b 16 	lds	r22, 0x164B
    7e08:	88 e4       	ldi	r24, 0x48	; 72
    7e0a:	96 e1       	ldi	r25, 0x16	; 22
    7e0c:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
				
			case FOLLOW_DFS:
	
									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);

									if((maze_getDepthsearch(&robot.pos, robot.dir) < depthsearchNum) &&
    7e10:	81 11       	cpse	r24, r1
    7e12:	13 c2       	rjmp	.+1062   	; 0x823a <maze_solve+0x884>
													 maze_tileIsVisitable(&robot.pos, robot.dir))
									{
										maze_solve_state_path = DRIVE_DOT; //Geradeaus
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+1) < depthsearchNum) &&
    7e14:	60 91 4b 16 	lds	r22, 0x164B
    7e18:	6f 5f       	subi	r22, 0xFF	; 255
    7e1a:	88 e4       	ldi	r24, 0x48	; 72
    7e1c:	96 e1       	ldi	r25, 0x16	; 22
    7e1e:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7e22:	81 17       	cp	r24, r17
    7e24:	c0 f4       	brcc	.+48     	; 0x7e56 <maze_solve+0x4a0>
											maze_tileIsVisitable(&robot.pos, robot.dir+1))
    7e26:	60 91 4b 16 	lds	r22, 0x164B
    7e2a:	6f 5f       	subi	r22, 0xFF	; 255
    7e2c:	88 e4       	ldi	r24, 0x48	; 72
    7e2e:	96 e1       	ldi	r25, 0x16	; 22
    7e30:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
									if((maze_getDepthsearch(&robot.pos, robot.dir) < depthsearchNum) &&
													 maze_tileIsVisitable(&robot.pos, robot.dir))
									{
										maze_solve_state_path = DRIVE_DOT; //Geradeaus
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+1) < depthsearchNum) &&
    7e34:	88 23       	and	r24, r24
    7e36:	79 f0       	breq	.+30     	; 0x7e56 <maze_solve+0x4a0>
											maze_tileIsVisitable(&robot.pos, robot.dir+1))
									{
										bt_putLong(maze_getDepthsearch(&robot.pos, robot.dir+1));
    7e38:	60 91 4b 16 	lds	r22, 0x164B
    7e3c:	6f 5f       	subi	r22, 0xFF	; 255
    7e3e:	88 e4       	ldi	r24, 0x48	; 72
    7e40:	96 e1       	ldi	r25, 0x16	; 22
    7e42:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7e46:	68 2f       	mov	r22, r24
    7e48:	70 e0       	ldi	r23, 0x00	; 0
    7e4a:	80 e0       	ldi	r24, 0x00	; 0
    7e4c:	90 e0       	ldi	r25, 0x00	; 0
    7e4e:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
										maze_solve_state_path = TURN_RIGHT;
    7e52:	88 e0       	ldi	r24, 0x08	; 8
    7e54:	f3 c1       	rjmp	.+998    	; 0x823c <maze_solve+0x886>
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+3) < depthsearchNum) &&
    7e56:	60 91 4b 16 	lds	r22, 0x164B
    7e5a:	6d 5f       	subi	r22, 0xFD	; 253
    7e5c:	88 e4       	ldi	r24, 0x48	; 72
    7e5e:	96 e1       	ldi	r25, 0x16	; 22
    7e60:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7e64:	81 17       	cp	r24, r17
    7e66:	48 f4       	brcc	.+18     	; 0x7e7a <maze_solve+0x4c4>
													 maze_tileIsVisitable(&robot.pos, robot.dir+3))
    7e68:	60 91 4b 16 	lds	r22, 0x164B
    7e6c:	6d 5f       	subi	r22, 0xFD	; 253
    7e6e:	88 e4       	ldi	r24, 0x48	; 72
    7e70:	96 e1       	ldi	r25, 0x16	; 22
    7e72:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
											maze_tileIsVisitable(&robot.pos, robot.dir+1))
									{
										bt_putLong(maze_getDepthsearch(&robot.pos, robot.dir+1));
										maze_solve_state_path = TURN_RIGHT;
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+3) < depthsearchNum) &&
    7e76:	81 11       	cpse	r24, r1
    7e78:	12 c0       	rjmp	.+36     	; 0x7e9e <maze_solve+0x4e8>
													 maze_tileIsVisitable(&robot.pos, robot.dir+3))
									{
										maze_solve_state_path = TURN_LEFT;
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+2) < depthsearchNum) &&
    7e7a:	60 91 4b 16 	lds	r22, 0x164B
    7e7e:	6e 5f       	subi	r22, 0xFE	; 254
    7e80:	88 e4       	ldi	r24, 0x48	; 72
    7e82:	96 e1       	ldi	r25, 0x16	; 22
    7e84:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7e88:	81 17       	cp	r24, r17
    7e8a:	58 f4       	brcc	.+22     	; 0x7ea2 <maze_solve+0x4ec>
													 maze_tileIsVisitable(&robot.pos, robot.dir+2))
    7e8c:	60 91 4b 16 	lds	r22, 0x164B
    7e90:	6e 5f       	subi	r22, 0xFE	; 254
    7e92:	88 e4       	ldi	r24, 0x48	; 72
    7e94:	96 e1       	ldi	r25, 0x16	; 22
    7e96:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
									else if((maze_getDepthsearch(&robot.pos, robot.dir+3) < depthsearchNum) &&
													 maze_tileIsVisitable(&robot.pos, robot.dir+3))
									{
										maze_solve_state_path = TURN_LEFT;
									}
									else if((maze_getDepthsearch(&robot.pos, robot.dir+2) < depthsearchNum) &&
    7e9a:	88 23       	and	r24, r24
    7e9c:	11 f0       	breq	.+4      	; 0x7ea2 <maze_solve+0x4ec>
													 maze_tileIsVisitable(&robot.pos, robot.dir+2))
									{
										maze_solve_state_path = TURN_LEFT;
    7e9e:	89 e0       	ldi	r24, 0x09	; 9
    7ea0:	cd c1       	rjmp	.+922    	; 0x823c <maze_solve+0x886>
									}
									else
									{
										maze_clearDepthsearch();
    7ea2:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
										maze_solve_state_path = FOLLOW_RIGHTWALL;
    7ea6:	81 e0       	ldi	r24, 0x01	; 1
    7ea8:	80 93 cd 05 	sts	0x05CD, r24
    7eac:	a1 c2       	rjmp	.+1346   	; 0x83f0 <maze_solve+0xa3a>
							
								break;
								
			case MAZE_ERR:
									
									mot.d[LEFT].speed.to = 0;
    7eae:	10 92 6a 16 	sts	0x166A, r1
    7eb2:	10 92 69 16 	sts	0x1669, r1
									mot.d[RIGHT].speed.to = 0;
    7eb6:	10 92 76 16 	sts	0x1676, r1
    7eba:	10 92 75 16 	sts	0x1675, r1
    7ebe:	97 c2       	rjmp	.+1326   	; 0x83ee <maze_solve+0xa38>
									
								break;
								
			case RESTART:
							
									mot.d[LEFT].speed.to = 0;
    7ec0:	10 92 6a 16 	sts	0x166A, r1
    7ec4:	10 92 69 16 	sts	0x1669, r1
									mot.d[RIGHT].speed.to = 0;
    7ec8:	10 92 76 16 	sts	0x1676, r1
    7ecc:	10 92 75 16 	sts	0x1675, r1

									returnvar = 0; //0 zurckgeben, wenn fertig, sonst 1

									if(timer_rdy_restart == -1)
    7ed0:	80 91 93 02 	lds	r24, 0x0293
    7ed4:	90 91 94 02 	lds	r25, 0x0294
    7ed8:	01 96       	adiw	r24, 0x01	; 1
    7eda:	31 f4       	brne	.+12     	; 0x7ee8 <maze_solve+0x532>
										timer_rdy_restart = TIMER_RDY_RESTART; //Setze Timer
    7edc:	88 e5       	ldi	r24, 0x58	; 88
    7ede:	92 e0       	ldi	r25, 0x02	; 2
    7ee0:	90 93 94 02 	sts	0x0294, r25
    7ee4:	80 93 93 02 	sts	0x0293, r24

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
    7ee8:	60 e0       	ldi	r22, 0x00	; 0
    7eea:	88 e4       	ldi	r24, 0x48	; 72
    7eec:	96 e1       	ldi	r25, 0x16	; 22
    7eee:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7ef2:	e8 2e       	mov	r14, r24
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
    7ef4:	ff 24       	eor	r15, r15
    7ef6:	f3 94       	inc	r15
										if(((maze_getDepthsearch(&robot.pos, dir) < depthsearchNum) ||
												(!maze_getBeenthere(&robot.pos, dir))) &&
												maze_tileIsVisitable(&robot.pos, dir))
										{
											maze_clearDepthsearch();
											timer_rdy_restart = -1;
    7ef8:	0f ef       	ldi	r16, 0xFF	; 255
    7efa:	1f ef       	ldi	r17, 0xFF	; 255
											maze_solve_state_path = FOLLOW_RIGHTWALL; //When the program came into RESTART by RR_RTNOPOSS and there is suddenly an option (Wall wrong detected?) proceed!
    7efc:	dd 24       	eor	r13, r13
    7efe:	d3 94       	inc	r13
										timer_rdy_restart = TIMER_RDY_RESTART; //Setze Timer

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
									{
										if(((maze_getDepthsearch(&robot.pos, dir) < depthsearchNum) ||
    7f00:	6f 2d       	mov	r22, r15
    7f02:	88 e4       	ldi	r24, 0x48	; 72
    7f04:	96 e1       	ldi	r25, 0x16	; 22
    7f06:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    7f0a:	8e 15       	cp	r24, r14
    7f0c:	80 f4       	brcc	.+32     	; 0x7f2e <maze_solve+0x578>
												(!maze_getBeenthere(&robot.pos, dir))) &&
												maze_tileIsVisitable(&robot.pos, dir))
    7f0e:	6f 2d       	mov	r22, r15
    7f10:	88 e4       	ldi	r24, 0x48	; 72
    7f12:	96 e1       	ldi	r25, 0x16	; 22
    7f14:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
									{
										if(((maze_getDepthsearch(&robot.pos, dir) < depthsearchNum) ||
												(!maze_getBeenthere(&robot.pos, dir))) &&
    7f18:	88 23       	and	r24, r24
    7f1a:	81 f0       	breq	.+32     	; 0x7f3c <maze_solve+0x586>
												maze_tileIsVisitable(&robot.pos, dir))
										{
											maze_clearDepthsearch();
    7f1c:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
											timer_rdy_restart = -1;
    7f20:	10 93 94 02 	sts	0x0294, r17
    7f24:	00 93 93 02 	sts	0x0293, r16
											maze_solve_state_path = FOLLOW_RIGHTWALL; //When the program came into RESTART by RR_RTNOPOSS and there is suddenly an option (Wall wrong detected?) proceed!
    7f28:	d0 92 cd 05 	sts	0x05CD, r13
    7f2c:	07 c0       	rjmp	.+14     	; 0x7f3c <maze_solve+0x586>

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
									{
										if(((maze_getDepthsearch(&robot.pos, dir) < depthsearchNum) ||
												(!maze_getBeenthere(&robot.pos, dir))) &&
    7f2e:	6f 2d       	mov	r22, r15
    7f30:	88 e4       	ldi	r24, 0x48	; 72
    7f32:	96 e1       	ldi	r25, 0x16	; 22
    7f34:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
										timer_rdy_restart = TIMER_RDY_RESTART; //Setze Timer

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
									{
										if(((maze_getDepthsearch(&robot.pos, dir) < depthsearchNum) ||
    7f38:	88 23       	and	r24, r24
    7f3a:	49 f3       	breq	.-46     	; 0x7f0e <maze_solve+0x558>

									if(timer_rdy_restart == -1)
										timer_rdy_restart = TIMER_RDY_RESTART; //Setze Timer

									depthsearchNum = maze_getDepthsearch(&robot.pos, NONE);
									for(uint8_t dir = NORTH; dir <= WEST; dir++) //check for each direction
    7f3c:	f3 94       	inc	r15
    7f3e:	25 e0       	ldi	r18, 0x05	; 5
    7f40:	f2 12       	cpse	r15, r18
    7f42:	de cf       	rjmp	.-68     	; 0x7f00 <maze_solve+0x54a>
											timer_rdy_restart = -1;
											maze_solve_state_path = FOLLOW_RIGHTWALL; //When the program came into RESTART by RR_RTNOPOSS and there is suddenly an option (Wall wrong detected?) proceed!
										}
									}

									maze_updateWalls();
    7f44:	75 dc       	rcall	.-1814   	; 0x7830 <maze_updateWalls>
    7f46:	80 91 53 05 	lds	r24, 0x0553

									if(debug > 0){bt_putStr_P(PSTR("\r")); bt_putLong(timer); bt_putStr_P(PSTR(": DONE::restart:")); bt_putLong(timer_rdy_restart*25); bt_putStr_P(PSTR("ms"));}
    7f4a:	88 23       	and	r24, r24
    7f4c:	09 f4       	brne	.+2      	; 0x7f50 <maze_solve+0x59a>
    7f4e:	4d c2       	rjmp	.+1178   	; 0x83ea <maze_solve+0xa34>
    7f50:	86 e5       	ldi	r24, 0x56	; 86
    7f52:	9a e2       	ldi	r25, 0x2A	; 42
    7f54:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    7f58:	60 91 47 05 	lds	r22, 0x0547
    7f5c:	70 91 48 05 	lds	r23, 0x0548
    7f60:	80 91 49 05 	lds	r24, 0x0549
    7f64:	90 91 4a 05 	lds	r25, 0x054A
    7f68:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    7f6c:	85 e4       	ldi	r24, 0x45	; 69
    7f6e:	9a e2       	ldi	r25, 0x2A	; 42
    7f70:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    7f74:	80 91 93 02 	lds	r24, 0x0293
    7f78:	90 91 94 02 	lds	r25, 0x0294
    7f7c:	29 e1       	ldi	r18, 0x19	; 25
    7f7e:	28 9f       	mul	r18, r24
    7f80:	b0 01       	movw	r22, r0
    7f82:	29 9f       	mul	r18, r25
    7f84:	70 0d       	add	r23, r0
    7f86:	11 24       	eor	r1, r1
    7f88:	88 27       	eor	r24, r24
    7f8a:	77 fd       	sbrc	r23, 7
    7f8c:	80 95       	com	r24
    7f8e:	98 2f       	mov	r25, r24
    7f90:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    7f94:	82 e4       	ldi	r24, 0x42	; 66
    7f96:	9a e2       	ldi	r25, 0x2A	; 42
    7f98:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    7f9c:	26 c2       	rjmp	.+1100   	; 0x83ea <maze_solve+0xa34>
    7f9e:	60 e0       	ldi	r22, 0x00	; 0
			///////////////////////////////////////////////////////////////////////////////
			
			case DRIVE_DOT:
									
									////////////////
									if((maze_getRampPosDirAtDir(&robot.pos, NONE) == robot.dir) &&
    7fa0:	88 e4       	ldi	r24, 0x48	; 72
    7fa2:	96 e1       	ldi	r25, 0x16	; 22
    7fa4:	0e 94 19 53 	call	0xa632	; 0xa632 <maze_getRampPosDirAtDir>
    7fa8:	90 e0       	ldi	r25, 0x00	; 0
    7faa:	20 91 4b 16 	lds	r18, 0x164B
    7fae:	33 27       	eor	r19, r19
    7fb0:	27 fd       	sbrc	r18, 7
    7fb2:	30 95       	com	r19
    7fb4:	82 17       	cp	r24, r18
    7fb6:	93 07       	cpc	r25, r19
    7fb8:	31 f4       	brne	.+12     	; 0x7fc6 <maze_solve+0x610>
    7fba:	80 91 4a 16 	lds	r24, 0x164A
    7fbe:	81 11       	cpse	r24, r1
    7fc0:	02 c0       	rjmp	.+4      	; 0x7fc6 <maze_solve+0x610>
    7fc2:	8a e0       	ldi	r24, 0x0A	; 10
										 (robot.pos.z == 0))
									{
										maze_solve_state_path = RAMP_UP; //Rampe hoch
    7fc4:	3b c1       	rjmp	.+630    	; 0x823c <maze_solve+0x886>
    7fc6:	60 e0       	ldi	r22, 0x00	; 0
									}
									else if((maze_getRampPosDirAtDir(&robot.pos, NONE) == robot.dir) &&
    7fc8:	88 e4       	ldi	r24, 0x48	; 72
    7fca:	96 e1       	ldi	r25, 0x16	; 22
    7fcc:	0e 94 19 53 	call	0xa632	; 0xa632 <maze_getRampPosDirAtDir>
    7fd0:	90 e0       	ldi	r25, 0x00	; 0
    7fd2:	20 91 4b 16 	lds	r18, 0x164B
    7fd6:	33 27       	eor	r19, r19
    7fd8:	27 fd       	sbrc	r18, 7
    7fda:	30 95       	com	r19
    7fdc:	82 17       	cp	r24, r18
    7fde:	93 07       	cpc	r25, r19
    7fe0:	31 f4       	brne	.+12     	; 0x7fee <maze_solve+0x638>
    7fe2:	80 91 4a 16 	lds	r24, 0x164A
    7fe6:	81 30       	cpi	r24, 0x01	; 1
    7fe8:	11 f4       	brne	.+4      	; 0x7fee <maze_solve+0x638>
    7fea:	8b e0       	ldi	r24, 0x0B	; 11
													(robot.pos.z == 1))
									{
										maze_solve_state_path = RAMP_DOWN; //Rampe runter
    7fec:	27 c1       	rjmp	.+590    	; 0x823c <maze_solve+0x886>
    7fee:	80 91 c8 05 	lds	r24, 0x05C8
									}
									else
									{
										driveVar = drive_oneTile(dot_abort);
    7ff2:	0e 94 f0 2b 	call	0x57e0	; 0x57e0 <drive_oneTile>
    7ff6:	85 30       	cpi	r24, 0x05	; 5
									
										if((driveVar == DOT_RET_INIT) && !dot_abort)
    7ff8:	99 f4       	brne	.+38     	; 0x8020 <maze_solve+0x66a>
    7ffa:	80 91 c8 05 	lds	r24, 0x05C8
    7ffe:	81 11       	cpse	r24, r1
    8000:	f6 c1       	rjmp	.+1004   	; 0x83ee <maze_solve+0xa38>
    8002:	10 92 c7 05 	sts	0x05C7, r1
										{
											dot_driven_oneTile = 0;
    8006:	10 92 59 16 	sts	0x1659, r1

											groundsens_cnt = 0;
    800a:	10 92 58 16 	sts	0x1658, r1
    800e:	80 91 0a 17 	lds	r24, 0x170A
											ramp_start = um6.theta_t;
    8012:	90 91 0b 17 	lds	r25, 0x170B
    8016:	90 93 57 08 	sts	0x0857, r25
    801a:	80 93 56 08 	sts	0x0856, r24
    801e:	e7 c1       	rjmp	.+974    	; 0x83ee <maze_solve+0xa38>
    8020:	81 30       	cpi	r24, 0x01	; 1
										}
										else if(driveVar == DOT_RET_ALIGN)
										{}
										else if((driveVar == AB_15) || (driveVar == UD_15)) //Driving... Dont change! See rotations in drive_oneTile...
    8022:	09 f4       	brne	.+2      	; 0x8026 <maze_solve+0x670>
    8024:	e4 c1       	rjmp	.+968    	; 0x83ee <maze_solve+0xa38>
    8026:	9d ef       	ldi	r25, 0xFD	; 253
    8028:	98 0f       	add	r25, r24
    802a:	92 30       	cpi	r25, 0x02	; 2
    802c:	08 f4       	brcc	.+2      	; 0x8030 <maze_solve+0x67a>
    802e:	df c1       	rjmp	.+958    	; 0x83ee <maze_solve+0xa38>
    8030:	82 30       	cpi	r24, 0x02	; 2
											//	maze_corrGround(&robot.pos, robot.dir, -1);

											if((groundsens_l < GROUNDSENS_L_TH_CHECKPOINT) && (driveVar == AB_15))
												groundsens_cnt ++;*/
										}
										else if((driveVar == NOW_15) || (driveVar == AT_15)) //Mitte beim Geradeausfahren (bergang 2 Fliesen)
    8032:	21 f0       	breq	.+8      	; 0x803c <maze_solve+0x686>
    8034:	86 30       	cpi	r24, 0x06	; 6
    8036:	09 f0       	breq	.+2      	; 0x803a <maze_solve+0x684>
    8038:	c6 c0       	rjmp	.+396    	; 0x81c6 <maze_solve+0x810>
    803a:	27 c0       	rjmp	.+78     	; 0x808a <maze_solve+0x6d4>
    803c:	80 91 c7 05 	lds	r24, 0x05C7
										{
											if(driveVar == NOW_15)
											{
												dot_driven_oneTile ++;
    8040:	8f 5f       	subi	r24, 0xFF	; 255
    8042:	80 93 c7 05 	sts	0x05C7, r24
    8046:	80 91 4b 16 	lds	r24, 0x164B

												switch(robot.dir)
    804a:	82 30       	cpi	r24, 0x02	; 2
    804c:	f1 f1       	breq	.+124    	; 0x80ca <maze_solve+0x714>
    804e:	1c f4       	brge	.+6      	; 0x8056 <maze_solve+0x6a0>
    8050:	81 30       	cpi	r24, 0x01	; 1
    8052:	b9 f1       	breq	.+110    	; 0x80c2 <maze_solve+0x70c>
    8054:	04 c0       	rjmp	.+8      	; 0x805e <maze_solve+0x6a8>
    8056:	83 30       	cpi	r24, 0x03	; 3
    8058:	51 f1       	breq	.+84     	; 0x80ae <maze_solve+0x6f8>
    805a:	84 30       	cpi	r24, 0x04	; 4
    805c:	71 f1       	breq	.+92     	; 0x80ba <maze_solve+0x704>
    805e:	80 91 53 05 	lds	r24, 0x0553
												{
													case NORTH:	robot.pos.y++;	break;
													case EAST:	robot.pos.x++;	break;
													case SOUTH:	robot.pos.y--;	break;
													case WEST:	robot.pos.x--;	break;
													default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.02]:DEFAULT_CASE"));}
    8062:	82 30       	cpi	r24, 0x02	; 2
    8064:	08 f4       	brcc	.+2      	; 0x8068 <maze_solve+0x6b2>
    8066:	4d c0       	rjmp	.+154    	; 0x8102 <maze_solve+0x74c>
    8068:	8f e3       	ldi	r24, 0x3F	; 63
    806a:	9a e2       	ldi	r25, 0x2A	; 42
    806c:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8070:	60 91 47 05 	lds	r22, 0x0547
    8074:	70 91 48 05 	lds	r23, 0x0548
    8078:	80 91 49 05 	lds	r24, 0x0549
    807c:	90 91 4a 05 	lds	r25, 0x054A
    8080:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    8084:	89 e0       	ldi	r24, 0x09	; 9
    8086:	9a e2       	ldi	r25, 0x2A	; 42
    8088:	3a c0       	rjmp	.+116    	; 0x80fe <maze_solve+0x748>
    808a:	80 91 c7 05 	lds	r24, 0x05C7
																		fatal_err = 1;
												}
											}
											else //AT_15 (Rckgngig machen)
											{
												dot_driven_oneTile --;
    808e:	81 50       	subi	r24, 0x01	; 1
    8090:	80 93 c7 05 	sts	0x05C7, r24
    8094:	80 91 4b 16 	lds	r24, 0x164B

												switch(robot.dir)
    8098:	82 30       	cpi	r24, 0x02	; 2
    809a:	79 f0       	breq	.+30     	; 0x80ba <maze_solve+0x704>
    809c:	1c f4       	brge	.+6      	; 0x80a4 <maze_solve+0x6ee>
    809e:	81 30       	cpi	r24, 0x01	; 1
    80a0:	31 f0       	breq	.+12     	; 0x80ae <maze_solve+0x6f8>
    80a2:	19 c0       	rjmp	.+50     	; 0x80d6 <maze_solve+0x720>
    80a4:	83 30       	cpi	r24, 0x03	; 3
    80a6:	69 f0       	breq	.+26     	; 0x80c2 <maze_solve+0x70c>
    80a8:	84 30       	cpi	r24, 0x04	; 4
    80aa:	79 f0       	breq	.+30     	; 0x80ca <maze_solve+0x714>
    80ac:	14 c0       	rjmp	.+40     	; 0x80d6 <maze_solve+0x720>
    80ae:	80 91 49 16 	lds	r24, 0x1649
												{
													case NORTH:	robot.pos.y--;	break;
    80b2:	81 50       	subi	r24, 0x01	; 1
    80b4:	80 93 49 16 	sts	0x1649, r24
    80b8:	27 c0       	rjmp	.+78     	; 0x8108 <maze_solve+0x752>
    80ba:	80 91 48 16 	lds	r24, 0x1648
													case EAST:	robot.pos.x--;	break;
    80be:	81 50       	subi	r24, 0x01	; 1
    80c0:	07 c0       	rjmp	.+14     	; 0x80d0 <maze_solve+0x71a>
    80c2:	80 91 49 16 	lds	r24, 0x1649
													case SOUTH:	robot.pos.y++;	break;
    80c6:	8f 5f       	subi	r24, 0xFF	; 255
    80c8:	f5 cf       	rjmp	.-22     	; 0x80b4 <maze_solve+0x6fe>
    80ca:	80 91 48 16 	lds	r24, 0x1648
													case WEST:	robot.pos.x++;	break;
    80ce:	8f 5f       	subi	r24, 0xFF	; 255
    80d0:	80 93 48 16 	sts	0x1648, r24
    80d4:	19 c0       	rjmp	.+50     	; 0x8108 <maze_solve+0x752>
    80d6:	80 91 53 05 	lds	r24, 0x0553
													default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.02]:DEFAULT_CASE"));}
    80da:	82 30       	cpi	r24, 0x02	; 2
    80dc:	90 f0       	brcs	.+36     	; 0x8102 <maze_solve+0x74c>
    80de:	86 e0       	ldi	r24, 0x06	; 6
    80e0:	9a e2       	ldi	r25, 0x2A	; 42
    80e2:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    80e6:	60 91 47 05 	lds	r22, 0x0547
    80ea:	70 91 48 05 	lds	r23, 0x0548
    80ee:	80 91 49 05 	lds	r24, 0x0549
    80f2:	90 91 4a 05 	lds	r25, 0x054A
    80f6:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    80fa:	80 ed       	ldi	r24, 0xD0	; 208
    80fc:	99 e2       	ldi	r25, 0x29	; 41
    80fe:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8102:	81 e0       	ldi	r24, 0x01	; 1
																		fatal_err = 1;
    8104:	80 93 63 05 	sts	0x0563, r24
    8108:	80 91 48 16 	lds	r24, 0x1648
												}
											}

											if(robot.pos.x < ROB_POS_X_MIN)
    810c:	18 16       	cp	r1, r24
    810e:	64 f0       	brlt	.+24     	; 0x8128 <maze_solve+0x772>
    8110:	4f ef       	ldi	r20, 0xFF	; 255
											{
												maze_chgOffset(X, robot.pos.z, -1);
    8112:	60 91 4a 16 	lds	r22, 0x164A
    8116:	81 e0       	ldi	r24, 0x01	; 1
    8118:	0e 94 74 59 	call	0xb2e8	; 0xb2e8 <maze_chgOffset>
    811c:	80 91 48 16 	lds	r24, 0x1648
												robot.pos.x ++;
    8120:	8f 5f       	subi	r24, 0xFF	; 255
    8122:	80 93 48 16 	sts	0x1648, r24
    8126:	1e c0       	rjmp	.+60     	; 0x8164 <maze_solve+0x7ae>
    8128:	8c 30       	cpi	r24, 0x0C	; 12
											}
											else if(robot.pos.x >= (MAZE_SIZE_X-1))
    812a:	e4 f0       	brlt	.+56     	; 0x8164 <maze_solve+0x7ae>
    812c:	8b e0       	ldi	r24, 0x0B	; 11
											{
												robot.pos.x = (MAZE_SIZE_X-2);
    812e:	80 93 48 16 	sts	0x1648, r24
    8132:	84 e0       	ldi	r24, 0x04	; 4
												maze_solve_state_path = RESTART;
    8134:	80 93 cd 05 	sts	0x05CD, r24
    8138:	80 91 53 05 	lds	r24, 0x0553

												if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::robot.pos.x:MEMORY_TOO_SMALL:RESTART"));}
    813c:	88 23       	and	r24, r24
    813e:	91 f0       	breq	.+36     	; 0x8164 <maze_solve+0x7ae>
    8140:	8d ec       	ldi	r24, 0xCD	; 205
    8142:	99 e2       	ldi	r25, 0x29	; 41
    8144:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8148:	60 91 47 05 	lds	r22, 0x0547
    814c:	70 91 48 05 	lds	r23, 0x0548
    8150:	80 91 49 05 	lds	r24, 0x0549
    8154:	90 91 4a 05 	lds	r25, 0x054A
    8158:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    815c:	8f e9       	ldi	r24, 0x9F	; 159
    815e:	99 e2       	ldi	r25, 0x29	; 41
    8160:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8164:	80 91 49 16 	lds	r24, 0x1649
											}

											if(robot.pos.y < ROB_POS_Y_MIN)
    8168:	18 16       	cp	r1, r24
    816a:	64 f0       	brlt	.+24     	; 0x8184 <maze_solve+0x7ce>
    816c:	4f ef       	ldi	r20, 0xFF	; 255
											{
												maze_chgOffset(Y, robot.pos.z, -1);
    816e:	60 91 4a 16 	lds	r22, 0x164A
    8172:	82 e0       	ldi	r24, 0x02	; 2
    8174:	0e 94 74 59 	call	0xb2e8	; 0xb2e8 <maze_chgOffset>
    8178:	80 91 49 16 	lds	r24, 0x1649
												robot.pos.y ++;
    817c:	8f 5f       	subi	r24, 0xFF	; 255
    817e:	80 93 49 16 	sts	0x1649, r24
    8182:	35 c1       	rjmp	.+618    	; 0x83ee <maze_solve+0xa38>
    8184:	8c 30       	cpi	r24, 0x0C	; 12
											}
											else if(robot.pos.y >= (MAZE_SIZE_Y-1))
    8186:	0c f4       	brge	.+2      	; 0x818a <maze_solve+0x7d4>
    8188:	32 c1       	rjmp	.+612    	; 0x83ee <maze_solve+0xa38>
    818a:	8b e0       	ldi	r24, 0x0B	; 11
											{
												robot.pos.y = (MAZE_SIZE_Y-2);
    818c:	80 93 49 16 	sts	0x1649, r24
    8190:	84 e0       	ldi	r24, 0x04	; 4
												maze_solve_state_path = RESTART;
    8192:	80 93 cd 05 	sts	0x05CD, r24
    8196:	80 91 53 05 	lds	r24, 0x0553

												if(debug > 0){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::robot.pos.y:MEMORY_TOO_SMALL:RESTART"));}
    819a:	88 23       	and	r24, r24
    819c:	09 f4       	brne	.+2      	; 0x81a0 <maze_solve+0x7ea>
    819e:	27 c1       	rjmp	.+590    	; 0x83ee <maze_solve+0xa38>
    81a0:	8c e9       	ldi	r24, 0x9C	; 156
    81a2:	99 e2       	ldi	r25, 0x29	; 41
    81a4:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    81a8:	60 91 47 05 	lds	r22, 0x0547
    81ac:	70 91 48 05 	lds	r23, 0x0548
    81b0:	80 91 49 05 	lds	r24, 0x0549
    81b4:	90 91 4a 05 	lds	r25, 0x054A
    81b8:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    81bc:	8e e6       	ldi	r24, 0x6E	; 110
    81be:	99 e2       	ldi	r25, 0x29	; 41
    81c0:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    81c4:	14 c1       	rjmp	.+552    	; 0x83ee <maze_solve+0xa38>
    81c6:	81 11       	cpse	r24, r1
											}
										}
										else if(driveVar == DOT_RET_READY) // Ende geradeaus fahren (eine Fliese gefahren)
    81c8:	12 c1       	rjmp	.+548    	; 0x83ee <maze_solve+0xa38>
    81ca:	10 92 c7 05 	sts	0x05C7, r1

													maze_solve_state_path = RAMP_DOWN;
												}*/
											}

											dot_driven_oneTile = 0;
    81ce:	10 92 c8 05 	sts	0x05C8, r1
											dot_abort = 0;
    81d2:	80 91 cd 05 	lds	r24, 0x05CD

											if(maze_solve_state_path == DRIVE_DOT) //Only, when there is no RESTART and no RAMP_xx or something other than DRIVE_DOT
    81d6:	87 30       	cpi	r24, 0x07	; 7
    81d8:	09 f0       	breq	.+2      	; 0x81dc <maze_solve+0x826>
    81da:	09 c1       	rjmp	.+530    	; 0x83ee <maze_solve+0xa38>
    81dc:	47 c0       	rjmp	.+142    	; 0x826c <maze_solve+0x8b6>
    81de:	61 e0       	ldi	r22, 0x01	; 1
									
								break;
								
			case TURN_RIGHT:
									//Rechts drehen
									if(drive_turn(90, 1) == 0)
    81e0:	8a e5       	ldi	r24, 0x5A	; 90
    81e2:	90 e0       	ldi	r25, 0x00	; 0
    81e4:	0e 94 47 31 	call	0x628e	; 0x628e <drive_turn>
    81e8:	81 11       	cpse	r24, r1
    81ea:	01 c1       	rjmp	.+514    	; 0x83ee <maze_solve+0xa38>
    81ec:	80 91 4b 16 	lds	r24, 0x164B
									{
										robot.dir = maze_alignDir(robot.dir + 1);
    81f0:	8f 5f       	subi	r24, 0xFF	; 255
    81f2:	0a c0       	rjmp	.+20     	; 0x8208 <maze_solve+0x852>
    81f4:	61 e0       	ldi	r22, 0x01	; 1
								
								break;
								
			case TURN_LEFT:

									if(drive_turn(-90, 1) == 0)
    81f6:	86 ea       	ldi	r24, 0xA6	; 166
    81f8:	9f ef       	ldi	r25, 0xFF	; 255
    81fa:	0e 94 47 31 	call	0x628e	; 0x628e <drive_turn>
    81fe:	81 11       	cpse	r24, r1
    8200:	f6 c0       	rjmp	.+492    	; 0x83ee <maze_solve+0xa38>
    8202:	80 91 4b 16 	lds	r24, 0x164B
									{
										robot.dir = maze_alignDir(robot.dir + 3);
    8206:	8d 5f       	subi	r24, 0xFD	; 253
    8208:	a5 d6       	rcall	.+3402   	; 0x8f54 <maze_alignDir>
    820a:	80 93 4b 16 	sts	0x164B, r24
    820e:	2e c0       	rjmp	.+92     	; 0x826c <maze_solve+0x8b6>
    8210:	0e 94 e7 31 	call	0x63ce	; 0x63ce <drive_neutralPos>
									
								break;
			
			case DRIVE_NEUTRPOS:
									
									if(!drive_neutralPos())
    8214:	81 11       	cpse	r24, r1
    8216:	eb c0       	rjmp	.+470    	; 0x83ee <maze_solve+0xa38>
    8218:	29 c0       	rjmp	.+82     	; 0x826c <maze_solve+0x8b6>
    821a:	61 e0       	ldi	r22, 0x01	; 1
    821c:	80 e0       	ldi	r24, 0x00	; 0
									
								break;

			case VIC_DEPL_L:

									if(!drive_deployResKit(LEFT, 1))
    821e:	0e 94 56 34 	call	0x68ac	; 0x68ac <drive_deployResKit>
    8222:	81 11       	cpse	r24, r1
    8224:	e4 c0       	rjmp	.+456    	; 0x83ee <maze_solve+0xa38>
    8226:	8f ef       	ldi	r24, 0xFF	; 255
    8228:	9f ef       	ldi	r25, 0xFF	; 255
									{
										timer_victim_led = -1;
    822a:	90 93 98 02 	sts	0x0298, r25
    822e:	80 93 97 02 	sts	0x0297, r24
    8232:	80 91 cb 05 	lds	r24, 0x05CB

										if(maze_solve_depl_kit == 0)
    8236:	81 11       	cpse	r24, r1
    8238:	07 c0       	rjmp	.+14     	; 0x8248 <maze_solve+0x892>
    823a:	87 e0       	ldi	r24, 0x07	; 7
    823c:	80 93 cd 05 	sts	0x05CD, r24
											maze_solve_state_path = DRIVE_DOT;
    8240:	d6 c0       	rjmp	.+428    	; 0x83ee <maze_solve+0xa38>
    8242:	61 e0       	ldi	r22, 0x01	; 1
    8244:	81 e0       	ldi	r24, 0x01	; 1
								break;
			case VIC_DEPL_R:

									//maze_solve_state_path - VIC_DEPL_L == LEFT for VIC_DEPL_L, otherwise RIGHT

									if(!drive_deployResKit(RIGHT, 1))
    8246:	eb cf       	rjmp	.-42     	; 0x821e <maze_solve+0x868>
    8248:	10 92 cd 05 	sts	0x05CD, r1
										timer_victim_led = -1;
										if(maze_solve_depl_kit == 0)
											maze_solve_state_path = DRIVE_DOT;
										else
										{
											maze_solve_state_path = DRIVE_READY;
    824c:	10 92 cb 05 	sts	0x05CB, r1
											maze_solve_depl_kit = 0;
    8250:	ce c0       	rjmp	.+412    	; 0x83ee <maze_solve+0xa38>
    8252:	82 e0       	ldi	r24, 0x02	; 2
    8254:	0e 94 5c 35 	call	0x6ab8	; 0x6ab8 <rescueKit_drop>

								break;

			case VIC_DEPL:

									if(!rescueKit_drop(2))
    8258:	81 11       	cpse	r24, r1
    825a:	c9 c0       	rjmp	.+402    	; 0x83ee <maze_solve+0xa38>
    825c:	10 92 cb 05 	sts	0x05CB, r1
									{
										maze_solve_depl_kit = FALSE;
    8260:	8f ef       	ldi	r24, 0xFF	; 255
    8262:	9f ef       	ldi	r25, 0xFF	; 255
										timer_victim_led = -1;
    8264:	90 93 98 02 	sts	0x0298, r25
    8268:	80 93 97 02 	sts	0x0297, r24
    826c:	10 92 cd 05 	sts	0x05CD, r1

										maze_solve_state_path = DRIVE_READY;
    8270:	be c0       	rjmp	.+380    	; 0x83ee <maze_solve+0xa38>
    8272:	20 91 ca 05 	lds	r18, 0x05CA

								break;

			case CHECK_BLACKTILE:

									switch(maze_solve_check_blacktile)
    8276:	22 30       	cpi	r18, 0x02	; 2
    8278:	09 f4       	brne	.+2      	; 0x827c <maze_solve+0x8c6>
    827a:	40 c0       	rjmp	.+128    	; 0x82fc <maze_solve+0x946>
    827c:	28 f4       	brcc	.+10     	; 0x8288 <maze_solve+0x8d2>
    827e:	22 23       	and	r18, r18
    8280:	39 f0       	breq	.+14     	; 0x8290 <maze_solve+0x8da>
    8282:	21 30       	cpi	r18, 0x01	; 1
    8284:	01 f1       	breq	.+64     	; 0x82c6 <maze_solve+0x910>
    8286:	b3 c0       	rjmp	.+358    	; 0x83ee <maze_solve+0xa38>
    8288:	26 30       	cpi	r18, 0x06	; 6
    828a:	08 f4       	brcc	.+2      	; 0x828e <maze_solve+0x8d8>
    828c:	81 c0       	rjmp	.+258    	; 0x8390 <maze_solve+0x9da>
    828e:	af c0       	rjmp	.+350    	; 0x83ee <maze_solve+0xa38>
    8290:	43 e0       	ldi	r20, 0x03	; 3
    8292:	64 e1       	ldi	r22, 0x14	; 20
									{
										case 0:

												if(!drive_dist(0,20,3))
    8294:	80 e0       	ldi	r24, 0x00	; 0
    8296:	0e 94 2c 32 	call	0x6458	; 0x6458 <drive_dist>
    829a:	81 11       	cpse	r24, r1
    829c:	a8 c0       	rjmp	.+336    	; 0x83ee <maze_solve+0xa38>
    829e:	80 91 7c 07 	lds	r24, 0x077C
												{
													if((groundsens_r > GROUNDSENS_R_TH_BLACKTILE) && (groundsens_l > GROUNDSENS_L_TH_BLACKTILE))
    82a2:	90 91 7d 07 	lds	r25, 0x077D
    82a6:	81 32       	cpi	r24, 0x21	; 33
    82a8:	93 40       	sbci	r25, 0x03	; 3
    82aa:	5c f0       	brlt	.+22     	; 0x82c2 <maze_solve+0x90c>
    82ac:	80 91 80 07 	lds	r24, 0x0780
    82b0:	90 91 81 07 	lds	r25, 0x0781
    82b4:	81 32       	cpi	r24, 0x21	; 33
    82b6:	93 40       	sbci	r25, 0x03	; 3
    82b8:	24 f0       	brlt	.+8      	; 0x82c2 <maze_solve+0x90c>
    82ba:	81 e0       	ldi	r24, 0x01	; 1
    82bc:	80 93 ca 05 	sts	0x05CA, r24
													{
														maze_solve_check_blacktile = 1;
    82c0:	97 c0       	rjmp	.+302    	; 0x83f0 <maze_solve+0xa3a>
    82c2:	83 e0       	ldi	r24, 0x03	; 3
    82c4:	18 c0       	rjmp	.+48     	; 0x82f6 <maze_solve+0x940>
													}
													else
													{
														maze_solve_check_blacktile = 3;
    82c6:	43 e0       	ldi	r20, 0x03	; 3
    82c8:	64 e1       	ldi	r22, 0x14	; 20

											break;

										case 1:

												if(!drive_dist(0,20,3))
    82ca:	80 e0       	ldi	r24, 0x00	; 0
    82cc:	0e 94 2c 32 	call	0x6458	; 0x6458 <drive_dist>
    82d0:	81 11       	cpse	r24, r1
    82d2:	8d c0       	rjmp	.+282    	; 0x83ee <maze_solve+0xa38>
    82d4:	80 91 7c 07 	lds	r24, 0x077C
												{
													if((groundsens_r > GROUNDSENS_R_TH_BLACKTILE) && (groundsens_l > GROUNDSENS_L_TH_BLACKTILE))
    82d8:	90 91 7d 07 	lds	r25, 0x077D
    82dc:	81 32       	cpi	r24, 0x21	; 33
    82de:	93 40       	sbci	r25, 0x03	; 3
    82e0:	4c f0       	brlt	.+18     	; 0x82f4 <maze_solve+0x93e>
    82e2:	80 91 80 07 	lds	r24, 0x0780
    82e6:	90 91 81 07 	lds	r25, 0x0781
    82ea:	81 32       	cpi	r24, 0x21	; 33
    82ec:	93 40       	sbci	r25, 0x03	; 3
    82ee:	14 f0       	brlt	.+4      	; 0x82f4 <maze_solve+0x93e>
    82f0:	82 e0       	ldi	r24, 0x02	; 2
    82f2:	01 c0       	rjmp	.+2      	; 0x82f6 <maze_solve+0x940>
													{
														maze_solve_check_blacktile = 2;
    82f4:	84 e0       	ldi	r24, 0x04	; 4
    82f6:	80 93 ca 05 	sts	0x05CA, r24
													}
													else
													{
														maze_solve_check_blacktile = 4;
    82fa:	79 c0       	rjmp	.+242    	; 0x83ee <maze_solve+0xa38>
    82fc:	43 e0       	ldi	r20, 0x03	; 3
    82fe:	64 e1       	ldi	r22, 0x14	; 20
												}

											break;

										case 2:
												if(!drive_dist(0,20,3))
    8300:	80 e0       	ldi	r24, 0x00	; 0
    8302:	0e 94 2c 32 	call	0x6458	; 0x6458 <drive_dist>
    8306:	81 11       	cpse	r24, r1
    8308:	72 c0       	rjmp	.+228    	; 0x83ee <maze_solve+0xa38>
    830a:	20 91 56 08 	lds	r18, 0x0856
												{
													displayvar[3] = abs(ramp_start - um6.theta_t);
    830e:	30 91 57 08 	lds	r19, 0x0857
    8312:	80 91 0a 17 	lds	r24, 0x170A
    8316:	90 91 0b 17 	lds	r25, 0x170B
    831a:	28 1b       	sub	r18, r24
    831c:	39 0b       	sbc	r19, r25
    831e:	c9 01       	movw	r24, r18
    8320:	37 ff       	sbrs	r19, 7
    8322:	04 c0       	rjmp	.+8      	; 0x832c <maze_solve+0x976>
    8324:	88 27       	eor	r24, r24
    8326:	99 27       	eor	r25, r25
    8328:	82 1b       	sub	r24, r18
    832a:	93 0b       	sbc	r25, r19
    832c:	aa 27       	eor	r26, r26
    832e:	97 fd       	sbrc	r25, 7
    8330:	a0 95       	com	r26
    8332:	ba 2f       	mov	r27, r26
    8334:	80 93 5e 07 	sts	0x075E, r24
    8338:	90 93 5f 07 	sts	0x075F, r25
    833c:	a0 93 60 07 	sts	0x0760, r26
    8340:	b0 93 61 07 	sts	0x0761, r27
    8344:	80 91 7c 07 	lds	r24, 0x077C

													if((groundsens_r > GROUNDSENS_R_TH_BLACKTILE) && (groundsens_l > GROUNDSENS_L_TH_BLACKTILE) &&
    8348:	90 91 7d 07 	lds	r25, 0x077D
    834c:	81 32       	cpi	r24, 0x21	; 33
    834e:	93 40       	sbci	r25, 0x03	; 3
    8350:	e4 f0       	brlt	.+56     	; 0x838a <maze_solve+0x9d4>
    8352:	80 91 80 07 	lds	r24, 0x0780
    8356:	90 91 81 07 	lds	r25, 0x0781
    835a:	81 32       	cpi	r24, 0x21	; 33
    835c:	93 40       	sbci	r25, 0x03	; 3
    835e:	ac f0       	brlt	.+42     	; 0x838a <maze_solve+0x9d4>
    8360:	2d 5f       	subi	r18, 0xFD	; 253
    8362:	3f 4f       	sbci	r19, 0xFF	; 255
															(abs(ramp_start - um6.theta_t) < 4))
    8364:	27 30       	cpi	r18, 0x07	; 7
    8366:	31 05       	cpc	r19, r1
										case 2:
												if(!drive_dist(0,20,3))
												{
													displayvar[3] = abs(ramp_start - um6.theta_t);

													if((groundsens_r > GROUNDSENS_R_TH_BLACKTILE) && (groundsens_l > GROUNDSENS_L_TH_BLACKTILE) &&
    8368:	80 f4       	brcc	.+32     	; 0x838a <maze_solve+0x9d4>
    836a:	81 e0       	ldi	r24, 0x01	; 1
    836c:	80 93 c8 05 	sts	0x05C8, r24
															(abs(ramp_start - um6.theta_t) < 4))
													{
														dot_abort = 1;
    8370:	80 91 c7 05 	lds	r24, 0x05C7
														if(dot_driven_oneTile == 0)
    8374:	42 e0       	ldi	r20, 0x02	; 2
    8376:	81 11       	cpse	r24, r1
															maze_corrGround(&robot.pos, robot.dir, 2);
    8378:	03 c0       	rjmp	.+6      	; 0x8380 <maze_solve+0x9ca>

													if((groundsens_r > GROUNDSENS_R_TH_BLACKTILE) && (groundsens_l > GROUNDSENS_L_TH_BLACKTILE) &&
															(abs(ramp_start - um6.theta_t) < 4))
													{
														dot_abort = 1;
														if(dot_driven_oneTile == 0)
    837a:	60 91 4b 16 	lds	r22, 0x164B
															maze_corrGround(&robot.pos, robot.dir, 2);
    837e:	01 c0       	rjmp	.+2      	; 0x8382 <maze_solve+0x9cc>
    8380:	60 e0       	ldi	r22, 0x00	; 0
    8382:	88 e4       	ldi	r24, 0x48	; 72
														else
															maze_corrGround(&robot.pos, NONE, 2);
    8384:	96 e1       	ldi	r25, 0x16	; 22
    8386:	0e 94 2e 4e 	call	0x9c5c	; 0x9c5c <maze_corrGround>
    838a:	10 92 ca 05 	sts	0x05CA, r1
													else
													{
														maze_solve_check_blacktile = 5;
													}

													maze_solve_check_blacktile = 0;
    838e:	55 cf       	rjmp	.-342    	; 0x823a <maze_solve+0x884>
    8390:	82 e0       	ldi	r24, 0x02	; 2
    8392:	90 e0       	ldi	r25, 0x00	; 0
												}
											break;

										case 3 ... 5:

											if(!drive_dist(0,20,-((maze_solve_check_blacktile-2)*3)))
    8394:	82 1b       	sub	r24, r18
    8396:	91 09       	sbc	r25, r1
    8398:	48 2f       	mov	r20, r24
    839a:	44 0f       	add	r20, r20
    839c:	48 0f       	add	r20, r24
    839e:	64 e1       	ldi	r22, 0x14	; 20
    83a0:	80 e0       	ldi	r24, 0x00	; 0
    83a2:	0e 94 2c 32 	call	0x6458	; 0x6458 <drive_dist>
    83a6:	81 11       	cpse	r24, r1
    83a8:	22 c0       	rjmp	.+68     	; 0x83ee <maze_solve+0xa38>
    83aa:	87 e0       	ldi	r24, 0x07	; 7
    83ac:	80 93 cd 05 	sts	0x05CD, r24
											{
												maze_solve_state_path = DRIVE_DOT;
    83b0:	10 92 ca 05 	sts	0x05CA, r1
												maze_solve_check_blacktile = 0;
    83b4:	1c c0       	rjmp	.+56     	; 0x83ee <maze_solve+0xa38>
    83b6:	80 91 53 05 	lds	r24, 0x0553
									}

								break;
								
			default:
									if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.03]:DEFAULT_CASE"));}
    83ba:	82 30       	cpi	r24, 0x02	; 2
    83bc:	90 f0       	brcs	.+36     	; 0x83e2 <maze_solve+0xa2c>
    83be:	8b e6       	ldi	r24, 0x6B	; 107
    83c0:	99 e2       	ldi	r25, 0x29	; 41
    83c2:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    83c6:	60 91 47 05 	lds	r22, 0x0547
    83ca:	70 91 48 05 	lds	r23, 0x0548
    83ce:	80 91 49 05 	lds	r24, 0x0549
    83d2:	90 91 4a 05 	lds	r25, 0x054A
    83d6:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    83da:	85 e3       	ldi	r24, 0x35	; 53
    83dc:	99 e2       	ldi	r25, 0x29	; 41
    83de:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    83e2:	81 e0       	ldi	r24, 0x01	; 1
    83e4:	80 93 63 05 	sts	0x0563, r24
									fatal_err = 1;
    83e8:	03 c0       	rjmp	.+6      	; 0x83f0 <maze_solve+0xa3a>
    83ea:	80 e0       	ldi	r24, 0x00	; 0
    83ec:	01 c0       	rjmp	.+2      	; 0x83f0 <maze_solve+0xa3a>
			case RESTART:
							
									mot.d[LEFT].speed.to = 0;
									mot.d[RIGHT].speed.to = 0;

									returnvar = 0; //0 zurckgeben, wenn fertig, sonst 1
    83ee:	81 e0       	ldi	r24, 0x01	; 1
    83f0:	23 96       	adiw	r28, 0x03	; 3
MATCHINGWALLS matchingWalls;
TILE cleartiles;

uint8_t maze_solve(void) //called from RIOS periodical task
{		
	uint8_t returnvar = 1;
    83f2:	e7 e0       	ldi	r30, 0x07	; 7
			ui_setLED(1, 255);
		}*/
	}

	return returnvar;
}
    83f4:	0c 94 c2 6b 	jmp	0xd784	; 0xd784 <__epilogue_restores__+0x16>

000083f8 <maze_localize>:

uint8_t loc_ambiguity = 0;
uint8_t loc_accordance = 0;

void maze_localize(void)
{
    83f8:	a1 e1       	ldi	r26, 0x11	; 17
    83fa:	b0 e0       	ldi	r27, 0x00	; 0
    83fc:	e2 e0       	ldi	r30, 0x02	; 2
    83fe:	f2 e4       	ldi	r31, 0x42	; 66
    8400:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
	COORD sizediff[MAZE_SIZE_Z];

	COORD savestage_size;
	COORD overwrite_orig, overwrite_pos_save;

	switch(locRequest)
    8404:	10 91 c4 05 	lds	r17, 0x05C4
    8408:	11 30       	cpi	r17, 0x01	; 1
    840a:	09 f0       	breq	.+2      	; 0x840e <maze_localize+0x16>
    840c:	b4 c0       	rjmp	.+360    	; 0x8576 <maze_localize+0x17e>
		
		case LR_MATCH:
		
					for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
					{
						sizediff[i].z = i;
    840e:	1b 82       	std	Y+3, r1	; 0x03
						maze_stageGetSize(&sizediff[i]);
    8410:	ce 01       	movw	r24, r28
    8412:	01 96       	adiw	r24, 0x01	; 1
    8414:	0e 94 a5 54 	call	0xa94a	; 0xa94a <maze_stageGetSize>
		
		case LR_MATCH:
		
					for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
					{
						sizediff[i].z = i;
    8418:	1e 83       	std	Y+6, r17	; 0x06
						maze_stageGetSize(&sizediff[i]);
    841a:	ce 01       	movw	r24, r28
    841c:	04 96       	adiw	r24, 0x04	; 4
    841e:	0e 94 a5 54 	call	0xa94a	; 0xa94a <maze_stageGetSize>
		
		case LR_MATCH:
		
					for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
					{
						sizediff[i].z = i;
    8422:	12 e0       	ldi	r17, 0x02	; 2
    8424:	19 87       	std	Y+9, r17	; 0x09
						maze_stageGetSize(&sizediff[i]);
    8426:	ce 01       	movw	r24, r28
    8428:	07 96       	adiw	r24, 0x07	; 7
    842a:	0e 94 a5 54 	call	0xa94a	; 0xa94a <maze_stageGetSize>
					}
					for(uint8_t i = 0; i < MAZE_SAVESTAGE; i++)
					{
						sizediff[i].x -= sizediff[MAZE_SAVESTAGE].x;
    842e:	89 81       	ldd	r24, Y+1	; 0x01
    8430:	2f 81       	ldd	r18, Y+7	; 0x07
    8432:	82 1b       	sub	r24, r18
    8434:	89 83       	std	Y+1, r24	; 0x01
						sizediff[i].y -= sizediff[MAZE_SAVESTAGE].y;
    8436:	8a 81       	ldd	r24, Y+2	; 0x02
    8438:	98 85       	ldd	r25, Y+8	; 0x08
    843a:	89 1b       	sub	r24, r25
    843c:	8a 83       	std	Y+2, r24	; 0x02
						sizediff[i].z = i;
						maze_stageGetSize(&sizediff[i]);
					}
					for(uint8_t i = 0; i < MAZE_SAVESTAGE; i++)
					{
						sizediff[i].x -= sizediff[MAZE_SAVESTAGE].x;
    843e:	8c 81       	ldd	r24, Y+4	; 0x04
    8440:	82 1b       	sub	r24, r18
    8442:	8c 83       	std	Y+4, r24	; 0x04
						sizediff[i].y -= sizediff[MAZE_SAVESTAGE].y;
    8444:	8d 81       	ldd	r24, Y+5	; 0x05
    8446:	89 1b       	sub	r24, r25
    8448:	8d 83       	std	Y+5, r24	; 0x05
					}

					if((sizediff[rob_z_lost].x < 0) || (sizediff[rob_z_lost].y < 0))
    844a:	20 91 42 16 	lds	r18, 0x1642
    844e:	82 2f       	mov	r24, r18
    8450:	99 27       	eor	r25, r25
    8452:	87 fd       	sbrc	r24, 7
    8454:	90 95       	com	r25
    8456:	fc 01       	movw	r30, r24
    8458:	ee 0f       	add	r30, r30
    845a:	ff 1f       	adc	r31, r31
    845c:	e8 0f       	add	r30, r24
    845e:	f9 1f       	adc	r31, r25
    8460:	81 e0       	ldi	r24, 0x01	; 1
    8462:	90 e0       	ldi	r25, 0x00	; 0
    8464:	8c 0f       	add	r24, r28
    8466:	9d 1f       	adc	r25, r29
    8468:	e8 0f       	add	r30, r24
    846a:	f9 1f       	adc	r31, r25
    846c:	80 81       	ld	r24, Z
    846e:	87 fd       	sbrc	r24, 7
    8470:	03 c0       	rjmp	.+6      	; 0x8478 <maze_localize+0x80>
    8472:	81 81       	ldd	r24, Z+1	; 0x01
    8474:	87 ff       	sbrs	r24, 7
    8476:	04 c0       	rjmp	.+8      	; 0x8480 <maze_localize+0x88>
					{
						matchStages.stage_a = MAZE_SAVESTAGE;
    8478:	82 e0       	ldi	r24, 0x02	; 2
    847a:	8a 87       	std	Y+10, r24	; 0x0a
						matchStages.stage_b = rob_z_lost;
    847c:	2b 87       	std	Y+11, r18	; 0x0b
    847e:	02 c0       	rjmp	.+4      	; 0x8484 <maze_localize+0x8c>
					}
					else
					{
						matchStages.stage_a = rob_z_lost;
    8480:	2a 87       	std	Y+10, r18	; 0x0a
						matchStages.stage_b = MAZE_SAVESTAGE;
    8482:	1b 87       	std	Y+11, r17	; 0x0b
					}
					maze_matchStages(&matchStages);
    8484:	ce 01       	movw	r24, r28
    8486:	0a 96       	adiw	r24, 0x0a	; 10
    8488:	0e 94 d1 55 	call	0xaba2	; 0xaba2 <maze_matchStages>

					loc_ambiguity = matchStages.ambiguity;
    848c:	99 89       	ldd	r25, Y+17	; 0x11
    848e:	90 93 c3 05 	sts	0x05C3, r25
					loc_accordance = matchStages.accordance;
    8492:	88 89       	ldd	r24, Y+16	; 0x10
    8494:	80 93 c2 05 	sts	0x05C2, r24
					displayvar[4] = matchStages.ambiguity;

					displayvar[5] = sizediff[0].x;
					displayvar[6] = sizediff[0].y;*/

					if((matchStages.ambiguity == 0) && (matchStages.accordance > 80) && (maze_stageGetVisitedTiles(MAZE_SAVESTAGE) > 5))
    8498:	91 11       	cpse	r25, r1
    849a:	6a c0       	rjmp	.+212    	; 0x8570 <maze_localize+0x178>
    849c:	81 35       	cpi	r24, 0x51	; 81
    849e:	0c f4       	brge	.+2      	; 0x84a2 <maze_localize+0xaa>
    84a0:	67 c0       	rjmp	.+206    	; 0x8570 <maze_localize+0x178>
    84a2:	82 e0       	ldi	r24, 0x02	; 2
    84a4:	0e 94 ab 56 	call	0xad56	; 0xad56 <maze_stageGetVisitedTiles>
    84a8:	86 30       	cpi	r24, 0x06	; 6
    84aa:	08 f4       	brcc	.+2      	; 0x84ae <maze_localize+0xb6>
    84ac:	61 c0       	rjmp	.+194    	; 0x8570 <maze_localize+0x178>
					{
						if((sizediff[rob_z_lost].x < 0) || (sizediff[rob_z_lost].y < 0))
    84ae:	80 91 42 16 	lds	r24, 0x1642
    84b2:	99 27       	eor	r25, r25
    84b4:	87 fd       	sbrc	r24, 7
    84b6:	90 95       	com	r25
    84b8:	fc 01       	movw	r30, r24
    84ba:	ee 0f       	add	r30, r30
    84bc:	ff 1f       	adc	r31, r31
    84be:	e8 0f       	add	r30, r24
    84c0:	f9 1f       	adc	r31, r25
    84c2:	81 e0       	ldi	r24, 0x01	; 1
    84c4:	90 e0       	ldi	r25, 0x00	; 0
    84c6:	8c 0f       	add	r24, r28
    84c8:	9d 1f       	adc	r25, r29
    84ca:	e8 0f       	add	r30, r24
    84cc:	f9 1f       	adc	r31, r25
    84ce:	80 81       	ld	r24, Z

uint8_t loc_ambiguity = 0;
uint8_t loc_accordance = 0;

void maze_localize(void)
{
    84d0:	10 e0       	ldi	r17, 0x00	; 0
					displayvar[5] = sizediff[0].x;
					displayvar[6] = sizediff[0].y;*/

					if((matchStages.ambiguity == 0) && (matchStages.accordance > 80) && (maze_stageGetVisitedTiles(MAZE_SAVESTAGE) > 5))
					{
						if((sizediff[rob_z_lost].x < 0) || (sizediff[rob_z_lost].y < 0))
    84d2:	87 fd       	sbrc	r24, 7
    84d4:	03 c0       	rjmp	.+6      	; 0x84dc <maze_localize+0xe4>
    84d6:	81 81       	ldd	r24, Z+1	; 0x01
    84d8:	87 ff       	sbrs	r24, 7
    84da:	23 c0       	rjmp	.+70     	; 0x8522 <maze_localize+0x12a>
						{
							for(uint8_t i = 0; i < matchStages.match.dir; i++)
    84dc:	21 2f       	mov	r18, r17
    84de:	30 e0       	ldi	r19, 0x00	; 0
    84e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    84e2:	99 27       	eor	r25, r25
    84e4:	87 fd       	sbrc	r24, 7
    84e6:	90 95       	com	r25
    84e8:	28 17       	cp	r18, r24
    84ea:	39 07       	cpc	r19, r25
    84ec:	34 f4       	brge	.+12     	; 0x84fa <maze_localize+0x102>
								maze_rotateStage(rob_z_lost);
    84ee:	80 91 42 16 	lds	r24, 0x1642
    84f2:	0e 94 c3 54 	call	0xa986	; 0xa986 <maze_rotateStage>

					if((matchStages.ambiguity == 0) && (matchStages.accordance > 80) && (maze_stageGetVisitedTiles(MAZE_SAVESTAGE) > 5))
					{
						if((sizediff[rob_z_lost].x < 0) || (sizediff[rob_z_lost].y < 0))
						{
							for(uint8_t i = 0; i < matchStages.match.dir; i++)
    84f6:	1f 5f       	subi	r17, 0xFF	; 255
    84f8:	f1 cf       	rjmp	.-30     	; 0x84dc <maze_localize+0xe4>
								maze_rotateStage(rob_z_lost);

							maze_chgOffset(X,rob_z_lost,-(matchStages.match.pos.x-ROB_POS_X_MIN-1));
    84fa:	12 e0       	ldi	r17, 0x02	; 2
    84fc:	8c 85       	ldd	r24, Y+12	; 0x0c
    84fe:	41 2f       	mov	r20, r17
    8500:	48 1b       	sub	r20, r24
    8502:	60 91 42 16 	lds	r22, 0x1642
    8506:	81 e0       	ldi	r24, 0x01	; 1
    8508:	0e 94 74 59 	call	0xb2e8	; 0xb2e8 <maze_chgOffset>
							maze_chgOffset(Y,rob_z_lost,-(matchStages.match.pos.y-ROB_POS_Y_MIN-1));
    850c:	8d 85       	ldd	r24, Y+13	; 0x0d
    850e:	41 2f       	mov	r20, r17
    8510:	48 1b       	sub	r20, r24
    8512:	60 91 42 16 	lds	r22, 0x1642
    8516:	82 e0       	ldi	r24, 0x02	; 2
    8518:	0e 94 74 59 	call	0xb2e8	; 0xb2e8 <maze_chgOffset>

							robot.pos.z = rob_z_lost;
    851c:	80 91 42 16 	lds	r24, 0x1642
    8520:	1d c0       	rjmp	.+58     	; 0x855c <maze_localize+0x164>
						}
						else
						{
							for(uint8_t i = 0; i < matchStages.match.dir; i++)
    8522:	21 2f       	mov	r18, r17
    8524:	30 e0       	ldi	r19, 0x00	; 0
    8526:	8f 85       	ldd	r24, Y+15	; 0x0f
    8528:	99 27       	eor	r25, r25
    852a:	87 fd       	sbrc	r24, 7
    852c:	90 95       	com	r25
    852e:	28 17       	cp	r18, r24
    8530:	39 07       	cpc	r19, r25
    8532:	2c f4       	brge	.+10     	; 0x853e <maze_localize+0x146>
								maze_rotateStage(MAZE_SAVESTAGE);
    8534:	82 e0       	ldi	r24, 0x02	; 2
    8536:	0e 94 c3 54 	call	0xa986	; 0xa986 <maze_rotateStage>

							robot.pos.z = rob_z_lost;
						}
						else
						{
							for(uint8_t i = 0; i < matchStages.match.dir; i++)
    853a:	1f 5f       	subi	r17, 0xFF	; 255
    853c:	f2 cf       	rjmp	.-28     	; 0x8522 <maze_localize+0x12a>
							sizediff[rob_z_lost].y -= sizediff[MAZE_SAVESTAGE].y;

							maze_chgOffset(X,MAZE_SAVESTAGE,-sizediff[rob_z_lost].x);
							maze_chgOffset(Y,MAZE_SAVESTAGE,-sizediff[rob_z_lost].y);*/

							robot.pos.x += matchStages.match.pos.x - ROB_POS_X_MIN-1;
    853e:	80 91 48 16 	lds	r24, 0x1648
    8542:	9c 85       	ldd	r25, Y+12	; 0x0c
    8544:	89 0f       	add	r24, r25
    8546:	82 50       	subi	r24, 0x02	; 2
    8548:	80 93 48 16 	sts	0x1648, r24
							robot.pos.y += matchStages.match.pos.y - ROB_POS_Y_MIN-1;
    854c:	80 91 49 16 	lds	r24, 0x1649
    8550:	9d 85       	ldd	r25, Y+13	; 0x0d
    8552:	89 0f       	add	r24, r25
    8554:	82 50       	subi	r24, 0x02	; 2
    8556:	80 93 49 16 	sts	0x1649, r24
							robot.pos.z = matchStages.match.pos.z;
    855a:	8e 85       	ldd	r24, Y+14	; 0x0e
    855c:	80 93 4a 16 	sts	0x164A, r24
						robot.pos.y -= sizediff[rob_z_lost].y;
						maze_chgOffset(X,rob_z_lost,sizediff[rob_z_lost].x);
						maze_chgOffset(Y,rob_z_lost,sizediff[rob_z_lost].y);*/

						//End
						locRequest = LR_SUCCESS;
    8560:	82 e0       	ldi	r24, 0x02	; 2
    8562:	80 93 c4 05 	sts	0x05C4, r24
						loc_ambiguity = 0;
    8566:	10 92 c3 05 	sts	0x05C3, r1
						loc_accordance = 0;
    856a:	10 92 c2 05 	sts	0x05C2, r1
    856e:	03 c0       	rjmp	.+6      	; 0x8576 <maze_localize+0x17e>
					}
					else
					{
						locRequest = LR_FAILURE;
    8570:	83 e0       	ldi	r24, 0x03	; 3
    8572:	80 93 c4 05 	sts	0x05C4, r24
		
		case LR_SUCCESS:	break; //Has to be checked in maze_solve
		case LR_FAILURE:	break; //"

	}
}
    8576:	61 96       	adiw	r28, 0x11	; 17
    8578:	e3 e0       	ldi	r30, 0x03	; 3
    857a:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

0000857e <u8g_DrawMaze>:
#define MAP_ROB_POS_Y (MAPEND_PART_Y-MAPEND_PART_Y_TOP)/2

int8_t wall_size_part = WALL_SIZE_STD;

void u8g_DrawMaze(void)
{
    857e:	a5 e0       	ldi	r26, 0x05	; 5
    8580:	b0 e0       	ldi	r27, 0x00	; 0
    8582:	e5 ec       	ldi	r30, 0xC5	; 197
    8584:	f2 e4       	ldi	r31, 0x42	; 66
    8586:	0c 94 9b 6b 	jmp	0xd736	; 0xd736 <__prologue_saves__>
	//				//Ka//      //
	//    X			//rt//      //
	//				//e	//      //
	//////////////////////////////
	
	if(wall_size_part < WALL_SIZE_MIN)
    858a:	80 91 c2 02 	lds	r24, 0x02C2
    858e:	82 30       	cpi	r24, 0x02	; 2
    8590:	14 f4       	brge	.+4      	; 0x8596 <u8g_DrawMaze+0x18>
		wall_size_part = WALL_SIZE_MAX;
    8592:	88 e2       	ldi	r24, 0x28	; 40
    8594:	03 c0       	rjmp	.+6      	; 0x859c <u8g_DrawMaze+0x1e>
	else if(wall_size_part > WALL_SIZE_MAX)
    8596:	89 32       	cpi	r24, 0x29	; 41
    8598:	1c f0       	brlt	.+6      	; 0x85a0 <u8g_DrawMaze+0x22>
		wall_size_part = WALL_SIZE_MIN;
    859a:	82 e0       	ldi	r24, 0x02	; 2
    859c:	80 93 c2 02 	sts	0x02C2, r24

	int8_t disp_x = 0;
	int8_t disp_y = 0;
	COORD _maze;
	_maze.z = robot.pos.z;
    85a0:	80 91 4a 16 	lds	r24, 0x164A
    85a4:	8b 83       	std	Y+3, r24	; 0x03

	u8g_drawArrow(wall_size_part/2, MAP_ROB_POS_X, MAP_ROB_POS_Y, maze_alignDir(robot.dir + 3), 1);
    85a6:	80 91 4b 16 	lds	r24, 0x164B
    85aa:	8d 5f       	subi	r24, 0xFD	; 253
    85ac:	d3 d4       	rcall	.+2470   	; 0x8f54 <maze_alignDir>
    85ae:	90 91 c2 02 	lds	r25, 0x02C2
    85b2:	97 fd       	sbrc	r25, 7
    85b4:	9f 5f       	subi	r25, 0xFF	; 255
    85b6:	01 e0       	ldi	r16, 0x01	; 1
    85b8:	28 2f       	mov	r18, r24
    85ba:	4c e1       	ldi	r20, 0x1C	; 28
    85bc:	63 e2       	ldi	r22, 0x23	; 35
    85be:	89 2f       	mov	r24, r25
    85c0:	85 95       	asr	r24
    85c2:	0e 94 35 22 	call	0x446a	; 0x446a <u8g_drawArrow>
    85c6:	20 91 c2 02 	lds	r18, 0x02C2

	uint8_t map_tiles_rob_x = 0; //How many displayable tiles are at the x-achse on the left side of the robot?
	uint8_t map_tiles_rob_y = 0; //... y ...

	int8_t mapstart_x = MAP_ROB_POS_X - wall_size_part/2;
    85ca:	a2 2e       	mov	r10, r18
    85cc:	27 ff       	sbrs	r18, 7
    85ce:	03 c0       	rjmp	.+6      	; 0x85d6 <u8g_DrawMaze+0x58>
    85d0:	aa 24       	eor	r10, r10
    85d2:	a3 94       	inc	r10
    85d4:	a2 0e       	add	r10, r18
    85d6:	a5 94       	asr	r10
    85d8:	a1 94       	neg	r10
    85da:	33 e2       	ldi	r19, 0x23	; 35
    85dc:	a3 0e       	add	r10, r19
    85de:	8e e0       	ldi	r24, 0x0E	; 14
	while(mapstart_x > 0)
    85e0:	1a 14       	cp	r1, r10
    85e2:	1c f4       	brge	.+6      	; 0x85ea <u8g_DrawMaze+0x6c>
    85e4:	a2 1a       	sub	r10, r18
	{
		map_tiles_rob_x ++;
		mapstart_x -= wall_size_part;
    85e6:	81 50       	subi	r24, 0x01	; 1
    85e8:	d9 f7       	brne	.-10     	; 0x85e0 <u8g_DrawMaze+0x62>

		if(map_tiles_rob_x > MAZE_SIZE_X)
    85ea:	12 2f       	mov	r17, r18
			fatal_err = 1;
		}
	}
	disp_x = mapstart_x;

	int8_t mapstart_y = MAP_ROB_POS_Y + wall_size_part/2;
    85ec:	27 ff       	sbrs	r18, 7
    85ee:	02 c0       	rjmp	.+4      	; 0x85f4 <u8g_DrawMaze+0x76>
    85f0:	11 e0       	ldi	r17, 0x01	; 1
    85f2:	12 0f       	add	r17, r18
    85f4:	15 95       	asr	r17
    85f6:	14 5e       	subi	r17, 0xE4	; 228
    85f8:	71 2c       	mov	r7, r1
	_maze.z = robot.pos.z;

	u8g_drawArrow(wall_size_part/2, MAP_ROB_POS_X, MAP_ROB_POS_Y, maze_alignDir(robot.dir + 3), 1);

	uint8_t map_tiles_rob_x = 0; //How many displayable tiles are at the x-achse on the left side of the robot?
	uint8_t map_tiles_rob_y = 0; //... y ...
    85fa:	1f 33       	cpi	r17, 0x3F	; 63
		}
	}
	disp_x = mapstart_x;

	int8_t mapstart_y = MAP_ROB_POS_Y + wall_size_part/2;
	while(mapstart_y < MAPEND_PART_Y)
    85fc:	2c f4       	brge	.+10     	; 0x8608 <u8g_DrawMaze+0x8a>
    85fe:	73 94       	inc	r7
	{
		map_tiles_rob_y ++;
    8600:	12 0f       	add	r17, r18
		mapstart_y += wall_size_part;
    8602:	8e e0       	ldi	r24, 0x0E	; 14

		if(map_tiles_rob_y > MAZE_SIZE_Y)
    8604:	78 12       	cpse	r7, r24
    8606:	f9 cf       	rjmp	.-14     	; 0x85fa <u8g_DrawMaze+0x7c>
    8608:	33 27       	eor	r19, r19
			fatal_err = 1;
		}
	}
	disp_y = mapstart_y;

	uint8_t map_part_size_x = MAPEND_PART_X / wall_size_part; //Size of the extract of the map
    860a:	27 fd       	sbrc	r18, 7
    860c:	30 95       	com	r19
    860e:	86 e4       	ldi	r24, 0x46	; 70
    8610:	90 e0       	ldi	r25, 0x00	; 0
    8612:	b9 01       	movw	r22, r18
    8614:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    8618:	56 2e       	mov	r5, r22
    861a:	89 2b       	or	r24, r25
	if(MAPEND_PART_X % wall_size_part != 0)
    861c:	19 f0       	breq	.+6      	; 0x8624 <u8g_DrawMaze+0xa6>
    861e:	55 24       	eor	r5, r5
		map_part_size_x ++;
    8620:	53 94       	inc	r5
    8622:	56 0e       	add	r5, r22
    8624:	8f e3       	ldi	r24, 0x3F	; 63

	uint8_t map_part_size_y = MAPEND_PART_Y / wall_size_part; //Size of the extract of the map
    8626:	90 e0       	ldi	r25, 0x00	; 0
    8628:	b9 01       	movw	r22, r18
    862a:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    862e:	46 2e       	mov	r4, r22
    8630:	89 2b       	or	r24, r25
	if(MAPEND_PART_Y % wall_size_part != 0)
    8632:	19 f0       	breq	.+6      	; 0x863a <u8g_DrawMaze+0xbc>
    8634:	44 24       	eor	r4, r4
		map_part_size_y ++;
    8636:	43 94       	inc	r4
    8638:	46 0e       	add	r4, r22
    863a:	ba 2c       	mov	r11, r10
		{
			break;
			fatal_err = 1;
		}
	}
	disp_x = mapstart_x;
    863c:	61 2c       	mov	r6, r1

	uint8_t map_part_size_y = MAPEND_PART_Y / wall_size_part; //Size of the extract of the map
	if(MAPEND_PART_Y % wall_size_part != 0)
		map_part_size_y ++;

	for(uint8_t maze_part_y = 0; maze_part_y <= map_part_size_y; maze_part_y++)
    863e:	f6 e4       	ldi	r31, 0x46	; 70
					{
						wall_size_x_temp = wall_size_part;

						if((uint8_t)(disp_x + wall_size_part) > MAPEND_PART_X)
						{
							wall_size_x_temp = MAPEND_PART_X-disp_x;
    8640:	3f 2e       	mov	r3, r31
    8642:	a6 e0       	ldi	r26, 0x06	; 6
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y-1, wall_size_part/6, wall_size_part/8, U8G_DRAW_UPPER_LEFT);
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y-1, wall_size_part/6, wall_size_part/8, U8G_DRAW_UPPER_RIGHT);
							}
							if(maze_getVictim(&_maze, WEST) > 0)
							{
								u8g_DrawEllipse(&u8g, disp_x+1, disp_y - (wall_size_part/2), wall_size_part/8, wall_size_part/6, U8G_DRAW_UPPER_RIGHT);
    8644:	9a 2e       	mov	r9, r26
    8646:	81 2c       	mov	r8, r1
	_maze.z = robot.pos.z;

	u8g_drawArrow(wall_size_part/2, MAP_ROB_POS_X, MAP_ROB_POS_Y, maze_alignDir(robot.dir + 3), 1);

	uint8_t map_tiles_rob_x = 0; //How many displayable tiles are at the x-achse on the left side of the robot?
	uint8_t map_tiles_rob_y = 0; //... y ...
    8648:	90 91 48 16 	lds	r25, 0x1648

	for(uint8_t maze_part_y = 0; maze_part_y <= map_part_size_y; maze_part_y++)
	{
		for(uint8_t maze_part_x = 0; maze_part_x <= map_part_size_x; maze_part_x++)
		{
			_maze.x = robot.pos.x + maze_part_x - map_tiles_rob_y;
    864c:	97 19       	sub	r25, r7
    864e:	98 0d       	add	r25, r8
    8650:	99 83       	std	Y+1, r25	; 0x01
    8652:	80 91 49 16 	lds	r24, 0x1649
			_maze.y = robot.pos.y + maze_part_y - map_tiles_rob_y;
    8656:	87 19       	sub	r24, r7
    8658:	86 0d       	add	r24, r6
    865a:	8a 83       	std	Y+2, r24	; 0x02
    865c:	9d 30       	cpi	r25, 0x0D	; 13

			if((_maze.x >= 0) && (_maze.y >= 0) && (_maze.x < MAZE_SIZE_X) && (_maze.y < MAZE_SIZE_Y)) //Existiert die Position in der Karte?
    865e:	08 f0       	brcs	.+2      	; 0x8662 <u8g_DrawMaze+0xe4>
    8660:	79 c2       	rjmp	.+1266   	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8662:	8d 30       	cpi	r24, 0x0D	; 13
    8664:	08 f0       	brcs	.+2      	; 0x8668 <u8g_DrawMaze+0xea>
    8666:	76 c2       	rjmp	.+1260   	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8668:	e5 e4       	ldi	r30, 0x45	; 69
			{
				if((disp_x < MAPEND_PART_X) && (disp_y >= MAPEND_PART_Y_TOP))
    866a:	eb 15       	cp	r30, r11
    866c:	44 f0       	brlt	.+16     	; 0x867e <u8g_DrawMaze+0x100>
    866e:	17 30       	cpi	r17, 0x07	; 7
    8670:	34 f0       	brlt	.+12     	; 0x867e <u8g_DrawMaze+0x100>
    8672:	41 2f       	mov	r20, r17
						u8g_DrawPixel(&u8g, disp_x, disp_y);
    8674:	6b 2d       	mov	r22, r11
    8676:	8b e1       	ldi	r24, 0x1B	; 27
    8678:	97 e0       	ldi	r25, 0x07	; 7
    867a:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    867e:	60 e0       	ldi	r22, 0x00	; 0

				int8_t wall_size_x_temp;
				int8_t wall_size_y_temp;

				if(maze_getGround(&_maze, NONE) > MAZE_ISBLTILE)
    8680:	ce 01       	movw	r24, r28
    8682:	01 96       	adiw	r24, 0x01	; 1
    8684:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <maze_getGround>
    8688:	60 91 c2 02 	lds	r22, 0x02C2
    868c:	82 30       	cpi	r24, 0x02	; 2
    868e:	3c f1       	brlt	.+78     	; 0x86de <u8g_DrawMaze+0x160>
    8690:	46 2f       	mov	r20, r22
				{
					wall_size_x_temp = wall_size_part;
					if(((int16_t) disp_x + wall_size_part) > MAPEND_PART_X)
    8692:	55 27       	eor	r21, r21
    8694:	47 fd       	sbrc	r20, 7
    8696:	50 95       	com	r21
    8698:	9a 01       	movw	r18, r20
    869a:	2b 0d       	add	r18, r11
    869c:	31 1d       	adc	r19, r1
    869e:	b7 fc       	sbrc	r11, 7
    86a0:	3a 95       	dec	r19
    86a2:	27 34       	cpi	r18, 0x47	; 71
    86a4:	31 05       	cpc	r19, r1
    86a6:	1c f0       	brlt	.+6      	; 0x86ae <u8g_DrawMaze+0x130>
    86a8:	23 2d       	mov	r18, r3
						wall_size_x_temp = MAPEND_PART_X-disp_x;
    86aa:	2b 19       	sub	r18, r11
    86ac:	01 c0       	rjmp	.+2      	; 0x86b0 <u8g_DrawMaze+0x132>
    86ae:	26 2f       	mov	r18, r22
				int8_t wall_size_x_temp;
				int8_t wall_size_y_temp;

				if(maze_getGround(&_maze, NONE) > MAZE_ISBLTILE)
				{
					wall_size_x_temp = wall_size_part;
    86b0:	81 2f       	mov	r24, r17
					if(((int16_t) disp_x + wall_size_part) > MAPEND_PART_X)
						wall_size_x_temp = MAPEND_PART_X-disp_x;

					wall_size_y_temp = wall_size_part;
					if(((int16_t)disp_y - wall_size_y_temp) < MAPEND_PART_Y_TOP)
    86b2:	99 27       	eor	r25, r25
    86b4:	87 fd       	sbrc	r24, 7
    86b6:	90 95       	com	r25
    86b8:	84 1b       	sub	r24, r20
    86ba:	95 0b       	sbc	r25, r21
    86bc:	07 97       	sbiw	r24, 0x07	; 7
    86be:	14 f4       	brge	.+4      	; 0x86c4 <u8g_DrawMaze+0x146>
    86c0:	6b ef       	ldi	r22, 0xFB	; 251
						wall_size_y_temp = disp_y - MAPEND_PART_Y_TOP + 2;
    86c2:	61 0f       	add	r22, r17
    86c4:	0f ef       	ldi	r16, 0xFF	; 255

					u8g_DrawBox(&u8g, disp_x+1, (uint8_t)disp_y+1-wall_size_y_temp, wall_size_x_temp-1, wall_size_y_temp-1);
    86c6:	06 0f       	add	r16, r22
    86c8:	21 50       	subi	r18, 0x01	; 1
    86ca:	41 e0       	ldi	r20, 0x01	; 1
    86cc:	41 0f       	add	r20, r17
    86ce:	46 1b       	sub	r20, r22
    86d0:	61 e0       	ldi	r22, 0x01	; 1
    86d2:	6b 0d       	add	r22, r11
    86d4:	8b e1       	ldi	r24, 0x1B	; 27
    86d6:	97 e0       	ldi	r25, 0x07	; 7
    86d8:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <u8g_DrawBox>
    86dc:	b4 c1       	rjmp	.+872    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    86de:	99 81       	ldd	r25, Y+1	; 0x01
				}
				else
				{
					if(!((_maze.x == robot.pos.x) && (_maze.y == robot.pos.y))) //Where is the robot?
    86e0:	80 91 48 16 	lds	r24, 0x1648
    86e4:	98 13       	cpse	r25, r24
    86e6:	0b c0       	rjmp	.+22     	; 0x86fe <u8g_DrawMaze+0x180>
    86e8:	9a 81       	ldd	r25, Y+2	; 0x02
    86ea:	80 91 49 16 	lds	r24, 0x1649
    86ee:	98 13       	cpse	r25, r24
    86f0:	06 c0       	rjmp	.+12     	; 0x86fe <u8g_DrawMaze+0x180>
    86f2:	20 91 c2 02 	lds	r18, 0x02C2
							}
						}
					}

					//Victims
					if(wall_size_part <= WALL_SIZE_STD)
    86f6:	2d 30       	cpi	r18, 0x0D	; 13
    86f8:	0c f4       	brge	.+2      	; 0x86fc <u8g_DrawMaze+0x17e>
    86fa:	89 c0       	rjmp	.+274    	; 0x880e <u8g_DrawMaze+0x290>
    86fc:	a4 c1       	rjmp	.+840    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    86fe:	eb 2c       	mov	r14, r11
				}
				else
				{
					if(!((_maze.x == robot.pos.x) && (_maze.y == robot.pos.y))) //Where is the robot?
					{
						if((disp_x + wall_size_part-2 < MAPEND_PART_X) &&
    8700:	ff 24       	eor	r15, r15
    8702:	e7 fc       	sbrc	r14, 7
    8704:	f0 94       	com	r15
    8706:	86 2f       	mov	r24, r22
    8708:	99 27       	eor	r25, r25
    870a:	87 fd       	sbrc	r24, 7
    870c:	90 95       	com	r25
    870e:	97 01       	movw	r18, r14
    8710:	28 0f       	add	r18, r24
    8712:	39 1f       	adc	r19, r25
    8714:	28 34       	cpi	r18, 0x48	; 72
    8716:	31 05       	cpc	r19, r1
    8718:	64 f7       	brge	.-40     	; 0x86f2 <u8g_DrawMaze+0x174>
    871a:	b7 fc       	sbrc	r11, 7
    871c:	ea cf       	rjmp	.-44     	; 0x86f2 <u8g_DrawMaze+0x174>
    871e:	c1 2e       	mov	r12, r17
						   (disp_x >= 0) &&
						   (disp_y - wall_size_part+2 > MAPEND_PART_Y_TOP))
    8720:	dd 24       	eor	r13, r13
    8722:	c7 fc       	sbrc	r12, 7
    8724:	d0 94       	com	r13
    8726:	96 01       	movw	r18, r12
    8728:	28 1b       	sub	r18, r24
    872a:	39 0b       	sbc	r19, r25
    872c:	26 30       	cpi	r18, 0x06	; 6
				else
				{
					if(!((_maze.x == robot.pos.x) && (_maze.y == robot.pos.y))) //Where is the robot?
					{
						if((disp_x + wall_size_part-2 < MAPEND_PART_X) &&
						   (disp_x >= 0) &&
    872e:	31 05       	cpc	r19, r1
    8730:	04 f3       	brlt	.-64     	; 0x86f2 <u8g_DrawMaze+0x174>
    8732:	60 e0       	ldi	r22, 0x00	; 0
						   (disp_y - wall_size_part+2 > MAPEND_PART_Y_TOP))
						{
							if(maze_getBeenthere(&_maze, NONE))
    8734:	ce 01       	movw	r24, r28
    8736:	01 96       	adiw	r24, 0x01	; 1
    8738:	0e 94 60 53 	call	0xa6c0	; 0xa6c0 <maze_getBeenthere>
    873c:	88 23       	and	r24, r24
    873e:	59 f0       	breq	.+22     	; 0x8756 <u8g_DrawMaze+0x1d8>
    8740:	60 91 c2 02 	lds	r22, 0x02C2
							{
								u8g_DrawPixel(&u8g,disp_x + wall_size_part - 2, disp_y - wall_size_part + 2);
    8744:	42 e0       	ldi	r20, 0x02	; 2
    8746:	46 1b       	sub	r20, r22
    8748:	41 0f       	add	r20, r17
    874a:	62 50       	subi	r22, 0x02	; 2
    874c:	6b 0d       	add	r22, r11
    874e:	8b e1       	ldi	r24, 0x1B	; 27
    8750:	97 e0       	ldi	r25, 0x07	; 7
    8752:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    8756:	ce 01       	movw	r24, r28
							}

							uint8_t ramp_dir = maze_getRampPosDir(&_maze);
    8758:	01 96       	adiw	r24, 0x01	; 1
    875a:	0e 94 f0 52 	call	0xa5e0	; 0xa5e0 <maze_getRampPosDir>
    875e:	21 2c       	mov	r2, r1

							for(uint8_t i = 0; i < 6; i++)
    8760:	3e ef       	ldi	r19, 0xFE	; 254
								else if((maze_getDepthsearch(&_maze, NONE) < 0xff) && (wall_size_part > 6))
								{
									if((disp_x + wall_size_part < MAPEND_PART_X) &&
									   (disp_y - wall_size_part > MAPEND_PART_Y_TOP))
									{
										u8g_DrawLong(disp_x+2, 	disp_y-2, maze_getDepthsearch(&_maze, NONE));
    8762:	31 0f       	add	r19, r17
    8764:	3c 83       	std	Y+4, r19	; 0x04
    8766:	82 e0       	ldi	r24, 0x02	; 2
    8768:	8b 0d       	add	r24, r11
    876a:	8d 83       	std	Y+5, r24	; 0x05
    876c:	62 2d       	mov	r22, r2

							uint8_t ramp_dir = maze_getRampPosDir(&_maze);

							for(uint8_t i = 0; i < 6; i++)
							{
								COORD checkpoint_disp = *maze_getCheckpoint(robot.pos.z, i);
    876e:	80 91 4a 16 	lds	r24, 0x164A
    8772:	2d d4       	rcall	.+2138   	; 0x8fce <maze_getCheckpoint>
    8774:	fc 01       	movw	r30, r24
    8776:	21 81       	ldd	r18, Z+1	; 0x01
    8778:	39 81       	ldd	r19, Y+1	; 0x01
    877a:	80 81       	ld	r24, Z

								if((_maze.x == checkpoint_disp.x) && (_maze.y == checkpoint_disp.y)) //Where is the checkpoint?
    877c:	38 13       	cpse	r19, r24
    877e:	1b c0       	rjmp	.+54     	; 0x87b6 <u8g_DrawMaze+0x238>
    8780:	8a 81       	ldd	r24, Y+2	; 0x02
    8782:	82 13       	cpse	r24, r18
    8784:	18 c0       	rjmp	.+48     	; 0x87b6 <u8g_DrawMaze+0x238>
    8786:	20 91 c2 02 	lds	r18, 0x02C2
								{
									u8g_DrawLine(&u8g, disp_x, disp_y, disp_x + wall_size_part, disp_y - wall_size_part);
    878a:	01 2f       	mov	r16, r17
    878c:	02 1b       	sub	r16, r18
    878e:	2b 0d       	add	r18, r11
    8790:	41 2f       	mov	r20, r17
    8792:	6b 2d       	mov	r22, r11
    8794:	8b e1       	ldi	r24, 0x1B	; 27
    8796:	97 e0       	ldi	r25, 0x07	; 7
    8798:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
    879c:	80 91 c2 02 	lds	r24, 0x02C2
									u8g_DrawLine(&u8g, disp_x, disp_y - wall_size_part, disp_x + wall_size_part, disp_y);
    87a0:	2b 2d       	mov	r18, r11
    87a2:	28 0f       	add	r18, r24
    87a4:	41 2f       	mov	r20, r17
    87a6:	48 1b       	sub	r20, r24
    87a8:	01 2f       	mov	r16, r17
    87aa:	6b 2d       	mov	r22, r11
    87ac:	8b e1       	ldi	r24, 0x1B	; 27
    87ae:	97 e0       	ldi	r25, 0x07	; 7
    87b0:	0e 94 d4 65 	call	0xcba8	; 0xcba8 <u8g_DrawLine>
    87b4:	27 c0       	rjmp	.+78     	; 0x8804 <u8g_DrawMaze+0x286>
    87b6:	60 e0       	ldi	r22, 0x00	; 0
    87b8:	ce 01       	movw	r24, r28
								}
								else if((maze_getDepthsearch(&_maze, NONE) < 0xff) && (wall_size_part > 6))
    87ba:	01 96       	adiw	r24, 0x01	; 1
    87bc:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    87c0:	8f 3f       	cpi	r24, 0xFF	; 255
    87c2:	01 f1       	breq	.+64     	; 0x8804 <u8g_DrawMaze+0x286>
    87c4:	80 91 c2 02 	lds	r24, 0x02C2
    87c8:	87 30       	cpi	r24, 0x07	; 7
    87ca:	e4 f0       	brlt	.+56     	; 0x8804 <u8g_DrawMaze+0x286>
    87cc:	99 27       	eor	r25, r25
    87ce:	87 fd       	sbrc	r24, 7
								{
									if((disp_x + wall_size_part < MAPEND_PART_X) &&
    87d0:	90 95       	com	r25
    87d2:	97 01       	movw	r18, r14
    87d4:	28 0f       	add	r18, r24
    87d6:	39 1f       	adc	r19, r25
    87d8:	26 34       	cpi	r18, 0x46	; 70
    87da:	31 05       	cpc	r19, r1
    87dc:	9c f4       	brge	.+38     	; 0x8804 <u8g_DrawMaze+0x286>
    87de:	96 01       	movw	r18, r12
    87e0:	28 1b       	sub	r18, r24
									   (disp_y - wall_size_part > MAPEND_PART_Y_TOP))
    87e2:	39 0b       	sbc	r19, r25
    87e4:	28 30       	cpi	r18, 0x08	; 8
    87e6:	31 05       	cpc	r19, r1
									u8g_DrawLine(&u8g, disp_x, disp_y, disp_x + wall_size_part, disp_y - wall_size_part);
									u8g_DrawLine(&u8g, disp_x, disp_y - wall_size_part, disp_x + wall_size_part, disp_y);
								}
								else if((maze_getDepthsearch(&_maze, NONE) < 0xff) && (wall_size_part > 6))
								{
									if((disp_x + wall_size_part < MAPEND_PART_X) &&
    87e8:	6c f0       	brlt	.+26     	; 0x8804 <u8g_DrawMaze+0x286>
    87ea:	60 e0       	ldi	r22, 0x00	; 0
    87ec:	ce 01       	movw	r24, r28
									   (disp_y - wall_size_part > MAPEND_PART_Y_TOP))
									{
										u8g_DrawLong(disp_x+2, 	disp_y-2, maze_getDepthsearch(&_maze, NONE));
    87ee:	01 96       	adiw	r24, 0x01	; 1
    87f0:	0e 94 dc 56 	call	0xadb8	; 0xadb8 <maze_getDepthsearch>
    87f4:	28 2f       	mov	r18, r24
    87f6:	30 e0       	ldi	r19, 0x00	; 0
    87f8:	40 e0       	ldi	r20, 0x00	; 0
    87fa:	50 e0       	ldi	r21, 0x00	; 0
    87fc:	6c 81       	ldd	r22, Y+4	; 0x04
    87fe:	8d 81       	ldd	r24, Y+5	; 0x05
    8800:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    8804:	23 94       	inc	r2
    8806:	36 e0       	ldi	r19, 0x06	; 6
								u8g_DrawPixel(&u8g,disp_x + wall_size_part - 2, disp_y - wall_size_part + 2);
							}

							uint8_t ramp_dir = maze_getRampPosDir(&_maze);

							for(uint8_t i = 0; i < 6; i++)
    8808:	23 12       	cpse	r2, r19
    880a:	b0 cf       	rjmp	.-160    	; 0x876c <u8g_DrawMaze+0x1ee>
    880c:	72 cf       	rjmp	.-284    	; 0x86f2 <u8g_DrawMaze+0x174>
    880e:	33 27       	eor	r19, r19
    8810:	27 fd       	sbrc	r18, 7
					}

					//Victims
					if(wall_size_part <= WALL_SIZE_STD)
					{
						if((disp_x + wall_size_part-2 < MAPEND_PART_X) &&
    8812:	30 95       	com	r19
    8814:	c9 01       	movw	r24, r18
    8816:	8b 0d       	add	r24, r11
    8818:	91 1d       	adc	r25, r1
    881a:	b7 fc       	sbrc	r11, 7
    881c:	9a 95       	dec	r25
    881e:	88 34       	cpi	r24, 0x48	; 72
    8820:	91 05       	cpc	r25, r1
    8822:	0c f0       	brlt	.+2      	; 0x8826 <u8g_DrawMaze+0x2a8>
    8824:	10 c1       	rjmp	.+544    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    8826:	b7 fc       	sbrc	r11, 7
    8828:	0e c1       	rjmp	.+540    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    882a:	81 2f       	mov	r24, r17
    882c:	99 27       	eor	r25, r25
						   (disp_x >= 0) &&
						   (disp_y - wall_size_part+2 > MAPEND_PART_Y_TOP))
    882e:	87 fd       	sbrc	r24, 7
    8830:	90 95       	com	r25
    8832:	82 1b       	sub	r24, r18
    8834:	93 0b       	sbc	r25, r19
    8836:	06 97       	sbiw	r24, 0x06	; 6
    8838:	0c f4       	brge	.+2      	; 0x883c <u8g_DrawMaze+0x2be>

					//Victims
					if(wall_size_part <= WALL_SIZE_STD)
					{
						if((disp_x + wall_size_part-2 < MAPEND_PART_X) &&
						   (disp_x >= 0) &&
    883a:	05 c1       	rjmp	.+522    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    883c:	61 e0       	ldi	r22, 0x01	; 1
    883e:	ce 01       	movw	r24, r28
						   (disp_y - wall_size_part+2 > MAPEND_PART_Y_TOP))
						{
							if(maze_getVictim(&_maze, NORTH) > 0)
    8840:	01 96       	adiw	r24, 0x01	; 1
    8842:	1a d6       	rcall	.+3124   	; 0x9478 <maze_getVictim>
    8844:	18 16       	cp	r1, r24
    8846:	d4 f5       	brge	.+116    	; 0x88bc <u8g_DrawMaze+0x33e>
    8848:	30 91 c2 02 	lds	r19, 0x02C2
    884c:	03 2f       	mov	r16, r19
							{
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y - wall_size_part+1, wall_size_part/6, wall_size_part/8, U8G_DRAW_LOWER_RIGHT);
    884e:	37 ff       	sbrs	r19, 7
    8850:	02 c0       	rjmp	.+4      	; 0x8856 <u8g_DrawMaze+0x2d8>
    8852:	07 e0       	ldi	r16, 0x07	; 7
    8854:	03 0f       	add	r16, r19
    8856:	05 95       	asr	r16
    8858:	05 95       	asr	r16
    885a:	05 95       	asr	r16
    885c:	83 2f       	mov	r24, r19
    885e:	69 2d       	mov	r22, r9
    8860:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    8864:	41 2f       	mov	r20, r17
    8866:	43 1b       	sub	r20, r19
    8868:	4f 5f       	subi	r20, 0xFF	; 255
    886a:	37 fd       	sbrc	r19, 7
    886c:	3f 5f       	subi	r19, 0xFF	; 255
    886e:	63 2f       	mov	r22, r19
    8870:	65 95       	asr	r22
    8872:	6b 0d       	add	r22, r11
    8874:	e8 e0       	ldi	r30, 0x08	; 8
    8876:	ee 2e       	mov	r14, r30
    8878:	28 2f       	mov	r18, r24
    887a:	8b e1       	ldi	r24, 0x1B	; 27
    887c:	97 e0       	ldi	r25, 0x07	; 7
    887e:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    8882:	30 91 c2 02 	lds	r19, 0x02C2
    8886:	03 2f       	mov	r16, r19
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y - wall_size_part+1, wall_size_part/6, wall_size_part/8, U8G_DRAW_LOWER_LEFT);
    8888:	37 ff       	sbrs	r19, 7
    888a:	02 c0       	rjmp	.+4      	; 0x8890 <u8g_DrawMaze+0x312>
    888c:	07 e0       	ldi	r16, 0x07	; 7
    888e:	03 0f       	add	r16, r19
    8890:	05 95       	asr	r16
    8892:	05 95       	asr	r16
    8894:	05 95       	asr	r16
    8896:	83 2f       	mov	r24, r19
    8898:	69 2d       	mov	r22, r9
    889a:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    889e:	41 2f       	mov	r20, r17
    88a0:	43 1b       	sub	r20, r19
    88a2:	4f 5f       	subi	r20, 0xFF	; 255
    88a4:	37 fd       	sbrc	r19, 7
    88a6:	3f 5f       	subi	r19, 0xFF	; 255
    88a8:	63 2f       	mov	r22, r19
    88aa:	65 95       	asr	r22
    88ac:	6b 0d       	add	r22, r11
    88ae:	74 e0       	ldi	r23, 0x04	; 4
    88b0:	e7 2e       	mov	r14, r23
    88b2:	28 2f       	mov	r18, r24
    88b4:	8b e1       	ldi	r24, 0x1B	; 27
    88b6:	97 e0       	ldi	r25, 0x07	; 7
    88b8:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    88bc:	62 e0       	ldi	r22, 0x02	; 2
    88be:	ce 01       	movw	r24, r28
    88c0:	01 96       	adiw	r24, 0x01	; 1
							}
							if(maze_getVictim(&_maze, EAST) > 0)
    88c2:	da d5       	rcall	.+2996   	; 0x9478 <maze_getVictim>
    88c4:	18 16       	cp	r1, r24
    88c6:	0c f0       	brlt	.+2      	; 0x88ca <u8g_DrawMaze+0x34c>
    88c8:	40 c0       	rjmp	.+128    	; 0x894a <u8g_DrawMaze+0x3cc>
    88ca:	30 91 c2 02 	lds	r19, 0x02C2
    88ce:	83 2f       	mov	r24, r19
    88d0:	69 2d       	mov	r22, r9
							{
								u8g_DrawEllipse(&u8g, disp_x + wall_size_part-1, disp_y - (wall_size_part/2), wall_size_part/8, wall_size_part/6, U8G_DRAW_UPPER_LEFT);
    88d2:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    88d6:	23 2f       	mov	r18, r19
    88d8:	37 ff       	sbrs	r19, 7
    88da:	02 c0       	rjmp	.+4      	; 0x88e0 <u8g_DrawMaze+0x362>
    88dc:	27 e0       	ldi	r18, 0x07	; 7
    88de:	23 0f       	add	r18, r19
    88e0:	25 95       	asr	r18
    88e2:	25 95       	asr	r18
    88e4:	25 95       	asr	r18
    88e6:	93 2f       	mov	r25, r19
    88e8:	37 ff       	sbrs	r19, 7
    88ea:	02 c0       	rjmp	.+4      	; 0x88f0 <u8g_DrawMaze+0x372>
    88ec:	91 e0       	ldi	r25, 0x01	; 1
    88ee:	93 0f       	add	r25, r19
    88f0:	95 95       	asr	r25
    88f2:	41 2f       	mov	r20, r17
    88f4:	49 1b       	sub	r20, r25
    88f6:	6f ef       	ldi	r22, 0xFF	; 255
    88f8:	63 0f       	add	r22, r19
    88fa:	6b 0d       	add	r22, r11
    88fc:	52 e0       	ldi	r21, 0x02	; 2
    88fe:	e5 2e       	mov	r14, r21
    8900:	08 2f       	mov	r16, r24
    8902:	8b e1       	ldi	r24, 0x1B	; 27
    8904:	97 e0       	ldi	r25, 0x07	; 7
    8906:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    890a:	30 91 c2 02 	lds	r19, 0x02C2
    890e:	83 2f       	mov	r24, r19
    8910:	69 2d       	mov	r22, r9
								u8g_DrawEllipse(&u8g, disp_x + wall_size_part-1, disp_y - (wall_size_part/2), wall_size_part/8, wall_size_part/6, U8G_DRAW_LOWER_LEFT);
    8912:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    8916:	23 2f       	mov	r18, r19
    8918:	37 ff       	sbrs	r19, 7
    891a:	02 c0       	rjmp	.+4      	; 0x8920 <u8g_DrawMaze+0x3a2>
    891c:	27 e0       	ldi	r18, 0x07	; 7
    891e:	23 0f       	add	r18, r19
    8920:	25 95       	asr	r18
    8922:	25 95       	asr	r18
    8924:	25 95       	asr	r18
    8926:	93 2f       	mov	r25, r19
    8928:	37 ff       	sbrs	r19, 7
    892a:	02 c0       	rjmp	.+4      	; 0x8930 <u8g_DrawMaze+0x3b2>
    892c:	91 e0       	ldi	r25, 0x01	; 1
    892e:	93 0f       	add	r25, r19
    8930:	95 95       	asr	r25
    8932:	41 2f       	mov	r20, r17
    8934:	49 1b       	sub	r20, r25
    8936:	6f ef       	ldi	r22, 0xFF	; 255
    8938:	63 0f       	add	r22, r19
    893a:	6b 0d       	add	r22, r11
    893c:	34 e0       	ldi	r19, 0x04	; 4
    893e:	e3 2e       	mov	r14, r19
    8940:	08 2f       	mov	r16, r24
    8942:	8b e1       	ldi	r24, 0x1B	; 27
    8944:	97 e0       	ldi	r25, 0x07	; 7
    8946:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    894a:	63 e0       	ldi	r22, 0x03	; 3
    894c:	ce 01       	movw	r24, r28
    894e:	01 96       	adiw	r24, 0x01	; 1
    8950:	93 d5       	rcall	.+2854   	; 0x9478 <maze_getVictim>
							}
							if(maze_getVictim(&_maze, SOUTH) > 0)
    8952:	18 16       	cp	r1, r24
    8954:	cc f5       	brge	.+114    	; 0x89c8 <u8g_DrawMaze+0x44a>
    8956:	30 91 c2 02 	lds	r19, 0x02C2
    895a:	ff 24       	eor	r15, r15
    895c:	fa 94       	dec	r15
    895e:	f1 0e       	add	r15, r17
							{
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y-1, wall_size_part/6, wall_size_part/8, U8G_DRAW_UPPER_LEFT);
    8960:	03 2f       	mov	r16, r19
    8962:	37 ff       	sbrs	r19, 7
    8964:	02 c0       	rjmp	.+4      	; 0x896a <u8g_DrawMaze+0x3ec>
    8966:	07 e0       	ldi	r16, 0x07	; 7
    8968:	03 0f       	add	r16, r19
    896a:	05 95       	asr	r16
    896c:	05 95       	asr	r16
    896e:	05 95       	asr	r16
    8970:	83 2f       	mov	r24, r19
    8972:	69 2d       	mov	r22, r9
    8974:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    8978:	37 fd       	sbrc	r19, 7
    897a:	3f 5f       	subi	r19, 0xFF	; 255
    897c:	63 2f       	mov	r22, r19
    897e:	65 95       	asr	r22
    8980:	6b 0d       	add	r22, r11
    8982:	92 e0       	ldi	r25, 0x02	; 2
    8984:	e9 2e       	mov	r14, r25
    8986:	28 2f       	mov	r18, r24
    8988:	4f 2d       	mov	r20, r15
    898a:	8b e1       	ldi	r24, 0x1B	; 27
    898c:	97 e0       	ldi	r25, 0x07	; 7
    898e:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    8992:	30 91 c2 02 	lds	r19, 0x02C2
    8996:	03 2f       	mov	r16, r19
    8998:	37 ff       	sbrs	r19, 7
    899a:	02 c0       	rjmp	.+4      	; 0x89a0 <u8g_DrawMaze+0x422>
								u8g_DrawEllipse(&u8g, disp_x + (wall_size_part/2), disp_y-1, wall_size_part/6, wall_size_part/8, U8G_DRAW_UPPER_RIGHT);
    899c:	07 e0       	ldi	r16, 0x07	; 7
    899e:	03 0f       	add	r16, r19
    89a0:	05 95       	asr	r16
    89a2:	05 95       	asr	r16
    89a4:	05 95       	asr	r16
    89a6:	83 2f       	mov	r24, r19
    89a8:	69 2d       	mov	r22, r9
    89aa:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    89ae:	37 fd       	sbrc	r19, 7
    89b0:	3f 5f       	subi	r19, 0xFF	; 255
    89b2:	63 2f       	mov	r22, r19
    89b4:	65 95       	asr	r22
    89b6:	6b 0d       	add	r22, r11
    89b8:	ee 24       	eor	r14, r14
    89ba:	e3 94       	inc	r14
    89bc:	28 2f       	mov	r18, r24
    89be:	4f 2d       	mov	r20, r15
    89c0:	8b e1       	ldi	r24, 0x1B	; 27
    89c2:	97 e0       	ldi	r25, 0x07	; 7
    89c4:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    89c8:	64 e0       	ldi	r22, 0x04	; 4
    89ca:	ce 01       	movw	r24, r28
    89cc:	01 96       	adiw	r24, 0x01	; 1
    89ce:	54 d5       	rcall	.+2728   	; 0x9478 <maze_getVictim>
    89d0:	18 16       	cp	r1, r24
							}
							if(maze_getVictim(&_maze, WEST) > 0)
    89d2:	cc f5       	brge	.+114    	; 0x8a46 <u8g_DrawMaze+0x4c8>
    89d4:	30 91 c2 02 	lds	r19, 0x02C2
    89d8:	ff 24       	eor	r15, r15
    89da:	f3 94       	inc	r15
    89dc:	fb 0c       	add	r15, r11
    89de:	83 2f       	mov	r24, r19
							{
								u8g_DrawEllipse(&u8g, disp_x+1, disp_y - (wall_size_part/2), wall_size_part/8, wall_size_part/6, U8G_DRAW_UPPER_RIGHT);
    89e0:	69 2d       	mov	r22, r9
    89e2:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
    89e6:	23 2f       	mov	r18, r19
    89e8:	37 ff       	sbrs	r19, 7
    89ea:	02 c0       	rjmp	.+4      	; 0x89f0 <u8g_DrawMaze+0x472>
    89ec:	27 e0       	ldi	r18, 0x07	; 7
    89ee:	23 0f       	add	r18, r19
    89f0:	25 95       	asr	r18
    89f2:	25 95       	asr	r18
    89f4:	25 95       	asr	r18
    89f6:	37 fd       	sbrc	r19, 7
    89f8:	3f 5f       	subi	r19, 0xFF	; 255
    89fa:	35 95       	asr	r19
    89fc:	41 2f       	mov	r20, r17
    89fe:	43 1b       	sub	r20, r19
    8a00:	ee 24       	eor	r14, r14
    8a02:	e3 94       	inc	r14
    8a04:	08 2f       	mov	r16, r24
    8a06:	6f 2d       	mov	r22, r15
    8a08:	8b e1       	ldi	r24, 0x1B	; 27
    8a0a:	97 e0       	ldi	r25, 0x07	; 7
    8a0c:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    8a10:	30 91 c2 02 	lds	r19, 0x02C2
    8a14:	83 2f       	mov	r24, r19
    8a16:	69 2d       	mov	r22, r9
    8a18:	0e 94 4b 6b 	call	0xd696	; 0xd696 <__divmodqi4>
								u8g_DrawEllipse(&u8g, disp_x+1, disp_y - (wall_size_part/2), wall_size_part/8, wall_size_part/6, U8G_DRAW_LOWER_RIGHT);
    8a1c:	23 2f       	mov	r18, r19
    8a1e:	37 ff       	sbrs	r19, 7
    8a20:	02 c0       	rjmp	.+4      	; 0x8a26 <u8g_DrawMaze+0x4a8>
    8a22:	27 e0       	ldi	r18, 0x07	; 7
    8a24:	23 0f       	add	r18, r19
    8a26:	25 95       	asr	r18
    8a28:	25 95       	asr	r18
    8a2a:	25 95       	asr	r18
    8a2c:	37 fd       	sbrc	r19, 7
    8a2e:	3f 5f       	subi	r19, 0xFF	; 255
    8a30:	35 95       	asr	r19
    8a32:	41 2f       	mov	r20, r17
    8a34:	43 1b       	sub	r20, r19
    8a36:	08 e0       	ldi	r16, 0x08	; 8
    8a38:	e0 2e       	mov	r14, r16
    8a3a:	08 2f       	mov	r16, r24
    8a3c:	6f 2d       	mov	r22, r15
    8a3e:	8b e1       	ldi	r24, 0x1B	; 27
    8a40:	97 e0       	ldi	r25, 0x07	; 7
    8a42:	0e 94 b2 65 	call	0xcb64	; 0xcb64 <u8g_DrawEllipse>
    8a46:	89 81       	ldd	r24, Y+1	; 0x01
    8a48:	8c 30       	cpi	r24, 0x0C	; 12
    8a4a:	0c f0       	brlt	.+2      	; 0x8a4e <u8g_DrawMaze+0x4d0>
    8a4c:	3d c0       	rjmp	.+122    	; 0x8ac8 <u8g_DrawMaze+0x54a>
    8a4e:	63 e0       	ldi	r22, 0x03	; 3
    8a50:	ce 01       	movw	r24, r28
						}
					}
				}

				//Wall south
				if(_maze.x < MAZE_SIZE_X-1)
    8a52:	01 96       	adiw	r24, 0x01	; 1
    8a54:	84 d6       	rcall	.+3336   	; 0x975e <maze_getWall>
    8a56:	81 11       	cpse	r24, r1
    8a58:	22 c0       	rjmp	.+68     	; 0x8a9e <u8g_DrawMaze+0x520>
				{
					int8_t wall_tmp = maze_getWall(&_maze, SOUTH);
    8a5a:	02 e0       	ldi	r16, 0x02	; 2
    8a5c:	0b 0d       	add	r16, r11
    8a5e:	eb 2c       	mov	r14, r11
    8a60:	ff 24       	eor	r15, r15
    8a62:	e7 fc       	sbrc	r14, 7

					if(wall_tmp == 0)
    8a64:	f0 94       	com	r15
    8a66:	80 91 c2 02 	lds	r24, 0x02C2
					{
						for(int8_t i = disp_x + 2; i < disp_x + wall_size_part - 1; i += 2)
    8a6a:	f7 01       	movw	r30, r14
    8a6c:	e8 0f       	add	r30, r24
    8a6e:	f1 1d       	adc	r31, r1
    8a70:	87 fd       	sbrc	r24, 7
    8a72:	fa 95       	dec	r31
    8a74:	cf 01       	movw	r24, r30
    8a76:	01 97       	sbiw	r24, 0x01	; 1
    8a78:	20 2f       	mov	r18, r16
    8a7a:	33 27       	eor	r19, r19
    8a7c:	27 fd       	sbrc	r18, 7
    8a7e:	30 95       	com	r19
    8a80:	28 17       	cp	r18, r24
    8a82:	39 07       	cpc	r19, r25
    8a84:	0c f5       	brge	.+66     	; 0x8ac8 <u8g_DrawMaze+0x54a>
    8a86:	06 34       	cpi	r16, 0x46	; 70
    8a88:	40 f4       	brcc	.+16     	; 0x8a9a <u8g_DrawMaze+0x51c>
    8a8a:	17 30       	cpi	r17, 0x07	; 7
    8a8c:	34 f0       	brlt	.+12     	; 0x8a9a <u8g_DrawMaze+0x51c>
    8a8e:	41 2f       	mov	r20, r17
    8a90:	60 2f       	mov	r22, r16
    8a92:	8b e1       	ldi	r24, 0x1B	; 27
						{
							if((i >= 0) && (i < MAPEND_PART_X) && (disp_y >= MAPEND_PART_Y_TOP))
    8a94:	97 e0       	ldi	r25, 0x07	; 7
    8a96:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    8a9a:	0e 5f       	subi	r16, 0xFE	; 254
								u8g_DrawPixel(&u8g, i, disp_y);
    8a9c:	e4 cf       	rjmp	.-56     	; 0x8a66 <u8g_DrawMaze+0x4e8>
    8a9e:	85 30       	cpi	r24, 0x05	; 5
    8aa0:	9c f0       	brlt	.+38     	; 0x8ac8 <u8g_DrawMaze+0x54a>
    8aa2:	20 91 c2 02 	lds	r18, 0x02C2
    8aa6:	8b 2d       	mov	r24, r11
    8aa8:	82 0f       	add	r24, r18
    8aaa:	87 34       	cpi	r24, 0x47	; 71
						}
					}
					else if(wall_tmp > MAZE_ISWALL)
    8aac:	10 f0       	brcs	.+4      	; 0x8ab2 <u8g_DrawMaze+0x534>
    8aae:	23 2d       	mov	r18, r3
					{
						wall_size_x_temp = wall_size_part;
    8ab0:	2b 19       	sub	r18, r11
    8ab2:	f5 e4       	ldi	r31, 0x45	; 69

						if((uint8_t)(disp_x + wall_size_part) > MAPEND_PART_X)
    8ab4:	fb 15       	cp	r31, r11
    8ab6:	44 f0       	brlt	.+16     	; 0x8ac8 <u8g_DrawMaze+0x54a>
    8ab8:	18 30       	cpi	r17, 0x08	; 8
    8aba:	34 f0       	brlt	.+12     	; 0x8ac8 <u8g_DrawMaze+0x54a>
						{
							wall_size_x_temp = MAPEND_PART_X-disp_x;
    8abc:	41 2f       	mov	r20, r17
    8abe:	6b 2d       	mov	r22, r11
						}
						if((disp_x < MAPEND_PART_X) && (disp_y > MAPEND_PART_Y_TOP))
    8ac0:	8b e1       	ldi	r24, 0x1B	; 27
    8ac2:	97 e0       	ldi	r25, 0x07	; 7
    8ac4:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <u8g_DrawHLine>
    8ac8:	8a 81       	ldd	r24, Y+2	; 0x02
							u8g_DrawHLine(&u8g, disp_x, disp_y, wall_size_x_temp);
    8aca:	8c 30       	cpi	r24, 0x0C	; 12
    8acc:	0c f0       	brlt	.+2      	; 0x8ad0 <u8g_DrawMaze+0x552>
    8ace:	42 c0       	rjmp	.+132    	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8ad0:	64 e0       	ldi	r22, 0x04	; 4
    8ad2:	ce 01       	movw	r24, r28
    8ad4:	01 96       	adiw	r24, 0x01	; 1
					}
				}

				//Wall west
				if(_maze.y < MAZE_SIZE_Y-1)
    8ad6:	43 d6       	rcall	.+3206   	; 0x975e <maze_getWall>
    8ad8:	20 91 c2 02 	lds	r18, 0x02C2
    8adc:	81 11       	cpse	r24, r1
				{
					int8_t wall_tmp = maze_getWall(&_maze, WEST);
    8ade:	20 c0       	rjmp	.+64     	; 0x8b20 <u8g_DrawMaze+0x5a2>
    8ae0:	02 e0       	ldi	r16, 0x02	; 2
    8ae2:	02 1b       	sub	r16, r18
    8ae4:	01 0f       	add	r16, r17
    8ae6:	e1 2e       	mov	r14, r17
    8ae8:	ff 24       	eor	r15, r15
    8aea:	e7 fc       	sbrc	r14, 7

					if(wall_tmp == 0)
    8aec:	f0 94       	com	r15
    8aee:	21 e0       	ldi	r18, 0x01	; 1
					{
						for(int8_t i = disp_y - wall_size_part + 2; i < disp_y - 1; i += 2)
    8af0:	e2 1a       	sub	r14, r18
    8af2:	f1 08       	sbc	r15, r1
    8af4:	80 2f       	mov	r24, r16
    8af6:	99 27       	eor	r25, r25
    8af8:	87 fd       	sbrc	r24, 7
    8afa:	90 95       	com	r25
    8afc:	8e 15       	cp	r24, r14
    8afe:	9f 05       	cpc	r25, r15
    8b00:	4c f5       	brge	.+82     	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8b02:	89 ef       	ldi	r24, 0xF9	; 249
    8b04:	80 0f       	add	r24, r16
    8b06:	89 33       	cpi	r24, 0x39	; 57
    8b08:	48 f4       	brcc	.+18     	; 0x8b1c <u8g_DrawMaze+0x59e>
    8b0a:	35 e4       	ldi	r19, 0x45	; 69
    8b0c:	3b 15       	cp	r19, r11
    8b0e:	34 f0       	brlt	.+12     	; 0x8b1c <u8g_DrawMaze+0x59e>
    8b10:	40 2f       	mov	r20, r16
    8b12:	6b 2d       	mov	r22, r11
    8b14:	8b e1       	ldi	r24, 0x1B	; 27
						{
							if((i >= MAPEND_PART_Y_TOP) && (i <= MAPEND_PART_Y) && (disp_x < MAPEND_PART_X))
    8b16:	97 e0       	ldi	r25, 0x07	; 7
    8b18:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    8b1c:	0e 5f       	subi	r16, 0xFE	; 254
    8b1e:	ea cf       	rjmp	.-44     	; 0x8af4 <u8g_DrawMaze+0x576>
								u8g_DrawPixel(&u8g, disp_x, i);
    8b20:	85 30       	cpi	r24, 0x05	; 5
    8b22:	c4 f0       	brlt	.+48     	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8b24:	81 2f       	mov	r24, r17
    8b26:	99 27       	eor	r25, r25
    8b28:	87 fd       	sbrc	r24, 7
    8b2a:	90 95       	com	r25
    8b2c:	82 1b       	sub	r24, r18
    8b2e:	91 09       	sbc	r25, r1
						}
					}
					else if(wall_tmp > MAZE_ISWALL)
    8b30:	27 fd       	sbrc	r18, 7
    8b32:	93 95       	inc	r25
					{
						wall_size_y_temp = wall_size_part;
						if(disp_y - wall_size_y_temp <= MAPEND_PART_Y_TOP)
    8b34:	08 97       	sbiw	r24, 0x08	; 8
    8b36:	14 f4       	brge	.+4      	; 0x8b3c <u8g_DrawMaze+0x5be>
    8b38:	2a ef       	ldi	r18, 0xFA	; 250
    8b3a:	21 0f       	add	r18, r17
    8b3c:	85 e4       	ldi	r24, 0x45	; 69
    8b3e:	8b 15       	cp	r24, r11
    8b40:	4c f0       	brlt	.+18     	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8b42:	18 30       	cpi	r17, 0x08	; 8
    8b44:	3c f0       	brlt	.+14     	; 0x8b54 <u8g_DrawMaze+0x5d6>
    8b46:	41 2f       	mov	r20, r17
						{
							wall_size_y_temp = disp_y - MAPEND_PART_Y_TOP + 1;
    8b48:	42 1b       	sub	r20, r18
    8b4a:	6b 2d       	mov	r22, r11
						}
						if((disp_x < MAPEND_PART_X) && (disp_y > MAPEND_PART_Y_TOP))
    8b4c:	8b e1       	ldi	r24, 0x1B	; 27
    8b4e:	97 e0       	ldi	r25, 0x07	; 7
    8b50:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    8b54:	80 91 c2 02 	lds	r24, 0x02C2
							u8g_DrawVLine(&u8g, disp_x, disp_y-wall_size_y_temp, wall_size_y_temp);
    8b58:	b8 0e       	add	r11, r24
    8b5a:	85 10       	cpse	r8, r5
    8b5c:	02 c0       	rjmp	.+4      	; 0x8b62 <u8g_DrawMaze+0x5e4>
    8b5e:	18 1b       	sub	r17, r24
    8b60:	ba 2c       	mov	r11, r10
    8b62:	83 94       	inc	r8
					}
				}
			}
			disp_x += wall_size_part;
    8b64:	58 14       	cp	r5, r8
    8b66:	08 f0       	brcs	.+2      	; 0x8b6a <u8g_DrawMaze+0x5ec>
    8b68:	6f cd       	rjmp	.-1314   	; 0x8648 <u8g_DrawMaze+0xca>
			if(maze_part_x == map_part_size_x)
    8b6a:	63 94       	inc	r6
    8b6c:	46 14       	cp	r4, r6
			{
				disp_y -= wall_size_part;
    8b6e:	08 f0       	brcs	.+2      	; 0x8b72 <u8g_DrawMaze+0x5f4>
				disp_x = mapstart_x;
    8b70:	6a cd       	rjmp	.-1324   	; 0x8646 <u8g_DrawMaze+0xc8>
	if(MAPEND_PART_Y % wall_size_part != 0)
		map_part_size_y ++;

	for(uint8_t maze_part_y = 0; maze_part_y <= map_part_size_y; maze_part_y++)
	{
		for(uint8_t maze_part_x = 0; maze_part_x <= map_part_size_x; maze_part_x++)
    8b72:	29 e3       	ldi	r18, 0x39	; 57
    8b74:	47 e0       	ldi	r20, 0x07	; 7
    8b76:	65 e4       	ldi	r22, 0x45	; 69
    8b78:	8b e1       	ldi	r24, 0x1B	; 27

	uint8_t map_part_size_y = MAPEND_PART_Y / wall_size_part; //Size of the extract of the map
	if(MAPEND_PART_Y % wall_size_part != 0)
		map_part_size_y ++;

	for(uint8_t maze_part_y = 0; maze_part_y <= map_part_size_y; maze_part_y++)
    8b7a:	97 e0       	ldi	r25, 0x07	; 7
    8b7c:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <u8g_DrawVLine>
    8b80:	0e 94 59 5b 	call	0xb6b2	; 0xb6b2 <get_incrOk>
	//				//Ka//      //
	//				//rt//      //
	//				//eX//      //
	//////////////////////////////

	u8g_DrawVLine(&u8g, MAPEND_PART_X-1, 7, 57); //Vertikale Abgenzung
    8b84:	88 23       	and	r24, r24
    8b86:	11 f1       	breq	.+68     	; 0x8bcc <u8g_DrawMaze+0x64e>
    8b88:	80 91 50 05 	lds	r24, 0x0550
    8b8c:	81 11       	cpse	r24, r1
    8b8e:	1e c0       	rjmp	.+60     	; 0x8bcc <u8g_DrawMaze+0x64e>

	//Positionswahl per Inkrementalgeber

	if(get_incrOk() && (timer_incr_entpr == 0) && mot.off)
    8b90:	80 91 7f 16 	lds	r24, 0x167F
    8b94:	88 23       	and	r24, r24
    8b96:	d1 f0       	breq	.+52     	; 0x8bcc <u8g_DrawMaze+0x64e>
    8b98:	80 91 c3 02 	lds	r24, 0x02C3
    8b9c:	8f 5f       	subi	r24, 0xFF	; 255
    8b9e:	85 30       	cpi	r24, 0x05	; 5
    8ba0:	18 f4       	brcc	.+6      	; 0x8ba8 <u8g_DrawMaze+0x62a>
    8ba2:	80 93 c3 02 	sts	0x02C3, r24
    8ba6:	02 c0       	rjmp	.+4      	; 0x8bac <u8g_DrawMaze+0x62e>
	{
		incr_ok_mode ++;
    8ba8:	10 92 c3 02 	sts	0x02C3, r1
    8bac:	84 e1       	ldi	r24, 0x14	; 20
		if(incr_ok_mode > INCR_OK_MODE_CNT)
    8bae:	80 93 50 05 	sts	0x0550, r24

	//Positionswahl per Inkrementalgeber

	if(get_incrOk() && (timer_incr_entpr == 0) && mot.off)
	{
		incr_ok_mode ++;
    8bb2:	80 91 c3 02 	lds	r24, 0x02C3
    8bb6:	81 30       	cpi	r24, 0x01	; 1
		if(incr_ok_mode > INCR_OK_MODE_CNT)
			incr_ok_mode = 0;
    8bb8:	49 f4       	brne	.+18     	; 0x8bcc <u8g_DrawMaze+0x64e>
    8bba:	0e 94 c3 34 	call	0x6986	; 0x6986 <drive_reset>
		timer_incr_entpr = TIMER_ENTPR_INCR;
    8bbe:	e2 d1       	rcall	.+964    	; 0x8f84 <maze_clearDepthsearch>
    8bc0:	10 92 cd 05 	sts	0x05CD, r1

		if(incr_ok_mode == 1)
    8bc4:	10 92 c6 05 	sts	0x05C6, r1
    8bc8:	10 92 c4 05 	sts	0x05C4, r1
		{
			drive_reset(); //Fahrfunktionen zurcksetzen
    8bcc:	80 91 c3 02 	lds	r24, 0x02C3
			maze_clearDepthsearch();
    8bd0:	84 30       	cpi	r24, 0x04	; 4
				maze_solve_state_path = DRIVE_READY;
    8bd2:	09 f4       	brne	.+2      	; 0x8bd6 <u8g_DrawMaze+0x658>
    8bd4:	e8 c0       	rjmp	.+464    	; 0x8da6 <u8g_DrawMaze+0x828>
				routeRequest = RR_WAIT;
    8bd6:	81 30       	cpi	r24, 0x01	; 1
    8bd8:	a1 f0       	breq	.+40     	; 0x8c02 <u8g_DrawMaze+0x684>
				locRequest = LR_WAIT;
    8bda:	28 f0       	brcs	.+10     	; 0x8be6 <u8g_DrawMaze+0x668>
    8bdc:	82 30       	cpi	r24, 0x02	; 2
		}
	}

	if(incr_ok_mode != 4)
    8bde:	f9 f0       	breq	.+62     	; 0x8c1e <u8g_DrawMaze+0x6a0>
    8be0:	83 30       	cpi	r24, 0x03	; 3
    8be2:	59 f1       	breq	.+86     	; 0x8c3a <u8g_DrawMaze+0x6bc>
    8be4:	3f c0       	rjmp	.+126    	; 0x8c64 <u8g_DrawMaze+0x6e6>
    8be6:	90 91 58 05 	lds	r25, 0x0558
	{
		switch(incr_ok_mode)
    8bea:	80 91 bb 05 	lds	r24, 0x05BB
    8bee:	98 1b       	sub	r25, r24
    8bf0:	80 91 c1 05 	lds	r24, 0x05C1
    8bf4:	e2 e0       	ldi	r30, 0x02	; 2
    8bf6:	9e 9f       	mul	r25, r30
		{
			case 0:		cursor_robot_pos_x += (incremental-incremental_old_mz)*2;		break;
    8bf8:	80 0d       	add	r24, r0
    8bfa:	11 24       	eor	r1, r1
    8bfc:	80 93 c1 05 	sts	0x05C1, r24
    8c00:	4a c0       	rjmp	.+148    	; 0x8c96 <u8g_DrawMaze+0x718>
    8c02:	90 91 58 05 	lds	r25, 0x0558
    8c06:	80 91 bb 05 	lds	r24, 0x05BB
    8c0a:	98 1b       	sub	r25, r24
    8c0c:	80 91 c0 05 	lds	r24, 0x05C0
    8c10:	f2 e0       	ldi	r31, 0x02	; 2
    8c12:	9f 9f       	mul	r25, r31
			case 1:		cursor_robot_pos_y += (incremental-incremental_old_mz)*2;		break;
    8c14:	80 0d       	add	r24, r0
    8c16:	11 24       	eor	r1, r1
    8c18:	80 93 c0 05 	sts	0x05C0, r24
    8c1c:	3c c0       	rjmp	.+120    	; 0x8c96 <u8g_DrawMaze+0x718>
    8c1e:	90 91 bb 05 	lds	r25, 0x05BB
    8c22:	80 91 58 05 	lds	r24, 0x0558
    8c26:	98 1b       	sub	r25, r24
    8c28:	80 91 bf 05 	lds	r24, 0x05BF
    8c2c:	22 e0       	ldi	r18, 0x02	; 2
    8c2e:	92 9f       	mul	r25, r18
			case 2:		cursor_robot_dir -= (incremental-incremental_old_mz)*2;			break;
    8c30:	80 0d       	add	r24, r0
    8c32:	11 24       	eor	r1, r1
    8c34:	80 93 bf 05 	sts	0x05BF, r24
    8c38:	2e c0       	rjmp	.+92     	; 0x8c96 <u8g_DrawMaze+0x718>
    8c3a:	90 91 58 05 	lds	r25, 0x0558
    8c3e:	80 91 bb 05 	lds	r24, 0x05BB
    8c42:	98 1b       	sub	r25, r24
    8c44:	80 91 c2 02 	lds	r24, 0x02C2
    8c48:	32 e0       	ldi	r19, 0x02	; 2
    8c4a:	93 9f       	mul	r25, r19
			case 3:		wall_size_part += (incremental-incremental_old_mz)*2;
    8c4c:	80 0d       	add	r24, r0
    8c4e:	11 24       	eor	r1, r1
    8c50:	82 30       	cpi	r24, 0x02	; 2
    8c52:	14 f4       	brge	.+4      	; 0x8c58 <u8g_DrawMaze+0x6da>
    8c54:	88 e2       	ldi	r24, 0x28	; 40
    8c56:	03 c0       	rjmp	.+6      	; 0x8c5e <u8g_DrawMaze+0x6e0>
    8c58:	89 32       	cpi	r24, 0x29	; 41
    8c5a:	0c f0       	brlt	.+2      	; 0x8c5e <u8g_DrawMaze+0x6e0>
    8c5c:	82 e0       	ldi	r24, 0x02	; 2
    8c5e:	80 93 c2 02 	sts	0x02C2, r24

						if(wall_size_part < WALL_SIZE_MIN)
    8c62:	19 c0       	rjmp	.+50     	; 0x8c96 <u8g_DrawMaze+0x718>
    8c64:	80 91 53 05 	lds	r24, 0x0553
							wall_size_part = WALL_SIZE_MAX;
    8c68:	82 30       	cpi	r24, 0x02	; 2
						else if(wall_size_part > WALL_SIZE_MAX)
    8c6a:	90 f0       	brcs	.+36     	; 0x8c90 <u8g_DrawMaze+0x712>
    8c6c:	87 ee       	ldi	r24, 0xE7	; 231
							wall_size_part = WALL_SIZE_MIN;
    8c6e:	98 e2       	ldi	r25, 0x28	; 40
    8c70:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8c74:	60 91 47 05 	lds	r22, 0x0547
						break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.17]:DEFAULT_CASE"));}
    8c78:	70 91 48 05 	lds	r23, 0x0548
    8c7c:	80 91 49 05 	lds	r24, 0x0549
    8c80:	90 91 4a 05 	lds	r25, 0x054A
    8c84:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    8c88:	81 eb       	ldi	r24, 0xB1	; 177
    8c8a:	98 e2       	ldi	r25, 0x28	; 40
    8c8c:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8c90:	81 e0       	ldi	r24, 0x01	; 1
    8c92:	80 93 63 05 	sts	0x0563, r24
    8c96:	80 91 58 05 	lds	r24, 0x0558
    8c9a:	90 91 59 05 	lds	r25, 0x0559
    8c9e:	a0 91 5a 05 	lds	r26, 0x055A
								fatal_err = 1;
    8ca2:	b0 91 5b 05 	lds	r27, 0x055B
    8ca6:	80 93 bb 05 	sts	0x05BB, r24
		}

		incremental_old_mz = incremental;
    8caa:	90 93 bc 05 	sts	0x05BC, r25
    8cae:	a0 93 bd 05 	sts	0x05BD, r26
    8cb2:	b0 93 be 05 	sts	0x05BE, r27
    8cb6:	90 91 c1 05 	lds	r25, 0x05C1
    8cba:	80 91 48 16 	lds	r24, 0x1648
    8cbe:	92 30       	cpi	r25, 0x02	; 2
    8cc0:	14 f0       	brlt	.+4      	; 0x8cc6 <u8g_DrawMaze+0x748>
    8cc2:	8f 5f       	subi	r24, 0xFF	; 255
    8cc4:	03 c0       	rjmp	.+6      	; 0x8ccc <u8g_DrawMaze+0x74e>
    8cc6:	9f 3f       	cpi	r25, 0xFF	; 255

		if(cursor_robot_pos_x > CURSOR_INCR_STEP)
    8cc8:	2c f4       	brge	.+10     	; 0x8cd4 <u8g_DrawMaze+0x756>
    8cca:	81 50       	subi	r24, 0x01	; 1
    8ccc:	80 93 48 16 	sts	0x1648, r24
    8cd0:	10 92 c1 05 	sts	0x05C1, r1
		{
			robot.pos.x ++;
    8cd4:	90 91 c0 05 	lds	r25, 0x05C0
			cursor_robot_pos_x = 0;
		}
		else if(cursor_robot_pos_x < -CURSOR_INCR_STEP)
    8cd8:	80 91 49 16 	lds	r24, 0x1649
		{
			robot.pos.x --;
    8cdc:	92 30       	cpi	r25, 0x02	; 2
    8cde:	14 f0       	brlt	.+4      	; 0x8ce4 <u8g_DrawMaze+0x766>
    8ce0:	81 50       	subi	r24, 0x01	; 1
			cursor_robot_pos_x = 0;
    8ce2:	03 c0       	rjmp	.+6      	; 0x8cea <u8g_DrawMaze+0x76c>
    8ce4:	9f 3f       	cpi	r25, 0xFF	; 255
		}
		if(cursor_robot_pos_y > CURSOR_INCR_STEP)
    8ce6:	2c f4       	brge	.+10     	; 0x8cf2 <u8g_DrawMaze+0x774>
    8ce8:	8f 5f       	subi	r24, 0xFF	; 255
    8cea:	80 93 49 16 	sts	0x1649, r24
    8cee:	10 92 c0 05 	sts	0x05C0, r1
		{
			robot.pos.y --;
    8cf2:	80 91 bf 05 	lds	r24, 0x05BF
			cursor_robot_pos_y = 0;
		}
		else if(cursor_robot_pos_y < -CURSOR_INCR_STEP)
    8cf6:	82 30       	cpi	r24, 0x02	; 2
    8cf8:	3c f0       	brlt	.+14     	; 0x8d08 <u8g_DrawMaze+0x78a>
		{
			robot.pos.y ++;
    8cfa:	80 91 4b 16 	lds	r24, 0x164B
    8cfe:	81 50       	subi	r24, 0x01	; 1
			cursor_robot_pos_y = 0;
    8d00:	18 16       	cp	r1, r24
    8d02:	54 f0       	brlt	.+20     	; 0x8d18 <u8g_DrawMaze+0x79a>
		}
		if(cursor_robot_dir > CURSOR_INCR_STEP)
    8d04:	84 e0       	ldi	r24, 0x04	; 4
    8d06:	08 c0       	rjmp	.+16     	; 0x8d18 <u8g_DrawMaze+0x79a>
    8d08:	8f 3f       	cpi	r24, 0xFF	; 255
    8d0a:	54 f4       	brge	.+20     	; 0x8d20 <u8g_DrawMaze+0x7a2>
		{
			robot.dir --;
    8d0c:	80 91 4b 16 	lds	r24, 0x164B
    8d10:	8f 5f       	subi	r24, 0xFF	; 255
			if(robot.dir < NORTH)
    8d12:	85 30       	cpi	r24, 0x05	; 5
    8d14:	0c f0       	brlt	.+2      	; 0x8d18 <u8g_DrawMaze+0x79a>
				robot.dir = WEST;
    8d16:	81 e0       	ldi	r24, 0x01	; 1
    8d18:	80 93 4b 16 	sts	0x164B, r24
			cursor_robot_dir = 0;
		}
		else if(cursor_robot_dir < -CURSOR_INCR_STEP)
    8d1c:	10 92 bf 05 	sts	0x05BF, r1
		{
			robot.dir ++;
    8d20:	80 91 48 16 	lds	r24, 0x1648
			if(robot.dir > WEST)
    8d24:	8c 30       	cpi	r24, 0x0C	; 12
    8d26:	14 f0       	brlt	.+4      	; 0x8d2c <u8g_DrawMaze+0x7ae>
				robot.dir = NORTH;
    8d28:	81 e0       	ldi	r24, 0x01	; 1
    8d2a:	03 c0       	rjmp	.+6      	; 0x8d32 <u8g_DrawMaze+0x7b4>
    8d2c:	18 16       	cp	r1, r24
			cursor_robot_dir = 0;
    8d2e:	1c f0       	brlt	.+6      	; 0x8d36 <u8g_DrawMaze+0x7b8>
    8d30:	8b e0       	ldi	r24, 0x0B	; 11
		}							

		if(robot.pos.x > (MAZE_SIZE_X-2))
    8d32:	80 93 48 16 	sts	0x1648, r24
    8d36:	80 91 49 16 	lds	r24, 0x1649
		{
			robot.pos.x = ROB_POS_X_MIN;
    8d3a:	8c 30       	cpi	r24, 0x0C	; 12
    8d3c:	6c f0       	brlt	.+26     	; 0x8d58 <u8g_DrawMaze+0x7da>
		}
		else if(robot.pos.x < ROB_POS_X_MIN)
    8d3e:	81 e0       	ldi	r24, 0x01	; 1
    8d40:	80 93 49 16 	sts	0x1649, r24
		{
			robot.pos.x = (MAZE_SIZE_X-2);
    8d44:	80 91 4a 16 	lds	r24, 0x164A
		}

		if(robot.pos.y > (MAZE_SIZE_Y-2))
    8d48:	8f 5f       	subi	r24, 0xFF	; 255
    8d4a:	80 93 4a 16 	sts	0x164A, r24
    8d4e:	83 30       	cpi	r24, 0x03	; 3
		{
			robot.pos.y = ROB_POS_Y_MIN;
    8d50:	94 f0       	brlt	.+36     	; 0x8d76 <u8g_DrawMaze+0x7f8>
    8d52:	10 92 4a 16 	sts	0x164A, r1
			robot.pos.z ++;
    8d56:	0f c0       	rjmp	.+30     	; 0x8d76 <u8g_DrawMaze+0x7f8>
    8d58:	18 16       	cp	r1, r24
    8d5a:	6c f0       	brlt	.+26     	; 0x8d76 <u8g_DrawMaze+0x7f8>
    8d5c:	8b e0       	ldi	r24, 0x0B	; 11
    8d5e:	80 93 49 16 	sts	0x1649, r24
			if(robot.pos.z > (MAZE_SIZE_Z-1))
    8d62:	80 91 4a 16 	lds	r24, 0x164A
			{
				robot.pos.z = 0;
    8d66:	81 50       	subi	r24, 0x01	; 1
    8d68:	80 93 4a 16 	sts	0x164A, r24
			}
		}
		else if(robot.pos.y < ROB_POS_Y_MIN)
    8d6c:	87 ff       	sbrs	r24, 7
		{
			robot.pos.y = (MAZE_SIZE_Y-2);
    8d6e:	03 c0       	rjmp	.+6      	; 0x8d76 <u8g_DrawMaze+0x7f8>
    8d70:	82 e0       	ldi	r24, 0x02	; 2
    8d72:	80 93 4a 16 	sts	0x164A, r24
			robot.pos.z --;
    8d76:	0e 94 ce 56 	call	0xad9c	; 0xad9c <maze_GetVisitedTiles>
    8d7a:	89 2b       	or	r24, r25
    8d7c:	71 f4       	brne	.+28     	; 0x8d9a <u8g_DrawMaze+0x81c>
			if(robot.pos.z < 0)
    8d7e:	80 91 48 16 	lds	r24, 0x1648
			{
				robot.pos.z = (MAZE_SIZE_Z-1);
    8d82:	81 50       	subi	r24, 0x01	; 1
    8d84:	80 93 45 16 	sts	0x1645, r24
			}
		}
		
		if(maze_GetVisitedTiles() == 0)
    8d88:	80 91 49 16 	lds	r24, 0x1649
    8d8c:	81 50       	subi	r24, 0x01	; 1
    8d8e:	80 93 46 16 	sts	0x1646, r24
		{
			off_start.x = robot.pos.x - ROB_START_MAZE_X; //ROB_START_MAZE_X is added again in maze_getStart
    8d92:	80 91 4a 16 	lds	r24, 0x164A
    8d96:	80 93 47 16 	sts	0x1647, r24
			off_start.y = robot.pos.y - ROB_START_MAZE_Y;
    8d9a:	8f ef       	ldi	r24, 0xFF	; 255
    8d9c:	9f ef       	ldi	r25, 0xFF	; 255
    8d9e:	90 93 94 02 	sts	0x0294, r25
    8da2:	80 93 93 02 	sts	0x0293, r24
			off_start.z = robot.pos.z - ROB_START_MAZE_Z;
    8da6:	80 91 c3 02 	lds	r24, 0x02C3
    8daa:	82 30       	cpi	r24, 0x02	; 2
		}
		
		timer_rdy_restart = -1;
    8dac:	91 f0       	breq	.+36     	; 0x8dd2 <u8g_DrawMaze+0x854>
    8dae:	38 f4       	brcc	.+14     	; 0x8dbe <u8g_DrawMaze+0x840>
    8db0:	88 23       	and	r24, r24
    8db2:	61 f0       	breq	.+24     	; 0x8dcc <u8g_DrawMaze+0x84e>
    8db4:	81 30       	cpi	r24, 0x01	; 1
    8db6:	51 f5       	brne	.+84     	; 0x8e0c <u8g_DrawMaze+0x88e>
	}
	
	switch(incr_ok_mode)
    8db8:	24 e3       	ldi	r18, 0x34	; 52
    8dba:	35 e0       	ldi	r19, 0x05	; 5
    8dbc:	0c c0       	rjmp	.+24     	; 0x8dd6 <u8g_DrawMaze+0x858>
    8dbe:	83 30       	cpi	r24, 0x03	; 3
    8dc0:	89 f0       	breq	.+34     	; 0x8de4 <u8g_DrawMaze+0x866>
    8dc2:	84 30       	cpi	r24, 0x04	; 4
    8dc4:	19 f5       	brne	.+70     	; 0x8e0c <u8g_DrawMaze+0x88e>
    8dc6:	29 e1       	ldi	r18, 0x19	; 25
    8dc8:	34 e0       	ldi	r19, 0x04	; 4
	{
		case 0:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgx");	break;
		case 1:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgy");	break;
    8dca:	05 c0       	rjmp	.+10     	; 0x8dd6 <u8g_DrawMaze+0x858>
    8dcc:	2f e2       	ldi	r18, 0x2F	; 47
    8dce:	35 e0       	ldi	r19, 0x05	; 5
		}
		
		timer_rdy_restart = -1;
	}
	
	switch(incr_ok_mode)
    8dd0:	02 c0       	rjmp	.+4      	; 0x8dd6 <u8g_DrawMaze+0x858>
    8dd2:	29 e3       	ldi	r18, 0x39	; 57
    8dd4:	35 e0       	ldi	r19, 0x05	; 5
    8dd6:	4e e0       	ldi	r20, 0x0E	; 14
		case 0:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgx");	break;
		case 1:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgy");	break;
		case 2:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgd");	break;
		case 3:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "sze:");
					u8g_DrawLong(MAPEND_PART_X+5, 21, wall_size_part);	break;
		case 4:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "ok");		break;
    8dd8:	67 e4       	ldi	r22, 0x47	; 71
    8dda:	8b e1       	ldi	r24, 0x1B	; 27
    8ddc:	97 e0       	ldi	r25, 0x07	; 7
		timer_rdy_restart = -1;
	}
	
	switch(incr_ok_mode)
	{
		case 0:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgx");	break;
    8dde:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8de2:	2d c0       	rjmp	.+90     	; 0x8e3e <u8g_DrawMaze+0x8c0>
		case 1:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgy");	break;
		case 2:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgd");	break;
    8de4:	2e e3       	ldi	r18, 0x3E	; 62
    8de6:	35 e0       	ldi	r19, 0x05	; 5
	}
	
	switch(incr_ok_mode)
	{
		case 0:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgx");	break;
		case 1:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgy");	break;
    8de8:	4e e0       	ldi	r20, 0x0E	; 14
    8dea:	67 e4       	ldi	r22, 0x47	; 71
    8dec:	8b e1       	ldi	r24, 0x1B	; 27
    8dee:	97 e0       	ldi	r25, 0x07	; 7
    8df0:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8df4:	20 91 c2 02 	lds	r18, 0x02C2
		case 2:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "chgd");	break;
		case 3:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "sze:");
    8df8:	33 27       	eor	r19, r19
    8dfa:	27 fd       	sbrc	r18, 7
    8dfc:	30 95       	com	r19
    8dfe:	43 2f       	mov	r20, r19
    8e00:	53 2f       	mov	r21, r19
    8e02:	65 e1       	ldi	r22, 0x15	; 21
    8e04:	8b e4       	ldi	r24, 0x4B	; 75
					u8g_DrawLong(MAPEND_PART_X+5, 21, wall_size_part);	break;
    8e06:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    8e0a:	19 c0       	rjmp	.+50     	; 0x8e3e <u8g_DrawMaze+0x8c0>
    8e0c:	80 91 53 05 	lds	r24, 0x0553
    8e10:	82 30       	cpi	r24, 0x02	; 2
    8e12:	90 f0       	brcs	.+36     	; 0x8e38 <u8g_DrawMaze+0x8ba>
    8e14:	8e ea       	ldi	r24, 0xAE	; 174
    8e16:	98 e2       	ldi	r25, 0x28	; 40
    8e18:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8e1c:	60 91 47 05 	lds	r22, 0x0547
		case 4:		u8g_DrawStr(&u8g, MAPEND_PART_X+1, 14, "ok");		break;
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
    8e20:	70 91 48 05 	lds	r23, 0x0548
    8e24:	80 91 49 05 	lds	r24, 0x0549
    8e28:	90 91 4a 05 	lds	r25, 0x054A
    8e2c:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    8e30:	88 e7       	ldi	r24, 0x78	; 120
    8e32:	98 e2       	ldi	r25, 0x28	; 40
    8e34:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    8e38:	81 e0       	ldi	r24, 0x01	; 1
    8e3a:	80 93 63 05 	sts	0x0563, r24
    8e3e:	22 e3       	ldi	r18, 0x32	; 50
    8e40:	35 e0       	ldi	r19, 0x05	; 5
    8e42:	4c e1       	ldi	r20, 0x1C	; 28
    8e44:	67 e4       	ldi	r22, 0x47	; 71
    8e46:	8b e1       	ldi	r24, 0x1B	; 27
    8e48:	97 e0       	ldi	r25, 0x07	; 7
							fatal_err = 1;
    8e4a:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8e4e:	2f e8       	ldi	r18, 0x8F	; 143
	}
	u8g_DrawStr(&u8g, MAPEND_PART_X+1, 28, "x"); u8g_DrawStr(&u8g, MAPEND_PART_X+4, 28, ":"); u8g_DrawLong(MAPEND_PART_X+7, 28, robot.pos.x);
    8e50:	33 e0       	ldi	r19, 0x03	; 3
    8e52:	4c e1       	ldi	r20, 0x1C	; 28
    8e54:	6a e4       	ldi	r22, 0x4A	; 74
    8e56:	8b e1       	ldi	r24, 0x1B	; 27
    8e58:	97 e0       	ldi	r25, 0x07	; 7
    8e5a:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8e5e:	20 91 48 16 	lds	r18, 0x1648
    8e62:	33 27       	eor	r19, r19
    8e64:	27 fd       	sbrc	r18, 7
    8e66:	30 95       	com	r19
    8e68:	43 2f       	mov	r20, r19
    8e6a:	53 2f       	mov	r21, r19
    8e6c:	6c e1       	ldi	r22, 0x1C	; 28
    8e6e:	8d e4       	ldi	r24, 0x4D	; 77
    8e70:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    8e74:	27 e3       	ldi	r18, 0x37	; 55
    8e76:	35 e0       	ldi	r19, 0x05	; 5
    8e78:	43 e2       	ldi	r20, 0x23	; 35
    8e7a:	67 e4       	ldi	r22, 0x47	; 71
    8e7c:	8b e1       	ldi	r24, 0x1B	; 27
    8e7e:	97 e0       	ldi	r25, 0x07	; 7
    8e80:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8e84:	2f e8       	ldi	r18, 0x8F	; 143
	u8g_DrawStr(&u8g, MAPEND_PART_X+1, 35, "y"); u8g_DrawStr(&u8g, MAPEND_PART_X+4, 35, ":"); u8g_DrawLong(MAPEND_PART_X+7, 35, robot.pos.y);
    8e86:	33 e0       	ldi	r19, 0x03	; 3
    8e88:	43 e2       	ldi	r20, 0x23	; 35
    8e8a:	6a e4       	ldi	r22, 0x4A	; 74
    8e8c:	8b e1       	ldi	r24, 0x1B	; 27
    8e8e:	97 e0       	ldi	r25, 0x07	; 7
    8e90:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8e94:	20 91 49 16 	lds	r18, 0x1649
    8e98:	33 27       	eor	r19, r19
    8e9a:	27 fd       	sbrc	r18, 7
    8e9c:	30 95       	com	r19
    8e9e:	43 2f       	mov	r20, r19
    8ea0:	53 2f       	mov	r21, r19
    8ea2:	63 e2       	ldi	r22, 0x23	; 35
    8ea4:	8d e4       	ldi	r24, 0x4D	; 77
    8ea6:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    8eaa:	23 e4       	ldi	r18, 0x43	; 67
    8eac:	35 e0       	ldi	r19, 0x05	; 5
    8eae:	4a e2       	ldi	r20, 0x2A	; 42
    8eb0:	67 e4       	ldi	r22, 0x47	; 71
    8eb2:	8b e1       	ldi	r24, 0x1B	; 27
    8eb4:	97 e0       	ldi	r25, 0x07	; 7
    8eb6:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8eba:	2f e8       	ldi	r18, 0x8F	; 143
	u8g_DrawStr(&u8g, MAPEND_PART_X+1, 42, "z"); u8g_DrawStr(&u8g, MAPEND_PART_X+4, 42, ":"); u8g_DrawLong(MAPEND_PART_X+7, 42, robot.pos.z);
    8ebc:	33 e0       	ldi	r19, 0x03	; 3
    8ebe:	4a e2       	ldi	r20, 0x2A	; 42
    8ec0:	6a e4       	ldi	r22, 0x4A	; 74
    8ec2:	8b e1       	ldi	r24, 0x1B	; 27
    8ec4:	97 e0       	ldi	r25, 0x07	; 7
    8ec6:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
    8eca:	20 91 4a 16 	lds	r18, 0x164A
    8ece:	33 27       	eor	r19, r19
    8ed0:	27 fd       	sbrc	r18, 7
    8ed2:	30 95       	com	r19
    8ed4:	43 2f       	mov	r20, r19
    8ed6:	53 2f       	mov	r21, r19
    8ed8:	6a e2       	ldi	r22, 0x2A	; 42
    8eda:	8d e4       	ldi	r24, 0x4D	; 77
    8edc:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
    8ee0:	80 91 4a 16 	lds	r24, 0x164A
    8ee4:	82 30       	cpi	r24, 0x02	; 2
    8ee6:	91 f5       	brne	.+100    	; 0x8f4c <u8g_DrawMaze+0x9ce>
    8ee8:	20 91 c3 05 	lds	r18, 0x05C3
    8eec:	30 e0       	ldi	r19, 0x00	; 0
    8eee:	40 e0       	ldi	r20, 0x00	; 0
    8ef0:	50 e0       	ldi	r21, 0x00	; 0

	if(robot.pos.z == MAZE_SAVESTAGE)
    8ef2:	68 e3       	ldi	r22, 0x38	; 56
    8ef4:	87 e4       	ldi	r24, 0x47	; 71
    8ef6:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
	{
		u8g_DrawLong(MAPEND_PART_X+1, 56, loc_ambiguity);
    8efa:	80 91 c3 05 	lds	r24, 0x05C3
    8efe:	22 e3       	ldi	r18, 0x32	; 50
    8f00:	35 e0       	ldi	r19, 0x05	; 5
    8f02:	48 e3       	ldi	r20, 0x38	; 56
    8f04:	8a 30       	cpi	r24, 0x0A	; 10
    8f06:	10 f4       	brcc	.+4      	; 0x8f0c <u8g_DrawMaze+0x98e>
    8f08:	6b e4       	ldi	r22, 0x4B	; 75
    8f0a:	01 c0       	rjmp	.+2      	; 0x8f0e <u8g_DrawMaze+0x990>
			if(loc_ambiguity < 10)
    8f0c:	6f e4       	ldi	r22, 0x4F	; 79
    8f0e:	8b e1       	ldi	r24, 0x1B	; 27
				u8g_DrawStr(&u8g, MAPEND_PART_X+5, 56, "x");
    8f10:	97 e0       	ldi	r25, 0x07	; 7
    8f12:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
	u8g_DrawStr(&u8g, MAPEND_PART_X+1, 42, "z"); u8g_DrawStr(&u8g, MAPEND_PART_X+4, 42, ":"); u8g_DrawLong(MAPEND_PART_X+7, 42, robot.pos.z);

	if(robot.pos.z == MAZE_SAVESTAGE)
	{
		u8g_DrawLong(MAPEND_PART_X+1, 56, loc_ambiguity);
			if(loc_ambiguity < 10)
    8f16:	20 91 c2 05 	lds	r18, 0x05C2
				u8g_DrawStr(&u8g, MAPEND_PART_X+5, 56, "x");
    8f1a:	30 e0       	ldi	r19, 0x00	; 0
    8f1c:	40 e0       	ldi	r20, 0x00	; 0
			else
				u8g_DrawStr(&u8g, MAPEND_PART_X+9, 56, "x");
    8f1e:	50 e0       	ldi	r21, 0x00	; 0
    8f20:	6f e3       	ldi	r22, 0x3F	; 63
    8f22:	87 e4       	ldi	r24, 0x47	; 71
    8f24:	0e 94 0a 20 	call	0x4014	; 0x4014 <u8g_DrawLong>
		u8g_DrawLong(MAPEND_PART_X+1, 63, loc_accordance);
    8f28:	80 91 c2 05 	lds	r24, 0x05C2
    8f2c:	2e e5       	ldi	r18, 0x5E	; 94
    8f2e:	33 e0       	ldi	r19, 0x03	; 3
    8f30:	4f e3       	ldi	r20, 0x3F	; 63
    8f32:	8a 30       	cpi	r24, 0x0A	; 10
    8f34:	10 f4       	brcc	.+4      	; 0x8f3a <u8g_DrawMaze+0x9bc>
    8f36:	6b e4       	ldi	r22, 0x4B	; 75
    8f38:	05 c0       	rjmp	.+10     	; 0x8f44 <u8g_DrawMaze+0x9c6>
			if(loc_accordance < 10)
    8f3a:	84 36       	cpi	r24, 0x64	; 100
    8f3c:	10 f4       	brcc	.+4      	; 0x8f42 <u8g_DrawMaze+0x9c4>
				u8g_DrawStr(&u8g, MAPEND_PART_X+5, 63, "%");
    8f3e:	6f e4       	ldi	r22, 0x4F	; 79
    8f40:	01 c0       	rjmp	.+2      	; 0x8f44 <u8g_DrawMaze+0x9c6>
    8f42:	63 e5       	ldi	r22, 0x53	; 83
			if(loc_ambiguity < 10)
				u8g_DrawStr(&u8g, MAPEND_PART_X+5, 56, "x");
			else
				u8g_DrawStr(&u8g, MAPEND_PART_X+9, 56, "x");
		u8g_DrawLong(MAPEND_PART_X+1, 63, loc_accordance);
			if(loc_accordance < 10)
    8f44:	8b e1       	ldi	r24, 0x1B	; 27
    8f46:	97 e0       	ldi	r25, 0x07	; 7
				u8g_DrawStr(&u8g, MAPEND_PART_X+5, 63, "%");
    8f48:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <u8g_DrawStr>
			else if(loc_accordance < 100)
    8f4c:	25 96       	adiw	r28, 0x05	; 5
    8f4e:	e2 e1       	ldi	r30, 0x12	; 18
				u8g_DrawStr(&u8g, MAPEND_PART_X+9, 63, "%");
    8f50:	0c 94 b7 6b 	jmp	0xd76e	; 0xd76e <__epilogue_restores__>

00008f54 <maze_alignDir>:
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    8f54:	85 30       	cpi	r24, 0x05	; 5
    8f56:	10 f0       	brcs	.+4      	; 0x8f5c <maze_alignDir+0x8>
		dir -= WEST;
    8f58:	84 50       	subi	r24, 0x04	; 4
    8f5a:	fc cf       	rjmp	.-8      	; 0x8f54 <maze_alignDir>
	
	return dir;
}
    8f5c:	08 95       	ret

00008f5e <maze_cmpCoords>:
//
// @return: TRUE when identical, otherwise FALSE
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_cmpCoords(COORD *_coordA, COORD *_coordB)
{
    8f5e:	fc 01       	movw	r30, r24
    8f60:	db 01       	movw	r26, r22
	if((_coordA->x - _coordB->x == 0) &&
    8f62:	90 81       	ld	r25, Z
    8f64:	8c 91       	ld	r24, X
    8f66:	98 13       	cpse	r25, r24
    8f68:	0b c0       	rjmp	.+22     	; 0x8f80 <maze_cmpCoords+0x22>
    8f6a:	91 81       	ldd	r25, Z+1	; 0x01
    8f6c:	11 96       	adiw	r26, 0x01	; 1
    8f6e:	8c 91       	ld	r24, X
    8f70:	11 97       	sbiw	r26, 0x01	; 1
    8f72:	98 13       	cpse	r25, r24
    8f74:	05 c0       	rjmp	.+10     	; 0x8f80 <maze_cmpCoords+0x22>
		 (_coordA->y - _coordB->y == 0) &&
    8f76:	81 e0       	ldi	r24, 0x01	; 1
    8f78:	22 81       	ldd	r18, Z+2	; 0x02
    8f7a:	12 96       	adiw	r26, 0x02	; 2
    8f7c:	9c 91       	ld	r25, X
    8f7e:	29 13       	cpse	r18, r25
	{
		return TRUE;
	}
	else
	{
		return FALSE;
    8f80:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    8f82:	08 95       	ret

00008f84 <maze_clearDepthsearch>:
//
// @return: NONE
////////////////////////////////////////////////////////////////////////////////

void maze_clearDepthsearch(void)
{
    8f84:	cf 93       	push	r28
    8f86:	80 e0       	ldi	r24, 0x00	; 0
    8f88:	90 e0       	ldi	r25, 0x00	; 0
	{
		for(uint8_t maze_y = 0; maze_y < MAZE_SIZE_Y; maze_y++)
		{
			for(uint8_t maze_x = 0; maze_x < MAZE_SIZE_X; maze_x++)
			{
				maze[maze_x][maze_y][maze_z].depthsearch = 0xff;
    8f8a:	cf ef       	ldi	r28, 0xFF	; 255
//
// @return: NONE
////////////////////////////////////////////////////////////////////////////////

void maze_clearDepthsearch(void)
{
    8f8c:	20 e0       	ldi	r18, 0x00	; 0
    8f8e:	30 e0       	ldi	r19, 0x00	; 0
    8f90:	bc 01       	movw	r22, r24
    8f92:	65 5a       	subi	r22, 0xA5	; 165
    8f94:	77 4f       	sbci	r23, 0xF7	; 247
    8f96:	40 e0       	ldi	r20, 0x00	; 0
    8f98:	50 e0       	ldi	r21, 0x00	; 0
    8f9a:	fb 01       	movw	r30, r22
    8f9c:	e2 0f       	add	r30, r18
    8f9e:	f3 1f       	adc	r31, r19
    8fa0:	df 01       	movw	r26, r30
    8fa2:	a4 0f       	add	r26, r20
    8fa4:	b5 1f       	adc	r27, r21
	{
		for(uint8_t maze_y = 0; maze_y < MAZE_SIZE_Y; maze_y++)
		{
			for(uint8_t maze_x = 0; maze_x < MAZE_SIZE_X; maze_x++)
			{
				maze[maze_x][maze_y][maze_z].depthsearch = 0xff;
    8fa6:	16 96       	adiw	r26, 0x06	; 6
    8fa8:	cc 93       	st	X, r28
    8faa:	4f 5e       	subi	r20, 0xEF	; 239
    8fac:	5e 4f       	sbci	r21, 0xFE	; 254
{
	for(uint8_t maze_z = 0; maze_z < MAZE_SIZE_Z; maze_z++)
	{
		for(uint8_t maze_y = 0; maze_y < MAZE_SIZE_Y; maze_y++)
		{
			for(uint8_t maze_x = 0; maze_x < MAZE_SIZE_X; maze_x++)
    8fae:	4d 3d       	cpi	r20, 0xDD	; 221
    8fb0:	ad e0       	ldi	r26, 0x0D	; 13
    8fb2:	5a 07       	cpc	r21, r26
    8fb4:	a9 f7       	brne	.-22     	; 0x8fa0 <maze_clearDepthsearch+0x1c>
    8fb6:	2b 5e       	subi	r18, 0xEB	; 235
    8fb8:	3f 4f       	sbci	r19, 0xFF	; 255

void maze_clearDepthsearch(void)
{
	for(uint8_t maze_z = 0; maze_z < MAZE_SIZE_Z; maze_z++)
	{
		for(uint8_t maze_y = 0; maze_y < MAZE_SIZE_Y; maze_y++)
    8fba:	21 31       	cpi	r18, 0x11	; 17
    8fbc:	41 e0       	ldi	r20, 0x01	; 1
    8fbe:	34 07       	cpc	r19, r20
    8fc0:	51 f7       	brne	.-44     	; 0x8f96 <maze_clearDepthsearch+0x12>
    8fc2:	07 96       	adiw	r24, 0x07	; 7
// @return: NONE
////////////////////////////////////////////////////////////////////////////////

void maze_clearDepthsearch(void)
{
	for(uint8_t maze_z = 0; maze_z < MAZE_SIZE_Z; maze_z++)
    8fc4:	85 31       	cpi	r24, 0x15	; 21
    8fc6:	91 05       	cpc	r25, r1
    8fc8:	09 f7       	brne	.-62     	; 0x8f8c <maze_clearDepthsearch+0x8>
			{
				maze[maze_x][maze_y][maze_z].depthsearch = 0xff;
			}
		}
	}
}
    8fca:	cf 91       	pop	r28
    8fcc:	08 95       	ret

00008fce <maze_getCheckpoint>:
// @return: Pointer to the coordinates of the checkpoint
////////////////////////////////////////////////////////////////////////////////

COORD *maze_getCheckpoint(uint8_t pos_z, uint8_t index)
{
	return &checkpoint[pos_z][index].pos;
    8fce:	26 e0       	ldi	r18, 0x06	; 6
    8fd0:	82 9f       	mul	r24, r18
    8fd2:	c0 01       	movw	r24, r0
    8fd4:	11 24       	eor	r1, r1
    8fd6:	86 0f       	add	r24, r22
    8fd8:	91 1d       	adc	r25, r1
    8fda:	88 0f       	add	r24, r24
    8fdc:	99 1f       	adc	r25, r25
    8fde:	88 0f       	add	r24, r24
    8fe0:	99 1f       	adc	r25, r25
}
    8fe2:	8d 5e       	subi	r24, 0xED	; 237
    8fe4:	97 4f       	sbci	r25, 0xF7	; 247
    8fe6:	08 95       	ret

00008fe8 <maze_getRamp>:
// @return: void
////////////////////////////////////////////////////////////////////////////////
COORD *maze_getRamp(int8_t pos_z)
{
	static COORD rampPos;
	rampPos.z = pos_z;
    8fe8:	80 93 d3 05 	sts	0x05D3, r24
	
	if(offset_z != 0)
    8fec:	90 91 5a 16 	lds	r25, 0x165A
    8ff0:	99 23       	and	r25, r25
    8ff2:	21 f0       	breq	.+8      	; 0x8ffc <maze_getRamp+0x14>
	{
		if(pos_z == 0)
    8ff4:	91 e0       	ldi	r25, 0x01	; 1
    8ff6:	81 11       	cpse	r24, r1
    8ff8:	90 e0       	ldi	r25, 0x00	; 0
			pos_z = 1;
    8ffa:	89 2f       	mov	r24, r25
		else
			pos_z = 0;
	}
	
	rampPos.x = ramp[pos_z].pos.x;
    8ffc:	99 27       	eor	r25, r25
    8ffe:	87 fd       	sbrc	r24, 7
    9000:	90 95       	com	r25
    9002:	9c 01       	movw	r18, r24
    9004:	22 0f       	add	r18, r18
    9006:	33 1f       	adc	r19, r19
    9008:	22 0f       	add	r18, r18
    900a:	33 1f       	adc	r19, r19
    900c:	d9 01       	movw	r26, r18
    900e:	a6 5b       	subi	r26, 0xB6	; 182
    9010:	b7 4f       	sbci	r27, 0xF7	; 247
	rampPos.x -= offset[pos_z].x;
    9012:	88 0f       	add	r24, r24
    9014:	99 1f       	adc	r25, r25
    9016:	fc 01       	movw	r30, r24
    9018:	e0 5b       	subi	r30, 0xB0	; 176
    901a:	f9 4e       	sbci	r31, 0xE9	; 233
    901c:	4c 91       	ld	r20, X
    901e:	50 81       	ld	r21, Z
    9020:	45 1b       	sub	r20, r21
	while(rampPos.x >= MAZE_SIZE_X)
    9022:	4d 30       	cpi	r20, 0x0D	; 13
    9024:	14 f0       	brlt	.+4      	; 0x902a <maze_getRamp+0x42>
    9026:	4d 50       	subi	r20, 0x0D	; 13
    9028:	fc cf       	rjmp	.-8      	; 0x9022 <maze_getRamp+0x3a>
    902a:	40 93 d1 05 	sts	0x05D1, r20
		rampPos.x -= MAZE_SIZE_X;
	
	rampPos.y = ramp[pos_z].pos.y;
    902e:	d9 01       	movw	r26, r18
    9030:	a6 5b       	subi	r26, 0xB6	; 182
    9032:	b7 4f       	sbci	r27, 0xF7	; 247
	rampPos.y -= offset[pos_z].y;
    9034:	fc 01       	movw	r30, r24
    9036:	e0 5b       	subi	r30, 0xB0	; 176
    9038:	f9 4e       	sbci	r31, 0xE9	; 233
    903a:	11 96       	adiw	r26, 0x01	; 1
    903c:	2c 91       	ld	r18, X
    903e:	81 81       	ldd	r24, Z+1	; 0x01
    9040:	28 1b       	sub	r18, r24
	while(rampPos.y >= MAZE_SIZE_Y)
    9042:	2d 30       	cpi	r18, 0x0D	; 13
    9044:	14 f0       	brlt	.+4      	; 0x904a <maze_getRamp+0x62>
    9046:	2d 50       	subi	r18, 0x0D	; 13
    9048:	fc cf       	rjmp	.-8      	; 0x9042 <maze_getRamp+0x5a>
    904a:	20 93 d2 05 	sts	0x05D2, r18
		rampPos.y -= MAZE_SIZE_Y;
	
	return &rampPos;
}
    904e:	81 ed       	ldi	r24, 0xD1	; 209
    9050:	95 e0       	ldi	r25, 0x05	; 5
    9052:	08 95       	ret

00009054 <maze_getStartPos>:
	//offset_z value (because the first used level will always be offset[0],
	//except for when the off_start.z is 1 (started by rotary encoder in upper
	//stage)
	static COORD start;
	
	start.x = abs(offset[off_start.z].x) + off_start.x + ROB_START_MAZE_X;
    9054:	60 91 47 16 	lds	r22, 0x1647
    9058:	90 91 45 16 	lds	r25, 0x1645
    905c:	9f 5f       	subi	r25, 0xFF	; 255
    905e:	46 2f       	mov	r20, r22
    9060:	44 0f       	add	r20, r20
    9062:	55 0b       	sbc	r21, r21
    9064:	fa 01       	movw	r30, r20
    9066:	e0 5b       	subi	r30, 0xB0	; 176
    9068:	f9 4e       	sbci	r31, 0xE9	; 233
    906a:	20 81       	ld	r18, Z
    906c:	33 27       	eor	r19, r19
    906e:	27 fd       	sbrc	r18, 7
    9070:	30 95       	com	r19
    9072:	37 ff       	sbrs	r19, 7
    9074:	03 c0       	rjmp	.+6      	; 0x907c <maze_getStartPos+0x28>
    9076:	31 95       	neg	r19
    9078:	21 95       	neg	r18
    907a:	31 09       	sbc	r19, r1
    907c:	29 0f       	add	r18, r25
    907e:	20 93 ce 05 	sts	0x05CE, r18
	start.y = abs(offset[off_start.z].y) + off_start.y + ROB_START_MAZE_Y;
    9082:	90 91 46 16 	lds	r25, 0x1646
    9086:	9f 5f       	subi	r25, 0xFF	; 255
    9088:	fa 01       	movw	r30, r20
    908a:	e0 5b       	subi	r30, 0xB0	; 176
    908c:	f9 4e       	sbci	r31, 0xE9	; 233
    908e:	21 81       	ldd	r18, Z+1	; 0x01
    9090:	33 27       	eor	r19, r19
    9092:	27 fd       	sbrc	r18, 7
    9094:	30 95       	com	r19
    9096:	37 ff       	sbrs	r19, 7
    9098:	03 c0       	rjmp	.+6      	; 0x90a0 <maze_getStartPos+0x4c>
    909a:	31 95       	neg	r19
    909c:	21 95       	neg	r18
    909e:	31 09       	sbc	r19, r1
    90a0:	29 0f       	add	r18, r25
    90a2:	20 93 cf 05 	sts	0x05CF, r18
	start.z = abs(offset_z) + off_start.z + ROB_START_MAZE_Z;
    90a6:	80 91 5a 16 	lds	r24, 0x165A
    90aa:	99 27       	eor	r25, r25
    90ac:	87 fd       	sbrc	r24, 7
    90ae:	90 95       	com	r25
    90b0:	97 ff       	sbrs	r25, 7
    90b2:	03 c0       	rjmp	.+6      	; 0x90ba <maze_getStartPos+0x66>
    90b4:	91 95       	neg	r25
    90b6:	81 95       	neg	r24
    90b8:	91 09       	sbc	r25, r1
    90ba:	86 0f       	add	r24, r22
    90bc:	80 93 d0 05 	sts	0x05D0, r24
	
	return &start;
}
    90c0:	8e ec       	ldi	r24, 0xCE	; 206
    90c2:	95 e0       	ldi	r25, 0x05	; 5
    90c4:	08 95       	ret

000090c6 <maze_adaptOffset>:
		fatal_err = 1;
	}
}

int8_t maze_adaptOffset(COORD *_coord)
{
    90c6:	fc 01       	movw	r30, r24
	int8_t returnvar = 1;
	
	if((_coord->z >= 0) && (_coord->z <= (MAZE_SIZE_Z-1))) //Offset z has to be adapted as first, because otherwise the difference between offset[z] is not rigth
    90c8:	92 81       	ldd	r25, Z+2	; 0x02
    90ca:	93 30       	cpi	r25, 0x03	; 3
    90cc:	88 f4       	brcc	.+34     	; 0x90f0 <maze_adaptOffset+0x2a>
	{
		_coord->z += offset_z;
    90ce:	80 91 5a 16 	lds	r24, 0x165A
    90d2:	89 0f       	add	r24, r25
		while(_coord->z < 0)
			_coord->z += MAZE_SIZE_Z;
    90d4:	82 83       	std	Z+2, r24	; 0x02
	int8_t returnvar = 1;
	
	if((_coord->z >= 0) && (_coord->z <= (MAZE_SIZE_Z-1))) //Offset z has to be adapted as first, because otherwise the difference between offset[z] is not rigth
	{
		_coord->z += offset_z;
		while(_coord->z < 0)
    90d6:	82 81       	ldd	r24, Z+2	; 0x02
    90d8:	87 ff       	sbrs	r24, 7
    90da:	02 c0       	rjmp	.+4      	; 0x90e0 <maze_adaptOffset+0x1a>
			_coord->z += MAZE_SIZE_Z;
    90dc:	8d 5f       	subi	r24, 0xFD	; 253
    90de:	fa cf       	rjmp	.-12     	; 0x90d4 <maze_adaptOffset+0xe>
		while(_coord->z >= MAZE_SIZE_Z)
    90e0:	82 81       	ldd	r24, Z+2	; 0x02
    90e2:	83 30       	cpi	r24, 0x03	; 3
    90e4:	1c f0       	brlt	.+6      	; 0x90ec <maze_adaptOffset+0x26>
			_coord->z -= MAZE_SIZE_Z;
    90e6:	83 50       	subi	r24, 0x03	; 3
    90e8:	82 83       	std	Z+2, r24	; 0x02
    90ea:	fa cf       	rjmp	.-12     	; 0x90e0 <maze_adaptOffset+0x1a>
	}
}

int8_t maze_adaptOffset(COORD *_coord)
{
	int8_t returnvar = 1;
    90ec:	81 e0       	ldi	r24, 0x01	; 1
    90ee:	01 c0       	rjmp	.+2      	; 0x90f2 <maze_adaptOffset+0x2c>
		while(_coord->z < 0)
			_coord->z += MAZE_SIZE_Z;
		while(_coord->z >= MAZE_SIZE_Z)
			_coord->z -= MAZE_SIZE_Z;
	}
	else returnvar = 0;
    90f0:	80 e0       	ldi	r24, 0x00	; 0
	
	if((_coord->x >= 0) && (_coord->x <= (MAZE_SIZE_X-1)))
    90f2:	20 81       	ld	r18, Z
    90f4:	2d 30       	cpi	r18, 0x0D	; 13
    90f6:	68 f4       	brcc	.+26     	; 0x9112 <maze_adaptOffset+0x4c>
	{
		_coord->x += offset[_coord->z].x;
    90f8:	a2 81       	ldd	r26, Z+2	; 0x02
    90fa:	aa 0f       	add	r26, r26
    90fc:	bb 0b       	sbc	r27, r27
    90fe:	a0 5b       	subi	r26, 0xB0	; 176
    9100:	b9 4e       	sbci	r27, 0xE9	; 233
    9102:	9c 91       	ld	r25, X
    9104:	92 0f       	add	r25, r18
		while(_coord->x < 0)
			_coord->x += MAZE_SIZE_X;
    9106:	90 83       	st	Z, r25
	else returnvar = 0;
	
	if((_coord->x >= 0) && (_coord->x <= (MAZE_SIZE_X-1)))
	{
		_coord->x += offset[_coord->z].x;
		while(_coord->x < 0)
    9108:	90 81       	ld	r25, Z
    910a:	97 ff       	sbrs	r25, 7
    910c:	03 c0       	rjmp	.+6      	; 0x9114 <maze_adaptOffset+0x4e>
			_coord->x += MAZE_SIZE_X;
    910e:	93 5f       	subi	r25, 0xF3	; 243
    9110:	fa cf       	rjmp	.-12     	; 0x9106 <maze_adaptOffset+0x40>
	}
	else returnvar = 0;
    9112:	80 e0       	ldi	r24, 0x00	; 0
	
	if((_coord->y >= 0) && (_coord->y <= (MAZE_SIZE_Y-1)))
    9114:	21 81       	ldd	r18, Z+1	; 0x01
    9116:	2d 30       	cpi	r18, 0x0D	; 13
    9118:	78 f4       	brcc	.+30     	; 0x9138 <maze_adaptOffset+0x72>
	{
		_coord->y += offset[_coord->z].y;
    911a:	a2 81       	ldd	r26, Z+2	; 0x02
    911c:	aa 0f       	add	r26, r26
    911e:	bb 0b       	sbc	r27, r27
    9120:	a0 5b       	subi	r26, 0xB0	; 176
    9122:	b9 4e       	sbci	r27, 0xE9	; 233
    9124:	11 96       	adiw	r26, 0x01	; 1
    9126:	9c 91       	ld	r25, X
    9128:	92 0f       	add	r25, r18
		while(_coord->y < 0)
			_coord->y += MAZE_SIZE_Y;
    912a:	91 83       	std	Z+1, r25	; 0x01
	else returnvar = 0;
	
	if((_coord->y >= 0) && (_coord->y <= (MAZE_SIZE_Y-1)))
	{
		_coord->y += offset[_coord->z].y;
		while(_coord->y < 0)
    912c:	91 81       	ldd	r25, Z+1	; 0x01
    912e:	97 ff       	sbrs	r25, 7
    9130:	02 c0       	rjmp	.+4      	; 0x9136 <maze_adaptOffset+0x70>
			_coord->y += MAZE_SIZE_Y;
    9132:	93 5f       	subi	r25, 0xF3	; 243
    9134:	fa cf       	rjmp	.-12     	; 0x912a <maze_adaptOffset+0x64>
    9136:	08 95       	ret
	}
	else returnvar = 0;
    9138:	80 e0       	ldi	r24, 0x00	; 0
	
	return returnvar;
}
    913a:	08 95       	ret

0000913c <maze_setTile>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_setTile(COORD *_coord, TILE *_tile)
{
    913c:	a3 e0       	ldi	r26, 0x03	; 3
    913e:	b0 e0       	ldi	r27, 0x00	; 0
    9140:	e4 ea       	ldi	r30, 0xA4	; 164
    9142:	f8 e4       	ldi	r31, 0x48	; 72
    9144:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    9148:	8b 01       	movw	r16, r22
	COORD c = *_coord;
    914a:	fc 01       	movw	r30, r24
    914c:	80 81       	ld	r24, Z
    914e:	91 81       	ldd	r25, Z+1	; 0x01
    9150:	a2 81       	ldd	r26, Z+2	; 0x02
    9152:	89 83       	std	Y+1, r24	; 0x01
    9154:	9a 83       	std	Y+2, r25	; 0x02
    9156:	ab 83       	std	Y+3, r26	; 0x03
	
	if(maze_adaptOffset(&c))
    9158:	ce 01       	movw	r24, r28
    915a:	01 96       	adiw	r24, 0x01	; 1
    915c:	b4 df       	rcall	.-152    	; 0x90c6 <maze_adaptOffset>
    915e:	88 23       	and	r24, r24
    9160:	e1 f0       	breq	.+56     	; 0x919a <maze_setTile+0x5e>
    9162:	9b 81       	ldd	r25, Y+3	; 0x03
		maze[c.x][c.y][c.z] = *_tile;
    9164:	8a 81       	ldd	r24, Y+2	; 0x02
    9166:	49 81       	ldd	r20, Y+1	; 0x01
    9168:	21 e1       	ldi	r18, 0x11	; 17
    916a:	31 e0       	ldi	r19, 0x01	; 1
    916c:	42 03       	mulsu	r20, r18
    916e:	d0 01       	movw	r26, r0
    9170:	43 9f       	mul	r20, r19
    9172:	b0 0d       	add	r27, r0
    9174:	11 24       	eor	r1, r1
    9176:	f7 e0       	ldi	r31, 0x07	; 7
    9178:	9f 02       	muls	r25, r31
    917a:	a0 0d       	add	r26, r0
    917c:	b1 1d       	adc	r27, r1
    917e:	11 24       	eor	r1, r1
    9180:	25 e1       	ldi	r18, 0x15	; 21
    9182:	82 02       	muls	r24, r18
    9184:	a0 0d       	add	r26, r0
    9186:	b1 1d       	adc	r27, r1
    9188:	11 24       	eor	r1, r1
    918a:	a5 5a       	subi	r26, 0xA5	; 165
    918c:	b7 4f       	sbci	r27, 0xF7	; 247
    918e:	f8 01       	movw	r30, r16
    9190:	87 e0       	ldi	r24, 0x07	; 7
    9192:	01 90       	ld	r0, Z+
    9194:	0d 92       	st	X+, r0
    9196:	8a 95       	dec	r24
    9198:	e1 f7       	brne	.-8      	; 0x9192 <maze_setTile+0x56>
    919a:	23 96       	adiw	r28, 0x03	; 3
}
    919c:	e4 e0       	ldi	r30, 0x04	; 4
    919e:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

000091a2 <maze_getTile>:
//
// @return: Pointer to the TILE information at the given position
////////////////////////////////////////////////////////////////////////////////

TILE *maze_getTile(COORD *_coord)
{
    91a2:	a3 e0       	ldi	r26, 0x03	; 3
    91a4:	b0 e0       	ldi	r27, 0x00	; 0
    91a6:	e7 ed       	ldi	r30, 0xD7	; 215
    91a8:	f8 e4       	ldi	r31, 0x48	; 72
    91aa:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	TILE *_tile = NULL;
	COORD c = *_coord;
    91ae:	fc 01       	movw	r30, r24
    91b0:	80 81       	ld	r24, Z
    91b2:	91 81       	ldd	r25, Z+1	; 0x01
    91b4:	a2 81       	ldd	r26, Z+2	; 0x02
    91b6:	89 83       	std	Y+1, r24	; 0x01
    91b8:	9a 83       	std	Y+2, r25	; 0x02
    91ba:	ab 83       	std	Y+3, r26	; 0x03
	
	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    91bc:	ce 01       	movw	r24, r28
    91be:	01 96       	adiw	r24, 0x01	; 1
    91c0:	82 df       	rcall	.-252    	; 0x90c6 <maze_adaptOffset>
    91c2:	88 23       	and	r24, r24
    91c4:	c1 f0       	breq	.+48     	; 0x91f6 <maze_getTile+0x54>
    91c6:	2b 81       	ldd	r18, Y+3	; 0x03
		_tile = &maze[c.x][c.y][c.z];
    91c8:	8a 81       	ldd	r24, Y+2	; 0x02
    91ca:	f5 e1       	ldi	r31, 0x15	; 21
    91cc:	8f 02       	muls	r24, r31
    91ce:	c0 01       	movw	r24, r0
    91d0:	11 24       	eor	r1, r1
    91d2:	37 e0       	ldi	r19, 0x07	; 7
    91d4:	23 02       	muls	r18, r19
    91d6:	80 0d       	add	r24, r0
    91d8:	91 1d       	adc	r25, r1
    91da:	11 24       	eor	r1, r1
    91dc:	69 81       	ldd	r22, Y+1	; 0x01
    91de:	41 e1       	ldi	r20, 0x11	; 17
    91e0:	51 e0       	ldi	r21, 0x01	; 1
    91e2:	64 03       	mulsu	r22, r20
    91e4:	90 01       	movw	r18, r0
    91e6:	65 9f       	mul	r22, r21
    91e8:	30 0d       	add	r19, r0
    91ea:	11 24       	eor	r1, r1
    91ec:	82 0f       	add	r24, r18
    91ee:	93 1f       	adc	r25, r19
    91f0:	85 5a       	subi	r24, 0xA5	; 165
    91f2:	97 4f       	sbci	r25, 0xF7	; 247
    91f4:	02 c0       	rjmp	.+4      	; 0x91fa <maze_getTile+0x58>
    91f6:	80 e0       	ldi	r24, 0x00	; 0
// @return: Pointer to the TILE information at the given position
////////////////////////////////////////////////////////////////////////////////

TILE *maze_getTile(COORD *_coord)
{
	TILE *_tile = NULL;
    91f8:	90 e0       	ldi	r25, 0x00	; 0
    91fa:	23 96       	adiw	r28, 0x03	; 3
	
	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
		_tile = &maze[c.x][c.y][c.z];
	
	return _tile;
}
    91fc:	e2 e0       	ldi	r30, 0x02	; 2
    91fe:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00009202 <maze_clearTile>:
// @*_coord:	Pointer to the Structure with the coordinate-information
//
// @return: void
////////////////////////////////////////////////////////////////////////////////
void maze_clearTile(COORD *_coord, TILE *_clear)
{
    9202:	a3 e0       	ldi	r26, 0x03	; 3
    9204:	b0 e0       	ldi	r27, 0x00	; 0
    9206:	e7 e0       	ldi	r30, 0x07	; 7
    9208:	f9 e4       	ldi	r31, 0x49	; 73
    920a:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    920e:	8b 01       	movw	r16, r22
	COORD c = *_coord;
    9210:	fc 01       	movw	r30, r24
    9212:	80 81       	ld	r24, Z
    9214:	91 81       	ldd	r25, Z+1	; 0x01
    9216:	a2 81       	ldd	r26, Z+2	; 0x02
    9218:	89 83       	std	Y+1, r24	; 0x01
    921a:	9a 83       	std	Y+2, r25	; 0x02
    921c:	ab 83       	std	Y+3, r26	; 0x03

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    921e:	ce 01       	movw	r24, r28
    9220:	01 96       	adiw	r24, 0x01	; 1
    9222:	51 df       	rcall	.-350    	; 0x90c6 <maze_adaptOffset>
    9224:	88 23       	and	r24, r24
    9226:	09 f4       	brne	.+2      	; 0x922a <maze_clearTile+0x28>
    9228:	23 c1       	rjmp	.+582    	; 0x9470 <maze_clearTile+0x26e>
    922a:	f8 01       	movw	r30, r16
	{
		if(_clear->beenthere)
    922c:	80 81       	ld	r24, Z
    922e:	80 ff       	sbrs	r24, 0
    9230:	19 c0       	rjmp	.+50     	; 0x9264 <maze_clearTile+0x62>
    9232:	9b 81       	ldd	r25, Y+3	; 0x03
				maze[c.x][c.y][c.z].beenthere = 0;
    9234:	8a 81       	ldd	r24, Y+2	; 0x02
    9236:	49 81       	ldd	r20, Y+1	; 0x01
    9238:	21 e1       	ldi	r18, 0x11	; 17
    923a:	31 e0       	ldi	r19, 0x01	; 1
    923c:	42 03       	mulsu	r20, r18
    923e:	f0 01       	movw	r30, r0
    9240:	43 9f       	mul	r20, r19
    9242:	f0 0d       	add	r31, r0
    9244:	11 24       	eor	r1, r1
    9246:	27 e0       	ldi	r18, 0x07	; 7
    9248:	92 02       	muls	r25, r18
    924a:	e0 0d       	add	r30, r0
    924c:	f1 1d       	adc	r31, r1
    924e:	11 24       	eor	r1, r1
    9250:	95 e1       	ldi	r25, 0x15	; 21
    9252:	89 02       	muls	r24, r25
    9254:	e0 0d       	add	r30, r0
    9256:	f1 1d       	adc	r31, r1
    9258:	11 24       	eor	r1, r1
    925a:	e5 5a       	subi	r30, 0xA5	; 165
    925c:	f7 4f       	sbci	r31, 0xF7	; 247
    925e:	80 81       	ld	r24, Z
    9260:	8e 7f       	andi	r24, 0xFE	; 254
    9262:	80 83       	st	Z, r24
    9264:	f8 01       	movw	r30, r16
		if(_clear->ground)
    9266:	80 81       	ld	r24, Z
    9268:	8e 7f       	andi	r24, 0xFE	; 254
    926a:	c9 f0       	breq	.+50     	; 0x929e <maze_clearTile+0x9c>
    926c:	9b 81       	ldd	r25, Y+3	; 0x03
			maze[c.x][c.y][c.z].ground = 0;
    926e:	8a 81       	ldd	r24, Y+2	; 0x02
    9270:	49 81       	ldd	r20, Y+1	; 0x01
    9272:	21 e1       	ldi	r18, 0x11	; 17
    9274:	31 e0       	ldi	r19, 0x01	; 1
    9276:	42 03       	mulsu	r20, r18
    9278:	f0 01       	movw	r30, r0
    927a:	43 9f       	mul	r20, r19
    927c:	f0 0d       	add	r31, r0
    927e:	11 24       	eor	r1, r1
    9280:	27 e0       	ldi	r18, 0x07	; 7
    9282:	92 02       	muls	r25, r18
    9284:	e0 0d       	add	r30, r0
    9286:	f1 1d       	adc	r31, r1
    9288:	11 24       	eor	r1, r1
    928a:	95 e1       	ldi	r25, 0x15	; 21
    928c:	89 02       	muls	r24, r25
    928e:	e0 0d       	add	r30, r0
    9290:	f1 1d       	adc	r31, r1
    9292:	11 24       	eor	r1, r1
    9294:	e5 5a       	subi	r30, 0xA5	; 165
    9296:	f7 4f       	sbci	r31, 0xF7	; 247
    9298:	80 81       	ld	r24, Z
    929a:	81 70       	andi	r24, 0x01	; 1
    929c:	80 83       	st	Z, r24
    929e:	f8 01       	movw	r30, r16
		if(_clear->wall_s)
    92a0:	81 81       	ldd	r24, Z+1	; 0x01
    92a2:	88 23       	and	r24, r24
    92a4:	c1 f0       	breq	.+48     	; 0x92d6 <maze_clearTile+0xd4>
    92a6:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].wall_s = 0;
    92a8:	ea 81       	ldd	r30, Y+2	; 0x02
    92aa:	49 81       	ldd	r20, Y+1	; 0x01
    92ac:	25 e1       	ldi	r18, 0x15	; 21
    92ae:	e2 02       	muls	r30, r18
    92b0:	f0 01       	movw	r30, r0
    92b2:	11 24       	eor	r1, r1
    92b4:	97 e0       	ldi	r25, 0x07	; 7
    92b6:	89 02       	muls	r24, r25
    92b8:	e0 0d       	add	r30, r0
    92ba:	f1 1d       	adc	r31, r1
    92bc:	11 24       	eor	r1, r1
    92be:	21 e1       	ldi	r18, 0x11	; 17
    92c0:	31 e0       	ldi	r19, 0x01	; 1
    92c2:	42 03       	mulsu	r20, r18
    92c4:	c0 01       	movw	r24, r0
    92c6:	43 9f       	mul	r20, r19
    92c8:	90 0d       	add	r25, r0
    92ca:	11 24       	eor	r1, r1
    92cc:	e8 0f       	add	r30, r24
    92ce:	f9 1f       	adc	r31, r25
    92d0:	e5 5a       	subi	r30, 0xA5	; 165
    92d2:	f7 4f       	sbci	r31, 0xF7	; 247
    92d4:	11 82       	std	Z+1, r1	; 0x01
    92d6:	f8 01       	movw	r30, r16
		if(_clear->wall_w)
    92d8:	82 81       	ldd	r24, Z+2	; 0x02
    92da:	88 23       	and	r24, r24
    92dc:	c1 f0       	breq	.+48     	; 0x930e <maze_clearTile+0x10c>
    92de:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].wall_w = 0;
    92e0:	ea 81       	ldd	r30, Y+2	; 0x02
    92e2:	49 81       	ldd	r20, Y+1	; 0x01
    92e4:	25 e1       	ldi	r18, 0x15	; 21
    92e6:	e2 02       	muls	r30, r18
    92e8:	f0 01       	movw	r30, r0
    92ea:	11 24       	eor	r1, r1
    92ec:	97 e0       	ldi	r25, 0x07	; 7
    92ee:	89 02       	muls	r24, r25
    92f0:	e0 0d       	add	r30, r0
    92f2:	f1 1d       	adc	r31, r1
    92f4:	11 24       	eor	r1, r1
    92f6:	21 e1       	ldi	r18, 0x11	; 17
    92f8:	31 e0       	ldi	r19, 0x01	; 1
    92fa:	42 03       	mulsu	r20, r18
    92fc:	c0 01       	movw	r24, r0
    92fe:	43 9f       	mul	r20, r19
    9300:	90 0d       	add	r25, r0
    9302:	11 24       	eor	r1, r1
    9304:	e8 0f       	add	r30, r24
    9306:	f9 1f       	adc	r31, r25
    9308:	e5 5a       	subi	r30, 0xA5	; 165
    930a:	f7 4f       	sbci	r31, 0xF7	; 247
    930c:	12 82       	std	Z+2, r1	; 0x02
    930e:	f8 01       	movw	r30, r16
		if(_clear->obstacle)
    9310:	83 81       	ldd	r24, Z+3	; 0x03
    9312:	88 23       	and	r24, r24
    9314:	c1 f0       	breq	.+48     	; 0x9346 <maze_clearTile+0x144>
    9316:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].obstacle = 0;
    9318:	ea 81       	ldd	r30, Y+2	; 0x02
    931a:	49 81       	ldd	r20, Y+1	; 0x01
    931c:	25 e1       	ldi	r18, 0x15	; 21
    931e:	e2 02       	muls	r30, r18
    9320:	f0 01       	movw	r30, r0
    9322:	11 24       	eor	r1, r1
    9324:	97 e0       	ldi	r25, 0x07	; 7
    9326:	89 02       	muls	r24, r25
    9328:	e0 0d       	add	r30, r0
    932a:	f1 1d       	adc	r31, r1
    932c:	11 24       	eor	r1, r1
    932e:	21 e1       	ldi	r18, 0x11	; 17
    9330:	31 e0       	ldi	r19, 0x01	; 1
    9332:	42 03       	mulsu	r20, r18
    9334:	c0 01       	movw	r24, r0
    9336:	43 9f       	mul	r20, r19
    9338:	90 0d       	add	r25, r0
    933a:	11 24       	eor	r1, r1
    933c:	e8 0f       	add	r30, r24
    933e:	f9 1f       	adc	r31, r25
    9340:	e5 5a       	subi	r30, 0xA5	; 165
    9342:	f7 4f       	sbci	r31, 0xF7	; 247
    9344:	13 82       	std	Z+3, r1	; 0x03
    9346:	f8 01       	movw	r30, r16
		if(_clear->depthsearch)
    9348:	86 81       	ldd	r24, Z+6	; 0x06
    934a:	88 23       	and	r24, r24
    934c:	c9 f0       	breq	.+50     	; 0x9380 <maze_clearTile+0x17e>
    934e:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].depthsearch = 0xff;
    9350:	ea 81       	ldd	r30, Y+2	; 0x02
    9352:	49 81       	ldd	r20, Y+1	; 0x01
    9354:	25 e1       	ldi	r18, 0x15	; 21
    9356:	e2 02       	muls	r30, r18
    9358:	f0 01       	movw	r30, r0
    935a:	11 24       	eor	r1, r1
    935c:	97 e0       	ldi	r25, 0x07	; 7
    935e:	89 02       	muls	r24, r25
    9360:	e0 0d       	add	r30, r0
    9362:	f1 1d       	adc	r31, r1
    9364:	11 24       	eor	r1, r1
    9366:	21 e1       	ldi	r18, 0x11	; 17
    9368:	31 e0       	ldi	r19, 0x01	; 1
    936a:	42 03       	mulsu	r20, r18
    936c:	c0 01       	movw	r24, r0
    936e:	43 9f       	mul	r20, r19
    9370:	90 0d       	add	r25, r0
    9372:	11 24       	eor	r1, r1
    9374:	e8 0f       	add	r30, r24
    9376:	f9 1f       	adc	r31, r25
    9378:	e5 5a       	subi	r30, 0xA5	; 165
    937a:	f7 4f       	sbci	r31, 0xF7	; 247
    937c:	8f ef       	ldi	r24, 0xFF	; 255
    937e:	86 83       	std	Z+6, r24	; 0x06
    9380:	f8 01       	movw	r30, r16
		if(_clear->victim_n)
    9382:	84 81       	ldd	r24, Z+4	; 0x04
    9384:	8f 70       	andi	r24, 0x0F	; 15
    9386:	d1 f0       	breq	.+52     	; 0x93bc <maze_clearTile+0x1ba>
    9388:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].victim_n = 0;
    938a:	ea 81       	ldd	r30, Y+2	; 0x02
    938c:	49 81       	ldd	r20, Y+1	; 0x01
    938e:	25 e1       	ldi	r18, 0x15	; 21
    9390:	e2 02       	muls	r30, r18
    9392:	f0 01       	movw	r30, r0
    9394:	11 24       	eor	r1, r1
    9396:	97 e0       	ldi	r25, 0x07	; 7
    9398:	89 02       	muls	r24, r25
    939a:	e0 0d       	add	r30, r0
    939c:	f1 1d       	adc	r31, r1
    939e:	11 24       	eor	r1, r1
    93a0:	21 e1       	ldi	r18, 0x11	; 17
    93a2:	31 e0       	ldi	r19, 0x01	; 1
    93a4:	42 03       	mulsu	r20, r18
    93a6:	c0 01       	movw	r24, r0
    93a8:	43 9f       	mul	r20, r19
    93aa:	90 0d       	add	r25, r0
    93ac:	11 24       	eor	r1, r1
    93ae:	e8 0f       	add	r30, r24
    93b0:	f9 1f       	adc	r31, r25
    93b2:	e1 5a       	subi	r30, 0xA1	; 161
    93b4:	f7 4f       	sbci	r31, 0xF7	; 247
    93b6:	80 81       	ld	r24, Z
    93b8:	80 7f       	andi	r24, 0xF0	; 240
    93ba:	80 83       	st	Z, r24
    93bc:	f8 01       	movw	r30, r16
		if(_clear->victim_e)
    93be:	84 81       	ldd	r24, Z+4	; 0x04
    93c0:	80 7f       	andi	r24, 0xF0	; 240
    93c2:	d1 f0       	breq	.+52     	; 0x93f8 <maze_clearTile+0x1f6>
    93c4:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].victim_e = 0;
    93c6:	ea 81       	ldd	r30, Y+2	; 0x02
    93c8:	49 81       	ldd	r20, Y+1	; 0x01
    93ca:	25 e1       	ldi	r18, 0x15	; 21
    93cc:	e2 02       	muls	r30, r18
    93ce:	f0 01       	movw	r30, r0
    93d0:	11 24       	eor	r1, r1
    93d2:	97 e0       	ldi	r25, 0x07	; 7
    93d4:	89 02       	muls	r24, r25
    93d6:	e0 0d       	add	r30, r0
    93d8:	f1 1d       	adc	r31, r1
    93da:	11 24       	eor	r1, r1
    93dc:	21 e1       	ldi	r18, 0x11	; 17
    93de:	31 e0       	ldi	r19, 0x01	; 1
    93e0:	42 03       	mulsu	r20, r18
    93e2:	c0 01       	movw	r24, r0
    93e4:	43 9f       	mul	r20, r19
    93e6:	90 0d       	add	r25, r0
    93e8:	11 24       	eor	r1, r1
    93ea:	e8 0f       	add	r30, r24
    93ec:	f9 1f       	adc	r31, r25
    93ee:	e1 5a       	subi	r30, 0xA1	; 161
    93f0:	f7 4f       	sbci	r31, 0xF7	; 247
    93f2:	80 81       	ld	r24, Z
    93f4:	8f 70       	andi	r24, 0x0F	; 15
    93f6:	80 83       	st	Z, r24
    93f8:	f8 01       	movw	r30, r16
		if(_clear->victim_s)
    93fa:	85 81       	ldd	r24, Z+5	; 0x05
    93fc:	8f 70       	andi	r24, 0x0F	; 15
    93fe:	d1 f0       	breq	.+52     	; 0x9434 <maze_clearTile+0x232>
    9400:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].victim_s = 0;
    9402:	ea 81       	ldd	r30, Y+2	; 0x02
    9404:	49 81       	ldd	r20, Y+1	; 0x01
    9406:	25 e1       	ldi	r18, 0x15	; 21
    9408:	e2 02       	muls	r30, r18
    940a:	f0 01       	movw	r30, r0
    940c:	11 24       	eor	r1, r1
    940e:	97 e0       	ldi	r25, 0x07	; 7
    9410:	89 02       	muls	r24, r25
    9412:	e0 0d       	add	r30, r0
    9414:	f1 1d       	adc	r31, r1
    9416:	11 24       	eor	r1, r1
    9418:	21 e1       	ldi	r18, 0x11	; 17
    941a:	31 e0       	ldi	r19, 0x01	; 1
    941c:	42 03       	mulsu	r20, r18
    941e:	c0 01       	movw	r24, r0
    9420:	43 9f       	mul	r20, r19
    9422:	90 0d       	add	r25, r0
    9424:	11 24       	eor	r1, r1
    9426:	e8 0f       	add	r30, r24
    9428:	f9 1f       	adc	r31, r25
    942a:	e1 5a       	subi	r30, 0xA1	; 161
    942c:	f7 4f       	sbci	r31, 0xF7	; 247
    942e:	81 81       	ldd	r24, Z+1	; 0x01
    9430:	80 7f       	andi	r24, 0xF0	; 240
    9432:	81 83       	std	Z+1, r24	; 0x01
    9434:	f8 01       	movw	r30, r16
		if(_clear->victim_w)
    9436:	85 81       	ldd	r24, Z+5	; 0x05
    9438:	80 7f       	andi	r24, 0xF0	; 240
    943a:	d1 f0       	breq	.+52     	; 0x9470 <maze_clearTile+0x26e>
    943c:	8b 81       	ldd	r24, Y+3	; 0x03
			maze[c.x][c.y][c.z].victim_w = 0;
    943e:	ea 81       	ldd	r30, Y+2	; 0x02
    9440:	49 81       	ldd	r20, Y+1	; 0x01
    9442:	25 e1       	ldi	r18, 0x15	; 21
    9444:	e2 02       	muls	r30, r18
    9446:	f0 01       	movw	r30, r0
    9448:	11 24       	eor	r1, r1
    944a:	97 e0       	ldi	r25, 0x07	; 7
    944c:	89 02       	muls	r24, r25
    944e:	e0 0d       	add	r30, r0
    9450:	f1 1d       	adc	r31, r1
    9452:	11 24       	eor	r1, r1
    9454:	21 e1       	ldi	r18, 0x11	; 17
    9456:	31 e0       	ldi	r19, 0x01	; 1
    9458:	42 03       	mulsu	r20, r18
    945a:	c0 01       	movw	r24, r0
    945c:	43 9f       	mul	r20, r19
    945e:	90 0d       	add	r25, r0
    9460:	11 24       	eor	r1, r1
    9462:	e8 0f       	add	r30, r24
    9464:	f9 1f       	adc	r31, r25
    9466:	e1 5a       	subi	r30, 0xA1	; 161
    9468:	f7 4f       	sbci	r31, 0xF7	; 247
    946a:	81 81       	ldd	r24, Z+1	; 0x01
    946c:	8f 70       	andi	r24, 0x0F	; 15
    946e:	81 83       	std	Z+1, r24	; 0x01
    9470:	23 96       	adiw	r28, 0x03	; 3
	}
}
    9472:	e4 e0       	ldi	r30, 0x04	; 4
    9474:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

00009478 <maze_getVictim>:
//
// @return: value of the wall at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getVictim(COORD *_coord, uint8_t dir)
{
    9478:	a4 e0       	ldi	r26, 0x04	; 4
    947a:	b0 e0       	ldi	r27, 0x00	; 0
    947c:	e2 e4       	ldi	r30, 0x42	; 66
    947e:	fa e4       	ldi	r31, 0x4A	; 74
    9480:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	int8_t returnvar = MAZE_ERROR;
	COORD c = *_coord;
    9484:	fc 01       	movw	r30, r24
    9486:	80 81       	ld	r24, Z
    9488:	91 81       	ldd	r25, Z+1	; 0x01
    948a:	a2 81       	ldd	r26, Z+2	; 0x02
    948c:	89 83       	std	Y+1, r24	; 0x01
    948e:	9a 83       	std	Y+2, r25	; 0x02
    9490:	ab 83       	std	Y+3, r26	; 0x03
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    9492:	65 30       	cpi	r22, 0x05	; 5
    9494:	10 f0       	brcs	.+4      	; 0x949a <maze_getVictim+0x22>
		dir -= WEST;
    9496:	64 50       	subi	r22, 0x04	; 4
    9498:	fc cf       	rjmp	.-8      	; 0x9492 <maze_getVictim+0x1a>
	int8_t returnvar = MAZE_ERROR;
	COORD c = *_coord;

	dir = maze_alignDir(dir);

	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
    949a:	ce 01       	movw	r24, r28
    949c:	01 96       	adiw	r24, 0x01	; 1
    949e:	6c 83       	std	Y+4, r22	; 0x04
    94a0:	12 de       	rcall	.-988    	; 0x90c6 <maze_adaptOffset>
    94a2:	6c 81       	ldd	r22, Y+4	; 0x04
    94a4:	88 23       	and	r24, r24
    94a6:	09 f4       	brne	.+2      	; 0x94aa <maze_getVictim+0x32>
    94a8:	8d c0       	rjmp	.+282    	; 0x95c4 <maze_getVictim+0x14c>
    94aa:	62 30       	cpi	r22, 0x02	; 2
	{
		switch(dir)
    94ac:	c9 f1       	breq	.+114    	; 0x9520 <maze_getVictim+0xa8>
    94ae:	d8 f4       	brcc	.+54     	; 0x94e6 <maze_getVictim+0x6e>
    94b0:	61 30       	cpi	r22, 0x01	; 1
    94b2:	09 f0       	breq	.+2      	; 0x94b6 <maze_getVictim+0x3e>
    94b4:	6e c0       	rjmp	.+220    	; 0x9592 <maze_getVictim+0x11a>
    94b6:	8b 81       	ldd	r24, Y+3	; 0x03
		{
			case NORTH:	returnvar = maze[c.x][c.y][c.z].victim_n;	break;
    94b8:	ea 81       	ldd	r30, Y+2	; 0x02
    94ba:	49 81       	ldd	r20, Y+1	; 0x01
    94bc:	95 e1       	ldi	r25, 0x15	; 21
    94be:	e9 02       	muls	r30, r25
    94c0:	f0 01       	movw	r30, r0
    94c2:	11 24       	eor	r1, r1
    94c4:	97 e0       	ldi	r25, 0x07	; 7
    94c6:	89 02       	muls	r24, r25
    94c8:	e0 0d       	add	r30, r0
    94ca:	f1 1d       	adc	r31, r1
    94cc:	11 24       	eor	r1, r1
    94ce:	21 e1       	ldi	r18, 0x11	; 17
    94d0:	31 e0       	ldi	r19, 0x01	; 1
    94d2:	42 03       	mulsu	r20, r18
    94d4:	c0 01       	movw	r24, r0
    94d6:	43 9f       	mul	r20, r19
    94d8:	90 0d       	add	r25, r0
    94da:	11 24       	eor	r1, r1
    94dc:	e8 0f       	add	r30, r24
    94de:	f9 1f       	adc	r31, r25
    94e0:	e1 5a       	subi	r30, 0xA1	; 161
    94e2:	f7 4f       	sbci	r31, 0xF7	; 247
    94e4:	4c c0       	rjmp	.+152    	; 0x957e <maze_getVictim+0x106>
    94e6:	63 30       	cpi	r22, 0x03	; 3

	dir = maze_alignDir(dir);

	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
	{
		switch(dir)
    94e8:	99 f1       	breq	.+102    	; 0x9550 <maze_getVictim+0xd8>
    94ea:	64 30       	cpi	r22, 0x04	; 4
    94ec:	09 f0       	breq	.+2      	; 0x94f0 <maze_getVictim+0x78>
    94ee:	51 c0       	rjmp	.+162    	; 0x9592 <maze_getVictim+0x11a>
    94f0:	8b 81       	ldd	r24, Y+3	; 0x03
		{
			case NORTH:	returnvar = maze[c.x][c.y][c.z].victim_n;	break;
			case EAST:	returnvar = maze[c.x][c.y][c.z].victim_e;	break;
			case SOUTH:	returnvar = maze[c.x][c.y][c.z].victim_s;	break;
			case WEST:	returnvar = maze[c.x][c.y][c.z].victim_w;	break;
    94f2:	ea 81       	ldd	r30, Y+2	; 0x02
    94f4:	49 81       	ldd	r20, Y+1	; 0x01
    94f6:	95 e1       	ldi	r25, 0x15	; 21
    94f8:	e9 02       	muls	r30, r25
    94fa:	f0 01       	movw	r30, r0
    94fc:	11 24       	eor	r1, r1
    94fe:	97 e0       	ldi	r25, 0x07	; 7
    9500:	89 02       	muls	r24, r25
    9502:	e0 0d       	add	r30, r0
    9504:	f1 1d       	adc	r31, r1
    9506:	11 24       	eor	r1, r1
    9508:	21 e1       	ldi	r18, 0x11	; 17
    950a:	31 e0       	ldi	r19, 0x01	; 1
    950c:	42 03       	mulsu	r20, r18
    950e:	c0 01       	movw	r24, r0
    9510:	43 9f       	mul	r20, r19
    9512:	90 0d       	add	r25, r0
    9514:	11 24       	eor	r1, r1
    9516:	e8 0f       	add	r30, r24
    9518:	f9 1f       	adc	r31, r25
    951a:	e0 5a       	subi	r30, 0xA0	; 160
    951c:	f7 4f       	sbci	r31, 0xF7	; 247
    951e:	33 c0       	rjmp	.+102    	; 0x9586 <maze_getVictim+0x10e>
    9520:	8b 81       	ldd	r24, Y+3	; 0x03
	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
	{
		switch(dir)
		{
			case NORTH:	returnvar = maze[c.x][c.y][c.z].victim_n;	break;
			case EAST:	returnvar = maze[c.x][c.y][c.z].victim_e;	break;
    9522:	ea 81       	ldd	r30, Y+2	; 0x02
    9524:	49 81       	ldd	r20, Y+1	; 0x01
    9526:	95 e1       	ldi	r25, 0x15	; 21
    9528:	e9 02       	muls	r30, r25
    952a:	f0 01       	movw	r30, r0
    952c:	11 24       	eor	r1, r1
    952e:	97 e0       	ldi	r25, 0x07	; 7
    9530:	89 02       	muls	r24, r25
    9532:	e0 0d       	add	r30, r0
    9534:	f1 1d       	adc	r31, r1
    9536:	11 24       	eor	r1, r1
    9538:	21 e1       	ldi	r18, 0x11	; 17
    953a:	31 e0       	ldi	r19, 0x01	; 1
    953c:	42 03       	mulsu	r20, r18
    953e:	c0 01       	movw	r24, r0
    9540:	43 9f       	mul	r20, r19
    9542:	90 0d       	add	r25, r0
    9544:	11 24       	eor	r1, r1
    9546:	e8 0f       	add	r30, r24
    9548:	f9 1f       	adc	r31, r25
    954a:	e1 5a       	subi	r30, 0xA1	; 161
    954c:	f7 4f       	sbci	r31, 0xF7	; 247
    954e:	1b c0       	rjmp	.+54     	; 0x9586 <maze_getVictim+0x10e>
    9550:	8b 81       	ldd	r24, Y+3	; 0x03
			case SOUTH:	returnvar = maze[c.x][c.y][c.z].victim_s;	break;
    9552:	ea 81       	ldd	r30, Y+2	; 0x02
    9554:	49 81       	ldd	r20, Y+1	; 0x01
    9556:	95 e1       	ldi	r25, 0x15	; 21
    9558:	e9 02       	muls	r30, r25
    955a:	f0 01       	movw	r30, r0
    955c:	11 24       	eor	r1, r1
    955e:	97 e0       	ldi	r25, 0x07	; 7
    9560:	89 02       	muls	r24, r25
    9562:	e0 0d       	add	r30, r0
    9564:	f1 1d       	adc	r31, r1
    9566:	11 24       	eor	r1, r1
    9568:	21 e1       	ldi	r18, 0x11	; 17
    956a:	31 e0       	ldi	r19, 0x01	; 1
    956c:	42 03       	mulsu	r20, r18
    956e:	c0 01       	movw	r24, r0
    9570:	43 9f       	mul	r20, r19
    9572:	90 0d       	add	r25, r0
    9574:	11 24       	eor	r1, r1
    9576:	e8 0f       	add	r30, r24
    9578:	f9 1f       	adc	r31, r25
    957a:	e0 5a       	subi	r30, 0xA0	; 160
    957c:	f7 4f       	sbci	r31, 0xF7	; 247
    957e:	80 81       	ld	r24, Z
    9580:	82 95       	swap	r24
    9582:	80 7f       	andi	r24, 0xF0	; 240
    9584:	01 c0       	rjmp	.+2      	; 0x9588 <maze_getVictim+0x110>
    9586:	80 81       	ld	r24, Z
			case WEST:	returnvar = maze[c.x][c.y][c.z].victim_w;	break;
    9588:	85 95       	asr	r24
    958a:	85 95       	asr	r24
    958c:	85 95       	asr	r24
    958e:	85 95       	asr	r24
    9590:	1a c0       	rjmp	.+52     	; 0x95c6 <maze_getVictim+0x14e>
    9592:	80 91 53 05 	lds	r24, 0x0553
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.08]:DEFAULT_CASE"));}
    9596:	82 30       	cpi	r24, 0x02	; 2
    9598:	90 f0       	brcs	.+36     	; 0x95be <maze_getVictim+0x146>
    959a:	89 e6       	ldi	r24, 0x69	; 105
    959c:	9c e2       	ldi	r25, 0x2C	; 44
    959e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    95a2:	60 91 47 05 	lds	r22, 0x0547
    95a6:	70 91 48 05 	lds	r23, 0x0548
    95aa:	80 91 49 05 	lds	r24, 0x0549
    95ae:	90 91 4a 05 	lds	r25, 0x054A
    95b2:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    95b6:	83 e3       	ldi	r24, 0x33	; 51
    95b8:	9c e2       	ldi	r25, 0x2C	; 44
    95ba:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    95be:	81 e0       	ldi	r24, 0x01	; 1
								fatal_err = 1;
    95c0:	80 93 63 05 	sts	0x0563, r24
    95c4:	8f e7       	ldi	r24, 0x7F	; 127
// @return: value of the wall at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getVictim(COORD *_coord, uint8_t dir)
{
	int8_t returnvar = MAZE_ERROR;
    95c6:	24 96       	adiw	r28, 0x04	; 4
								fatal_err = 1;
		}
	}

	return returnvar;
}
    95c8:	e2 e0       	ldi	r30, 0x02	; 2
    95ca:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

000095ce <maze_setWall>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_setWall(COORD *_coord, int8_t dir, int8_t value)
{
    95ce:	a4 e0       	ldi	r26, 0x04	; 4
    95d0:	b0 e0       	ldi	r27, 0x00	; 0
    95d2:	ed ee       	ldi	r30, 0xED	; 237
    95d4:	fa e4       	ldi	r31, 0x4A	; 74
    95d6:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
	COORD c = *_coord;
    95da:	fc 01       	movw	r30, r24
    95dc:	80 81       	ld	r24, Z
    95de:	91 81       	ldd	r25, Z+1	; 0x01
    95e0:	a2 81       	ldd	r26, Z+2	; 0x02
    95e2:	89 83       	std	Y+1, r24	; 0x01
    95e4:	9a 83       	std	Y+2, r25	; 0x02
    95e6:	ab 83       	std	Y+3, r26	; 0x03
	dir = maze_alignDir(dir); //NOW Align
    95e8:	16 2f       	mov	r17, r22
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    95ea:	15 30       	cpi	r17, 0x05	; 5
    95ec:	10 f0       	brcs	.+4      	; 0x95f2 <maze_setWall+0x24>
		dir -= WEST;
    95ee:	14 50       	subi	r17, 0x04	; 4
    95f0:	fc cf       	rjmp	.-8      	; 0x95ea <maze_setWall+0x1c>
void maze_setWall(COORD *_coord, int8_t dir, int8_t value)
{
	COORD c = *_coord;
	dir = maze_alignDir(dir); //NOW Align

	if(maze_adaptOffset(&c))
    95f2:	ce 01       	movw	r24, r28
    95f4:	01 96       	adiw	r24, 0x01	; 1
    95f6:	4c 83       	std	Y+4, r20	; 0x04
    95f8:	66 dd       	rcall	.-1332   	; 0x90c6 <maze_adaptOffset>
    95fa:	4c 81       	ldd	r20, Y+4	; 0x04
    95fc:	88 23       	and	r24, r24
    95fe:	09 f4       	brne	.+2      	; 0x9602 <maze_setWall+0x34>
    9600:	aa c0       	rjmp	.+340    	; 0x9756 <maze_setWall+0x188>
    9602:	12 30       	cpi	r17, 0x02	; 2
	{
		switch(dir)
    9604:	09 f4       	brne	.+2      	; 0x9608 <maze_setWall+0x3a>
    9606:	49 c0       	rjmp	.+146    	; 0x969a <maze_setWall+0xcc>
    9608:	1c f4       	brge	.+6      	; 0x9610 <maze_setWall+0x42>
    960a:	11 30       	cpi	r17, 0x01	; 1
    960c:	e9 f0       	breq	.+58     	; 0x9648 <maze_setWall+0x7a>
    960e:	8a c0       	rjmp	.+276    	; 0x9724 <maze_setWall+0x156>
    9610:	13 30       	cpi	r17, 0x03	; 3
    9612:	09 f4       	brne	.+2      	; 0x9616 <maze_setWall+0x48>
    9614:	6a c0       	rjmp	.+212    	; 0x96ea <maze_setWall+0x11c>
    9616:	14 30       	cpi	r17, 0x04	; 4
    9618:	09 f0       	breq	.+2      	; 0x961c <maze_setWall+0x4e>
    961a:	84 c0       	rjmp	.+264    	; 0x9724 <maze_setWall+0x156>
    961c:	8b 81       	ldd	r24, Y+3	; 0x03
							break;
			case SOUTH:
								maze[c.x][c.y][c.z].wall_s = value; //Aktuelle Platte Wand Sden = Aktuelle Platte Wand Sden
							break;
			case WEST:
								maze[c.x][c.y][c.z].wall_w = value; //Aktuelle Platte Wand Westen = Aktuelle Platte Wand Westen
    961e:	ea 81       	ldd	r30, Y+2	; 0x02
    9620:	59 81       	ldd	r21, Y+1	; 0x01
    9622:	35 e1       	ldi	r19, 0x15	; 21
    9624:	e3 02       	muls	r30, r19
    9626:	f0 01       	movw	r30, r0
    9628:	11 24       	eor	r1, r1
    962a:	97 e0       	ldi	r25, 0x07	; 7
    962c:	89 02       	muls	r24, r25
    962e:	e0 0d       	add	r30, r0
    9630:	f1 1d       	adc	r31, r1
    9632:	11 24       	eor	r1, r1
    9634:	21 e1       	ldi	r18, 0x11	; 17
    9636:	31 e0       	ldi	r19, 0x01	; 1
    9638:	52 03       	mulsu	r21, r18
    963a:	c0 01       	movw	r24, r0
    963c:	53 9f       	mul	r21, r19
    963e:	90 0d       	add	r25, r0
    9640:	11 24       	eor	r1, r1
    9642:	e8 0f       	add	r30, r24
    9644:	f9 1f       	adc	r31, r25
    9646:	6a c0       	rjmp	.+212    	; 0x971c <maze_setWall+0x14e>
    9648:	8a 81       	ldd	r24, Y+2	; 0x02
	if(maze_adaptOffset(&c))
	{
		switch(dir)
		{
			case NORTH:
								if((c.y + 1) <= (MAZE_SIZE_Y-1))	maze[c.x][c.y + 1][c.z].wall_s = value; //Aktuelle Platte Wand Norden = nchste Platte Norden Wand Sden
    964a:	5b 81       	ldd	r21, Y+3	; 0x03
    964c:	69 81       	ldd	r22, Y+1	; 0x01
    964e:	8c 30       	cpi	r24, 0x0C	; 12
    9650:	bc f4       	brge	.+46     	; 0x9680 <maze_setWall+0xb2>
    9652:	99 27       	eor	r25, r25
    9654:	87 fd       	sbrc	r24, 7
    9656:	90 95       	com	r25
    9658:	01 96       	adiw	r24, 0x01	; 1
    965a:	25 e1       	ldi	r18, 0x15	; 21
    965c:	28 9f       	mul	r18, r24
    965e:	f0 01       	movw	r30, r0
    9660:	29 9f       	mul	r18, r25
    9662:	f0 0d       	add	r31, r0
    9664:	11 24       	eor	r1, r1
    9666:	37 e0       	ldi	r19, 0x07	; 7
    9668:	53 02       	muls	r21, r19
    966a:	e0 0d       	add	r30, r0
    966c:	f1 1d       	adc	r31, r1
    966e:	11 24       	eor	r1, r1
    9670:	21 e1       	ldi	r18, 0x11	; 17
    9672:	31 e0       	ldi	r19, 0x01	; 1
    9674:	62 03       	mulsu	r22, r18
    9676:	c0 01       	movw	r24, r0
    9678:	63 9f       	mul	r22, r19
    967a:	90 0d       	add	r25, r0
    967c:	11 24       	eor	r1, r1
    967e:	48 c0       	rjmp	.+144    	; 0x9710 <maze_setWall+0x142>
    9680:	21 e1       	ldi	r18, 0x11	; 17
								else								maze[c.x][0		 ][c.z].wall_s = value;
    9682:	31 e0       	ldi	r19, 0x01	; 1
    9684:	62 03       	mulsu	r22, r18
    9686:	f0 01       	movw	r30, r0
    9688:	63 9f       	mul	r22, r19
    968a:	f0 0d       	add	r31, r0
    968c:	11 24       	eor	r1, r1
    968e:	87 e0       	ldi	r24, 0x07	; 7
    9690:	58 02       	muls	r21, r24
    9692:	e0 0d       	add	r30, r0
    9694:	f1 1d       	adc	r31, r1
    9696:	11 24       	eor	r1, r1
    9698:	3d c0       	rjmp	.+122    	; 0x9714 <maze_setWall+0x146>
    969a:	89 81       	ldd	r24, Y+1	; 0x01
							break;
			case EAST:
								if((c.x + 1) <= (MAZE_SIZE_X-1))	maze[c.x + 1][c.y][c.z].wall_w = value; //Aktuelle Platte Wand Osten = nchste Platte Wand Westen
    969c:	ea 81       	ldd	r30, Y+2	; 0x02
    969e:	2b 81       	ldd	r18, Y+3	; 0x03
    96a0:	8c 30       	cpi	r24, 0x0C	; 12
    96a2:	cc f4       	brge	.+50     	; 0x96d6 <maze_setWall+0x108>
    96a4:	99 27       	eor	r25, r25
    96a6:	87 fd       	sbrc	r24, 7
    96a8:	90 95       	com	r25
    96aa:	01 96       	adiw	r24, 0x01	; 1
    96ac:	35 e1       	ldi	r19, 0x15	; 21
    96ae:	e3 02       	muls	r30, r19
    96b0:	f0 01       	movw	r30, r0
    96b2:	11 24       	eor	r1, r1
    96b4:	37 e0       	ldi	r19, 0x07	; 7
    96b6:	23 02       	muls	r18, r19
    96b8:	e0 0d       	add	r30, r0
    96ba:	f1 1d       	adc	r31, r1
    96bc:	11 24       	eor	r1, r1
    96be:	61 e1       	ldi	r22, 0x11	; 17
    96c0:	71 e0       	ldi	r23, 0x01	; 1
    96c2:	86 9f       	mul	r24, r22
    96c4:	90 01       	movw	r18, r0
    96c6:	87 9f       	mul	r24, r23
    96c8:	30 0d       	add	r19, r0
    96ca:	96 9f       	mul	r25, r22
    96cc:	30 0d       	add	r19, r0
    96ce:	11 24       	eor	r1, r1
    96d0:	e2 0f       	add	r30, r18
    96d2:	f3 1f       	adc	r31, r19
    96d4:	23 c0       	rjmp	.+70     	; 0x971c <maze_setWall+0x14e>
    96d6:	85 e1       	ldi	r24, 0x15	; 21
								else								maze[0		][c.y][c.z].wall_w = value;
    96d8:	e8 02       	muls	r30, r24
    96da:	f0 01       	movw	r30, r0
    96dc:	11 24       	eor	r1, r1
    96de:	97 e0       	ldi	r25, 0x07	; 7
    96e0:	29 02       	muls	r18, r25
    96e2:	e0 0d       	add	r30, r0
    96e4:	f1 1d       	adc	r31, r1
    96e6:	11 24       	eor	r1, r1
    96e8:	19 c0       	rjmp	.+50     	; 0x971c <maze_setWall+0x14e>
    96ea:	8b 81       	ldd	r24, Y+3	; 0x03
							break;
			case SOUTH:
								maze[c.x][c.y][c.z].wall_s = value; //Aktuelle Platte Wand Sden = Aktuelle Platte Wand Sden
    96ec:	ea 81       	ldd	r30, Y+2	; 0x02
    96ee:	59 81       	ldd	r21, Y+1	; 0x01
    96f0:	35 e1       	ldi	r19, 0x15	; 21
    96f2:	e3 02       	muls	r30, r19
    96f4:	f0 01       	movw	r30, r0
    96f6:	11 24       	eor	r1, r1
    96f8:	97 e0       	ldi	r25, 0x07	; 7
    96fa:	89 02       	muls	r24, r25
    96fc:	e0 0d       	add	r30, r0
    96fe:	f1 1d       	adc	r31, r1
    9700:	11 24       	eor	r1, r1
    9702:	21 e1       	ldi	r18, 0x11	; 17
    9704:	31 e0       	ldi	r19, 0x01	; 1
    9706:	52 03       	mulsu	r21, r18
    9708:	c0 01       	movw	r24, r0
    970a:	53 9f       	mul	r21, r19
    970c:	90 0d       	add	r25, r0
    970e:	11 24       	eor	r1, r1
    9710:	e8 0f       	add	r30, r24
    9712:	f9 1f       	adc	r31, r25
    9714:	e5 5a       	subi	r30, 0xA5	; 165
    9716:	f7 4f       	sbci	r31, 0xF7	; 247
    9718:	41 83       	std	Z+1, r20	; 0x01
    971a:	1d c0       	rjmp	.+58     	; 0x9756 <maze_setWall+0x188>
							break;
    971c:	e5 5a       	subi	r30, 0xA5	; 165
			case WEST:
								maze[c.x][c.y][c.z].wall_w = value; //Aktuelle Platte Wand Westen = Aktuelle Platte Wand Westen
    971e:	f7 4f       	sbci	r31, 0xF7	; 247
    9720:	42 83       	std	Z+2, r20	; 0x02
    9722:	19 c0       	rjmp	.+50     	; 0x9756 <maze_setWall+0x188>
							break;
    9724:	80 91 53 05 	lds	r24, 0x0553
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.08]:DEFAULT_CASE"));}
    9728:	82 30       	cpi	r24, 0x02	; 2
    972a:	90 f0       	brcs	.+36     	; 0x9750 <maze_setWall+0x182>
    972c:	80 e3       	ldi	r24, 0x30	; 48
    972e:	9c e2       	ldi	r25, 0x2C	; 44
    9730:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    9734:	60 91 47 05 	lds	r22, 0x0547
    9738:	70 91 48 05 	lds	r23, 0x0548
    973c:	80 91 49 05 	lds	r24, 0x0549
    9740:	90 91 4a 05 	lds	r25, 0x054A
    9744:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    9748:	8a ef       	ldi	r24, 0xFA	; 250
    974a:	9b e2       	ldi	r25, 0x2B	; 43
    974c:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    9750:	81 e0       	ldi	r24, 0x01	; 1
								fatal_err = 1;
    9752:	80 93 63 05 	sts	0x0563, r24
    9756:	24 96       	adiw	r28, 0x04	; 4
		}
	}
}
    9758:	e3 e0       	ldi	r30, 0x03	; 3
    975a:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

0000975e <maze_getWall>:
//
// @return: value of the wall at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getWall(COORD *_coord, uint8_t dir)
{
    975e:	a4 e0       	ldi	r26, 0x04	; 4
    9760:	b0 e0       	ldi	r27, 0x00	; 0
    9762:	e5 eb       	ldi	r30, 0xB5	; 181
    9764:	fb e4       	ldi	r31, 0x4B	; 75
    9766:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	int8_t returnvar = MAZE_ERROR;
	COORD c = *_coord;
    976a:	fc 01       	movw	r30, r24
    976c:	80 81       	ld	r24, Z
    976e:	91 81       	ldd	r25, Z+1	; 0x01
    9770:	a2 81       	ldd	r26, Z+2	; 0x02
    9772:	89 83       	std	Y+1, r24	; 0x01
    9774:	9a 83       	std	Y+2, r25	; 0x02
    9776:	ab 83       	std	Y+3, r26	; 0x03
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    9778:	65 30       	cpi	r22, 0x05	; 5
    977a:	10 f0       	brcs	.+4      	; 0x9780 <maze_getWall+0x22>
		dir -= WEST;
    977c:	64 50       	subi	r22, 0x04	; 4
    977e:	fc cf       	rjmp	.-8      	; 0x9778 <maze_getWall+0x1a>
	int8_t returnvar = MAZE_ERROR;
	COORD c = *_coord;
	
	dir = maze_alignDir(dir);

	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
    9780:	ce 01       	movw	r24, r28
    9782:	01 96       	adiw	r24, 0x01	; 1
    9784:	6c 83       	std	Y+4, r22	; 0x04
    9786:	9f dc       	rcall	.-1730   	; 0x90c6 <maze_adaptOffset>
    9788:	6c 81       	ldd	r22, Y+4	; 0x04
    978a:	88 23       	and	r24, r24
    978c:	09 f4       	brne	.+2      	; 0x9790 <maze_getWall+0x32>
    978e:	ac c0       	rjmp	.+344    	; 0x98e8 <maze_getWall+0x18a>
    9790:	62 30       	cpi	r22, 0x02	; 2
	{
		switch(dir)
    9792:	09 f4       	brne	.+2      	; 0x9796 <maze_getWall+0x38>
    9794:	4c c0       	rjmp	.+152    	; 0x982e <maze_getWall+0xd0>
    9796:	18 f4       	brcc	.+6      	; 0x979e <maze_getWall+0x40>
    9798:	61 30       	cpi	r22, 0x01	; 1
    979a:	e9 f0       	breq	.+58     	; 0x97d6 <maze_getWall+0x78>
    979c:	8a c0       	rjmp	.+276    	; 0x98b2 <maze_getWall+0x154>
    979e:	63 30       	cpi	r22, 0x03	; 3
    97a0:	09 f4       	brne	.+2      	; 0x97a4 <maze_getWall+0x46>
    97a2:	6d c0       	rjmp	.+218    	; 0x987e <maze_getWall+0x120>
    97a4:	64 30       	cpi	r22, 0x04	; 4
    97a6:	09 f0       	breq	.+2      	; 0x97aa <maze_getWall+0x4c>
    97a8:	84 c0       	rjmp	.+264    	; 0x98b2 <maze_getWall+0x154>
    97aa:	8b 81       	ldd	r24, Y+3	; 0x03
							break;
			case SOUTH:
								returnvar = maze[c.x][c.y][c.z].wall_s; //Aktuelle Platte Wand Sden = Aktuelle Platte Wand Sden
							break;
			case WEST:
								returnvar = maze[c.x][c.y][c.z].wall_w; //Aktuelle Platte Wand Westen = Aktuelle Platte Wand Westen
    97ac:	ea 81       	ldd	r30, Y+2	; 0x02
    97ae:	49 81       	ldd	r20, Y+1	; 0x01
    97b0:	35 e1       	ldi	r19, 0x15	; 21
    97b2:	e3 02       	muls	r30, r19
    97b4:	f0 01       	movw	r30, r0
    97b6:	11 24       	eor	r1, r1
    97b8:	97 e0       	ldi	r25, 0x07	; 7
    97ba:	89 02       	muls	r24, r25
    97bc:	e0 0d       	add	r30, r0
    97be:	f1 1d       	adc	r31, r1
    97c0:	11 24       	eor	r1, r1
    97c2:	21 e1       	ldi	r18, 0x11	; 17
    97c4:	31 e0       	ldi	r19, 0x01	; 1
    97c6:	42 03       	mulsu	r20, r18
    97c8:	c0 01       	movw	r24, r0
    97ca:	43 9f       	mul	r20, r19
    97cc:	90 0d       	add	r25, r0
    97ce:	11 24       	eor	r1, r1
    97d0:	e8 0f       	add	r30, r24
    97d2:	f9 1f       	adc	r31, r25
    97d4:	6a c0       	rjmp	.+212    	; 0x98aa <maze_getWall+0x14c>
    97d6:	8a 81       	ldd	r24, Y+2	; 0x02
	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
	{
		switch(dir)
		{
			case NORTH:
								if((c.y + 1) <= (MAZE_SIZE_Y-1))	returnvar = maze[c.x][c.y + 1][c.z].wall_s; //Aktuelle Platte Wand Norden = nchste Platte Norden Wand Sden
    97d8:	4b 81       	ldd	r20, Y+3	; 0x03
    97da:	59 81       	ldd	r21, Y+1	; 0x01
    97dc:	8c 30       	cpi	r24, 0x0C	; 12
    97de:	bc f4       	brge	.+46     	; 0x980e <maze_getWall+0xb0>
    97e0:	99 27       	eor	r25, r25
    97e2:	87 fd       	sbrc	r24, 7
    97e4:	90 95       	com	r25
    97e6:	01 96       	adiw	r24, 0x01	; 1
    97e8:	25 e1       	ldi	r18, 0x15	; 21
    97ea:	28 9f       	mul	r18, r24
    97ec:	f0 01       	movw	r30, r0
    97ee:	29 9f       	mul	r18, r25
    97f0:	f0 0d       	add	r31, r0
    97f2:	11 24       	eor	r1, r1
    97f4:	37 e0       	ldi	r19, 0x07	; 7
    97f6:	43 02       	muls	r20, r19
    97f8:	e0 0d       	add	r30, r0
    97fa:	f1 1d       	adc	r31, r1
    97fc:	11 24       	eor	r1, r1
    97fe:	21 e1       	ldi	r18, 0x11	; 17
    9800:	31 e0       	ldi	r19, 0x01	; 1
    9802:	52 03       	mulsu	r21, r18
    9804:	c0 01       	movw	r24, r0
    9806:	53 9f       	mul	r21, r19
    9808:	90 0d       	add	r25, r0
    980a:	11 24       	eor	r1, r1
    980c:	4b c0       	rjmp	.+150    	; 0x98a4 <maze_getWall+0x146>
    980e:	21 e1       	ldi	r18, 0x11	; 17
								else								returnvar = maze[c.x][0		 ][c.z].wall_s;
    9810:	31 e0       	ldi	r19, 0x01	; 1
    9812:	52 03       	mulsu	r21, r18
    9814:	f0 01       	movw	r30, r0
    9816:	53 9f       	mul	r21, r19
    9818:	f0 0d       	add	r31, r0
    981a:	11 24       	eor	r1, r1
    981c:	87 e0       	ldi	r24, 0x07	; 7
    981e:	48 02       	muls	r20, r24
    9820:	e0 0d       	add	r30, r0
    9822:	f1 1d       	adc	r31, r1
    9824:	11 24       	eor	r1, r1
    9826:	e5 5a       	subi	r30, 0xA5	; 165
    9828:	f7 4f       	sbci	r31, 0xF7	; 247
    982a:	81 81       	ldd	r24, Z+1	; 0x01
    982c:	5e c0       	rjmp	.+188    	; 0x98ea <maze_getWall+0x18c>
    982e:	89 81       	ldd	r24, Y+1	; 0x01
							break;
			case EAST:
								if((c.x + 1) <= (MAZE_SIZE_X-1))	returnvar = maze[c.x + 1][c.y][c.z].wall_w; //Aktuelle Platte Wand Osten = nchste Platte Wand Westen
    9830:	ea 81       	ldd	r30, Y+2	; 0x02
    9832:	2b 81       	ldd	r18, Y+3	; 0x03
    9834:	8c 30       	cpi	r24, 0x0C	; 12
    9836:	cc f4       	brge	.+50     	; 0x986a <maze_getWall+0x10c>
    9838:	99 27       	eor	r25, r25
    983a:	87 fd       	sbrc	r24, 7
    983c:	90 95       	com	r25
    983e:	01 96       	adiw	r24, 0x01	; 1
    9840:	35 e1       	ldi	r19, 0x15	; 21
    9842:	e3 02       	muls	r30, r19
    9844:	f0 01       	movw	r30, r0
    9846:	11 24       	eor	r1, r1
    9848:	37 e0       	ldi	r19, 0x07	; 7
    984a:	23 02       	muls	r18, r19
    984c:	e0 0d       	add	r30, r0
    984e:	f1 1d       	adc	r31, r1
    9850:	11 24       	eor	r1, r1
    9852:	41 e1       	ldi	r20, 0x11	; 17
    9854:	51 e0       	ldi	r21, 0x01	; 1
    9856:	84 9f       	mul	r24, r20
    9858:	90 01       	movw	r18, r0
    985a:	85 9f       	mul	r24, r21
    985c:	30 0d       	add	r19, r0
    985e:	94 9f       	mul	r25, r20
    9860:	30 0d       	add	r19, r0
    9862:	11 24       	eor	r1, r1
    9864:	e2 0f       	add	r30, r18
    9866:	f3 1f       	adc	r31, r19
    9868:	20 c0       	rjmp	.+64     	; 0x98aa <maze_getWall+0x14c>
    986a:	85 e1       	ldi	r24, 0x15	; 21
								else								returnvar = maze[0		][c.y][c.z].wall_w;
    986c:	e8 02       	muls	r30, r24
    986e:	f0 01       	movw	r30, r0
    9870:	11 24       	eor	r1, r1
    9872:	97 e0       	ldi	r25, 0x07	; 7
    9874:	29 02       	muls	r18, r25
    9876:	e0 0d       	add	r30, r0
    9878:	f1 1d       	adc	r31, r1
    987a:	11 24       	eor	r1, r1
    987c:	16 c0       	rjmp	.+44     	; 0x98aa <maze_getWall+0x14c>
    987e:	8b 81       	ldd	r24, Y+3	; 0x03
							break;
			case SOUTH:
								returnvar = maze[c.x][c.y][c.z].wall_s; //Aktuelle Platte Wand Sden = Aktuelle Platte Wand Sden
    9880:	ea 81       	ldd	r30, Y+2	; 0x02
    9882:	49 81       	ldd	r20, Y+1	; 0x01
    9884:	35 e1       	ldi	r19, 0x15	; 21
    9886:	e3 02       	muls	r30, r19
    9888:	f0 01       	movw	r30, r0
    988a:	11 24       	eor	r1, r1
    988c:	97 e0       	ldi	r25, 0x07	; 7
    988e:	89 02       	muls	r24, r25
    9890:	e0 0d       	add	r30, r0
    9892:	f1 1d       	adc	r31, r1
    9894:	11 24       	eor	r1, r1
    9896:	21 e1       	ldi	r18, 0x11	; 17
    9898:	31 e0       	ldi	r19, 0x01	; 1
    989a:	42 03       	mulsu	r20, r18
    989c:	c0 01       	movw	r24, r0
    989e:	43 9f       	mul	r20, r19
    98a0:	90 0d       	add	r25, r0
    98a2:	11 24       	eor	r1, r1
    98a4:	e8 0f       	add	r30, r24
    98a6:	f9 1f       	adc	r31, r25
    98a8:	be cf       	rjmp	.-132    	; 0x9826 <maze_getWall+0xc8>
    98aa:	e5 5a       	subi	r30, 0xA5	; 165
							break;
			case WEST:
								returnvar = maze[c.x][c.y][c.z].wall_w; //Aktuelle Platte Wand Westen = Aktuelle Platte Wand Westen
    98ac:	f7 4f       	sbci	r31, 0xF7	; 247
    98ae:	82 81       	ldd	r24, Z+2	; 0x02
    98b0:	1c c0       	rjmp	.+56     	; 0x98ea <maze_getWall+0x18c>
							break;
    98b2:	80 91 53 05 	lds	r24, 0x0553
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.09]:DEFAULT_CASE"));}
    98b6:	82 30       	cpi	r24, 0x02	; 2
    98b8:	90 f0       	brcs	.+36     	; 0x98de <maze_getWall+0x180>
    98ba:	87 ef       	ldi	r24, 0xF7	; 247
    98bc:	9b e2       	ldi	r25, 0x2B	; 43
    98be:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    98c2:	60 91 47 05 	lds	r22, 0x0547
    98c6:	70 91 48 05 	lds	r23, 0x0548
    98ca:	80 91 49 05 	lds	r24, 0x0549
    98ce:	90 91 4a 05 	lds	r25, 0x054A
    98d2:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    98d6:	81 ec       	ldi	r24, 0xC1	; 193
    98d8:	9b e2       	ldi	r25, 0x2B	; 43
    98da:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    98de:	81 e0       	ldi	r24, 0x01	; 1
								fatal_err = 1;
    98e0:	80 93 63 05 	sts	0x0563, r24
    98e4:	8f e7       	ldi	r24, 0x7F	; 127
// @return: value of the wall at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getWall(COORD *_coord, uint8_t dir)
{
	int8_t returnvar = MAZE_ERROR;
    98e6:	01 c0       	rjmp	.+2      	; 0x98ea <maze_getWall+0x18c>
    98e8:	8f ef       	ldi	r24, 0xFF	; 255
							break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.09]:DEFAULT_CASE"));}
								fatal_err = 1;
		}
	}
	else returnvar = -1;
    98ea:	24 96       	adiw	r28, 0x04	; 4
	
	return returnvar;
}
    98ec:	e2 e0       	ldi	r30, 0x02	; 2
    98ee:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

000098f2 <maze_corrWall>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_corrWall(COORD *_coord, int8_t dir, int8_t value)
{
    98f2:	ef 92       	push	r14
    98f4:	ff 92       	push	r15
    98f6:	1f 93       	push	r17
    98f8:	cf 93       	push	r28
    98fa:	df 93       	push	r29
    98fc:	1f 92       	push	r1
    98fe:	cd b7       	in	r28, 0x3d	; 61
    9900:	de b7       	in	r29, 0x3e	; 62
    9902:	7c 01       	movw	r14, r24
    9904:	16 2f       	mov	r17, r22
	int16_t wallVal = maze_getWall(_coord, dir) + value;
    9906:	49 83       	std	Y+1, r20	; 0x01
    9908:	2a df       	rcall	.-428    	; 0x975e <maze_getWall>
    990a:	49 81       	ldd	r20, Y+1	; 0x01
    990c:	55 27       	eor	r21, r21
    990e:	47 fd       	sbrc	r20, 7
    9910:	50 95       	com	r21
    9912:	48 0f       	add	r20, r24
    9914:	51 1d       	adc	r21, r1
    9916:	87 fd       	sbrc	r24, 7
    9918:	5a 95       	dec	r21
    991a:	41 38       	cpi	r20, 0x81	; 129
    991c:	8f ef       	ldi	r24, 0xFF	; 255
    991e:	58 07       	cpc	r21, r24
    9920:	14 f4       	brge	.+4      	; 0x9926 <maze_corrWall+0x34>
    9922:	41 e8       	ldi	r20, 0x81	; 129
    9924:	5f ef       	ldi	r21, 0xFF	; 255
    9926:	4f 37       	cpi	r20, 0x7F	; 127
    9928:	51 05       	cpc	r21, r1
    992a:	14 f0       	brlt	.+4      	; 0x9930 <maze_corrWall+0x3e>
    992c:	4e e7       	ldi	r20, 0x7E	; 126
    992e:	50 e0       	ldi	r21, 0x00	; 0
    9930:	61 2f       	mov	r22, r17
	if(wallVal > MAZE_WALLVALUE_MAX)
		wallVal = MAZE_WALLVALUE_MAX;
	else if(wallVal < MAZE_WALLVALUE_MIN)
		wallVal = MAZE_WALLVALUE_MIN;

	maze_setWall(_coord, dir, wallVal);
    9932:	c7 01       	movw	r24, r14
    9934:	4c de       	rcall	.-872    	; 0x95ce <maze_setWall>
    9936:	0f 90       	pop	r0
    9938:	df 91       	pop	r29
}
    993a:	cf 91       	pop	r28
    993c:	1f 91       	pop	r17
    993e:	ff 90       	pop	r15
    9940:	ef 90       	pop	r14
    9942:	08 95       	ret

00009944 <maze_corrTile>:
//
// @return: 	void
////////////////////////////////////////////////////////////////////////////////

void maze_corrTile(COORD *_coordA, COORD *_coordB)
{
    9944:	ff 92       	push	r15
    9946:	0f 93       	push	r16
    9948:	1f 93       	push	r17
    994a:	cf 93       	push	r28
    994c:	df 93       	push	r29
    994e:	8c 01       	movw	r16, r24
    9950:	eb 01       	movw	r28, r22
	for(uint8_t dir = NORTH; dir <= WEST; dir++)
    9952:	ff 24       	eor	r15, r15
    9954:	f3 94       	inc	r15
		maze_corrWall(_coordB, dir, maze_getWall(_coordA, dir));
    9956:	6f 2d       	mov	r22, r15
    9958:	c8 01       	movw	r24, r16
    995a:	01 df       	rcall	.-510    	; 0x975e <maze_getWall>
    995c:	48 2f       	mov	r20, r24
    995e:	6f 2d       	mov	r22, r15
    9960:	ce 01       	movw	r24, r28
    9962:	c7 df       	rcall	.-114    	; 0x98f2 <maze_corrWall>
    9964:	f3 94       	inc	r15
    9966:	85 e0       	ldi	r24, 0x05	; 5
// @return: 	void
////////////////////////////////////////////////////////////////////////////////

void maze_corrTile(COORD *_coordA, COORD *_coordB)
{
	for(uint8_t dir = NORTH; dir <= WEST; dir++)
    9968:	f8 12       	cpse	r15, r24
    996a:	f5 cf       	rjmp	.-22     	; 0x9956 <maze_corrTile+0x12>
    996c:	cd b7       	in	r28, 0x3d	; 61
    996e:	de b7       	in	r29, 0x3e	; 62
		maze_corrWall(_coordB, dir, maze_getWall(_coordA, dir));
}
    9970:	e5 e0       	ldi	r30, 0x05	; 5
    9972:	0c 94 c4 6b 	jmp	0xd788	; 0xd788 <__epilogue_restores__+0x1a>

00009976 <maze_setGround>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_setGround(COORD *_coord, int8_t dir, int8_t value)
{
    9976:	a5 e0       	ldi	r26, 0x05	; 5
    9978:	b0 e0       	ldi	r27, 0x00	; 0
    997a:	e1 ec       	ldi	r30, 0xC1	; 193
    997c:	fc e4       	ldi	r31, 0x4C	; 76
    997e:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
	COORD c = *_coord;
    9982:	fc 01       	movw	r30, r24
    9984:	80 81       	ld	r24, Z
    9986:	91 81       	ldd	r25, Z+1	; 0x01
    9988:	a2 81       	ldd	r26, Z+2	; 0x02
    998a:	89 83       	std	Y+1, r24	; 0x01
    998c:	9a 83       	std	Y+2, r25	; 0x02
    998e:	ab 83       	std	Y+3, r26	; 0x03

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)switch(dir)
    9990:	ce 01       	movw	r24, r28
    9992:	01 96       	adiw	r24, 0x01	; 1
    9994:	4d 83       	std	Y+5, r20	; 0x05
    9996:	6c 83       	std	Y+4, r22	; 0x04
    9998:	96 db       	rcall	.-2260   	; 0x90c6 <maze_adaptOffset>
    999a:	4d 81       	ldd	r20, Y+5	; 0x05
    999c:	6c 81       	ldd	r22, Y+4	; 0x04
    999e:	88 23       	and	r24, r24
    99a0:	09 f4       	brne	.+2      	; 0x99a4 <maze_setGround+0x2e>
    99a2:	ac c0       	rjmp	.+344    	; 0x9afc <maze_setGround+0x186>
    99a4:	65 30       	cpi	r22, 0x05	; 5
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    99a6:	10 f0       	brcs	.+4      	; 0x99ac <maze_setGround+0x36>
    99a8:	64 50       	subi	r22, 0x04	; 4
		dir -= WEST;
    99aa:	fc cf       	rjmp	.-8      	; 0x99a4 <maze_setGround+0x2e>
    99ac:	19 81       	ldd	r17, Y+1	; 0x01
    99ae:	2a 81       	ldd	r18, Y+2	; 0x02
    99b0:	5b 81       	ldd	r21, Y+3	; 0x03
    99b2:	62 30       	cpi	r22, 0x02	; 2

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)switch(dir)
	{
		dir = maze_alignDir(dir); //NOW align the direction

		switch(dir)
    99b4:	b9 f1       	breq	.+110    	; 0x9a24 <maze_setGround+0xae>
    99b6:	1c f4       	brge	.+6      	; 0x99be <maze_setGround+0x48>
    99b8:	61 30       	cpi	r22, 0x01	; 1
    99ba:	19 f1       	breq	.+70     	; 0x9a02 <maze_setGround+0x8c>
    99bc:	06 c0       	rjmp	.+12     	; 0x99ca <maze_setGround+0x54>
    99be:	63 30       	cpi	r22, 0x03	; 3
    99c0:	09 f4       	brne	.+2      	; 0x99c4 <maze_setGround+0x4e>
    99c2:	43 c0       	rjmp	.+134    	; 0x9a4a <maze_setGround+0xd4>
    99c4:	64 30       	cpi	r22, 0x04	; 4
    99c6:	09 f4       	brne	.+2      	; 0x99ca <maze_setGround+0x54>
    99c8:	6c c0       	rjmp	.+216    	; 0x9aa2 <maze_setGround+0x12c>
    99ca:	61 e1       	ldi	r22, 0x11	; 17
		{
			case NONE:
							maze[c.x][c.y][c.z].ground += value;
    99cc:	71 e0       	ldi	r23, 0x01	; 1
    99ce:	16 03       	mulsu	r17, r22
    99d0:	f0 01       	movw	r30, r0
    99d2:	17 9f       	mul	r17, r23
    99d4:	f0 0d       	add	r31, r0
    99d6:	11 24       	eor	r1, r1
    99d8:	87 e0       	ldi	r24, 0x07	; 7
    99da:	58 02       	muls	r21, r24
    99dc:	e0 0d       	add	r30, r0
    99de:	f1 1d       	adc	r31, r1
    99e0:	11 24       	eor	r1, r1
    99e2:	85 e1       	ldi	r24, 0x15	; 21
    99e4:	28 02       	muls	r18, r24
    99e6:	e0 0d       	add	r30, r0
    99e8:	f1 1d       	adc	r31, r1
    99ea:	11 24       	eor	r1, r1
    99ec:	e5 5a       	subi	r30, 0xA5	; 165
    99ee:	f7 4f       	sbci	r31, 0xF7	; 247
    99f0:	90 81       	ld	r25, Z
    99f2:	89 2f       	mov	r24, r25
    99f4:	85 95       	asr	r24
    99f6:	84 0f       	add	r24, r20
    99f8:	88 0f       	add	r24, r24
    99fa:	91 70       	andi	r25, 0x01	; 1
    99fc:	98 2b       	or	r25, r24
    99fe:	90 83       	st	Z, r25
    9a00:	7d c0       	rjmp	.+250    	; 0x9afc <maze_setGround+0x186>
						break;
    9a02:	44 0f       	add	r20, r20
    9a04:	2c 30       	cpi	r18, 0x0C	; 12
			case NORTH:
							if((c.y + 1) <= (MAZE_SIZE_Y-1))	maze[c.x][c.y + 1][c.z].ground = value;
    9a06:	34 f4       	brge	.+12     	; 0x9a14 <maze_setGround+0x9e>
    9a08:	33 27       	eor	r19, r19
    9a0a:	27 fd       	sbrc	r18, 7
    9a0c:	30 95       	com	r19
    9a0e:	2f 5f       	subi	r18, 0xFF	; 255
    9a10:	3f 4f       	sbci	r19, 0xFF	; 255
    9a12:	23 c0       	rjmp	.+70     	; 0x9a5a <maze_setGround+0xe4>
    9a14:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][0		 ][c.z].ground = value;
    9a16:	31 e0       	ldi	r19, 0x01	; 1
    9a18:	12 03       	mulsu	r17, r18
    9a1a:	f0 01       	movw	r30, r0
    9a1c:	13 9f       	mul	r17, r19
    9a1e:	f0 0d       	add	r31, r0
    9a20:	11 24       	eor	r1, r1
    9a22:	0d c0       	rjmp	.+26     	; 0x9a3e <maze_setGround+0xc8>
    9a24:	44 0f       	add	r20, r20
    9a26:	1c 30       	cpi	r17, 0x0C	; 12
						break;
			case EAST:
							if((c.x + 1) <= (MAZE_SIZE_X-1))	maze[c.x + 1][c.y][c.z].ground = value;
    9a28:	34 f4       	brge	.+12     	; 0x9a36 <maze_setGround+0xc0>
    9a2a:	81 2f       	mov	r24, r17
    9a2c:	99 27       	eor	r25, r25
    9a2e:	87 fd       	sbrc	r24, 7
    9a30:	90 95       	com	r25
    9a32:	01 96       	adiw	r24, 0x01	; 1
    9a34:	3e c0       	rjmp	.+124    	; 0x9ab2 <maze_setGround+0x13c>
    9a36:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[0		][c.y][c.z].ground = value;
    9a38:	28 02       	muls	r18, r24
    9a3a:	f0 01       	movw	r30, r0
    9a3c:	11 24       	eor	r1, r1
    9a3e:	87 e0       	ldi	r24, 0x07	; 7
    9a40:	58 02       	muls	r21, r24
    9a42:	e0 0d       	add	r30, r0
    9a44:	f1 1d       	adc	r31, r1
    9a46:	11 24       	eor	r1, r1
    9a48:	47 c0       	rjmp	.+142    	; 0x9ad8 <maze_setGround+0x162>
    9a4a:	44 0f       	add	r20, r20
    9a4c:	12 16       	cp	r1, r18
						break;
			case SOUTH:
							if((c.y - 1) >= 0)					maze[c.x][c.y - 1	   ][c.z].ground = value;
    9a4e:	d4 f4       	brge	.+52     	; 0x9a84 <maze_setGround+0x10e>
    9a50:	33 27       	eor	r19, r19
    9a52:	27 fd       	sbrc	r18, 7
    9a54:	30 95       	com	r19
    9a56:	21 50       	subi	r18, 0x01	; 1
    9a58:	31 09       	sbc	r19, r1
    9a5a:	61 e1       	ldi	r22, 0x11	; 17
    9a5c:	71 e0       	ldi	r23, 0x01	; 1
    9a5e:	16 03       	mulsu	r17, r22
    9a60:	f0 01       	movw	r30, r0
    9a62:	17 9f       	mul	r17, r23
    9a64:	f0 0d       	add	r31, r0
    9a66:	11 24       	eor	r1, r1
    9a68:	87 e0       	ldi	r24, 0x07	; 7
    9a6a:	58 02       	muls	r21, r24
    9a6c:	e0 0d       	add	r30, r0
    9a6e:	f1 1d       	adc	r31, r1
    9a70:	11 24       	eor	r1, r1
    9a72:	55 e1       	ldi	r21, 0x15	; 21
    9a74:	52 9f       	mul	r21, r18
    9a76:	c0 01       	movw	r24, r0
    9a78:	53 9f       	mul	r21, r19
    9a7a:	90 0d       	add	r25, r0
    9a7c:	11 24       	eor	r1, r1
    9a7e:	e8 0f       	add	r30, r24
    9a80:	f9 1f       	adc	r31, r25
    9a82:	2a c0       	rjmp	.+84     	; 0x9ad8 <maze_setGround+0x162>
    9a84:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][MAZE_SIZE_Y-1][c.z].ground = value;
    9a86:	31 e0       	ldi	r19, 0x01	; 1
    9a88:	12 03       	mulsu	r17, r18
    9a8a:	f0 01       	movw	r30, r0
    9a8c:	13 9f       	mul	r17, r19
    9a8e:	f0 0d       	add	r31, r0
    9a90:	11 24       	eor	r1, r1
    9a92:	87 e0       	ldi	r24, 0x07	; 7
    9a94:	58 02       	muls	r21, r24
    9a96:	e0 0d       	add	r30, r0
    9a98:	f1 1d       	adc	r31, r1
    9a9a:	11 24       	eor	r1, r1
    9a9c:	e9 5a       	subi	r30, 0xA9	; 169
    9a9e:	f6 4f       	sbci	r31, 0xF6	; 246
    9aa0:	29 c0       	rjmp	.+82     	; 0x9af4 <maze_setGround+0x17e>
    9aa2:	44 0f       	add	r20, r20
    9aa4:	11 16       	cp	r1, r17
						break;
			case WEST:
							if((c.x - 1) >= 0)					maze[c.x - 1	  ][c.y][c.z].ground = value;
    9aa6:	dc f4       	brge	.+54     	; 0x9ade <maze_setGround+0x168>
    9aa8:	81 2f       	mov	r24, r17
    9aaa:	99 27       	eor	r25, r25
    9aac:	87 fd       	sbrc	r24, 7
    9aae:	90 95       	com	r25
    9ab0:	01 97       	sbiw	r24, 0x01	; 1
    9ab2:	61 e1       	ldi	r22, 0x11	; 17
    9ab4:	71 e0       	ldi	r23, 0x01	; 1
    9ab6:	86 9f       	mul	r24, r22
    9ab8:	f0 01       	movw	r30, r0
    9aba:	87 9f       	mul	r24, r23
    9abc:	f0 0d       	add	r31, r0
    9abe:	96 9f       	mul	r25, r22
    9ac0:	f0 0d       	add	r31, r0
    9ac2:	11 24       	eor	r1, r1
    9ac4:	87 e0       	ldi	r24, 0x07	; 7
    9ac6:	58 02       	muls	r21, r24
    9ac8:	e0 0d       	add	r30, r0
    9aca:	f1 1d       	adc	r31, r1
    9acc:	11 24       	eor	r1, r1
    9ace:	85 e1       	ldi	r24, 0x15	; 21
    9ad0:	28 02       	muls	r18, r24
    9ad2:	e0 0d       	add	r30, r0
    9ad4:	f1 1d       	adc	r31, r1
    9ad6:	11 24       	eor	r1, r1
    9ad8:	e5 5a       	subi	r30, 0xA5	; 165
    9ada:	f7 4f       	sbci	r31, 0xF7	; 247
    9adc:	0b c0       	rjmp	.+22     	; 0x9af4 <maze_setGround+0x17e>
    9ade:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[MAZE_SIZE_X-1][c.y][c.z].ground = value;
    9ae0:	28 02       	muls	r18, r24
    9ae2:	f0 01       	movw	r30, r0
    9ae4:	11 24       	eor	r1, r1
    9ae6:	87 e0       	ldi	r24, 0x07	; 7
    9ae8:	58 02       	muls	r21, r24
    9aea:	e0 0d       	add	r30, r0
    9aec:	f1 1d       	adc	r31, r1
    9aee:	11 24       	eor	r1, r1
    9af0:	e9 5d       	subi	r30, 0xD9	; 217
    9af2:	fa 4e       	sbci	r31, 0xEA	; 234
    9af4:	80 81       	ld	r24, Z
    9af6:	81 70       	andi	r24, 0x01	; 1
    9af8:	84 2b       	or	r24, r20
    9afa:	80 83       	st	Z, r24
    9afc:	25 96       	adiw	r28, 0x05	; 5
						break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
								fatal_err = 1;
		}
	}
}
    9afe:	e3 e0       	ldi	r30, 0x03	; 3
    9b00:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

00009b04 <maze_getGround>:
//
// @return: value of the ground at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getGround(COORD *_coord, int8_t dir)
{
    9b04:	a4 e0       	ldi	r26, 0x04	; 4
    9b06:	b0 e0       	ldi	r27, 0x00	; 0
    9b08:	e8 e8       	ldi	r30, 0x88	; 136
    9b0a:	fd e4       	ldi	r31, 0x4D	; 77
    9b0c:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	int8_t returnvar = -1;	
	COORD c = *_coord;
    9b10:	fc 01       	movw	r30, r24
    9b12:	80 81       	ld	r24, Z
    9b14:	91 81       	ldd	r25, Z+1	; 0x01
    9b16:	a2 81       	ldd	r26, Z+2	; 0x02
    9b18:	89 83       	std	Y+1, r24	; 0x01
    9b1a:	9a 83       	std	Y+2, r25	; 0x02
    9b1c:	ab 83       	std	Y+3, r26	; 0x03

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    9b1e:	ce 01       	movw	r24, r28
    9b20:	01 96       	adiw	r24, 0x01	; 1
    9b22:	6c 83       	std	Y+4, r22	; 0x04
    9b24:	d0 da       	rcall	.-2656   	; 0x90c6 <maze_adaptOffset>
    9b26:	6c 81       	ldd	r22, Y+4	; 0x04
    9b28:	88 23       	and	r24, r24
    9b2a:	09 f4       	brne	.+2      	; 0x9b2e <maze_getGround+0x2a>
    9b2c:	92 c0       	rjmp	.+292    	; 0x9c52 <maze_getGround+0x14e>
    9b2e:	65 30       	cpi	r22, 0x05	; 5
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    9b30:	10 f0       	brcs	.+4      	; 0x9b36 <maze_getGround+0x32>
    9b32:	64 50       	subi	r22, 0x04	; 4
		dir -= WEST;
    9b34:	fc cf       	rjmp	.-8      	; 0x9b2e <maze_getGround+0x2a>
    9b36:	4b 81       	ldd	r20, Y+3	; 0x03
    9b38:	2a 81       	ldd	r18, Y+2	; 0x02
    9b3a:	59 81       	ldd	r21, Y+1	; 0x01
    9b3c:	62 30       	cpi	r22, 0x02	; 2
	COORD c = *_coord;

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
	{
		dir = maze_alignDir(dir);
		switch(dir)
    9b3e:	09 f1       	breq	.+66     	; 0x9b82 <maze_getGround+0x7e>
    9b40:	1c f4       	brge	.+6      	; 0x9b48 <maze_getGround+0x44>
    9b42:	61 30       	cpi	r22, 0x01	; 1
    9b44:	71 f0       	breq	.+28     	; 0x9b62 <maze_getGround+0x5e>
    9b46:	05 c0       	rjmp	.+10     	; 0x9b52 <maze_getGround+0x4e>
    9b48:	63 30       	cpi	r22, 0x03	; 3
    9b4a:	69 f1       	breq	.+90     	; 0x9ba6 <maze_getGround+0xa2>
    9b4c:	64 30       	cpi	r22, 0x04	; 4
    9b4e:	09 f4       	brne	.+2      	; 0x9b52 <maze_getGround+0x4e>
    9b50:	55 c0       	rjmp	.+170    	; 0x9bfc <maze_getGround+0xf8>
    9b52:	61 e1       	ldi	r22, 0x11	; 17
		{
			case NONE:
							returnvar = maze[c.x][c.y][c.z].ground;
    9b54:	71 e0       	ldi	r23, 0x01	; 1
    9b56:	56 03       	mulsu	r21, r22
    9b58:	f0 01       	movw	r30, r0
    9b5a:	57 9f       	mul	r21, r23
    9b5c:	f0 0d       	add	r31, r0
    9b5e:	11 24       	eor	r1, r1
    9b60:	5d c0       	rjmp	.+186    	; 0x9c1c <maze_getGround+0x118>
    9b62:	2c 30       	cpi	r18, 0x0C	; 12
						break;
			case NORTH:
							if((c.y + 1) <= (MAZE_SIZE_Y-1))	returnvar = maze[c.x][c.y + 1][c.z].ground;
    9b64:	34 f4       	brge	.+12     	; 0x9b72 <maze_getGround+0x6e>
    9b66:	33 27       	eor	r19, r19
    9b68:	27 fd       	sbrc	r18, 7
    9b6a:	30 95       	com	r19
    9b6c:	2f 5f       	subi	r18, 0xFF	; 255
    9b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    9b70:	21 c0       	rjmp	.+66     	; 0x9bb4 <maze_getGround+0xb0>
    9b72:	21 e1       	ldi	r18, 0x11	; 17
							else								returnvar = maze[c.x][0		 ][c.z].ground;
    9b74:	31 e0       	ldi	r19, 0x01	; 1
    9b76:	52 03       	mulsu	r21, r18
    9b78:	f0 01       	movw	r30, r0
    9b7a:	53 9f       	mul	r21, r19
    9b7c:	f0 0d       	add	r31, r0
    9b7e:	11 24       	eor	r1, r1
    9b80:	0c c0       	rjmp	.+24     	; 0x9b9a <maze_getGround+0x96>
    9b82:	5c 30       	cpi	r21, 0x0C	; 12
						break;
			case EAST:
							if((c.x + 1) <= (MAZE_SIZE_X-1))	returnvar = maze[c.x + 1][c.y][c.z].ground;
    9b84:	34 f4       	brge	.+12     	; 0x9b92 <maze_getGround+0x8e>
    9b86:	85 2f       	mov	r24, r21
    9b88:	99 27       	eor	r25, r25
    9b8a:	87 fd       	sbrc	r24, 7
    9b8c:	90 95       	com	r25
    9b8e:	01 96       	adiw	r24, 0x01	; 1
    9b90:	3c c0       	rjmp	.+120    	; 0x9c0a <maze_getGround+0x106>
    9b92:	85 e1       	ldi	r24, 0x15	; 21
							else								returnvar = maze[0		][c.y][c.z].ground;
    9b94:	28 02       	muls	r18, r24
    9b96:	f0 01       	movw	r30, r0
    9b98:	11 24       	eor	r1, r1
    9b9a:	87 e0       	ldi	r24, 0x07	; 7
    9b9c:	48 02       	muls	r20, r24
    9b9e:	e0 0d       	add	r30, r0
    9ba0:	f1 1d       	adc	r31, r1
    9ba2:	11 24       	eor	r1, r1
    9ba4:	45 c0       	rjmp	.+138    	; 0x9c30 <maze_getGround+0x12c>
    9ba6:	12 16       	cp	r1, r18
						break;
			case SOUTH:
							if((c.y - 1) >= 0)					returnvar = maze[c.x][c.y - 1	   ][c.z].ground;
    9ba8:	d4 f4       	brge	.+52     	; 0x9bde <maze_getGround+0xda>
    9baa:	33 27       	eor	r19, r19
    9bac:	27 fd       	sbrc	r18, 7
    9bae:	30 95       	com	r19
    9bb0:	21 50       	subi	r18, 0x01	; 1
    9bb2:	31 09       	sbc	r19, r1
    9bb4:	61 e1       	ldi	r22, 0x11	; 17
    9bb6:	71 e0       	ldi	r23, 0x01	; 1
    9bb8:	56 03       	mulsu	r21, r22
    9bba:	f0 01       	movw	r30, r0
    9bbc:	57 9f       	mul	r21, r23
    9bbe:	f0 0d       	add	r31, r0
    9bc0:	11 24       	eor	r1, r1
    9bc2:	87 e0       	ldi	r24, 0x07	; 7
    9bc4:	48 02       	muls	r20, r24
    9bc6:	e0 0d       	add	r30, r0
    9bc8:	f1 1d       	adc	r31, r1
    9bca:	11 24       	eor	r1, r1
    9bcc:	45 e1       	ldi	r20, 0x15	; 21
    9bce:	42 9f       	mul	r20, r18
    9bd0:	c0 01       	movw	r24, r0
    9bd2:	43 9f       	mul	r20, r19
    9bd4:	90 0d       	add	r25, r0
    9bd6:	11 24       	eor	r1, r1
    9bd8:	e8 0f       	add	r30, r24
    9bda:	f9 1f       	adc	r31, r25
    9bdc:	29 c0       	rjmp	.+82     	; 0x9c30 <maze_getGround+0x12c>
    9bde:	21 e1       	ldi	r18, 0x11	; 17
							else								returnvar = maze[c.x][MAZE_SIZE_Y-1][c.z].ground;
    9be0:	31 e0       	ldi	r19, 0x01	; 1
    9be2:	52 03       	mulsu	r21, r18
    9be4:	f0 01       	movw	r30, r0
    9be6:	53 9f       	mul	r21, r19
    9be8:	f0 0d       	add	r31, r0
    9bea:	11 24       	eor	r1, r1
    9bec:	87 e0       	ldi	r24, 0x07	; 7
    9bee:	48 02       	muls	r20, r24
    9bf0:	e0 0d       	add	r30, r0
    9bf2:	f1 1d       	adc	r31, r1
    9bf4:	11 24       	eor	r1, r1
    9bf6:	e9 5a       	subi	r30, 0xA9	; 169
    9bf8:	f6 4f       	sbci	r31, 0xF6	; 246
    9bfa:	28 c0       	rjmp	.+80     	; 0x9c4c <maze_getGround+0x148>
    9bfc:	15 16       	cp	r1, r21
						break;
			case WEST:
							if((c.x - 1) >= 0)					returnvar = maze[c.x - 1	  ][c.y][c.z].ground;
    9bfe:	dc f4       	brge	.+54     	; 0x9c36 <maze_getGround+0x132>
    9c00:	85 2f       	mov	r24, r21
    9c02:	99 27       	eor	r25, r25
    9c04:	87 fd       	sbrc	r24, 7
    9c06:	90 95       	com	r25
    9c08:	01 97       	sbiw	r24, 0x01	; 1
    9c0a:	61 e1       	ldi	r22, 0x11	; 17
    9c0c:	71 e0       	ldi	r23, 0x01	; 1
    9c0e:	86 9f       	mul	r24, r22
    9c10:	f0 01       	movw	r30, r0
    9c12:	87 9f       	mul	r24, r23
    9c14:	f0 0d       	add	r31, r0
    9c16:	96 9f       	mul	r25, r22
    9c18:	f0 0d       	add	r31, r0
    9c1a:	11 24       	eor	r1, r1
    9c1c:	87 e0       	ldi	r24, 0x07	; 7
    9c1e:	48 02       	muls	r20, r24
    9c20:	e0 0d       	add	r30, r0
    9c22:	f1 1d       	adc	r31, r1
    9c24:	11 24       	eor	r1, r1
    9c26:	85 e1       	ldi	r24, 0x15	; 21
    9c28:	28 02       	muls	r18, r24
    9c2a:	e0 0d       	add	r30, r0
    9c2c:	f1 1d       	adc	r31, r1
    9c2e:	11 24       	eor	r1, r1
    9c30:	e5 5a       	subi	r30, 0xA5	; 165
    9c32:	f7 4f       	sbci	r31, 0xF7	; 247
    9c34:	0b c0       	rjmp	.+22     	; 0x9c4c <maze_getGround+0x148>
    9c36:	85 e1       	ldi	r24, 0x15	; 21
							else								returnvar = maze[MAZE_SIZE_X-1][c.y][c.z].ground;
    9c38:	28 02       	muls	r18, r24
    9c3a:	f0 01       	movw	r30, r0
    9c3c:	11 24       	eor	r1, r1
    9c3e:	87 e0       	ldi	r24, 0x07	; 7
    9c40:	48 02       	muls	r20, r24
    9c42:	e0 0d       	add	r30, r0
    9c44:	f1 1d       	adc	r31, r1
    9c46:	11 24       	eor	r1, r1
    9c48:	e9 5d       	subi	r30, 0xD9	; 217
    9c4a:	fa 4e       	sbci	r31, 0xEA	; 234
    9c4c:	80 81       	ld	r24, Z
    9c4e:	85 95       	asr	r24
    9c50:	01 c0       	rjmp	.+2      	; 0x9c54 <maze_getGround+0x150>
    9c52:	8f ef       	ldi	r24, 0xFF	; 255
// @return: value of the ground at the given coordinate and direction
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getGround(COORD *_coord, int8_t dir)
{
	int8_t returnvar = -1;	
    9c54:	24 96       	adiw	r28, 0x04	; 4
								fatal_err = 1;
		}
	}
	
	return returnvar;
}
    9c56:	e2 e0       	ldi	r30, 0x02	; 2
    9c58:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00009c5c <maze_corrGround>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_corrGround(COORD *_coord, int8_t dir, int8_t value)
{
    9c5c:	ef 92       	push	r14
    9c5e:	ff 92       	push	r15
    9c60:	1f 93       	push	r17
    9c62:	cf 93       	push	r28
    9c64:	df 93       	push	r29
    9c66:	1f 92       	push	r1
    9c68:	cd b7       	in	r28, 0x3d	; 61
    9c6a:	de b7       	in	r29, 0x3e	; 62
    9c6c:	7c 01       	movw	r14, r24
    9c6e:	16 2f       	mov	r17, r22
	int16_t groundVal = maze_getGround(_coord, dir) + value;
    9c70:	49 83       	std	Y+1, r20	; 0x01
    9c72:	48 df       	rcall	.-368    	; 0x9b04 <maze_getGround>
    9c74:	49 81       	ldd	r20, Y+1	; 0x01
    9c76:	55 27       	eor	r21, r21
    9c78:	47 fd       	sbrc	r20, 7
    9c7a:	50 95       	com	r21
    9c7c:	48 0f       	add	r20, r24
    9c7e:	51 1d       	adc	r21, r1
    9c80:	87 fd       	sbrc	r24, 7
    9c82:	5a 95       	dec	r21
    9c84:	41 3c       	cpi	r20, 0xC1	; 193
    9c86:	8f ef       	ldi	r24, 0xFF	; 255
    9c88:	58 07       	cpc	r21, r24
    9c8a:	14 f4       	brge	.+4      	; 0x9c90 <maze_corrGround+0x34>
    9c8c:	41 ec       	ldi	r20, 0xC1	; 193
    9c8e:	5f ef       	ldi	r21, 0xFF	; 255
    9c90:	40 34       	cpi	r20, 0x40	; 64
    9c92:	51 05       	cpc	r21, r1
    9c94:	14 f0       	brlt	.+4      	; 0x9c9a <maze_corrGround+0x3e>
    9c96:	4f e3       	ldi	r20, 0x3F	; 63
    9c98:	50 e0       	ldi	r21, 0x00	; 0
    9c9a:	61 2f       	mov	r22, r17
	if(groundVal > MAZE_GROUNDVALUE_MAX)
		groundVal = MAZE_GROUNDVALUE_MAX;
	else if(groundVal < MAZE_GROUNDVALUE_MIN)
		groundVal = MAZE_GROUNDVALUE_MIN;

	maze_setGround(_coord, dir, groundVal);
    9c9c:	c7 01       	movw	r24, r14
    9c9e:	6b de       	rcall	.-810    	; 0x9976 <maze_setGround>
    9ca0:	0f 90       	pop	r0
    9ca2:	df 91       	pop	r29
}
    9ca4:	cf 91       	pop	r28
    9ca6:	1f 91       	pop	r17
    9ca8:	ff 90       	pop	r15
    9caa:	ef 90       	pop	r14
    9cac:	08 95       	ret

00009cae <maze_tileIsVisitable>:
//
// @return: 	TRUE when visitable, otherwise FALSE.
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_tileIsVisitable(COORD *_coord, int8_t dir)
{
    9cae:	1f 93       	push	r17
    9cb0:	cf 93       	push	r28
    9cb2:	df 93       	push	r29
    9cb4:	ec 01       	movw	r28, r24
    9cb6:	16 2f       	mov	r17, r22
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    9cb8:	15 30       	cpi	r17, 0x05	; 5
    9cba:	10 f0       	brcs	.+4      	; 0x9cc0 <maze_tileIsVisitable+0x12>
		dir -= WEST;
    9cbc:	14 50       	subi	r17, 0x04	; 4
    9cbe:	fc cf       	rjmp	.-8      	; 0x9cb8 <maze_tileIsVisitable+0xa>
uint8_t maze_tileIsVisitable(COORD *_coord, int8_t dir)
{
	uint8_t returnvar = 0;
	dir = maze_alignDir(dir);
	
	if((maze_getGround(_coord, dir) < MAZE_ISBLTILE) &&
    9cc0:	61 2f       	mov	r22, r17
    9cc2:	ce 01       	movw	r24, r28
    9cc4:	1f df       	rcall	.-450    	; 0x9b04 <maze_getGround>
    9cc6:	18 16       	cp	r1, r24
    9cc8:	34 f0       	brlt	.+12     	; 0x9cd6 <maze_tileIsVisitable+0x28>
    9cca:	61 2f       	mov	r22, r17
		 (maze_getWall(_coord, dir) < MAZE_ISWALL))
    9ccc:	ce 01       	movw	r24, r28
    9cce:	47 dd       	rcall	.-1394   	; 0x975e <maze_getWall>
    9cd0:	91 e0       	ldi	r25, 0x01	; 1
    9cd2:	84 30       	cpi	r24, 0x04	; 4
uint8_t maze_tileIsVisitable(COORD *_coord, int8_t dir)
{
	uint8_t returnvar = 0;
	dir = maze_alignDir(dir);
	
	if((maze_getGround(_coord, dir) < MAZE_ISBLTILE) &&
    9cd4:	0c f0       	brlt	.+2      	; 0x9cd8 <maze_tileIsVisitable+0x2a>
    9cd6:	90 e0       	ldi	r25, 0x00	; 0
    9cd8:	89 2f       	mov	r24, r25
// @return: 	TRUE when visitable, otherwise FALSE.
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_tileIsVisitable(COORD *_coord, int8_t dir)
{
	uint8_t returnvar = 0;
    9cda:	df 91       	pop	r29
	{
		returnvar = 1;
	}
	
	return returnvar;
}
    9cdc:	cf 91       	pop	r28
    9cde:	1f 91       	pop	r17
    9ce0:	08 95       	ret

00009ce2 <maze_setBeenthere>:
//
// @return: void
////////////////////////////////////////////////////////////////////////////////

void maze_setBeenthere(COORD *_coord, int8_t dir, uint8_t value)
{
    9ce2:	a5 e0       	ldi	r26, 0x05	; 5
    9ce4:	b0 e0       	ldi	r27, 0x00	; 0
    9ce6:	e7 e7       	ldi	r30, 0x77	; 119
    9ce8:	fe e4       	ldi	r31, 0x4E	; 78
    9cea:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
	COORD c = *_coord;
    9cee:	fc 01       	movw	r30, r24
    9cf0:	80 81       	ld	r24, Z
    9cf2:	91 81       	ldd	r25, Z+1	; 0x01
    9cf4:	a2 81       	ldd	r26, Z+2	; 0x02
    9cf6:	89 83       	std	Y+1, r24	; 0x01
    9cf8:	9a 83       	std	Y+2, r25	; 0x02
    9cfa:	ab 83       	std	Y+3, r26	; 0x03
	
	if(maze_adaptOffset(&c))
    9cfc:	ce 01       	movw	r24, r28
    9cfe:	01 96       	adiw	r24, 0x01	; 1
    9d00:	4d 83       	std	Y+5, r20	; 0x05
    9d02:	6c 83       	std	Y+4, r22	; 0x04
    9d04:	e0 d9       	rcall	.-3136   	; 0x90c6 <maze_adaptOffset>
    9d06:	4d 81       	ldd	r20, Y+5	; 0x05
    9d08:	6c 81       	ldd	r22, Y+4	; 0x04
    9d0a:	88 23       	and	r24, r24
    9d0c:	09 f4       	brne	.+2      	; 0x9d10 <maze_setBeenthere+0x2e>
    9d0e:	93 c0       	rjmp	.+294    	; 0x9e36 <maze_setBeenthere+0x154>
    9d10:	65 30       	cpi	r22, 0x05	; 5
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    9d12:	10 f0       	brcs	.+4      	; 0x9d18 <maze_setBeenthere+0x36>
    9d14:	64 50       	subi	r22, 0x04	; 4
		dir -= WEST;
    9d16:	fc cf       	rjmp	.-8      	; 0x9d10 <maze_setBeenthere+0x2e>
    9d18:	5b 81       	ldd	r21, Y+3	; 0x03
    9d1a:	2a 81       	ldd	r18, Y+2	; 0x02
    9d1c:	19 81       	ldd	r17, Y+1	; 0x01
    9d1e:	62 30       	cpi	r22, 0x02	; 2
	
	if(maze_adaptOffset(&c))
	{
		dir = maze_alignDir(dir);
		
		switch(dir)
    9d20:	09 f1       	breq	.+66     	; 0x9d64 <maze_setBeenthere+0x82>
    9d22:	1c f4       	brge	.+6      	; 0x9d2a <maze_setBeenthere+0x48>
    9d24:	61 30       	cpi	r22, 0x01	; 1
    9d26:	71 f0       	breq	.+28     	; 0x9d44 <maze_setBeenthere+0x62>
    9d28:	05 c0       	rjmp	.+10     	; 0x9d34 <maze_setBeenthere+0x52>
    9d2a:	63 30       	cpi	r22, 0x03	; 3
    9d2c:	69 f1       	breq	.+90     	; 0x9d88 <maze_setBeenthere+0xa6>
    9d2e:	64 30       	cpi	r22, 0x04	; 4
    9d30:	09 f4       	brne	.+2      	; 0x9d34 <maze_setBeenthere+0x52>
    9d32:	55 c0       	rjmp	.+170    	; 0x9dde <maze_setBeenthere+0xfc>
    9d34:	61 e1       	ldi	r22, 0x11	; 17
		{
			case NONE:
							maze[c.x][c.y][c.z].beenthere = value;
    9d36:	71 e0       	ldi	r23, 0x01	; 1
    9d38:	16 03       	mulsu	r17, r22
    9d3a:	f0 01       	movw	r30, r0
    9d3c:	17 9f       	mul	r17, r23
    9d3e:	f0 0d       	add	r31, r0
    9d40:	11 24       	eor	r1, r1
    9d42:	5d c0       	rjmp	.+186    	; 0x9dfe <maze_setBeenthere+0x11c>
    9d44:	2c 30       	cpi	r18, 0x0C	; 12
						break;
			case NORTH:
							if((c.y + 1) <= (MAZE_SIZE_Y-1))	maze[c.x][c.y + 1][c.z].beenthere = value;
    9d46:	34 f4       	brge	.+12     	; 0x9d54 <maze_setBeenthere+0x72>
    9d48:	33 27       	eor	r19, r19
    9d4a:	27 fd       	sbrc	r18, 7
    9d4c:	30 95       	com	r19
    9d4e:	2f 5f       	subi	r18, 0xFF	; 255
    9d50:	3f 4f       	sbci	r19, 0xFF	; 255
    9d52:	21 c0       	rjmp	.+66     	; 0x9d96 <maze_setBeenthere+0xb4>
    9d54:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][0		 ][c.z].beenthere = value;
    9d56:	31 e0       	ldi	r19, 0x01	; 1
    9d58:	12 03       	mulsu	r17, r18
    9d5a:	f0 01       	movw	r30, r0
    9d5c:	13 9f       	mul	r17, r19
    9d5e:	f0 0d       	add	r31, r0
    9d60:	11 24       	eor	r1, r1
    9d62:	0c c0       	rjmp	.+24     	; 0x9d7c <maze_setBeenthere+0x9a>
    9d64:	1c 30       	cpi	r17, 0x0C	; 12
						break;
			case EAST:
							if((c.x + 1) <= (MAZE_SIZE_X-1))	maze[c.x + 1][c.y][c.z].beenthere = value;
    9d66:	34 f4       	brge	.+12     	; 0x9d74 <maze_setBeenthere+0x92>
    9d68:	81 2f       	mov	r24, r17
    9d6a:	99 27       	eor	r25, r25
    9d6c:	87 fd       	sbrc	r24, 7
    9d6e:	90 95       	com	r25
    9d70:	01 96       	adiw	r24, 0x01	; 1
    9d72:	3c c0       	rjmp	.+120    	; 0x9dec <maze_setBeenthere+0x10a>
    9d74:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[0		][c.y][c.z].beenthere = value;
    9d76:	28 02       	muls	r18, r24
    9d78:	f0 01       	movw	r30, r0
    9d7a:	11 24       	eor	r1, r1
    9d7c:	87 e0       	ldi	r24, 0x07	; 7
    9d7e:	58 02       	muls	r21, r24
    9d80:	e0 0d       	add	r30, r0
    9d82:	f1 1d       	adc	r31, r1
    9d84:	11 24       	eor	r1, r1
    9d86:	45 c0       	rjmp	.+138    	; 0x9e12 <maze_setBeenthere+0x130>
    9d88:	12 16       	cp	r1, r18
						break;
			case SOUTH:
							if((c.y - 1) >= 0)					maze[c.x][c.y - 1	   ][c.z].beenthere = value;
    9d8a:	d4 f4       	brge	.+52     	; 0x9dc0 <maze_setBeenthere+0xde>
    9d8c:	33 27       	eor	r19, r19
    9d8e:	27 fd       	sbrc	r18, 7
    9d90:	30 95       	com	r19
    9d92:	21 50       	subi	r18, 0x01	; 1
    9d94:	31 09       	sbc	r19, r1
    9d96:	61 e1       	ldi	r22, 0x11	; 17
    9d98:	71 e0       	ldi	r23, 0x01	; 1
    9d9a:	16 03       	mulsu	r17, r22
    9d9c:	f0 01       	movw	r30, r0
    9d9e:	17 9f       	mul	r17, r23
    9da0:	f0 0d       	add	r31, r0
    9da2:	11 24       	eor	r1, r1
    9da4:	87 e0       	ldi	r24, 0x07	; 7
    9da6:	58 02       	muls	r21, r24
    9da8:	e0 0d       	add	r30, r0
    9daa:	f1 1d       	adc	r31, r1
    9dac:	11 24       	eor	r1, r1
    9dae:	55 e1       	ldi	r21, 0x15	; 21
    9db0:	52 9f       	mul	r21, r18
    9db2:	c0 01       	movw	r24, r0
    9db4:	53 9f       	mul	r21, r19
    9db6:	90 0d       	add	r25, r0
    9db8:	11 24       	eor	r1, r1
    9dba:	e8 0f       	add	r30, r24
    9dbc:	f9 1f       	adc	r31, r25
    9dbe:	29 c0       	rjmp	.+82     	; 0x9e12 <maze_setBeenthere+0x130>
    9dc0:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][MAZE_SIZE_Y-1][c.z].beenthere = value;
    9dc2:	31 e0       	ldi	r19, 0x01	; 1
    9dc4:	12 03       	mulsu	r17, r18
    9dc6:	f0 01       	movw	r30, r0
    9dc8:	13 9f       	mul	r17, r19
    9dca:	f0 0d       	add	r31, r0
    9dcc:	11 24       	eor	r1, r1
    9dce:	87 e0       	ldi	r24, 0x07	; 7
    9dd0:	58 02       	muls	r21, r24
    9dd2:	e0 0d       	add	r30, r0
    9dd4:	f1 1d       	adc	r31, r1
    9dd6:	11 24       	eor	r1, r1
    9dd8:	e9 5a       	subi	r30, 0xA9	; 169
    9dda:	f6 4f       	sbci	r31, 0xF6	; 246
    9ddc:	28 c0       	rjmp	.+80     	; 0x9e2e <maze_setBeenthere+0x14c>
    9dde:	11 16       	cp	r1, r17
						break;
			case WEST:
							if((c.x - 1) >= 0)					maze[c.x - 1	  ][c.y][c.z].beenthere = value;
    9de0:	dc f4       	brge	.+54     	; 0x9e18 <maze_setBeenthere+0x136>
    9de2:	81 2f       	mov	r24, r17
    9de4:	99 27       	eor	r25, r25
    9de6:	87 fd       	sbrc	r24, 7
    9de8:	90 95       	com	r25
    9dea:	01 97       	sbiw	r24, 0x01	; 1
    9dec:	61 e1       	ldi	r22, 0x11	; 17
    9dee:	71 e0       	ldi	r23, 0x01	; 1
    9df0:	86 9f       	mul	r24, r22
    9df2:	f0 01       	movw	r30, r0
    9df4:	87 9f       	mul	r24, r23
    9df6:	f0 0d       	add	r31, r0
    9df8:	96 9f       	mul	r25, r22
    9dfa:	f0 0d       	add	r31, r0
    9dfc:	11 24       	eor	r1, r1
    9dfe:	87 e0       	ldi	r24, 0x07	; 7
    9e00:	58 02       	muls	r21, r24
    9e02:	e0 0d       	add	r30, r0
    9e04:	f1 1d       	adc	r31, r1
    9e06:	11 24       	eor	r1, r1
    9e08:	85 e1       	ldi	r24, 0x15	; 21
    9e0a:	28 02       	muls	r18, r24
    9e0c:	e0 0d       	add	r30, r0
    9e0e:	f1 1d       	adc	r31, r1
    9e10:	11 24       	eor	r1, r1
    9e12:	e5 5a       	subi	r30, 0xA5	; 165
    9e14:	f7 4f       	sbci	r31, 0xF7	; 247
    9e16:	0b c0       	rjmp	.+22     	; 0x9e2e <maze_setBeenthere+0x14c>
    9e18:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[MAZE_SIZE_X-1][c.y][c.z].beenthere = value;
    9e1a:	28 02       	muls	r18, r24
    9e1c:	f0 01       	movw	r30, r0
    9e1e:	11 24       	eor	r1, r1
    9e20:	87 e0       	ldi	r24, 0x07	; 7
    9e22:	58 02       	muls	r21, r24
    9e24:	e0 0d       	add	r30, r0
    9e26:	f1 1d       	adc	r31, r1
    9e28:	11 24       	eor	r1, r1
    9e2a:	e9 5d       	subi	r30, 0xD9	; 217
    9e2c:	fa 4e       	sbci	r31, 0xEA	; 234
    9e2e:	80 81       	ld	r24, Z
    9e30:	40 fb       	bst	r20, 0
    9e32:	80 f9       	bld	r24, 0
    9e34:	80 83       	st	Z, r24
    9e36:	25 96       	adiw	r28, 0x05	; 5
						break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
								fatal_err = 1;
		}
	}
}
    9e38:	e3 e0       	ldi	r30, 0x03	; 3
    9e3a:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

00009e3e <maze_setDepthsearch>:
//
// @return: 	void
////////////////////////////////////////////////////////////////////////////////

void maze_setDepthsearch(COORD *_coord, int8_t dir, uint8_t value)
{
    9e3e:	a5 e0       	ldi	r26, 0x05	; 5
    9e40:	b0 e0       	ldi	r27, 0x00	; 0
    9e42:	e5 e2       	ldi	r30, 0x25	; 37
    9e44:	ff e4       	ldi	r31, 0x4F	; 79
    9e46:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	COORD c = *_coord;
    9e4a:	fc 01       	movw	r30, r24
    9e4c:	80 81       	ld	r24, Z
    9e4e:	91 81       	ldd	r25, Z+1	; 0x01
    9e50:	a2 81       	ldd	r26, Z+2	; 0x02
    9e52:	89 83       	std	Y+1, r24	; 0x01
    9e54:	9a 83       	std	Y+2, r25	; 0x02
    9e56:	ab 83       	std	Y+3, r26	; 0x03
	
	if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
    9e58:	ce 01       	movw	r24, r28
    9e5a:	01 96       	adiw	r24, 0x01	; 1
    9e5c:	4d 83       	std	Y+5, r20	; 0x05
    9e5e:	6c 83       	std	Y+4, r22	; 0x04
    9e60:	32 d9       	rcall	.-3484   	; 0x90c6 <maze_adaptOffset>
    9e62:	4d 81       	ldd	r20, Y+5	; 0x05
    9e64:	6c 81       	ldd	r22, Y+4	; 0x04
    9e66:	88 23       	and	r24, r24
    9e68:	09 f4       	brne	.+2      	; 0x9e6c <maze_setDepthsearch+0x2e>
    9e6a:	c3 c0       	rjmp	.+390    	; 0x9ff2 <maze_setDepthsearch+0x1b4>
    9e6c:	62 30       	cpi	r22, 0x02	; 2
	{
		switch(dir)
    9e6e:	09 f4       	brne	.+2      	; 0x9e72 <maze_setDepthsearch+0x34>
    9e70:	4c c0       	rjmp	.+152    	; 0x9f0a <maze_setDepthsearch+0xcc>
    9e72:	2c f4       	brge	.+10     	; 0x9e7e <maze_setDepthsearch+0x40>
    9e74:	66 23       	and	r22, r22
    9e76:	51 f0       	breq	.+20     	; 0x9e8c <maze_setDepthsearch+0x4e>
    9e78:	61 30       	cpi	r22, 0x01	; 1
    9e7a:	e1 f0       	breq	.+56     	; 0x9eb4 <maze_setDepthsearch+0x76>
    9e7c:	a1 c0       	rjmp	.+322    	; 0x9fc0 <maze_setDepthsearch+0x182>
    9e7e:	63 30       	cpi	r22, 0x03	; 3
    9e80:	09 f4       	brne	.+2      	; 0x9e84 <maze_setDepthsearch+0x46>
    9e82:	57 c0       	rjmp	.+174    	; 0x9f32 <maze_setDepthsearch+0xf4>
    9e84:	64 30       	cpi	r22, 0x04	; 4
    9e86:	09 f4       	brne	.+2      	; 0x9e8a <maze_setDepthsearch+0x4c>
    9e88:	6d c0       	rjmp	.+218    	; 0x9f64 <maze_setDepthsearch+0x126>
    9e8a:	9a c0       	rjmp	.+308    	; 0x9fc0 <maze_setDepthsearch+0x182>
    9e8c:	8b 81       	ldd	r24, Y+3	; 0x03
		{
			case NONE:
							maze[c.x][c.y][c.z].depthsearch = value;
    9e8e:	ea 81       	ldd	r30, Y+2	; 0x02
    9e90:	59 81       	ldd	r21, Y+1	; 0x01
    9e92:	35 e1       	ldi	r19, 0x15	; 21
    9e94:	e3 02       	muls	r30, r19
    9e96:	f0 01       	movw	r30, r0
    9e98:	11 24       	eor	r1, r1
    9e9a:	97 e0       	ldi	r25, 0x07	; 7
    9e9c:	89 02       	muls	r24, r25
    9e9e:	e0 0d       	add	r30, r0
    9ea0:	f1 1d       	adc	r31, r1
    9ea2:	11 24       	eor	r1, r1
    9ea4:	21 e1       	ldi	r18, 0x11	; 17
    9ea6:	31 e0       	ldi	r19, 0x01	; 1
    9ea8:	52 03       	mulsu	r21, r18
    9eaa:	c0 01       	movw	r24, r0
    9eac:	53 9f       	mul	r21, r19
    9eae:	90 0d       	add	r25, r0
    9eb0:	11 24       	eor	r1, r1
    9eb2:	1b c0       	rjmp	.+54     	; 0x9eea <maze_setDepthsearch+0xac>
    9eb4:	8a 81       	ldd	r24, Y+2	; 0x02
						break;
			case NORTH:
							if((c.y + 1) <= (MAZE_SIZE_Y-1))	maze[c.x][c.y + 1][c.z].depthsearch = value;
    9eb6:	5b 81       	ldd	r21, Y+3	; 0x03
    9eb8:	69 81       	ldd	r22, Y+1	; 0x01
    9eba:	8c 30       	cpi	r24, 0x0C	; 12
    9ebc:	cc f4       	brge	.+50     	; 0x9ef0 <maze_setDepthsearch+0xb2>
    9ebe:	99 27       	eor	r25, r25
    9ec0:	87 fd       	sbrc	r24, 7
    9ec2:	90 95       	com	r25
    9ec4:	01 96       	adiw	r24, 0x01	; 1
    9ec6:	25 e1       	ldi	r18, 0x15	; 21
    9ec8:	28 9f       	mul	r18, r24
    9eca:	f0 01       	movw	r30, r0
    9ecc:	29 9f       	mul	r18, r25
    9ece:	f0 0d       	add	r31, r0
    9ed0:	11 24       	eor	r1, r1
    9ed2:	37 e0       	ldi	r19, 0x07	; 7
    9ed4:	53 02       	muls	r21, r19
    9ed6:	e0 0d       	add	r30, r0
    9ed8:	f1 1d       	adc	r31, r1
    9eda:	11 24       	eor	r1, r1
    9edc:	21 e1       	ldi	r18, 0x11	; 17
    9ede:	31 e0       	ldi	r19, 0x01	; 1
    9ee0:	62 03       	mulsu	r22, r18
    9ee2:	c0 01       	movw	r24, r0
    9ee4:	63 9f       	mul	r22, r19
    9ee6:	90 0d       	add	r25, r0
    9ee8:	11 24       	eor	r1, r1
    9eea:	e8 0f       	add	r30, r24
    9eec:	f9 1f       	adc	r31, r25
    9eee:	57 c0       	rjmp	.+174    	; 0x9f9e <maze_setDepthsearch+0x160>
    9ef0:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][0		 ][c.z].depthsearch = value;
    9ef2:	31 e0       	ldi	r19, 0x01	; 1
    9ef4:	62 03       	mulsu	r22, r18
    9ef6:	f0 01       	movw	r30, r0
    9ef8:	63 9f       	mul	r22, r19
    9efa:	f0 0d       	add	r31, r0
    9efc:	11 24       	eor	r1, r1
    9efe:	87 e0       	ldi	r24, 0x07	; 7
    9f00:	58 02       	muls	r21, r24
    9f02:	e0 0d       	add	r30, r0
    9f04:	f1 1d       	adc	r31, r1
    9f06:	11 24       	eor	r1, r1
    9f08:	4a c0       	rjmp	.+148    	; 0x9f9e <maze_setDepthsearch+0x160>
    9f0a:	89 81       	ldd	r24, Y+1	; 0x01
						break;
			case EAST:
							if((c.x + 1) <= (MAZE_SIZE_X-1))	maze[c.x + 1][c.y][c.z].depthsearch = value;
    9f0c:	2b 81       	ldd	r18, Y+3	; 0x03
    9f0e:	ea 81       	ldd	r30, Y+2	; 0x02
    9f10:	8c 30       	cpi	r24, 0x0C	; 12
    9f12:	2c f4       	brge	.+10     	; 0x9f1e <maze_setDepthsearch+0xe0>
    9f14:	99 27       	eor	r25, r25
    9f16:	87 fd       	sbrc	r24, 7
    9f18:	90 95       	com	r25
    9f1a:	01 96       	adiw	r24, 0x01	; 1
    9f1c:	2c c0       	rjmp	.+88     	; 0x9f76 <maze_setDepthsearch+0x138>
    9f1e:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[0		][c.y][c.z].depthsearch = value;
    9f20:	e8 02       	muls	r30, r24
    9f22:	f0 01       	movw	r30, r0
    9f24:	11 24       	eor	r1, r1
    9f26:	97 e0       	ldi	r25, 0x07	; 7
    9f28:	29 02       	muls	r18, r25
    9f2a:	e0 0d       	add	r30, r0
    9f2c:	f1 1d       	adc	r31, r1
    9f2e:	11 24       	eor	r1, r1
    9f30:	36 c0       	rjmp	.+108    	; 0x9f9e <maze_setDepthsearch+0x160>
    9f32:	8a 81       	ldd	r24, Y+2	; 0x02
						break;
			case SOUTH:
							if((c.y - 1) >= 0)					maze[c.x][c.y - 1			][c.z].depthsearch = value;
    9f34:	5b 81       	ldd	r21, Y+3	; 0x03
    9f36:	69 81       	ldd	r22, Y+1	; 0x01
    9f38:	18 16       	cp	r1, r24
    9f3a:	2c f4       	brge	.+10     	; 0x9f46 <maze_setDepthsearch+0x108>
    9f3c:	99 27       	eor	r25, r25
    9f3e:	87 fd       	sbrc	r24, 7
    9f40:	90 95       	com	r25
    9f42:	01 97       	sbiw	r24, 0x01	; 1
    9f44:	c0 cf       	rjmp	.-128    	; 0x9ec6 <maze_setDepthsearch+0x88>
    9f46:	21 e1       	ldi	r18, 0x11	; 17
							else								maze[c.x][MAZE_SIZE_Y-1][c.z].depthsearch = value;
    9f48:	31 e0       	ldi	r19, 0x01	; 1
    9f4a:	62 03       	mulsu	r22, r18
    9f4c:	f0 01       	movw	r30, r0
    9f4e:	63 9f       	mul	r22, r19
    9f50:	f0 0d       	add	r31, r0
    9f52:	11 24       	eor	r1, r1
    9f54:	87 e0       	ldi	r24, 0x07	; 7
    9f56:	58 02       	muls	r21, r24
    9f58:	e0 0d       	add	r30, r0
    9f5a:	f1 1d       	adc	r31, r1
    9f5c:	11 24       	eor	r1, r1
    9f5e:	e3 5a       	subi	r30, 0xA3	; 163
    9f60:	f6 4f       	sbci	r31, 0xF6	; 246
    9f62:	2c c0       	rjmp	.+88     	; 0x9fbc <maze_setDepthsearch+0x17e>
    9f64:	89 81       	ldd	r24, Y+1	; 0x01
						break;
			case WEST:
							if((c.x - 1) >= 0)					maze[c.x - 1	  ][c.y][c.z].depthsearch = value;
    9f66:	2b 81       	ldd	r18, Y+3	; 0x03
    9f68:	ea 81       	ldd	r30, Y+2	; 0x02
    9f6a:	18 16       	cp	r1, r24
    9f6c:	e4 f4       	brge	.+56     	; 0x9fa6 <maze_setDepthsearch+0x168>
    9f6e:	99 27       	eor	r25, r25
    9f70:	87 fd       	sbrc	r24, 7
    9f72:	90 95       	com	r25
    9f74:	01 97       	sbiw	r24, 0x01	; 1
    9f76:	35 e1       	ldi	r19, 0x15	; 21
    9f78:	e3 02       	muls	r30, r19
    9f7a:	f0 01       	movw	r30, r0
    9f7c:	11 24       	eor	r1, r1
    9f7e:	37 e0       	ldi	r19, 0x07	; 7
    9f80:	23 02       	muls	r18, r19
    9f82:	e0 0d       	add	r30, r0
    9f84:	f1 1d       	adc	r31, r1
    9f86:	11 24       	eor	r1, r1
    9f88:	61 e1       	ldi	r22, 0x11	; 17
    9f8a:	71 e0       	ldi	r23, 0x01	; 1
    9f8c:	86 9f       	mul	r24, r22
    9f8e:	90 01       	movw	r18, r0
    9f90:	87 9f       	mul	r24, r23
    9f92:	30 0d       	add	r19, r0
    9f94:	96 9f       	mul	r25, r22
    9f96:	30 0d       	add	r19, r0
    9f98:	11 24       	eor	r1, r1
    9f9a:	e2 0f       	add	r30, r18
    9f9c:	f3 1f       	adc	r31, r19
    9f9e:	e5 5a       	subi	r30, 0xA5	; 165
    9fa0:	f7 4f       	sbci	r31, 0xF7	; 247
    9fa2:	46 83       	std	Z+6, r20	; 0x06
    9fa4:	26 c0       	rjmp	.+76     	; 0x9ff2 <maze_setDepthsearch+0x1b4>
    9fa6:	85 e1       	ldi	r24, 0x15	; 21
							else								maze[MAZE_SIZE_X-1][c.y][c.z].depthsearch = value;
    9fa8:	e8 02       	muls	r30, r24
    9faa:	f0 01       	movw	r30, r0
    9fac:	11 24       	eor	r1, r1
    9fae:	97 e0       	ldi	r25, 0x07	; 7
    9fb0:	29 02       	muls	r18, r25
    9fb2:	e0 0d       	add	r30, r0
    9fb4:	f1 1d       	adc	r31, r1
    9fb6:	11 24       	eor	r1, r1
    9fb8:	e3 5d       	subi	r30, 0xD3	; 211
    9fba:	fa 4e       	sbci	r31, 0xEA	; 234
    9fbc:	40 83       	st	Z, r20
    9fbe:	19 c0       	rjmp	.+50     	; 0x9ff2 <maze_setDepthsearch+0x1b4>
    9fc0:	80 91 53 05 	lds	r24, 0x0553
						break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
    9fc4:	82 30       	cpi	r24, 0x02	; 2
    9fc6:	90 f0       	brcs	.+36     	; 0x9fec <maze_setDepthsearch+0x1ae>
    9fc8:	8e eb       	ldi	r24, 0xBE	; 190
    9fca:	9b e2       	ldi	r25, 0x2B	; 43
    9fcc:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    9fd0:	60 91 47 05 	lds	r22, 0x0547
    9fd4:	70 91 48 05 	lds	r23, 0x0548
    9fd8:	80 91 49 05 	lds	r24, 0x0549
    9fdc:	90 91 4a 05 	lds	r25, 0x054A
    9fe0:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    9fe4:	88 e8       	ldi	r24, 0x88	; 136
    9fe6:	9b e2       	ldi	r25, 0x2B	; 43
    9fe8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    9fec:	81 e0       	ldi	r24, 0x01	; 1
								fatal_err = 1;
    9fee:	80 93 63 05 	sts	0x0563, r24
    9ff2:	25 96       	adiw	r28, 0x05	; 5
		}
	}
}
    9ff4:	e2 e0       	ldi	r30, 0x02	; 2
    9ff6:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

00009ffa <maze_clearStage>:
//
// @return: 	void
////////////////////////////////////////////////////////////////////////////////

void maze_clearStage(uint8_t stage, TILE *clear)
{
    9ffa:	a3 e0       	ldi	r26, 0x03	; 3
    9ffc:	b0 e0       	ldi	r27, 0x00	; 0
    9ffe:	e3 e0       	ldi	r30, 0x03	; 3
    a000:	f0 e5       	ldi	r31, 0x50	; 80
    a002:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    a006:	8b 01       	movw	r16, r22
	COORD c;
	c.x = 0;
    a008:	19 82       	std	Y+1, r1	; 0x01
	c.y = 0;
    a00a:	1a 82       	std	Y+2, r1	; 0x02
	c.z = stage;
    a00c:	8b 83       	std	Y+3, r24	; 0x03

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    a00e:	ce 01       	movw	r24, r28
    a010:	01 96       	adiw	r24, 0x01	; 1
    a012:	59 d8       	rcall	.-3918   	; 0x90c6 <maze_adaptOffset>
    a014:	88 23       	and	r24, r24
    a016:	a1 f0       	breq	.+40     	; 0xa040 <maze_clearStage+0x46>
    a018:	1a 82       	std	Y+2, r1	; 0x02
	{
		for(c.y = 0; c.y < MAZE_SIZE_Y; c.y++)
    a01a:	8a 81       	ldd	r24, Y+2	; 0x02
    a01c:	8d 30       	cpi	r24, 0x0D	; 13
    a01e:	84 f4       	brge	.+32     	; 0xa040 <maze_clearStage+0x46>
    a020:	19 82       	std	Y+1, r1	; 0x01
		{
			for(c.x = 0; c.x < MAZE_SIZE_X; c.x++)
    a022:	89 81       	ldd	r24, Y+1	; 0x01
    a024:	8d 30       	cpi	r24, 0x0D	; 13
    a026:	44 f4       	brge	.+16     	; 0xa038 <maze_clearStage+0x3e>
    a028:	b8 01       	movw	r22, r16
			{
				maze_clearTile(&c, clear);
    a02a:	ce 01       	movw	r24, r28
    a02c:	01 96       	adiw	r24, 0x01	; 1
    a02e:	e9 d8       	rcall	.-3630   	; 0x9202 <maze_clearTile>
    a030:	89 81       	ldd	r24, Y+1	; 0x01
    a032:	8f 5f       	subi	r24, 0xFF	; 255

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
	{
		for(c.y = 0; c.y < MAZE_SIZE_Y; c.y++)
		{
			for(c.x = 0; c.x < MAZE_SIZE_X; c.x++)
    a034:	89 83       	std	Y+1, r24	; 0x01
    a036:	f5 cf       	rjmp	.-22     	; 0xa022 <maze_clearStage+0x28>
    a038:	8a 81       	ldd	r24, Y+2	; 0x02
    a03a:	8f 5f       	subi	r24, 0xFF	; 255
	c.y = 0;
	c.z = stage;

	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
	{
		for(c.y = 0; c.y < MAZE_SIZE_Y; c.y++)
    a03c:	8a 83       	std	Y+2, r24	; 0x02
    a03e:	ed cf       	rjmp	.-38     	; 0xa01a <maze_clearStage+0x20>
    a040:	23 96       	adiw	r28, 0x03	; 3
    a042:	e4 e0       	ldi	r30, 0x04	; 4
			{
				maze_clearTile(&c, clear);
			}
		}
	}
}
    a044:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000a048 <maze_init>:
//
// @return: NONE
////////////////////////////////////////////////////////////////////////////////

void maze_init(void)
{
    a048:	a7 e0       	ldi	r26, 0x07	; 7
    a04a:	b0 e0       	ldi	r27, 0x00	; 0
    a04c:	ea e2       	ldi	r30, 0x2A	; 42
    a04e:	f0 e5       	ldi	r31, 0x50	; 80
    a050:	0c 94 a8 6b 	jmp	0xd750	; 0xd750 <__prologue_saves__+0x1a>
	TILE clear;
	clear.beenthere = 1;
	clear.depthsearch = 1;
    a054:	81 e0       	ldi	r24, 0x01	; 1
    a056:	8f 83       	std	Y+7, r24	; 0x07
	clear.ground = 1;
    a058:	93 e0       	ldi	r25, 0x03	; 3
    a05a:	99 83       	std	Y+1, r25	; 0x01
	clear.obstacle = 1;
    a05c:	8c 83       	std	Y+4, r24	; 0x04
	clear.victim_e = 1;
	clear.victim_s = 1;
	clear.victim_w = 1;
    a05e:	91 e1       	ldi	r25, 0x11	; 17
    a060:	9e 83       	std	Y+6, r25	; 0x06
	clear.victim_n = 1;
    a062:	9d 83       	std	Y+5, r25	; 0x05
	clear.wall_s = 1;
    a064:	8a 83       	std	Y+2, r24	; 0x02
	clear.wall_w = 1;
    a066:	8b 83       	std	Y+3, r24	; 0x03

	for(uint8_t maze_z = 0; maze_z < MAZE_SIZE_Z; maze_z++) //Labyrinth lschen
	{
		maze_clearStage(maze_z, &clear);
    a068:	be 01       	movw	r22, r28
    a06a:	6f 5f       	subi	r22, 0xFF	; 255
    a06c:	7f 4f       	sbci	r23, 0xFF	; 255
    a06e:	80 e0       	ldi	r24, 0x00	; 0
    a070:	c4 df       	rcall	.-120    	; 0x9ffa <maze_clearStage>
    a072:	be 01       	movw	r22, r28
    a074:	6f 5f       	subi	r22, 0xFF	; 255
    a076:	7f 4f       	sbci	r23, 0xFF	; 255
    a078:	81 e0       	ldi	r24, 0x01	; 1
    a07a:	bf df       	rcall	.-130    	; 0x9ffa <maze_clearStage>
    a07c:	be 01       	movw	r22, r28
    a07e:	6f 5f       	subi	r22, 0xFF	; 255
    a080:	7f 4f       	sbci	r23, 0xFF	; 255
    a082:	82 e0       	ldi	r24, 0x02	; 2
    a084:	ba df       	rcall	.-140    	; 0x9ffa <maze_clearStage>
    a086:	e1 e5       	ldi	r30, 0x51	; 81
    a088:	f6 e1       	ldi	r31, 0x16	; 22
    a08a:	df 01       	movw	r26, r30
    a08c:	11 97       	sbiw	r26, 0x01	; 1
    a08e:	1c 92       	st	X, r1
    a090:	10 82       	st	Z, r1
    a092:	32 96       	adiw	r30, 0x02	; 2
	}
	
	for(int8_t i = 0; i < MAZE_SIZE_Y; i++)
	{
		offset[i].x = 0;
    a094:	86 e1       	ldi	r24, 0x16	; 22
		offset[i].y = 0;
    a096:	eb 36       	cpi	r30, 0x6B	; 107
    a098:	f8 07       	cpc	r31, r24
	for(uint8_t maze_z = 0; maze_z < MAZE_SIZE_Z; maze_z++) //Labyrinth lschen
	{
		maze_clearStage(maze_z, &clear);
	}
	
	for(int8_t i = 0; i < MAZE_SIZE_Y; i++)
    a09a:	b9 f7       	brne	.-18     	; 0xa08a <maze_init+0x42>
    a09c:	10 92 5a 16 	sts	0x165A, r1
    a0a0:	81 e0       	ldi	r24, 0x01	; 1
	{
		offset[i].x = 0;
		offset[i].y = 0;
	}
	offset_z = 0;
    a0a2:	80 93 48 16 	sts	0x1648, r24
	
	robot.pos.x = ROB_START_MAZE_X;
    a0a6:	10 92 4a 16 	sts	0x164A, r1
    a0aa:	80 93 4b 16 	sts	0x164B, r24
	robot.pos.y = ROB_START_MAZE_Y;
	robot.pos.z = ROB_START_MAZE_Z;
    a0ae:	10 92 45 16 	sts	0x1645, r1
	robot.dir = ROB_START_DIR;
    a0b2:	10 92 46 16 	sts	0x1646, r1

	off_start.x = 0;
    a0b6:	10 92 47 16 	sts	0x1647, r1
	off_start.y = 0;
    a0ba:	ed e4       	ldi	r30, 0x4D	; 77
	off_start.z = 0;
    a0bc:	f8 e0       	ldi	r31, 0x08	; 8
    a0be:	8f ef       	ldi	r24, 0xFF	; 255
    a0c0:	df 01       	movw	r26, r30
    a0c2:	13 97       	sbiw	r26, 0x03	; 3
	
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
	{
		ramp[i].pos.x = -1;
    a0c4:	8c 93       	st	X, r24
    a0c6:	df 01       	movw	r26, r30
    a0c8:	12 97       	sbiw	r26, 0x02	; 2
    a0ca:	8c 93       	st	X, r24
    a0cc:	df 01       	movw	r26, r30
    a0ce:	11 97       	sbiw	r26, 0x01	; 1
		ramp[i].pos.y = -1;
    a0d0:	8c 93       	st	X, r24
    a0d2:	10 82       	st	Z, r1
    a0d4:	34 96       	adiw	r30, 0x04	; 4
		ramp[i].pos.z = -1;
    a0d6:	98 e0       	ldi	r25, 0x08	; 8
		ramp[i].dir = NONE;
    a0d8:	e9 35       	cpi	r30, 0x59	; 89
    a0da:	f9 07       	cpc	r31, r25

	off_start.x = 0;
	off_start.y = 0;
	off_start.z = 0;
	
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
    a0dc:	89 f7       	brne	.-30     	; 0xa0c0 <maze_init+0x78>
    a0de:	62 e0       	ldi	r22, 0x02	; 2
    a0e0:	f6 2e       	mov	r15, r22
    a0e2:	f0 92 13 08 	sts	0x0813, r15
		ramp[i].pos.y = -1;
		ramp[i].pos.z = -1;
		ramp[i].dir = NONE;
	}
	
	checkpoint[0][0].pos.x = 2;
    a0e6:	f0 92 14 08 	sts	0x0814, r15
    a0ea:	13 e0       	ldi	r17, 0x03	; 3
	checkpoint[0][0].pos.y = 2;
    a0ec:	10 93 17 08 	sts	0x0817, r17

	checkpoint[0][1].pos.x = 3;
    a0f0:	10 93 18 08 	sts	0x0818, r17
    a0f4:	10 93 1b 08 	sts	0x081B, r17
	checkpoint[0][1].pos.y = 3;
    a0f8:	01 e0       	ldi	r16, 0x01	; 1

	checkpoint[0][2].pos.x = 3;
    a0fa:	00 93 1c 08 	sts	0x081C, r16
	checkpoint[0][2].pos.y = 1;
    a0fe:	84 e0       	ldi	r24, 0x04	; 4
    a100:	80 93 1f 08 	sts	0x081F, r24

	checkpoint[0][3].pos.x = 4;
    a104:	f0 92 20 08 	sts	0x0820, r15
    a108:	95 e0       	ldi	r25, 0x05	; 5
	checkpoint[0][3].pos.y = 2;
    a10a:	90 93 23 08 	sts	0x0823, r25

	checkpoint[0][4].pos.x = 5;
    a10e:	10 93 24 08 	sts	0x0824, r17
    a112:	80 93 27 08 	sts	0x0827, r24
	checkpoint[0][4].pos.y = 3;
    a116:	f0 92 28 08 	sts	0x0828, r15

	checkpoint[0][5].pos.x = 4;
    a11a:	10 93 2b 08 	sts	0x082B, r17
	checkpoint[0][5].pos.y = 2;
    a11e:	10 93 2c 08 	sts	0x082C, r17

	checkpoint[1][0].pos.x = 3;
    a122:	10 93 2f 08 	sts	0x082F, r17
	checkpoint[1][0].pos.y = 3;
    a126:	00 93 30 08 	sts	0x0830, r16

	checkpoint[1][1].pos.x = 3;
    a12a:	f0 92 33 08 	sts	0x0833, r15
	checkpoint[1][1].pos.y = 1;
    a12e:	10 93 34 08 	sts	0x0834, r17

	checkpoint[1][2].pos.x = 2;
    a132:	f0 92 37 08 	sts	0x0837, r15
	checkpoint[1][2].pos.y = 3;
    a136:	00 93 38 08 	sts	0x0838, r16

	checkpoint[1][3].pos.x = 2;
    a13a:	00 93 3b 08 	sts	0x083B, r16
	checkpoint[1][3].pos.y = 1;
    a13e:	10 93 3c 08 	sts	0x083C, r17

	checkpoint[1][4].pos.x = 1;
    a142:	00 93 3f 08 	sts	0x083F, r16
	checkpoint[1][4].pos.y = 3;
    a146:	00 93 40 08 	sts	0x0840, r16

	checkpoint[1][5].pos.x = 1;
    a14a:	10 92 cd 05 	sts	0x05CD, r1
	checkpoint[1][5].pos.y = 1;
    a14e:	10 92 c6 05 	sts	0x05C6, r1


	maze_solve_state_path = DRIVE_READY;
    a152:	10 93 49 16 	sts	0x1649, r17
	
	routeRequest = 0;
    a156:	4a e0       	ldi	r20, 0x0A	; 10

	robot.pos.x = 1;
	robot.pos.y = 3;
    a158:	61 e0       	ldi	r22, 0x01	; 1
    a15a:	88 e4       	ldi	r24, 0x48	; 72
	robot.pos.z = 0;

	maze_setWall(&robot.pos, NORTH, 10);
    a15c:	96 e1       	ldi	r25, 0x16	; 22
    a15e:	37 da       	rcall	.-2962   	; 0x95ce <maze_setWall>
    a160:	46 ef       	ldi	r20, 0xF6	; 246
    a162:	62 e0       	ldi	r22, 0x02	; 2
    a164:	88 e4       	ldi	r24, 0x48	; 72
    a166:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, EAST, -10);
    a168:	32 da       	rcall	.-2972   	; 0x95ce <maze_setWall>
    a16a:	4a e0       	ldi	r20, 0x0A	; 10
    a16c:	63 e0       	ldi	r22, 0x03	; 3
    a16e:	88 e4       	ldi	r24, 0x48	; 72
    a170:	96 e1       	ldi	r25, 0x16	; 22
    a172:	2d da       	rcall	.-2982   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, SOUTH, 10);
    a174:	4a e0       	ldi	r20, 0x0A	; 10
    a176:	64 e0       	ldi	r22, 0x04	; 4
    a178:	88 e4       	ldi	r24, 0x48	; 72
    a17a:	96 e1       	ldi	r25, 0x16	; 22
    a17c:	28 da       	rcall	.-2992   	; 0x95ce <maze_setWall>
    a17e:	80 91 48 16 	lds	r24, 0x1648
	maze_setWall(&robot.pos, WEST, 10);
    a182:	8f 5f       	subi	r24, 0xFF	; 255
    a184:	80 93 48 16 	sts	0x1648, r24
    a188:	4a e0       	ldi	r20, 0x0A	; 10
    a18a:	61 e0       	ldi	r22, 0x01	; 1

	robot.pos.x ++;
    a18c:	88 e4       	ldi	r24, 0x48	; 72
    a18e:	96 e1       	ldi	r25, 0x16	; 22
    a190:	1e da       	rcall	.-3012   	; 0x95ce <maze_setWall>
    a192:	46 ef       	ldi	r20, 0xF6	; 246
    a194:	62 e0       	ldi	r22, 0x02	; 2
	maze_setWall(&robot.pos, NORTH, 10);
    a196:	88 e4       	ldi	r24, 0x48	; 72
    a198:	96 e1       	ldi	r25, 0x16	; 22
    a19a:	19 da       	rcall	.-3022   	; 0x95ce <maze_setWall>
    a19c:	46 ef       	ldi	r20, 0xF6	; 246
    a19e:	63 e0       	ldi	r22, 0x03	; 3
    a1a0:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, EAST, -10);
    a1a2:	96 e1       	ldi	r25, 0x16	; 22
    a1a4:	14 da       	rcall	.-3032   	; 0x95ce <maze_setWall>
    a1a6:	46 ef       	ldi	r20, 0xF6	; 246
    a1a8:	64 e0       	ldi	r22, 0x04	; 4
    a1aa:	88 e4       	ldi	r24, 0x48	; 72
    a1ac:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, SOUTH, -10);
    a1ae:	0f da       	rcall	.-3042   	; 0x95ce <maze_setWall>
    a1b0:	80 91 48 16 	lds	r24, 0x1648
    a1b4:	8f 5f       	subi	r24, 0xFF	; 255
    a1b6:	80 93 48 16 	sts	0x1648, r24
	maze_setWall(&robot.pos, WEST, -10);
    a1ba:	4a e0       	ldi	r20, 0x0A	; 10
    a1bc:	61 e0       	ldi	r22, 0x01	; 1
    a1be:	88 e4       	ldi	r24, 0x48	; 72
    a1c0:	96 e1       	ldi	r25, 0x16	; 22
    a1c2:	05 da       	rcall	.-3062   	; 0x95ce <maze_setWall>
    a1c4:	46 ef       	ldi	r20, 0xF6	; 246

	robot.pos.x ++;
    a1c6:	62 e0       	ldi	r22, 0x02	; 2
    a1c8:	88 e4       	ldi	r24, 0x48	; 72
    a1ca:	96 e1       	ldi	r25, 0x16	; 22
    a1cc:	00 da       	rcall	.-3072   	; 0x95ce <maze_setWall>
    a1ce:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, NORTH, 10);
    a1d0:	63 e0       	ldi	r22, 0x03	; 3
    a1d2:	88 e4       	ldi	r24, 0x48	; 72
    a1d4:	96 e1       	ldi	r25, 0x16	; 22
    a1d6:	fb d9       	rcall	.-3082   	; 0x95ce <maze_setWall>
    a1d8:	46 ef       	ldi	r20, 0xF6	; 246
    a1da:	64 e0       	ldi	r22, 0x04	; 4
	maze_setWall(&robot.pos, EAST, -10);
    a1dc:	88 e4       	ldi	r24, 0x48	; 72
    a1de:	96 e1       	ldi	r25, 0x16	; 22
    a1e0:	f6 d9       	rcall	.-3092   	; 0x95ce <maze_setWall>
    a1e2:	80 91 48 16 	lds	r24, 0x1648
    a1e6:	8f 5f       	subi	r24, 0xFF	; 255
	maze_setWall(&robot.pos, SOUTH, -10);
    a1e8:	80 93 48 16 	sts	0x1648, r24
    a1ec:	4a e0       	ldi	r20, 0x0A	; 10
    a1ee:	61 e0       	ldi	r22, 0x01	; 1
    a1f0:	88 e4       	ldi	r24, 0x48	; 72
    a1f2:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, WEST, -10);
    a1f4:	ec d9       	rcall	.-3112   	; 0x95ce <maze_setWall>
    a1f6:	46 ef       	ldi	r20, 0xF6	; 246
    a1f8:	62 e0       	ldi	r22, 0x02	; 2
    a1fa:	88 e4       	ldi	r24, 0x48	; 72
    a1fc:	96 e1       	ldi	r25, 0x16	; 22
    a1fe:	e7 d9       	rcall	.-3122   	; 0x95ce <maze_setWall>

	robot.pos.x ++;
    a200:	46 ef       	ldi	r20, 0xF6	; 246
    a202:	63 e0       	ldi	r22, 0x03	; 3
    a204:	88 e4       	ldi	r24, 0x48	; 72
    a206:	96 e1       	ldi	r25, 0x16	; 22
    a208:	e2 d9       	rcall	.-3132   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, NORTH, 10);
    a20a:	46 ef       	ldi	r20, 0xF6	; 246
    a20c:	64 e0       	ldi	r22, 0x04	; 4
    a20e:	88 e4       	ldi	r24, 0x48	; 72
    a210:	96 e1       	ldi	r25, 0x16	; 22
    a212:	dd d9       	rcall	.-3142   	; 0x95ce <maze_setWall>
    a214:	80 91 48 16 	lds	r24, 0x1648
	maze_setWall(&robot.pos, EAST, -10);
    a218:	8f 5f       	subi	r24, 0xFF	; 255
    a21a:	80 93 48 16 	sts	0x1648, r24
    a21e:	4a e0       	ldi	r20, 0x0A	; 10
    a220:	61 e0       	ldi	r22, 0x01	; 1
	maze_setWall(&robot.pos, SOUTH, -10);
    a222:	88 e4       	ldi	r24, 0x48	; 72
    a224:	96 e1       	ldi	r25, 0x16	; 22
    a226:	d3 d9       	rcall	.-3162   	; 0x95ce <maze_setWall>
    a228:	4a e0       	ldi	r20, 0x0A	; 10
    a22a:	62 e0       	ldi	r22, 0x02	; 2
    a22c:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, WEST, -10);
    a22e:	96 e1       	ldi	r25, 0x16	; 22
    a230:	ce d9       	rcall	.-3172   	; 0x95ce <maze_setWall>
    a232:	46 ef       	ldi	r20, 0xF6	; 246
    a234:	63 e0       	ldi	r22, 0x03	; 3
    a236:	88 e4       	ldi	r24, 0x48	; 72
    a238:	96 e1       	ldi	r25, 0x16	; 22

	robot.pos.x ++;
    a23a:	c9 d9       	rcall	.-3182   	; 0x95ce <maze_setWall>
    a23c:	46 ef       	ldi	r20, 0xF6	; 246
    a23e:	64 e0       	ldi	r22, 0x04	; 4
    a240:	88 e4       	ldi	r24, 0x48	; 72
    a242:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, NORTH, 10);
    a244:	c4 d9       	rcall	.-3192   	; 0x95ce <maze_setWall>
    a246:	80 91 49 16 	lds	r24, 0x1649
    a24a:	81 50       	subi	r24, 0x01	; 1
    a24c:	80 93 49 16 	sts	0x1649, r24
	maze_setWall(&robot.pos, EAST, 10);
    a250:	46 ef       	ldi	r20, 0xF6	; 246
    a252:	61 e0       	ldi	r22, 0x01	; 1
    a254:	88 e4       	ldi	r24, 0x48	; 72
    a256:	96 e1       	ldi	r25, 0x16	; 22
    a258:	ba d9       	rcall	.-3212   	; 0x95ce <maze_setWall>
    a25a:	4a e0       	ldi	r20, 0x0A	; 10
	maze_setWall(&robot.pos, SOUTH, -10);
    a25c:	62 e0       	ldi	r22, 0x02	; 2
    a25e:	88 e4       	ldi	r24, 0x48	; 72
    a260:	96 e1       	ldi	r25, 0x16	; 22
    a262:	b5 d9       	rcall	.-3222   	; 0x95ce <maze_setWall>
    a264:	46 ef       	ldi	r20, 0xF6	; 246
    a266:	63 e0       	ldi	r22, 0x03	; 3
	maze_setWall(&robot.pos, WEST, -10);
    a268:	88 e4       	ldi	r24, 0x48	; 72
    a26a:	96 e1       	ldi	r25, 0x16	; 22
    a26c:	b0 d9       	rcall	.-3232   	; 0x95ce <maze_setWall>
    a26e:	46 ef       	ldi	r20, 0xF6	; 246
    a270:	64 e0       	ldi	r22, 0x04	; 4
    a272:	88 e4       	ldi	r24, 0x48	; 72

	robot.pos.y --;
    a274:	96 e1       	ldi	r25, 0x16	; 22
    a276:	ab d9       	rcall	.-3242   	; 0x95ce <maze_setWall>
    a278:	80 91 49 16 	lds	r24, 0x1649
    a27c:	81 50       	subi	r24, 0x01	; 1
	maze_setWall(&robot.pos, NORTH, -10);
    a27e:	80 93 49 16 	sts	0x1649, r24
    a282:	46 ef       	ldi	r20, 0xF6	; 246
    a284:	61 e0       	ldi	r22, 0x01	; 1
    a286:	88 e4       	ldi	r24, 0x48	; 72
    a288:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, EAST, 10);
    a28a:	a1 d9       	rcall	.-3262   	; 0x95ce <maze_setWall>
    a28c:	4a e0       	ldi	r20, 0x0A	; 10
    a28e:	62 e0       	ldi	r22, 0x02	; 2
    a290:	88 e4       	ldi	r24, 0x48	; 72
    a292:	96 e1       	ldi	r25, 0x16	; 22
    a294:	9c d9       	rcall	.-3272   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, SOUTH, -10);
    a296:	4a e0       	ldi	r20, 0x0A	; 10
    a298:	63 e0       	ldi	r22, 0x03	; 3
    a29a:	88 e4       	ldi	r24, 0x48	; 72
    a29c:	96 e1       	ldi	r25, 0x16	; 22
    a29e:	97 d9       	rcall	.-3282   	; 0x95ce <maze_setWall>
    a2a0:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, WEST, -10);
    a2a2:	64 e0       	ldi	r22, 0x04	; 4
    a2a4:	88 e4       	ldi	r24, 0x48	; 72
    a2a6:	96 e1       	ldi	r25, 0x16	; 22
    a2a8:	92 d9       	rcall	.-3292   	; 0x95ce <maze_setWall>
    a2aa:	80 91 48 16 	lds	r24, 0x1648

	robot.pos.y --;
    a2ae:	81 50       	subi	r24, 0x01	; 1
    a2b0:	80 93 48 16 	sts	0x1648, r24
    a2b4:	46 ef       	ldi	r20, 0xF6	; 246
    a2b6:	61 e0       	ldi	r22, 0x01	; 1
	maze_setWall(&robot.pos, NORTH, -10);
    a2b8:	88 e4       	ldi	r24, 0x48	; 72
    a2ba:	96 e1       	ldi	r25, 0x16	; 22
    a2bc:	88 d9       	rcall	.-3312   	; 0x95ce <maze_setWall>
    a2be:	46 ef       	ldi	r20, 0xF6	; 246
    a2c0:	62 e0       	ldi	r22, 0x02	; 2
    a2c2:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, EAST, 10);
    a2c4:	96 e1       	ldi	r25, 0x16	; 22
    a2c6:	83 d9       	rcall	.-3322   	; 0x95ce <maze_setWall>
    a2c8:	4a e0       	ldi	r20, 0x0A	; 10
    a2ca:	63 e0       	ldi	r22, 0x03	; 3
    a2cc:	88 e4       	ldi	r24, 0x48	; 72
    a2ce:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, SOUTH, 10);
    a2d0:	7e d9       	rcall	.-3332   	; 0x95ce <maze_setWall>
    a2d2:	46 ef       	ldi	r20, 0xF6	; 246
    a2d4:	64 e0       	ldi	r22, 0x04	; 4
    a2d6:	88 e4       	ldi	r24, 0x48	; 72
    a2d8:	96 e1       	ldi	r25, 0x16	; 22
    a2da:	79 d9       	rcall	.-3342   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, WEST, -10);
    a2dc:	80 91 48 16 	lds	r24, 0x1648
    a2e0:	81 50       	subi	r24, 0x01	; 1
    a2e2:	80 93 48 16 	sts	0x1648, r24
    a2e6:	46 ef       	ldi	r20, 0xF6	; 246

	robot.pos.x --;
    a2e8:	61 e0       	ldi	r22, 0x01	; 1
    a2ea:	88 e4       	ldi	r24, 0x48	; 72
    a2ec:	96 e1       	ldi	r25, 0x16	; 22
    a2ee:	6f d9       	rcall	.-3362   	; 0x95ce <maze_setWall>
    a2f0:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, NORTH, -10);
    a2f2:	62 e0       	ldi	r22, 0x02	; 2
    a2f4:	88 e4       	ldi	r24, 0x48	; 72
    a2f6:	96 e1       	ldi	r25, 0x16	; 22
    a2f8:	6a d9       	rcall	.-3372   	; 0x95ce <maze_setWall>
    a2fa:	4a e0       	ldi	r20, 0x0A	; 10
    a2fc:	63 e0       	ldi	r22, 0x03	; 3
	maze_setWall(&robot.pos, EAST, -10);
    a2fe:	88 e4       	ldi	r24, 0x48	; 72
    a300:	96 e1       	ldi	r25, 0x16	; 22
    a302:	65 d9       	rcall	.-3382   	; 0x95ce <maze_setWall>
    a304:	46 ef       	ldi	r20, 0xF6	; 246
    a306:	64 e0       	ldi	r22, 0x04	; 4
    a308:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, SOUTH, 10);
    a30a:	96 e1       	ldi	r25, 0x16	; 22
    a30c:	60 d9       	rcall	.-3392   	; 0x95ce <maze_setWall>
    a30e:	80 91 48 16 	lds	r24, 0x1648
    a312:	81 50       	subi	r24, 0x01	; 1
    a314:	80 93 48 16 	sts	0x1648, r24
	maze_setWall(&robot.pos, WEST, -10);
    a318:	46 ef       	ldi	r20, 0xF6	; 246
    a31a:	61 e0       	ldi	r22, 0x01	; 1
    a31c:	88 e4       	ldi	r24, 0x48	; 72
    a31e:	96 e1       	ldi	r25, 0x16	; 22
    a320:	56 d9       	rcall	.-3412   	; 0x95ce <maze_setWall>

	robot.pos.x --;
    a322:	46 ef       	ldi	r20, 0xF6	; 246
    a324:	62 e0       	ldi	r22, 0x02	; 2
    a326:	88 e4       	ldi	r24, 0x48	; 72
    a328:	96 e1       	ldi	r25, 0x16	; 22
    a32a:	51 d9       	rcall	.-3422   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, NORTH, -10);
    a32c:	4a e0       	ldi	r20, 0x0A	; 10
    a32e:	63 e0       	ldi	r22, 0x03	; 3
    a330:	88 e4       	ldi	r24, 0x48	; 72
    a332:	96 e1       	ldi	r25, 0x16	; 22
    a334:	4c d9       	rcall	.-3432   	; 0x95ce <maze_setWall>
    a336:	4a e0       	ldi	r20, 0x0A	; 10
	maze_setWall(&robot.pos, EAST, -10);
    a338:	64 e0       	ldi	r22, 0x04	; 4
    a33a:	88 e4       	ldi	r24, 0x48	; 72
    a33c:	96 e1       	ldi	r25, 0x16	; 22
    a33e:	47 d9       	rcall	.-3442   	; 0x95ce <maze_setWall>
    a340:	80 91 49 16 	lds	r24, 0x1649
	maze_setWall(&robot.pos, SOUTH, 10);
    a344:	8f 5f       	subi	r24, 0xFF	; 255
    a346:	80 93 49 16 	sts	0x1649, r24
    a34a:	46 ef       	ldi	r20, 0xF6	; 246
    a34c:	62 e0       	ldi	r22, 0x02	; 2
    a34e:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, WEST, -10);
    a350:	96 e1       	ldi	r25, 0x16	; 22
    a352:	3d d9       	rcall	.-3462   	; 0x95ce <maze_setWall>
    a354:	4a e0       	ldi	r20, 0x0A	; 10
    a356:	64 e0       	ldi	r22, 0x04	; 4
    a358:	88 e4       	ldi	r24, 0x48	; 72
    a35a:	96 e1       	ldi	r25, 0x16	; 22

	robot.pos.x --;
    a35c:	38 d9       	rcall	.-3472   	; 0x95ce <maze_setWall>
    a35e:	80 91 48 16 	lds	r24, 0x1648
    a362:	8f 5f       	subi	r24, 0xFF	; 255
    a364:	80 93 48 16 	sts	0x1648, r24
	maze_setWall(&robot.pos, NORTH, -10);
    a368:	46 ef       	ldi	r20, 0xF6	; 246
    a36a:	62 e0       	ldi	r22, 0x02	; 2
    a36c:	88 e4       	ldi	r24, 0x48	; 72
    a36e:	96 e1       	ldi	r25, 0x16	; 22
    a370:	2e d9       	rcall	.-3492   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, EAST, -10);
    a372:	46 ef       	ldi	r20, 0xF6	; 246
    a374:	64 e0       	ldi	r22, 0x04	; 4
    a376:	88 e4       	ldi	r24, 0x48	; 72
    a378:	96 e1       	ldi	r25, 0x16	; 22
    a37a:	29 d9       	rcall	.-3502   	; 0x95ce <maze_setWall>
    a37c:	00 93 48 16 	sts	0x1648, r16
	maze_setWall(&robot.pos, SOUTH, 10);
    a380:	00 93 49 16 	sts	0x1649, r16
    a384:	00 93 4a 16 	sts	0x164A, r16
    a388:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, WEST, 10);
    a38a:	61 e0       	ldi	r22, 0x01	; 1
    a38c:	88 e4       	ldi	r24, 0x48	; 72
    a38e:	96 e1       	ldi	r25, 0x16	; 22
    a390:	1e d9       	rcall	.-3524   	; 0x95ce <maze_setWall>
    a392:	46 ef       	ldi	r20, 0xF6	; 246
    a394:	62 e0       	ldi	r22, 0x02	; 2

	robot.pos.y ++;
    a396:	88 e4       	ldi	r24, 0x48	; 72
    a398:	96 e1       	ldi	r25, 0x16	; 22
    a39a:	19 d9       	rcall	.-3534   	; 0x95ce <maze_setWall>
    a39c:	4a e0       	ldi	r20, 0x0A	; 10
    a39e:	63 e0       	ldi	r22, 0x03	; 3
	maze_setWall(&robot.pos, EAST, -10);
    a3a0:	88 e4       	ldi	r24, 0x48	; 72
    a3a2:	96 e1       	ldi	r25, 0x16	; 22
    a3a4:	14 d9       	rcall	.-3544   	; 0x95ce <maze_setWall>
    a3a6:	4a e0       	ldi	r20, 0x0A	; 10
    a3a8:	64 e0       	ldi	r22, 0x04	; 4
    a3aa:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, WEST, 10);
    a3ac:	96 e1       	ldi	r25, 0x16	; 22
    a3ae:	0f d9       	rcall	.-3554   	; 0x95ce <maze_setWall>
    a3b0:	80 91 49 16 	lds	r24, 0x1649
    a3b4:	8f 5f       	subi	r24, 0xFF	; 255
    a3b6:	80 93 49 16 	sts	0x1649, r24

	robot.pos.x ++;
    a3ba:	46 ef       	ldi	r20, 0xF6	; 246
    a3bc:	61 e0       	ldi	r22, 0x01	; 1
    a3be:	88 e4       	ldi	r24, 0x48	; 72
    a3c0:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, EAST, -10);
    a3c2:	05 d9       	rcall	.-3574   	; 0x95ce <maze_setWall>
    a3c4:	46 ef       	ldi	r20, 0xF6	; 246
    a3c6:	62 e0       	ldi	r22, 0x02	; 2
    a3c8:	88 e4       	ldi	r24, 0x48	; 72
    a3ca:	96 e1       	ldi	r25, 0x16	; 22
    a3cc:	00 d9       	rcall	.-3584   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, WEST, -10);
    a3ce:	46 ef       	ldi	r20, 0xF6	; 246
    a3d0:	63 e0       	ldi	r22, 0x03	; 3
    a3d2:	88 e4       	ldi	r24, 0x48	; 72
    a3d4:	96 e1       	ldi	r25, 0x16	; 22
    a3d6:	fb d8       	rcall	.-3594   	; 0x95ce <maze_setWall>
    a3d8:	4a e0       	ldi	r20, 0x0A	; 10

	///////////////////////////////////////////////////////////////

	robot.pos.x = 1;
    a3da:	64 e0       	ldi	r22, 0x04	; 4
    a3dc:	88 e4       	ldi	r24, 0x48	; 72
	robot.pos.y = 1;
    a3de:	96 e1       	ldi	r25, 0x16	; 22
    a3e0:	f6 d8       	rcall	.-3604   	; 0x95ce <maze_setWall>
	robot.pos.z = 1;
    a3e2:	80 91 49 16 	lds	r24, 0x1649
	maze_setWall(&robot.pos, NORTH, -10);
    a3e6:	8f 5f       	subi	r24, 0xFF	; 255
    a3e8:	80 93 49 16 	sts	0x1649, r24
    a3ec:	4a e0       	ldi	r20, 0x0A	; 10
    a3ee:	61 e0       	ldi	r22, 0x01	; 1
    a3f0:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, EAST, -10);
    a3f2:	96 e1       	ldi	r25, 0x16	; 22
    a3f4:	ec d8       	rcall	.-3624   	; 0x95ce <maze_setWall>
    a3f6:	46 ef       	ldi	r20, 0xF6	; 246
    a3f8:	62 e0       	ldi	r22, 0x02	; 2
    a3fa:	88 e4       	ldi	r24, 0x48	; 72
    a3fc:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, SOUTH, 10);
    a3fe:	e7 d8       	rcall	.-3634   	; 0x95ce <maze_setWall>
    a400:	46 ef       	ldi	r20, 0xF6	; 246
    a402:	63 e0       	ldi	r22, 0x03	; 3
    a404:	88 e4       	ldi	r24, 0x48	; 72
    a406:	96 e1       	ldi	r25, 0x16	; 22
    a408:	e2 d8       	rcall	.-3644   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, WEST, 10);
    a40a:	4a e0       	ldi	r20, 0x0A	; 10
    a40c:	64 e0       	ldi	r22, 0x04	; 4
    a40e:	88 e4       	ldi	r24, 0x48	; 72
    a410:	96 e1       	ldi	r25, 0x16	; 22
    a412:	dd d8       	rcall	.-3654   	; 0x95ce <maze_setWall>
    a414:	80 91 48 16 	lds	r24, 0x1648

	robot.pos.y ++;
    a418:	8f 5f       	subi	r24, 0xFF	; 255
    a41a:	80 93 48 16 	sts	0x1648, r24
    a41e:	4a e0       	ldi	r20, 0x0A	; 10
	maze_setWall(&robot.pos, NORTH, -10);
    a420:	61 e0       	ldi	r22, 0x01	; 1
    a422:	88 e4       	ldi	r24, 0x48	; 72
    a424:	96 e1       	ldi	r25, 0x16	; 22
    a426:	d3 d8       	rcall	.-3674   	; 0x95ce <maze_setWall>
    a428:	46 ef       	ldi	r20, 0xF6	; 246
    a42a:	62 e0       	ldi	r22, 0x02	; 2
	maze_setWall(&robot.pos, EAST, -10);
    a42c:	88 e4       	ldi	r24, 0x48	; 72
    a42e:	96 e1       	ldi	r25, 0x16	; 22
    a430:	ce d8       	rcall	.-3684   	; 0x95ce <maze_setWall>
    a432:	46 ef       	ldi	r20, 0xF6	; 246
    a434:	63 e0       	ldi	r22, 0x03	; 3
    a436:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, SOUTH, -10);
    a438:	96 e1       	ldi	r25, 0x16	; 22
    a43a:	c9 d8       	rcall	.-3694   	; 0x95ce <maze_setWall>
    a43c:	46 ef       	ldi	r20, 0xF6	; 246
    a43e:	64 e0       	ldi	r22, 0x04	; 4
    a440:	88 e4       	ldi	r24, 0x48	; 72
    a442:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, WEST, 10);
    a444:	c4 d8       	rcall	.-3704   	; 0x95ce <maze_setWall>
    a446:	80 91 48 16 	lds	r24, 0x1648
    a44a:	8f 5f       	subi	r24, 0xFF	; 255
    a44c:	80 93 48 16 	sts	0x1648, r24

	robot.pos.y ++;
    a450:	4a e0       	ldi	r20, 0x0A	; 10
    a452:	61 e0       	ldi	r22, 0x01	; 1
    a454:	88 e4       	ldi	r24, 0x48	; 72
    a456:	96 e1       	ldi	r25, 0x16	; 22
    a458:	ba d8       	rcall	.-3724   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, NORTH, 10);
    a45a:	46 ef       	ldi	r20, 0xF6	; 246
    a45c:	62 e0       	ldi	r22, 0x02	; 2
    a45e:	88 e4       	ldi	r24, 0x48	; 72
    a460:	96 e1       	ldi	r25, 0x16	; 22
    a462:	b5 d8       	rcall	.-3734   	; 0x95ce <maze_setWall>
    a464:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, EAST, -10);
    a466:	63 e0       	ldi	r22, 0x03	; 3
    a468:	88 e4       	ldi	r24, 0x48	; 72
    a46a:	96 e1       	ldi	r25, 0x16	; 22
    a46c:	b0 d8       	rcall	.-3744   	; 0x95ce <maze_setWall>
    a46e:	46 ef       	ldi	r20, 0xF6	; 246
    a470:	64 e0       	ldi	r22, 0x04	; 4
	maze_setWall(&robot.pos, SOUTH, -10);
    a472:	88 e4       	ldi	r24, 0x48	; 72
    a474:	96 e1       	ldi	r25, 0x16	; 22
    a476:	ab d8       	rcall	.-3754   	; 0x95ce <maze_setWall>
    a478:	80 91 48 16 	lds	r24, 0x1648
    a47c:	8f 5f       	subi	r24, 0xFF	; 255
	maze_setWall(&robot.pos, WEST, 10);
    a47e:	80 93 48 16 	sts	0x1648, r24
    a482:	4a e0       	ldi	r20, 0x0A	; 10
    a484:	61 e0       	ldi	r22, 0x01	; 1
    a486:	88 e4       	ldi	r24, 0x48	; 72
    a488:	96 e1       	ldi	r25, 0x16	; 22

	robot.pos.x ++;
    a48a:	a1 d8       	rcall	.-3774   	; 0x95ce <maze_setWall>
    a48c:	46 ef       	ldi	r20, 0xF6	; 246
    a48e:	62 e0       	ldi	r22, 0x02	; 2
    a490:	88 e4       	ldi	r24, 0x48	; 72
    a492:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, NORTH, 10);
    a494:	9c d8       	rcall	.-3784   	; 0x95ce <maze_setWall>
    a496:	46 ef       	ldi	r20, 0xF6	; 246
    a498:	63 e0       	ldi	r22, 0x03	; 3
    a49a:	88 e4       	ldi	r24, 0x48	; 72
    a49c:	96 e1       	ldi	r25, 0x16	; 22
    a49e:	97 d8       	rcall	.-3794   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, EAST, -10);
    a4a0:	46 ef       	ldi	r20, 0xF6	; 246
    a4a2:	64 e0       	ldi	r22, 0x04	; 4
    a4a4:	88 e4       	ldi	r24, 0x48	; 72
    a4a6:	96 e1       	ldi	r25, 0x16	; 22
    a4a8:	92 d8       	rcall	.-3804   	; 0x95ce <maze_setWall>
    a4aa:	80 91 48 16 	lds	r24, 0x1648
	maze_setWall(&robot.pos, SOUTH, -10);
    a4ae:	8f 5f       	subi	r24, 0xFF	; 255
    a4b0:	80 93 48 16 	sts	0x1648, r24
    a4b4:	4a e0       	ldi	r20, 0x0A	; 10
    a4b6:	61 e0       	ldi	r22, 0x01	; 1
	maze_setWall(&robot.pos, WEST, -10);
    a4b8:	88 e4       	ldi	r24, 0x48	; 72
    a4ba:	96 e1       	ldi	r25, 0x16	; 22
    a4bc:	88 d8       	rcall	.-3824   	; 0x95ce <maze_setWall>
    a4be:	4a e0       	ldi	r20, 0x0A	; 10
    a4c0:	62 e0       	ldi	r22, 0x02	; 2
    a4c2:	88 e4       	ldi	r24, 0x48	; 72

	robot.pos.x ++;
    a4c4:	96 e1       	ldi	r25, 0x16	; 22
    a4c6:	83 d8       	rcall	.-3834   	; 0x95ce <maze_setWall>
    a4c8:	4a e0       	ldi	r20, 0x0A	; 10
    a4ca:	63 e0       	ldi	r22, 0x03	; 3
    a4cc:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, NORTH, 10);
    a4ce:	96 e1       	ldi	r25, 0x16	; 22
    a4d0:	7e d8       	rcall	.-3844   	; 0x95ce <maze_setWall>
    a4d2:	46 ef       	ldi	r20, 0xF6	; 246
    a4d4:	64 e0       	ldi	r22, 0x04	; 4
    a4d6:	88 e4       	ldi	r24, 0x48	; 72
    a4d8:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, EAST, -10);
    a4da:	79 d8       	rcall	.-3854   	; 0x95ce <maze_setWall>
    a4dc:	80 91 49 16 	lds	r24, 0x1649
    a4e0:	81 50       	subi	r24, 0x01	; 1
    a4e2:	80 93 49 16 	sts	0x1649, r24
	maze_setWall(&robot.pos, SOUTH, -10);
    a4e6:	4a e0       	ldi	r20, 0x0A	; 10
    a4e8:	64 e0       	ldi	r22, 0x04	; 4
    a4ea:	88 e4       	ldi	r24, 0x48	; 72
    a4ec:	96 e1       	ldi	r25, 0x16	; 22
    a4ee:	6f d8       	rcall	.-3874   	; 0x95ce <maze_setWall>
    a4f0:	80 91 49 16 	lds	r24, 0x1649
	maze_setWall(&robot.pos, WEST, -10);
    a4f4:	81 50       	subi	r24, 0x01	; 1
    a4f6:	80 93 49 16 	sts	0x1649, r24
    a4fa:	80 91 48 16 	lds	r24, 0x1648

	robot.pos.x ++;
    a4fe:	81 50       	subi	r24, 0x01	; 1
    a500:	80 93 48 16 	sts	0x1648, r24
    a504:	46 ef       	ldi	r20, 0xF6	; 246
    a506:	61 e0       	ldi	r22, 0x01	; 1
	maze_setWall(&robot.pos, NORTH, 10);
    a508:	88 e4       	ldi	r24, 0x48	; 72
    a50a:	96 e1       	ldi	r25, 0x16	; 22
    a50c:	60 d8       	rcall	.-3904   	; 0x95ce <maze_setWall>
    a50e:	4a e0       	ldi	r20, 0x0A	; 10
    a510:	62 e0       	ldi	r22, 0x02	; 2
    a512:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, EAST, -10);
    a514:	96 e1       	ldi	r25, 0x16	; 22
    a516:	5b d8       	rcall	.-3914   	; 0x95ce <maze_setWall>
    a518:	4a e0       	ldi	r20, 0x0A	; 10
    a51a:	63 e0       	ldi	r22, 0x03	; 3
    a51c:	88 e4       	ldi	r24, 0x48	; 72
    a51e:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, SOUTH, -10);
    a520:	56 d8       	rcall	.-3924   	; 0x95ce <maze_setWall>
    a522:	46 ef       	ldi	r20, 0xF6	; 246
    a524:	64 e0       	ldi	r22, 0x04	; 4
    a526:	88 e4       	ldi	r24, 0x48	; 72
    a528:	96 e1       	ldi	r25, 0x16	; 22
    a52a:	51 d8       	rcall	.-3934   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, WEST, -10);
    a52c:	80 91 48 16 	lds	r24, 0x1648
    a530:	81 50       	subi	r24, 0x01	; 1
    a532:	80 93 48 16 	sts	0x1648, r24
    a536:	46 ef       	ldi	r20, 0xF6	; 246

	robot.pos.x ++;
    a538:	61 e0       	ldi	r22, 0x01	; 1
    a53a:	88 e4       	ldi	r24, 0x48	; 72
    a53c:	96 e1       	ldi	r25, 0x16	; 22
    a53e:	47 d8       	rcall	.-3954   	; 0x95ce <maze_setWall>
    a540:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, NORTH, 10);
    a542:	62 e0       	ldi	r22, 0x02	; 2
    a544:	88 e4       	ldi	r24, 0x48	; 72
    a546:	96 e1       	ldi	r25, 0x16	; 22
    a548:	42 d8       	rcall	.-3964   	; 0x95ce <maze_setWall>
    a54a:	4a e0       	ldi	r20, 0x0A	; 10
    a54c:	63 e0       	ldi	r22, 0x03	; 3
	maze_setWall(&robot.pos, EAST, 10);
    a54e:	88 e4       	ldi	r24, 0x48	; 72
    a550:	96 e1       	ldi	r25, 0x16	; 22
    a552:	3d d8       	rcall	.-3974   	; 0x95ce <maze_setWall>
    a554:	46 ef       	ldi	r20, 0xF6	; 246
    a556:	64 e0       	ldi	r22, 0x04	; 4
    a558:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, SOUTH, 10);
    a55a:	96 e1       	ldi	r25, 0x16	; 22
    a55c:	38 d8       	rcall	.-3984   	; 0x95ce <maze_setWall>
    a55e:	80 91 48 16 	lds	r24, 0x1648
    a562:	81 50       	subi	r24, 0x01	; 1
    a564:	80 93 48 16 	sts	0x1648, r24
	maze_setWall(&robot.pos, WEST, -10);
    a568:	46 ef       	ldi	r20, 0xF6	; 246
    a56a:	61 e0       	ldi	r22, 0x01	; 1
    a56c:	88 e4       	ldi	r24, 0x48	; 72
    a56e:	96 e1       	ldi	r25, 0x16	; 22
    a570:	2e d8       	rcall	.-4004   	; 0x95ce <maze_setWall>

	robot.pos.y --;
    a572:	46 ef       	ldi	r20, 0xF6	; 246
    a574:	62 e0       	ldi	r22, 0x02	; 2
    a576:	88 e4       	ldi	r24, 0x48	; 72
    a578:	96 e1       	ldi	r25, 0x16	; 22
    a57a:	29 d8       	rcall	.-4014   	; 0x95ce <maze_setWall>
	maze_setWall(&robot.pos, WEST, 10);
    a57c:	4a e0       	ldi	r20, 0x0A	; 10
    a57e:	63 e0       	ldi	r22, 0x03	; 3
    a580:	88 e4       	ldi	r24, 0x48	; 72
    a582:	96 e1       	ldi	r25, 0x16	; 22
    a584:	24 d8       	rcall	.-4024   	; 0x95ce <maze_setWall>
    a586:	46 ef       	ldi	r20, 0xF6	; 246

	robot.pos.y --;
    a588:	64 e0       	ldi	r22, 0x04	; 4
    a58a:	88 e4       	ldi	r24, 0x48	; 72
    a58c:	96 e1       	ldi	r25, 0x16	; 22
    a58e:	1f d8       	rcall	.-4034   	; 0x95ce <maze_setWall>
    a590:	80 91 49 16 	lds	r24, 0x1649

	robot.pos.x --;
    a594:	8f 5f       	subi	r24, 0xFF	; 255
    a596:	80 93 49 16 	sts	0x1649, r24
    a59a:	46 ef       	ldi	r20, 0xF6	; 246
	maze_setWall(&robot.pos, NORTH, -10);
    a59c:	62 e0       	ldi	r22, 0x02	; 2
    a59e:	88 e4       	ldi	r24, 0x48	; 72
    a5a0:	96 e1       	ldi	r25, 0x16	; 22
    a5a2:	15 d8       	rcall	.-4054   	; 0x95ce <maze_setWall>
    a5a4:	80 91 48 16 	lds	r24, 0x1648
	maze_setWall(&robot.pos, EAST, 10);
    a5a8:	8f 5f       	subi	r24, 0xFF	; 255
    a5aa:	80 93 48 16 	sts	0x1648, r24
    a5ae:	46 ef       	ldi	r20, 0xF6	; 246
    a5b0:	62 e0       	ldi	r22, 0x02	; 2
    a5b2:	88 e4       	ldi	r24, 0x48	; 72
	maze_setWall(&robot.pos, SOUTH, 10);
    a5b4:	96 e1       	ldi	r25, 0x16	; 22
    a5b6:	0b d8       	rcall	.-4074   	; 0x95ce <maze_setWall>
    a5b8:	46 ef       	ldi	r20, 0xF6	; 246
    a5ba:	64 e0       	ldi	r22, 0x04	; 4
    a5bc:	88 e4       	ldi	r24, 0x48	; 72
    a5be:	96 e1       	ldi	r25, 0x16	; 22
	maze_setWall(&robot.pos, WEST, -10);
    a5c0:	06 d8       	rcall	.-4084   	; 0x95ce <maze_setWall>
    a5c2:	00 93 48 16 	sts	0x1648, r16
    a5c6:	10 93 49 16 	sts	0x1649, r17
    a5ca:	f0 92 4b 16 	sts	0x164B, r15

	robot.pos.x --;
    a5ce:	10 92 4a 16 	sts	0x164A, r1
    a5d2:	88 e0       	ldi	r24, 0x08	; 8
    a5d4:	80 93 c2 02 	sts	0x02C2, r24
	maze_setWall(&robot.pos, NORTH, -10);
    a5d8:	27 96       	adiw	r28, 0x07	; 7
    a5da:	e5 e0       	ldi	r30, 0x05	; 5
    a5dc:	0c 94 c4 6b 	jmp	0xd788	; 0xd788 <__epilogue_restores__+0x1a>

0000a5e0 <maze_getRampPosDir>:
//
// @return: 	NONE when there is no ramp, otherwise the direction of the ramp
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getRampPosDir(COORD *_coord)
{
    a5e0:	a3 e0       	ldi	r26, 0x03	; 3
    a5e2:	b0 e0       	ldi	r27, 0x00	; 0
    a5e4:	e6 ef       	ldi	r30, 0xF6	; 246
    a5e6:	f2 e5       	ldi	r31, 0x52	; 82
    a5e8:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	uint8_t returnvar = NONE;
	
	COORD c = *_coord;
    a5ec:	fc 01       	movw	r30, r24
    a5ee:	80 81       	ld	r24, Z
    a5f0:	91 81       	ldd	r25, Z+1	; 0x01
    a5f2:	a2 81       	ldd	r26, Z+2	; 0x02
    a5f4:	89 83       	std	Y+1, r24	; 0x01
    a5f6:	9a 83       	std	Y+2, r25	; 0x02
    a5f8:	ab 83       	std	Y+3, r26	; 0x03
	
	if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    a5fa:	ce 01       	movw	r24, r28
    a5fc:	01 96       	adiw	r24, 0x01	; 1
    a5fe:	0e 94 63 48 	call	0x90c6	; 0x90c6 <maze_adaptOffset>
    a602:	88 23       	and	r24, r24
    a604:	89 f0       	breq	.+34     	; 0xa628 <maze_getRampPosDir+0x48>
	{
		if((ramp[c.z].dir != NONE) &&
    a606:	eb 81       	ldd	r30, Y+3	; 0x03
    a608:	84 e0       	ldi	r24, 0x04	; 4
    a60a:	e8 02       	muls	r30, r24
    a60c:	f0 01       	movw	r30, r0
    a60e:	11 24       	eor	r1, r1
    a610:	e6 5b       	subi	r30, 0xB6	; 182
    a612:	f7 4f       	sbci	r31, 0xF7	; 247
    a614:	83 81       	ldd	r24, Z+3	; 0x03
    a616:	88 23       	and	r24, r24
    a618:	39 f0       	breq	.+14     	; 0xa628 <maze_getRampPosDir+0x48>
    a61a:	20 81       	ld	r18, Z
    a61c:	99 81       	ldd	r25, Y+1	; 0x01
    a61e:	29 13       	cpse	r18, r25
    a620:	03 c0       	rjmp	.+6      	; 0xa628 <maze_getRampPosDir+0x48>
			 (ramp[c.z].pos.x == c.x) &&
    a622:	21 81       	ldd	r18, Z+1	; 0x01
    a624:	9a 81       	ldd	r25, Y+2	; 0x02
    a626:	29 13       	cpse	r18, r25
// @return: 	NONE when there is no ramp, otherwise the direction of the ramp
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getRampPosDir(COORD *_coord)
{
	uint8_t returnvar = NONE;
    a628:	80 e0       	ldi	r24, 0x00	; 0
			returnvar = ramp[c.z].dir;
		}
	}
	
	return returnvar;
}
    a62a:	23 96       	adiw	r28, 0x03	; 3
    a62c:	e2 e0       	ldi	r30, 0x02	; 2
    a62e:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

0000a632 <maze_getRampPosDirAtDir>:
//
// @return: 	NONE when there is no ramp, otherwise the direction of the ramp
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getRampPosDirAtDir(COORD *_coord, int8_t dir)
{
    a632:	a3 e0       	ldi	r26, 0x03	; 3
    a634:	b0 e0       	ldi	r27, 0x00	; 0
    a636:	ef e1       	ldi	r30, 0x1F	; 31
    a638:	f3 e5       	ldi	r31, 0x53	; 83
    a63a:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	uint8_t returnvar = NONE;
	
	COORD c = *_coord;
    a63e:	fc 01       	movw	r30, r24
    a640:	80 81       	ld	r24, Z
    a642:	91 81       	ldd	r25, Z+1	; 0x01
    a644:	a2 81       	ldd	r26, Z+2	; 0x02
    a646:	89 83       	std	Y+1, r24	; 0x01
    a648:	9a 83       	std	Y+2, r25	; 0x02
    a64a:	ab 83       	std	Y+3, r26	; 0x03
	
	switch(dir)
    a64c:	62 30       	cpi	r22, 0x02	; 2
    a64e:	b1 f0       	breq	.+44     	; 0xa67c <maze_getRampPosDirAtDir+0x4a>
    a650:	3c f4       	brge	.+14     	; 0xa660 <maze_getRampPosDirAtDir+0x2e>
    a652:	66 23       	and	r22, r22
    a654:	79 f0       	breq	.+30     	; 0xa674 <maze_getRampPosDirAtDir+0x42>
    a656:	61 30       	cpi	r22, 0x01	; 1
    a658:	a9 f4       	brne	.+42     	; 0xa684 <maze_getRampPosDirAtDir+0x52>
	{
		case NONE:				returnvar = maze_getRampPosDir(&c);		break;
		case NORTH:	c.y ++;		returnvar = maze_getRampPosDir(&c);		break;
    a65a:	8a 81       	ldd	r24, Y+2	; 0x02
    a65c:	8f 5f       	subi	r24, 0xFF	; 255
    a65e:	09 c0       	rjmp	.+18     	; 0xa672 <maze_getRampPosDirAtDir+0x40>
{
	uint8_t returnvar = NONE;
	
	COORD c = *_coord;
	
	switch(dir)
    a660:	63 30       	cpi	r22, 0x03	; 3
    a662:	29 f0       	breq	.+10     	; 0xa66e <maze_getRampPosDirAtDir+0x3c>
    a664:	64 30       	cpi	r22, 0x04	; 4
    a666:	71 f4       	brne	.+28     	; 0xa684 <maze_getRampPosDirAtDir+0x52>
	{
		case NONE:				returnvar = maze_getRampPosDir(&c);		break;
		case NORTH:	c.y ++;		returnvar = maze_getRampPosDir(&c);		break;
		case EAST:	c.x ++;		returnvar = maze_getRampPosDir(&c);		break;
		case SOUTH:	c.y --;		returnvar = maze_getRampPosDir(&c);		break;
		case WEST:	c.x --;		returnvar = maze_getRampPosDir(&c);		break;
    a668:	89 81       	ldd	r24, Y+1	; 0x01
    a66a:	81 50       	subi	r24, 0x01	; 1
    a66c:	09 c0       	rjmp	.+18     	; 0xa680 <maze_getRampPosDirAtDir+0x4e>
	switch(dir)
	{
		case NONE:				returnvar = maze_getRampPosDir(&c);		break;
		case NORTH:	c.y ++;		returnvar = maze_getRampPosDir(&c);		break;
		case EAST:	c.x ++;		returnvar = maze_getRampPosDir(&c);		break;
		case SOUTH:	c.y --;		returnvar = maze_getRampPosDir(&c);		break;
    a66e:	8a 81       	ldd	r24, Y+2	; 0x02
    a670:	81 50       	subi	r24, 0x01	; 1
	COORD c = *_coord;
	
	switch(dir)
	{
		case NONE:				returnvar = maze_getRampPosDir(&c);		break;
		case NORTH:	c.y ++;		returnvar = maze_getRampPosDir(&c);		break;
    a672:	8a 83       	std	Y+2, r24	; 0x02
    a674:	ce 01       	movw	r24, r28
    a676:	01 96       	adiw	r24, 0x01	; 1
    a678:	b3 df       	rcall	.-154    	; 0xa5e0 <maze_getRampPosDir>
    a67a:	1e c0       	rjmp	.+60     	; 0xa6b8 <maze_getRampPosDirAtDir+0x86>
    a67c:	89 81       	ldd	r24, Y+1	; 0x01
		case EAST:	c.x ++;		returnvar = maze_getRampPosDir(&c);		break;
    a67e:	8f 5f       	subi	r24, 0xFF	; 255
    a680:	89 83       	std	Y+1, r24	; 0x01
		case SOUTH:	c.y --;		returnvar = maze_getRampPosDir(&c);		break;
		case WEST:	c.x --;		returnvar = maze_getRampPosDir(&c);		break;
    a682:	f8 cf       	rjmp	.-16     	; 0xa674 <maze_getRampPosDirAtDir+0x42>
    a684:	80 91 53 05 	lds	r24, 0x0553
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
    a688:	82 30       	cpi	r24, 0x02	; 2
    a68a:	90 f0       	brcs	.+36     	; 0xa6b0 <maze_getRampPosDirAtDir+0x7e>
    a68c:	85 e8       	ldi	r24, 0x85	; 133
    a68e:	9b e2       	ldi	r25, 0x2B	; 43
    a690:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    a694:	60 91 47 05 	lds	r22, 0x0547
    a698:	70 91 48 05 	lds	r23, 0x0548
    a69c:	80 91 49 05 	lds	r24, 0x0549
    a6a0:	90 91 4a 05 	lds	r25, 0x054A
    a6a4:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    a6a8:	8f e4       	ldi	r24, 0x4F	; 79
    a6aa:	9b e2       	ldi	r25, 0x2B	; 43
    a6ac:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    a6b0:	81 e0       	ldi	r24, 0x01	; 1
							fatal_err = 1;
    a6b2:	80 93 63 05 	sts	0x0563, r24
    a6b6:	80 e0       	ldi	r24, 0x00	; 0
// @return: 	NONE when there is no ramp, otherwise the direction of the ramp
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getRampPosDirAtDir(COORD *_coord, int8_t dir)
{
	uint8_t returnvar = NONE;
    a6b8:	23 96       	adiw	r28, 0x03	; 3
		default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.18]:DEFAULT_CASE"));}
							fatal_err = 1;
	}
	
	return returnvar;
}
    a6ba:	e2 e0       	ldi	r30, 0x02	; 2
    a6bc:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

0000a6c0 <maze_getBeenthere>:
//						robot visited this tile yet?), in case something went wrong
//						MAZE_ERROR
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getBeenthere(COORD *_coord, int8_t dir) 
{
    a6c0:	a4 e0       	ldi	r26, 0x04	; 4
    a6c2:	b0 e0       	ldi	r27, 0x00	; 0
    a6c4:	e6 e6       	ldi	r30, 0x66	; 102
    a6c6:	f3 e5       	ldi	r31, 0x53	; 83
    a6c8:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    a6cc:	8c 01       	movw	r16, r24
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    a6ce:	65 30       	cpi	r22, 0x05	; 5
    a6d0:	10 f0       	brcs	.+4      	; 0xa6d6 <maze_getBeenthere+0x16>
		dir -= WEST;
    a6d2:	64 50       	subi	r22, 0x04	; 4
    a6d4:	fc cf       	rjmp	.-8      	; 0xa6ce <maze_getBeenthere+0xe>
int8_t maze_getBeenthere(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
    a6d6:	66 23       	and	r22, r22
    a6d8:	19 f1       	breq	.+70     	; 0xa720 <maze_getBeenthere+0x60>
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
    a6da:	c8 01       	movw	r24, r16
    a6dc:	6c 83       	std	Y+4, r22	; 0x04
    a6de:	80 df       	rcall	.-256    	; 0xa5e0 <maze_getRampPosDir>
    a6e0:	6c 81       	ldd	r22, Y+4	; 0x04
int8_t maze_getBeenthere(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
    a6e2:	86 13       	cpse	r24, r22
    a6e4:	1d c0       	rjmp	.+58     	; 0xa720 <maze_getBeenthere+0x60>
    a6e6:	f8 01       	movw	r30, r16
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
		COORD _ramp = *_coord;
    a6e8:	80 81       	ld	r24, Z
    a6ea:	91 81       	ldd	r25, Z+1	; 0x01
    a6ec:	a2 81       	ldd	r26, Z+2	; 0x02
    a6ee:	89 83       	std	Y+1, r24	; 0x01
    a6f0:	9a 83       	std	Y+2, r25	; 0x02
    a6f2:	ab 83       	std	Y+3, r26	; 0x03
    a6f4:	8b 81       	ldd	r24, Y+3	; 0x03
		
		_ramp.z ++; //Works only in arenas with two stages...
    a6f6:	8f 5f       	subi	r24, 0xFF	; 255
    a6f8:	82 30       	cpi	r24, 0x02	; 2
		if(_ramp.z >= MAZE_SAVESTAGE)
    a6fa:	14 f4       	brge	.+4      	; 0xa700 <maze_getBeenthere+0x40>
    a6fc:	8b 83       	std	Y+3, r24	; 0x03
	if((dir != NONE) &&
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
		COORD _ramp = *_coord;
		
		_ramp.z ++; //Works only in arenas with two stages...
    a6fe:	01 c0       	rjmp	.+2      	; 0xa702 <maze_getBeenthere+0x42>
    a700:	1b 82       	std	Y+3, r1	; 0x03
		if(_ramp.z >= MAZE_SAVESTAGE)
			_ramp.z = 0;
    a702:	8b 81       	ldd	r24, Y+3	; 0x03
			
		_ramp = *maze_getRamp(_ramp.z);
    a704:	0e 94 f4 47 	call	0x8fe8	; 0x8fe8 <maze_getRamp>
    a708:	fc 01       	movw	r30, r24
    a70a:	80 81       	ld	r24, Z
    a70c:	91 81       	ldd	r25, Z+1	; 0x01
    a70e:	a2 81       	ldd	r26, Z+2	; 0x02
    a710:	89 83       	std	Y+1, r24	; 0x01
    a712:	9a 83       	std	Y+2, r25	; 0x02
    a714:	ab 83       	std	Y+3, r26	; 0x03
    a716:	60 e0       	ldi	r22, 0x00	; 0
		returnvar = maze_getBeenthere(&_ramp, NONE);
    a718:	ce 01       	movw	r24, r28
    a71a:	01 96       	adiw	r24, 0x01	; 1
    a71c:	d1 df       	rcall	.-94     	; 0xa6c0 <maze_getBeenthere>
    a71e:	9f c0       	rjmp	.+318    	; 0xa85e <maze_getBeenthere+0x19e>
    a720:	f8 01       	movw	r30, r16
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
    a722:	80 81       	ld	r24, Z
		_ramp = *maze_getRamp(_ramp.z);
		returnvar = maze_getBeenthere(&_ramp, NONE);
	}
	else
	{
		COORD c = *_coord;
    a724:	91 81       	ldd	r25, Z+1	; 0x01
    a726:	a2 81       	ldd	r26, Z+2	; 0x02
    a728:	89 83       	std	Y+1, r24	; 0x01
    a72a:	9a 83       	std	Y+2, r25	; 0x02
    a72c:	ab 83       	std	Y+3, r26	; 0x03
    a72e:	ce 01       	movw	r24, r28
    a730:	01 96       	adiw	r24, 0x01	; 1
		
		if(maze_adaptOffset(&c)) //Adapt position to offset of the map in the memory (RAM)
    a732:	6c 83       	std	Y+4, r22	; 0x04
    a734:	0e 94 63 48 	call	0x90c6	; 0x90c6 <maze_adaptOffset>
    a738:	6c 81       	ldd	r22, Y+4	; 0x04
    a73a:	88 23       	and	r24, r24
    a73c:	09 f4       	brne	.+2      	; 0xa740 <maze_getBeenthere+0x80>
    a73e:	8e c0       	rjmp	.+284    	; 0xa85c <maze_getBeenthere+0x19c>
    a740:	4b 81       	ldd	r20, Y+3	; 0x03
    a742:	2a 81       	ldd	r18, Y+2	; 0x02
    a744:	59 81       	ldd	r21, Y+1	; 0x01
    a746:	62 30       	cpi	r22, 0x02	; 2
    a748:	09 f1       	breq	.+66     	; 0xa78c <maze_getBeenthere+0xcc>
		{
			switch(dir)
    a74a:	1c f4       	brge	.+6      	; 0xa752 <maze_getBeenthere+0x92>
    a74c:	61 30       	cpi	r22, 0x01	; 1
    a74e:	71 f0       	breq	.+28     	; 0xa76c <maze_getBeenthere+0xac>
    a750:	05 c0       	rjmp	.+10     	; 0xa75c <maze_getBeenthere+0x9c>
    a752:	63 30       	cpi	r22, 0x03	; 3
    a754:	69 f1       	breq	.+90     	; 0xa7b0 <maze_getBeenthere+0xf0>
    a756:	64 30       	cpi	r22, 0x04	; 4
    a758:	09 f4       	brne	.+2      	; 0xa75c <maze_getBeenthere+0x9c>
    a75a:	55 c0       	rjmp	.+170    	; 0xa806 <maze_getBeenthere+0x146>
    a75c:	61 e1       	ldi	r22, 0x11	; 17
    a75e:	71 e0       	ldi	r23, 0x01	; 1
			{
				case NONE:
								returnvar = maze[c.x][c.y][c.z].beenthere;
    a760:	56 03       	mulsu	r21, r22
    a762:	f0 01       	movw	r30, r0
    a764:	57 9f       	mul	r21, r23
    a766:	f0 0d       	add	r31, r0
    a768:	11 24       	eor	r1, r1
    a76a:	5d c0       	rjmp	.+186    	; 0xa826 <maze_getBeenthere+0x166>
    a76c:	2c 30       	cpi	r18, 0x0C	; 12
    a76e:	34 f4       	brge	.+12     	; 0xa77c <maze_getBeenthere+0xbc>
							break;
				case NORTH:
								if((c.y + 1) <= (MAZE_SIZE_Y-1))	returnvar = maze[c.x][c.y + 1][c.z].beenthere;
    a770:	33 27       	eor	r19, r19
    a772:	27 fd       	sbrc	r18, 7
    a774:	30 95       	com	r19
    a776:	2f 5f       	subi	r18, 0xFF	; 255
    a778:	3f 4f       	sbci	r19, 0xFF	; 255
    a77a:	21 c0       	rjmp	.+66     	; 0xa7be <maze_getBeenthere+0xfe>
    a77c:	21 e1       	ldi	r18, 0x11	; 17
    a77e:	31 e0       	ldi	r19, 0x01	; 1
								else								returnvar = maze[c.x][0		 ][c.z].beenthere;
    a780:	52 03       	mulsu	r21, r18
    a782:	f0 01       	movw	r30, r0
    a784:	53 9f       	mul	r21, r19
    a786:	f0 0d       	add	r31, r0
    a788:	11 24       	eor	r1, r1
    a78a:	0c c0       	rjmp	.+24     	; 0xa7a4 <maze_getBeenthere+0xe4>
    a78c:	5c 30       	cpi	r21, 0x0C	; 12
    a78e:	34 f4       	brge	.+12     	; 0xa79c <maze_getBeenthere+0xdc>
							break;
				case EAST:
								if((c.x + 1) <= (MAZE_SIZE_X-1))	returnvar = maze[c.x + 1][c.y][c.z].beenthere;
    a790:	85 2f       	mov	r24, r21
    a792:	99 27       	eor	r25, r25
    a794:	87 fd       	sbrc	r24, 7
    a796:	90 95       	com	r25
    a798:	01 96       	adiw	r24, 0x01	; 1
    a79a:	3c c0       	rjmp	.+120    	; 0xa814 <maze_getBeenthere+0x154>
    a79c:	85 e1       	ldi	r24, 0x15	; 21
    a79e:	28 02       	muls	r18, r24
								else								returnvar = maze[0		][c.y][c.z].beenthere;
    a7a0:	f0 01       	movw	r30, r0
    a7a2:	11 24       	eor	r1, r1
    a7a4:	87 e0       	ldi	r24, 0x07	; 7
    a7a6:	48 02       	muls	r20, r24
    a7a8:	e0 0d       	add	r30, r0
    a7aa:	f1 1d       	adc	r31, r1
    a7ac:	11 24       	eor	r1, r1
    a7ae:	45 c0       	rjmp	.+138    	; 0xa83a <maze_getBeenthere+0x17a>
    a7b0:	12 16       	cp	r1, r18
    a7b2:	d4 f4       	brge	.+52     	; 0xa7e8 <maze_getBeenthere+0x128>
							break;
				case SOUTH:
								if((c.y - 1) >= 0)					returnvar = maze[c.x][c.y - 1	   ][c.z].beenthere;
    a7b4:	33 27       	eor	r19, r19
    a7b6:	27 fd       	sbrc	r18, 7
    a7b8:	30 95       	com	r19
    a7ba:	21 50       	subi	r18, 0x01	; 1
    a7bc:	31 09       	sbc	r19, r1
    a7be:	61 e1       	ldi	r22, 0x11	; 17
    a7c0:	71 e0       	ldi	r23, 0x01	; 1
    a7c2:	56 03       	mulsu	r21, r22
    a7c4:	f0 01       	movw	r30, r0
    a7c6:	57 9f       	mul	r21, r23
    a7c8:	f0 0d       	add	r31, r0
    a7ca:	11 24       	eor	r1, r1
    a7cc:	87 e0       	ldi	r24, 0x07	; 7
    a7ce:	48 02       	muls	r20, r24
    a7d0:	e0 0d       	add	r30, r0
    a7d2:	f1 1d       	adc	r31, r1
    a7d4:	11 24       	eor	r1, r1
    a7d6:	45 e1       	ldi	r20, 0x15	; 21
    a7d8:	42 9f       	mul	r20, r18
    a7da:	c0 01       	movw	r24, r0
    a7dc:	43 9f       	mul	r20, r19
    a7de:	90 0d       	add	r25, r0
    a7e0:	11 24       	eor	r1, r1
    a7e2:	e8 0f       	add	r30, r24
    a7e4:	f9 1f       	adc	r31, r25
    a7e6:	29 c0       	rjmp	.+82     	; 0xa83a <maze_getBeenthere+0x17a>
    a7e8:	21 e1       	ldi	r18, 0x11	; 17
    a7ea:	31 e0       	ldi	r19, 0x01	; 1
								else								returnvar = maze[c.x][MAZE_SIZE_Y-1][c.z].beenthere;
    a7ec:	52 03       	mulsu	r21, r18
    a7ee:	f0 01       	movw	r30, r0
    a7f0:	53 9f       	mul	r21, r19
    a7f2:	f0 0d       	add	r31, r0
    a7f4:	11 24       	eor	r1, r1
    a7f6:	87 e0       	ldi	r24, 0x07	; 7
    a7f8:	48 02       	muls	r20, r24
    a7fa:	e0 0d       	add	r30, r0
    a7fc:	f1 1d       	adc	r31, r1
    a7fe:	11 24       	eor	r1, r1
    a800:	e9 5a       	subi	r30, 0xA9	; 169
    a802:	f6 4f       	sbci	r31, 0xF6	; 246
    a804:	28 c0       	rjmp	.+80     	; 0xa856 <maze_getBeenthere+0x196>
    a806:	15 16       	cp	r1, r21
    a808:	dc f4       	brge	.+54     	; 0xa840 <maze_getBeenthere+0x180>
							break;
				case WEST:
								if((c.x - 1) >= 0)					returnvar = maze[c.x - 1	  ][c.y][c.z].beenthere;
    a80a:	85 2f       	mov	r24, r21
    a80c:	99 27       	eor	r25, r25
    a80e:	87 fd       	sbrc	r24, 7
    a810:	90 95       	com	r25
    a812:	01 97       	sbiw	r24, 0x01	; 1
    a814:	61 e1       	ldi	r22, 0x11	; 17
    a816:	71 e0       	ldi	r23, 0x01	; 1
    a818:	86 9f       	mul	r24, r22
    a81a:	f0 01       	movw	r30, r0
    a81c:	87 9f       	mul	r24, r23
    a81e:	f0 0d       	add	r31, r0
    a820:	96 9f       	mul	r25, r22
    a822:	f0 0d       	add	r31, r0
    a824:	11 24       	eor	r1, r1
    a826:	87 e0       	ldi	r24, 0x07	; 7
    a828:	48 02       	muls	r20, r24
    a82a:	e0 0d       	add	r30, r0
    a82c:	f1 1d       	adc	r31, r1
    a82e:	11 24       	eor	r1, r1
    a830:	85 e1       	ldi	r24, 0x15	; 21
    a832:	28 02       	muls	r18, r24
    a834:	e0 0d       	add	r30, r0
    a836:	f1 1d       	adc	r31, r1
    a838:	11 24       	eor	r1, r1
    a83a:	e5 5a       	subi	r30, 0xA5	; 165
    a83c:	f7 4f       	sbci	r31, 0xF7	; 247
    a83e:	0b c0       	rjmp	.+22     	; 0xa856 <maze_getBeenthere+0x196>
    a840:	85 e1       	ldi	r24, 0x15	; 21
    a842:	28 02       	muls	r18, r24
								else								returnvar = maze[MAZE_SIZE_X-1][c.y][c.z].beenthere;
    a844:	f0 01       	movw	r30, r0
    a846:	11 24       	eor	r1, r1
    a848:	87 e0       	ldi	r24, 0x07	; 7
    a84a:	48 02       	muls	r20, r24
    a84c:	e0 0d       	add	r30, r0
    a84e:	f1 1d       	adc	r31, r1
    a850:	11 24       	eor	r1, r1
    a852:	e9 5d       	subi	r30, 0xD9	; 217
    a854:	fa 4e       	sbci	r31, 0xEA	; 234
    a856:	80 81       	ld	r24, Z
    a858:	81 70       	andi	r24, 0x01	; 1
    a85a:	01 c0       	rjmp	.+2      	; 0xa85e <maze_getBeenthere+0x19e>
    a85c:	8f e7       	ldi	r24, 0x7F	; 127
    a85e:	24 96       	adiw	r28, 0x04	; 4
//						MAZE_ERROR
////////////////////////////////////////////////////////////////////////////////

int8_t maze_getBeenthere(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
    a860:	e4 e0       	ldi	r30, 0x04	; 4
			}
		}
	}
	
	return returnvar;
}
    a862:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000a866 <maze_stageGetOuterSize>:
// stage
//
////////////////////////////////////////////////////////////////////////////////

void maze_stageGetOuterSize(COORD *_size)
{
    a866:	a3 e0       	ldi	r26, 0x03	; 3
    a868:	b0 e0       	ldi	r27, 0x00	; 0
    a86a:	e9 e3       	ldi	r30, 0x39	; 57
    a86c:	f4 e5       	ldi	r31, 0x54	; 84
    a86e:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    a872:	8c 01       	movw	r16, r24
	_size->x = 0;
    a874:	fc 01       	movw	r30, r24
    a876:	10 82       	st	Z, r1
	_size->y = 0;
    a878:	11 82       	std	Z+1, r1	; 0x01
	
	COORD maze_tmp;
	maze_tmp.z = _size->z;
    a87a:	82 81       	ldd	r24, Z+2	; 0x02
    a87c:	8b 83       	std	Y+3, r24	; 0x03
	
	for(maze_tmp.x = 0; maze_tmp.x < MAZE_SIZE_X_USABLE; maze_tmp.x++)
    a87e:	19 82       	std	Y+1, r1	; 0x01
    a880:	89 81       	ldd	r24, Y+1	; 0x01
    a882:	8c 30       	cpi	r24, 0x0C	; 12
    a884:	f4 f4       	brge	.+60     	; 0xa8c2 <maze_stageGetOuterSize+0x5c>
	{
		for(maze_tmp.y = 0; maze_tmp.y < MAZE_SIZE_Y_USABLE; maze_tmp.y++)
    a886:	1a 82       	std	Y+2, r1	; 0x02
    a888:	8a 81       	ldd	r24, Y+2	; 0x02
    a88a:	8c 30       	cpi	r24, 0x0C	; 12
    a88c:	b4 f4       	brge	.+44     	; 0xa8ba <maze_stageGetOuterSize+0x54>
		{
			uint8_t beenthere = maze_getBeenthere(&maze_tmp, NONE);
    a88e:	60 e0       	ldi	r22, 0x00	; 0
    a890:	ce 01       	movw	r24, r28
    a892:	01 96       	adiw	r24, 0x01	; 1
    a894:	15 df       	rcall	.-470    	; 0xa6c0 <maze_getBeenthere>
    a896:	9a 81       	ldd	r25, Y+2	; 0x02
    a898:	88 23       	and	r24, r24
			if(beenthere && (maze_tmp.x > _size->x))
    a89a:	61 f0       	breq	.+24     	; 0xa8b4 <maze_stageGetOuterSize+0x4e>
    a89c:	89 81       	ldd	r24, Y+1	; 0x01
    a89e:	f8 01       	movw	r30, r16
    a8a0:	20 81       	ld	r18, Z
    a8a2:	28 17       	cp	r18, r24
    a8a4:	0c f4       	brge	.+2      	; 0xa8a8 <maze_stageGetOuterSize+0x42>
    a8a6:	80 83       	st	Z, r24
				_size->x = maze_tmp.x;
    a8a8:	f8 01       	movw	r30, r16
			if(beenthere && (maze_tmp.y > _size->y))
    a8aa:	81 81       	ldd	r24, Z+1	; 0x01
    a8ac:	89 17       	cp	r24, r25
    a8ae:	14 f4       	brge	.+4      	; 0xa8b4 <maze_stageGetOuterSize+0x4e>
    a8b0:	f8 01       	movw	r30, r16
				_size->y = maze_tmp.y;
    a8b2:	91 83       	std	Z+1, r25	; 0x01
    a8b4:	9f 5f       	subi	r25, 0xFF	; 255
	COORD maze_tmp;
	maze_tmp.z = _size->z;
	
	for(maze_tmp.x = 0; maze_tmp.x < MAZE_SIZE_X_USABLE; maze_tmp.x++)
	{
		for(maze_tmp.y = 0; maze_tmp.y < MAZE_SIZE_Y_USABLE; maze_tmp.y++)
    a8b6:	9a 83       	std	Y+2, r25	; 0x02
    a8b8:	e7 cf       	rjmp	.-50     	; 0xa888 <maze_stageGetOuterSize+0x22>
    a8ba:	89 81       	ldd	r24, Y+1	; 0x01
	_size->y = 0;
	
	COORD maze_tmp;
	maze_tmp.z = _size->z;
	
	for(maze_tmp.x = 0; maze_tmp.x < MAZE_SIZE_X_USABLE; maze_tmp.x++)
    a8bc:	8f 5f       	subi	r24, 0xFF	; 255
    a8be:	89 83       	std	Y+1, r24	; 0x01
    a8c0:	df cf       	rjmp	.-66     	; 0xa880 <maze_stageGetOuterSize+0x1a>
    a8c2:	23 96       	adiw	r28, 0x03	; 3
				_size->x = maze_tmp.x;
			if(beenthere && (maze_tmp.y > _size->y))
				_size->y = maze_tmp.y;
		}
	}
}
    a8c4:	e4 e0       	ldi	r30, 0x04	; 4
    a8c6:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000a8ca <maze_stageGetInnerSize>:
// stage
//
////////////////////////////////////////////////////////////////////////////////

void maze_stageGetInnerSize(COORD *_size)
{
    a8ca:	a3 e0       	ldi	r26, 0x03	; 3
    a8cc:	b0 e0       	ldi	r27, 0x00	; 0
    a8ce:	eb e6       	ldi	r30, 0x6B	; 107
    a8d0:	f4 e5       	ldi	r31, 0x54	; 84
    a8d2:	0c 94 a8 6b 	jmp	0xd750	; 0xd750 <__prologue_saves__+0x1a>
    a8d6:	8c 01       	movw	r16, r24
	_size->x = MAZE_SIZE_X;
    a8d8:	8d e0       	ldi	r24, 0x0D	; 13
    a8da:	f8 01       	movw	r30, r16
    a8dc:	80 83       	st	Z, r24
	_size->y = MAZE_SIZE_Y;
    a8de:	81 83       	std	Z+1, r24	; 0x01
	
	COORD maze_tmp;
	maze_tmp.z = _size->z;
    a8e0:	82 81       	ldd	r24, Z+2	; 0x02
    a8e2:	8b 83       	std	Y+3, r24	; 0x03
	
	for(maze_tmp.x = MAZE_SIZE_X_USABLE; maze_tmp.x >= 0 ; maze_tmp.x--)
    a8e4:	8c e0       	ldi	r24, 0x0C	; 12
    a8e6:	89 83       	std	Y+1, r24	; 0x01
	{
		for(maze_tmp.y = MAZE_SIZE_Y_USABLE; maze_tmp.y >= 0; maze_tmp.y--)
    a8e8:	7c e0       	ldi	r23, 0x0C	; 12
    a8ea:	f7 2e       	mov	r15, r23
	_size->y = MAZE_SIZE_Y;
	
	COORD maze_tmp;
	maze_tmp.z = _size->z;
	
	for(maze_tmp.x = MAZE_SIZE_X_USABLE; maze_tmp.x >= 0 ; maze_tmp.x--)
    a8ec:	89 81       	ldd	r24, Y+1	; 0x01
    a8ee:	87 fd       	sbrc	r24, 7
    a8f0:	1e c0       	rjmp	.+60     	; 0xa92e <maze_stageGetInnerSize+0x64>
	{
		for(maze_tmp.y = MAZE_SIZE_Y_USABLE; maze_tmp.y >= 0; maze_tmp.y--)
    a8f2:	fa 82       	std	Y+2, r15	; 0x02
    a8f4:	8a 81       	ldd	r24, Y+2	; 0x02
    a8f6:	87 fd       	sbrc	r24, 7
    a8f8:	16 c0       	rjmp	.+44     	; 0xa926 <maze_stageGetInnerSize+0x5c>
		{
			uint8_t beenthere = maze_getBeenthere(&maze_tmp, NONE);
    a8fa:	60 e0       	ldi	r22, 0x00	; 0
    a8fc:	ce 01       	movw	r24, r28
    a8fe:	01 96       	adiw	r24, 0x01	; 1
    a900:	df de       	rcall	.-578    	; 0xa6c0 <maze_getBeenthere>
    a902:	9a 81       	ldd	r25, Y+2	; 0x02
    a904:	88 23       	and	r24, r24
			if(beenthere && (maze_tmp.x < _size->x))
    a906:	61 f0       	breq	.+24     	; 0xa920 <maze_stageGetInnerSize+0x56>
    a908:	89 81       	ldd	r24, Y+1	; 0x01
    a90a:	f8 01       	movw	r30, r16
    a90c:	20 81       	ld	r18, Z
    a90e:	82 17       	cp	r24, r18
    a910:	0c f4       	brge	.+2      	; 0xa914 <maze_stageGetInnerSize+0x4a>
    a912:	80 83       	st	Z, r24
				_size->x = maze_tmp.x;
    a914:	f8 01       	movw	r30, r16
			if(beenthere && (maze_tmp.y < _size->y))
    a916:	81 81       	ldd	r24, Z+1	; 0x01
    a918:	98 17       	cp	r25, r24
    a91a:	14 f4       	brge	.+4      	; 0xa920 <maze_stageGetInnerSize+0x56>
    a91c:	f8 01       	movw	r30, r16
				_size->y = maze_tmp.y;
    a91e:	91 83       	std	Z+1, r25	; 0x01
    a920:	91 50       	subi	r25, 0x01	; 1
	COORD maze_tmp;
	maze_tmp.z = _size->z;
	
	for(maze_tmp.x = MAZE_SIZE_X_USABLE; maze_tmp.x >= 0 ; maze_tmp.x--)
	{
		for(maze_tmp.y = MAZE_SIZE_Y_USABLE; maze_tmp.y >= 0; maze_tmp.y--)
    a922:	9a 83       	std	Y+2, r25	; 0x02
    a924:	e7 cf       	rjmp	.-50     	; 0xa8f4 <maze_stageGetInnerSize+0x2a>
    a926:	89 81       	ldd	r24, Y+1	; 0x01
	_size->y = MAZE_SIZE_Y;
	
	COORD maze_tmp;
	maze_tmp.z = _size->z;
	
	for(maze_tmp.x = MAZE_SIZE_X_USABLE; maze_tmp.x >= 0 ; maze_tmp.x--)
    a928:	81 50       	subi	r24, 0x01	; 1
    a92a:	89 83       	std	Y+1, r24	; 0x01
    a92c:	df cf       	rjmp	.-66     	; 0xa8ec <maze_stageGetInnerSize+0x22>
    a92e:	f8 01       	movw	r30, r16
			if(beenthere && (maze_tmp.y < _size->y))
				_size->y = maze_tmp.y;
		}
	}
	
	if(_size->x == MAZE_SIZE_X)
    a930:	80 81       	ld	r24, Z
    a932:	8d 30       	cpi	r24, 0x0D	; 13
    a934:	09 f4       	brne	.+2      	; 0xa938 <maze_stageGetInnerSize+0x6e>
    a936:	10 82       	st	Z, r1
		_size->x = 0;
    a938:	f8 01       	movw	r30, r16
	if(_size->y == MAZE_SIZE_Y)
    a93a:	81 81       	ldd	r24, Z+1	; 0x01
    a93c:	8d 30       	cpi	r24, 0x0D	; 13
    a93e:	09 f4       	brne	.+2      	; 0xa942 <maze_stageGetInnerSize+0x78>
    a940:	11 82       	std	Z+1, r1	; 0x01
		_size->y = 0;
    a942:	23 96       	adiw	r28, 0x03	; 3
}
    a944:	e5 e0       	ldi	r30, 0x05	; 5
    a946:	0c 94 c4 6b 	jmp	0xd788	; 0xd788 <__epilogue_restores__+0x1a>

0000a94a <maze_stageGetSize>:
// Calculates the size of the given stage
//
////////////////////////////////////////////////////////////////////////////////

void maze_stageGetSize(COORD *_size)
{
    a94a:	a6 e0       	ldi	r26, 0x06	; 6
    a94c:	b0 e0       	ldi	r27, 0x00	; 0
    a94e:	eb ea       	ldi	r30, 0xAB	; 171
    a950:	f4 e5       	ldi	r31, 0x54	; 84
    a952:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    a956:	8c 01       	movw	r16, r24
	COORD outerSize;
	outerSize.z = _size->z;
    a958:	fc 01       	movw	r30, r24
    a95a:	82 81       	ldd	r24, Z+2	; 0x02
    a95c:	8e 83       	std	Y+6, r24	; 0x06
	COORD innerSize;
	innerSize.z = _size->z;
    a95e:	8b 83       	std	Y+3, r24	; 0x03
	
	maze_stageGetOuterSize(&outerSize);
    a960:	ce 01       	movw	r24, r28
    a962:	04 96       	adiw	r24, 0x04	; 4
    a964:	80 df       	rcall	.-256    	; 0xa866 <maze_stageGetOuterSize>
    a966:	ce 01       	movw	r24, r28
	maze_stageGetInnerSize(&innerSize);
    a968:	01 96       	adiw	r24, 0x01	; 1
    a96a:	af df       	rcall	.-162    	; 0xa8ca <maze_stageGetInnerSize>
    a96c:	8c 81       	ldd	r24, Y+4	; 0x04
    a96e:	99 81       	ldd	r25, Y+1	; 0x01
	
	_size->x = outerSize.x - innerSize.x;
    a970:	89 1b       	sub	r24, r25
    a972:	f8 01       	movw	r30, r16
    a974:	80 83       	st	Z, r24
    a976:	8d 81       	ldd	r24, Y+5	; 0x05
    a978:	9a 81       	ldd	r25, Y+2	; 0x02
	_size->y = outerSize.y - innerSize.y;
    a97a:	89 1b       	sub	r24, r25
    a97c:	81 83       	std	Z+1, r24	; 0x01
    a97e:	26 96       	adiw	r28, 0x06	; 6
    a980:	e4 e0       	ldi	r30, 0x04	; 4
}
    a982:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000a986 <maze_rotateStage>:
// Tries to find a match between the savecard and the original card
//
////////////////////////////////////////////////////////////////////////////////
	
void maze_rotateStage(uint8_t stage)
{
    a986:	a6 e1       	ldi	r26, 0x16	; 22
    a988:	b0 e0       	ldi	r27, 0x00	; 0
    a98a:	e9 ec       	ldi	r30, 0xC9	; 201
    a98c:	f4 e5       	ldi	r31, 0x54	; 84
    a98e:	0c 94 9e 6b 	jmp	0xd73c	; 0xd73c <__prologue_saves__+0x6>
    a992:	18 2f       	mov	r17, r24
	uint8_t n = 1;
	COORD stage_size;
	stage_size.z = stage;
    a994:	8e 8b       	std	Y+22, r24	; 0x16
	maze_stageGetSize(&stage_size);
    a996:	ce 01       	movw	r24, r28
    a998:	44 96       	adiw	r24, 0x14	; 20
    a99a:	d7 df       	rcall	.-82     	; 0xa94a <maze_stageGetSize>
    a99c:	9d 89       	ldd	r25, Y+21	; 0x15
	if(stage_size.y > stage_size.x)
    a99e:	8c 89       	ldd	r24, Y+20	; 0x14
    a9a0:	f3 e0       	ldi	r31, 0x03	; 3
		n += stage_size.y + 1 + ROB_POS_Y_MIN;
    a9a2:	cf 2e       	mov	r12, r31
    a9a4:	89 17       	cp	r24, r25
{
	uint8_t n = 1;
	COORD stage_size;
	stage_size.z = stage;
	maze_stageGetSize(&stage_size);
	if(stage_size.y > stage_size.x)
    a9a6:	14 f4       	brge	.+4      	; 0xa9ac <maze_rotateStage+0x26>
    a9a8:	c9 0e       	add	r12, r25
		n += stage_size.y + 1 + ROB_POS_Y_MIN;
    a9aa:	01 c0       	rjmp	.+2      	; 0xa9ae <maze_rotateStage+0x28>
    a9ac:	c8 0e       	add	r12, r24
	else
		n += stage_size.x + 1 + ROB_POS_X_MIN;
    a9ae:	1b 8b       	std	Y+19, r17	; 0x13
	
	TILE tile_tmp;
	COORD _coord_get, _coord_set;
	_coord_get.z = stage;
    a9b0:	18 8b       	std	Y+16, r17	; 0x10
	_coord_set.z = stage;
    a9b2:	7c 2c       	mov	r7, r12
	
	for (uint8_t i = 0; i < n / 2; i++)
    a9b4:	76 94       	lsr	r7
    a9b6:	61 2c       	mov	r6, r1
    a9b8:	ec 2c       	mov	r14, r12
    a9ba:	f1 2c       	mov	r15, r1
    a9bc:	aa 24       	eor	r10, r10
				robot.pos.y = -1;
			}
			
			_coord_set.x = i;
			_coord_set.y = j;
			_coord_get.x = n - j - 1;
    a9be:	aa 94       	dec	r10
    a9c0:	ac 0c       	add	r10, r12
    a9c2:	67 14       	cp	r6, r7
	TILE tile_tmp;
	COORD _coord_get, _coord_set;
	_coord_get.z = stage;
	_coord_set.z = stage;
	
	for (uint8_t i = 0; i < n / 2; i++)
    a9c4:	09 f4       	brne	.+2      	; 0xa9c8 <maze_rotateStage+0x42>
    a9c6:	b6 c0       	rjmp	.+364    	; 0xab34 <maze_rotateStage+0x1ae>
    a9c8:	d6 2c       	mov	r13, r6
    a9ca:	87 01       	movw	r16, r14
	{
		for (uint8_t j = i; j < n - i - 1; j++)
    a9cc:	06 19       	sub	r16, r6
    a9ce:	11 09       	sbc	r17, r1
    a9d0:	01 50       	subi	r16, 0x01	; 1
    a9d2:	11 09       	sbc	r17, r1
    a9d4:	e7 e0       	ldi	r30, 0x07	; 7
		{
			_coord_get.x = i;
			_coord_get.y = j;
			tile_tmp = *maze_getTile(&_coord_get);
    a9d6:	8e 2e       	mov	r8, r30
    a9d8:	99 24       	eor	r9, r9
			COORD _coord_tmp = _coord_get;
			COORD rob_pos_save = robot.pos;
			if(maze_cmpCoords(&_coord_tmp, &robot.pos))
			{
				robot.pos.x = -1;
    a9da:	9a 94       	dec	r9
    a9dc:	ba 2c       	mov	r11, r10
    a9de:	b6 18       	sub	r11, r6
    a9e0:	8d 2d       	mov	r24, r13
	_coord_get.z = stage;
	_coord_set.z = stage;
	
	for (uint8_t i = 0; i < n / 2; i++)
	{
		for (uint8_t j = i; j < n - i - 1; j++)
    a9e2:	90 e0       	ldi	r25, 0x00	; 0
    a9e4:	80 17       	cp	r24, r16
    a9e6:	91 07       	cpc	r25, r17
    a9e8:	0c f0       	brlt	.+2      	; 0xa9ec <maze_rotateStage+0x66>
    a9ea:	a2 c0       	rjmp	.+324    	; 0xab30 <maze_rotateStage+0x1aa>
    a9ec:	69 8a       	std	Y+17, r6	; 0x11
		{
			_coord_get.x = i;
    a9ee:	da 8a       	std	Y+18, r13	; 0x12
			_coord_get.y = j;
    a9f0:	ce 01       	movw	r24, r28
			tile_tmp = *maze_getTile(&_coord_get);
    a9f2:	41 96       	adiw	r24, 0x11	; 17
    a9f4:	0e 94 d1 48 	call	0x91a2	; 0x91a2 <maze_getTile>
    a9f8:	fc 01       	movw	r30, r24
    a9fa:	de 01       	movw	r26, r28
    a9fc:	11 96       	adiw	r26, 0x01	; 1
    a9fe:	88 2d       	mov	r24, r8
    aa00:	01 90       	ld	r0, Z+
    aa02:	0d 92       	st	X+, r0
    aa04:	8a 95       	dec	r24
    aa06:	e1 f7       	brne	.-8      	; 0xaa00 <maze_rotateStage+0x7a>
    aa08:	89 89       	ldd	r24, Y+17	; 0x11
			COORD _coord_tmp = _coord_get;
    aa0a:	9a 89       	ldd	r25, Y+18	; 0x12
    aa0c:	ab 89       	ldd	r26, Y+19	; 0x13
    aa0e:	8b 87       	std	Y+11, r24	; 0x0b
    aa10:	9c 87       	std	Y+12, r25	; 0x0c
    aa12:	ad 87       	std	Y+13, r26	; 0x0d
    aa14:	80 91 48 16 	lds	r24, 0x1648
			COORD rob_pos_save = robot.pos;
    aa18:	90 91 49 16 	lds	r25, 0x1649
    aa1c:	a0 91 4a 16 	lds	r26, 0x164A
    aa20:	88 87       	std	Y+8, r24	; 0x08
    aa22:	99 87       	std	Y+9, r25	; 0x09
    aa24:	aa 87       	std	Y+10, r26	; 0x0a
    aa26:	68 e4       	ldi	r22, 0x48	; 72
			if(maze_cmpCoords(&_coord_tmp, &robot.pos))
    aa28:	76 e1       	ldi	r23, 0x16	; 22
    aa2a:	ce 01       	movw	r24, r28
    aa2c:	0b 96       	adiw	r24, 0x0b	; 11
    aa2e:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    aa32:	88 23       	and	r24, r24
    aa34:	21 f0       	breq	.+8      	; 0xaa3e <maze_rotateStage+0xb8>
    aa36:	90 92 48 16 	sts	0x1648, r9
			{
				robot.pos.x = -1;
    aa3a:	90 92 49 16 	sts	0x1649, r9
				robot.pos.y = -1;
    aa3e:	6e 86       	std	Y+14, r6	; 0x0e
			}
			
			_coord_set.x = i;
    aa40:	df 86       	std	Y+15, r13	; 0x0f
			_coord_set.y = j;
    aa42:	5a 2c       	mov	r5, r10
    aa44:	5d 18       	sub	r5, r13
    aa46:	59 8a       	std	Y+17, r5	; 0x11
			_coord_get.x = n - j - 1;
    aa48:	6a 8a       	std	Y+18, r6	; 0x12
			_coord_get.y = i;
    aa4a:	ce 01       	movw	r24, r28
			maze_setTile(&_coord_set, maze_getTile(&_coord_get));
    aa4c:	41 96       	adiw	r24, 0x11	; 17
    aa4e:	0e 94 d1 48 	call	0x91a2	; 0x91a2 <maze_getTile>
    aa52:	bc 01       	movw	r22, r24
    aa54:	ce 01       	movw	r24, r28
    aa56:	0e 96       	adiw	r24, 0x0e	; 14
    aa58:	0e 94 9e 48 	call	0x913c	; 0x913c <maze_setTile>
    aa5c:	68 e4       	ldi	r22, 0x48	; 72
			if(maze_cmpCoords(&_coord_get, &robot.pos)) //Fehlerhaft
    aa5e:	76 e1       	ldi	r23, 0x16	; 22
    aa60:	ce 01       	movw	r24, r28
    aa62:	41 96       	adiw	r24, 0x11	; 17
    aa64:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    aa68:	88 23       	and	r24, r24
    aa6a:	49 f0       	breq	.+18     	; 0xaa7e <maze_rotateStage+0xf8>
    aa6c:	8e 85       	ldd	r24, Y+14	; 0x0e
			{
				robot.pos = _coord_set;
    aa6e:	9f 85       	ldd	r25, Y+15	; 0x0f
    aa70:	a8 89       	ldd	r26, Y+16	; 0x10
    aa72:	80 93 48 16 	sts	0x1648, r24
    aa76:	90 93 49 16 	sts	0x1649, r25
    aa7a:	a0 93 4a 16 	sts	0x164A, r26
    aa7e:	5e 86       	std	Y+14, r5	; 0x0e
			}
			
			_coord_set.x = n - j - 1;
    aa80:	6f 86       	std	Y+15, r6	; 0x0f
			_coord_set.y = i;
    aa82:	b9 8a       	std	Y+17, r11	; 0x11
			_coord_get.x = n - 1 - i;
    aa84:	5a 8a       	std	Y+18, r5	; 0x12
			_coord_get.y = n - 1 - j;
    aa86:	ce 01       	movw	r24, r28
			maze_setTile(&_coord_set, maze_getTile(&_coord_get));
    aa88:	41 96       	adiw	r24, 0x11	; 17
    aa8a:	0e 94 d1 48 	call	0x91a2	; 0x91a2 <maze_getTile>
    aa8e:	bc 01       	movw	r22, r24
    aa90:	ce 01       	movw	r24, r28
    aa92:	0e 96       	adiw	r24, 0x0e	; 14
    aa94:	0e 94 9e 48 	call	0x913c	; 0x913c <maze_setTile>
    aa98:	68 e4       	ldi	r22, 0x48	; 72
			if(maze_cmpCoords(&_coord_get, &robot.pos))
    aa9a:	76 e1       	ldi	r23, 0x16	; 22
    aa9c:	ce 01       	movw	r24, r28
    aa9e:	41 96       	adiw	r24, 0x11	; 17
    aaa0:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    aaa4:	88 23       	and	r24, r24
    aaa6:	49 f0       	breq	.+18     	; 0xaaba <maze_rotateStage+0x134>
    aaa8:	8e 85       	ldd	r24, Y+14	; 0x0e
			{
				robot.pos = _coord_set;
    aaaa:	9f 85       	ldd	r25, Y+15	; 0x0f
    aaac:	a8 89       	ldd	r26, Y+16	; 0x10
    aaae:	80 93 48 16 	sts	0x1648, r24
    aab2:	90 93 49 16 	sts	0x1649, r25
    aab6:	a0 93 4a 16 	sts	0x164A, r26
    aaba:	be 86       	std	Y+14, r11	; 0x0e
			}
			
			_coord_set.x = n - 1 - i;
    aabc:	5f 86       	std	Y+15, r5	; 0x0f
			_coord_set.y = n - 1 - j;
    aabe:	d9 8a       	std	Y+17, r13	; 0x11
			_coord_get.x = j;
    aac0:	ba 8a       	std	Y+18, r11	; 0x12
			_coord_get.y = n - 1 - i;
    aac2:	ce 01       	movw	r24, r28
			maze_setTile(&_coord_set, maze_getTile(&_coord_get));
    aac4:	41 96       	adiw	r24, 0x11	; 17
    aac6:	0e 94 d1 48 	call	0x91a2	; 0x91a2 <maze_getTile>
    aaca:	bc 01       	movw	r22, r24
    aacc:	ce 01       	movw	r24, r28
    aace:	0e 96       	adiw	r24, 0x0e	; 14
    aad0:	0e 94 9e 48 	call	0x913c	; 0x913c <maze_setTile>
    aad4:	68 e4       	ldi	r22, 0x48	; 72
			if(maze_cmpCoords(&_coord_get, &robot.pos))
    aad6:	76 e1       	ldi	r23, 0x16	; 22
    aad8:	ce 01       	movw	r24, r28
    aada:	41 96       	adiw	r24, 0x11	; 17
    aadc:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    aae0:	88 23       	and	r24, r24
    aae2:	49 f0       	breq	.+18     	; 0xaaf6 <maze_rotateStage+0x170>
    aae4:	8e 85       	ldd	r24, Y+14	; 0x0e
			{
				robot.pos = _coord_set;
    aae6:	9f 85       	ldd	r25, Y+15	; 0x0f
    aae8:	a8 89       	ldd	r26, Y+16	; 0x10
    aaea:	80 93 48 16 	sts	0x1648, r24
    aaee:	90 93 49 16 	sts	0x1649, r25
    aaf2:	a0 93 4a 16 	sts	0x164A, r26
    aaf6:	de 86       	std	Y+14, r13	; 0x0e
			}
			
			_coord_set.x = j;
    aaf8:	bf 86       	std	Y+15, r11	; 0x0f
			_coord_set.y = n - 1 - i;
    aafa:	be 01       	movw	r22, r28
			maze_setTile(&_coord_set, &tile_tmp);
    aafc:	6f 5f       	subi	r22, 0xFF	; 255
    aafe:	7f 4f       	sbci	r23, 0xFF	; 255
    ab00:	ce 01       	movw	r24, r28
    ab02:	0e 96       	adiw	r24, 0x0e	; 14
    ab04:	0e 94 9e 48 	call	0x913c	; 0x913c <maze_setTile>
    ab08:	be 01       	movw	r22, r28
			if(maze_cmpCoords(&_coord_tmp, &rob_pos_save))
    ab0a:	68 5f       	subi	r22, 0xF8	; 248
    ab0c:	7f 4f       	sbci	r23, 0xFF	; 255
    ab0e:	ce 01       	movw	r24, r28
    ab10:	0b 96       	adiw	r24, 0x0b	; 11
    ab12:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    ab16:	88 23       	and	r24, r24
    ab18:	49 f0       	breq	.+18     	; 0xab2c <maze_rotateStage+0x1a6>
    ab1a:	8e 85       	ldd	r24, Y+14	; 0x0e
			{
				robot.pos = _coord_set;
    ab1c:	9f 85       	ldd	r25, Y+15	; 0x0f
    ab1e:	a8 89       	ldd	r26, Y+16	; 0x10
    ab20:	80 93 48 16 	sts	0x1648, r24
    ab24:	90 93 49 16 	sts	0x1649, r25
    ab28:	a0 93 4a 16 	sts	0x164A, r26
    ab2c:	d3 94       	inc	r13
	_coord_get.z = stage;
	_coord_set.z = stage;
	
	for (uint8_t i = 0; i < n / 2; i++)
	{
		for (uint8_t j = i; j < n - i - 1; j++)
    ab2e:	58 cf       	rjmp	.-336    	; 0xa9e0 <maze_rotateStage+0x5a>
    ab30:	63 94       	inc	r6
	TILE tile_tmp;
	COORD _coord_get, _coord_set;
	_coord_get.z = stage;
	_coord_set.z = stage;
	
	for (uint8_t i = 0; i < n / 2; i++)
    ab32:	47 cf       	rjmp	.-370    	; 0xa9c2 <maze_rotateStage+0x3c>
    ab34:	1e 86       	std	Y+14, r1	; 0x0e
				robot.pos = _coord_set;
			}
		}
	}
	
	for(_coord_set.x = 0; _coord_set.x < n; _coord_set.x ++)
    ab36:	8e 85       	ldd	r24, Y+14	; 0x0e
    ab38:	99 27       	eor	r25, r25
    ab3a:	87 fd       	sbrc	r24, 7
    ab3c:	90 95       	com	r25
    ab3e:	8e 15       	cp	r24, r14
    ab40:	9f 05       	cpc	r25, r15
    ab42:	14 f5       	brge	.+68     	; 0xab88 <maze_rotateStage+0x202>
    ab44:	cf 86       	std	Y+15, r12	; 0x0f
	{
		for(_coord_set.y = n; _coord_set.y >= 0; _coord_set.y --)
    ab46:	8f 85       	ldd	r24, Y+15	; 0x0f
    ab48:	87 fd       	sbrc	r24, 7
    ab4a:	1a c0       	rjmp	.+52     	; 0xab80 <maze_rotateStage+0x1fa>
    ab4c:	64 e0       	ldi	r22, 0x04	; 4
		{
			maze_setWall(&_coord_set, NORTH, maze_getWall(&_coord_set, WEST));
    ab4e:	ce 01       	movw	r24, r28
    ab50:	0e 96       	adiw	r24, 0x0e	; 14
    ab52:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    ab56:	48 2f       	mov	r20, r24
    ab58:	61 e0       	ldi	r22, 0x01	; 1
    ab5a:	ce 01       	movw	r24, r28
    ab5c:	0e 96       	adiw	r24, 0x0e	; 14
    ab5e:	0e 94 e7 4a 	call	0x95ce	; 0x95ce <maze_setWall>
    ab62:	63 e0       	ldi	r22, 0x03	; 3
			maze_setWall(&_coord_set, WEST, maze_getWall(&_coord_set, SOUTH));
    ab64:	ce 01       	movw	r24, r28
    ab66:	0e 96       	adiw	r24, 0x0e	; 14
    ab68:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
    ab6c:	48 2f       	mov	r20, r24
    ab6e:	64 e0       	ldi	r22, 0x04	; 4
    ab70:	ce 01       	movw	r24, r28
    ab72:	0e 96       	adiw	r24, 0x0e	; 14
    ab74:	0e 94 e7 4a 	call	0x95ce	; 0x95ce <maze_setWall>
    ab78:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
	
	for(_coord_set.x = 0; _coord_set.x < n; _coord_set.x ++)
	{
		for(_coord_set.y = n; _coord_set.y >= 0; _coord_set.y --)
    ab7a:	81 50       	subi	r24, 0x01	; 1
    ab7c:	8f 87       	std	Y+15, r24	; 0x0f
    ab7e:	e3 cf       	rjmp	.-58     	; 0xab46 <maze_rotateStage+0x1c0>
    ab80:	8e 85       	ldd	r24, Y+14	; 0x0e
				robot.pos = _coord_set;
			}
		}
	}
	
	for(_coord_set.x = 0; _coord_set.x < n; _coord_set.x ++)
    ab82:	8f 5f       	subi	r24, 0xFF	; 255
    ab84:	8e 87       	std	Y+14, r24	; 0x0e
    ab86:	d7 cf       	rjmp	.-82     	; 0xab36 <maze_rotateStage+0x1b0>
    ab88:	80 91 4b 16 	lds	r24, 0x164B
			maze_setWall(&_coord_set, NORTH, maze_getWall(&_coord_set, WEST));
			maze_setWall(&_coord_set, WEST, maze_getWall(&_coord_set, SOUTH));
		}
	}
	
	robot.dir = maze_alignDir(robot.dir+1);
    ab8c:	8f 5f       	subi	r24, 0xFF	; 255
    ab8e:	85 30       	cpi	r24, 0x05	; 5
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    ab90:	10 f0       	brcs	.+4      	; 0xab96 <maze_rotateStage+0x210>
    ab92:	84 50       	subi	r24, 0x04	; 4
		dir -= WEST;
    ab94:	fc cf       	rjmp	.-8      	; 0xab8e <maze_rotateStage+0x208>
    ab96:	80 93 4b 16 	sts	0x164B, r24
			maze_setWall(&_coord_set, NORTH, maze_getWall(&_coord_set, WEST));
			maze_setWall(&_coord_set, WEST, maze_getWall(&_coord_set, SOUTH));
		}
	}
	
	robot.dir = maze_alignDir(robot.dir+1);
    ab9a:	66 96       	adiw	r28, 0x16	; 22
}
    ab9c:	ef e0       	ldi	r30, 0x0F	; 15
    ab9e:	0c 94 ba 6b 	jmp	0xd774	; 0xd774 <__epilogue_restores__+0x6>

0000aba2 <maze_matchStages>:

void maze_matchStages(MATCHSTAGES *matchStages)
{
    aba2:	a3 e1       	ldi	r26, 0x13	; 19
    aba4:	b0 e0       	ldi	r27, 0x00	; 0
    aba6:	e7 ed       	ldi	r30, 0xD7	; 215
    aba8:	f5 e5       	ldi	r31, 0x55	; 85
    abaa:	0c 94 9b 6b 	jmp	0xd736	; 0xd736 <__prologue_saves__>
    abae:	8c 01       	movw	r16, r24
	POS stage_a;
	stage_a.pos.z = matchStages->stage_a;
    abb0:	fc 01       	movw	r30, r24
    abb2:	70 80       	ld	r7, Z

	COORD stage_b;
	stage_b.z = matchStages->stage_b;
    abb4:	81 81       	ldd	r24, Z+1	; 0x01
    abb6:	8a 8b       	std	Y+18, r24	; 0x12
	int8_t accordance = 0; //bereinstimmung in %
	int8_t accordance_max = 0;
	uint8_t ambiguity = 0; //Uneindeutigkeiten
	
	COORD stage_b_innerSize, stage_b_outerSize;
	stage_b_innerSize.z = matchStages->stage_b;
    abb8:	8f 87       	std	Y+15, r24	; 0x0f
	maze_stageGetInnerSize(&stage_b_innerSize);
    abba:	ce 01       	movw	r24, r28
    abbc:	0d 96       	adiw	r24, 0x0d	; 13
    abbe:	85 de       	rcall	.-758    	; 0xa8ca <maze_stageGetInnerSize>
    abc0:	f8 01       	movw	r30, r16
	stage_b_outerSize.z = matchStages->stage_b;
    abc2:	81 81       	ldd	r24, Z+1	; 0x01
    abc4:	8c 87       	std	Y+12, r24	; 0x0c
    abc6:	ce 01       	movw	r24, r28
	maze_stageGetOuterSize(&stage_b_outerSize);
    abc8:	0a 96       	adiw	r24, 0x0a	; 10
    abca:	4d de       	rcall	.-870    	; 0xa866 <maze_stageGetOuterSize>
    abcc:	b1 2c       	mov	r11, r1
    abce:	81 2c       	mov	r8, r1

	uint8_t stage_b_visitedTiles;
	
	for(stage_a.dir = NONE; stage_a.dir < WEST; stage_a.dir ++)
    abd0:	91 2c       	mov	r9, r1

	COORD stage_b;
	stage_b.z = matchStages->stage_b;
	
	POS match_coord;
	match_coord.pos.x = 0;
    abd2:	a1 2c       	mov	r10, r1
	match_coord.pos.y = 0;
    abd4:	c1 2c       	mov	r12, r1
	match_coord.pos.z = 0;
    abd6:	d1 2c       	mov	r13, r1
	
	int16_t matches = 0;
	int8_t accordance = 0; //bereinstimmung in %
	int8_t accordance_max = 0;
	uint8_t ambiguity = 0; //Uneindeutigkeiten
    abd8:	f8 01       	movw	r30, r16
	match_coord.pos.y = 0;
	match_coord.pos.z = 0;
	
	int16_t matches = 0;
	int8_t accordance = 0; //bereinstimmung in %
	int8_t accordance_max = 0;
    abda:	80 81       	ld	r24, Z
	uint8_t stage_b_visitedTiles;
	
	for(stage_a.dir = NONE; stage_a.dir < WEST; stage_a.dir ++)
	{
		COORD stage_a_innerSize, stage_a_outerSize;
		stage_a_innerSize.z = matchStages->stage_a;
    abdc:	89 87       	std	Y+9, r24	; 0x09
    abde:	ce 01       	movw	r24, r28
    abe0:	07 96       	adiw	r24, 0x07	; 7
		maze_stageGetInnerSize(&stage_a_innerSize);
    abe2:	73 de       	rcall	.-794    	; 0xa8ca <maze_stageGetInnerSize>
    abe4:	f8 01       	movw	r30, r16
    abe6:	80 81       	ld	r24, Z
    abe8:	8e 83       	std	Y+6, r24	; 0x06
		stage_a_outerSize.z = matchStages->stage_a;
    abea:	ce 01       	movw	r24, r28
    abec:	04 96       	adiw	r24, 0x04	; 4
    abee:	3b de       	rcall	.-906    	; 0xa866 <maze_stageGetOuterSize>
		maze_stageGetOuterSize(&stage_a_outerSize);
    abf0:	58 84       	ldd	r5, Y+8	; 0x08
    abf2:	8d 81       	ldd	r24, Y+5	; 0x05
    abf4:	99 27       	eor	r25, r25
    abf6:	87 fd       	sbrc	r24, 7
    abf8:	90 95       	com	r25
		for(stage_a.pos.y = stage_a_innerSize.y; stage_a.pos.y <= stage_a_outerSize.y+1; stage_a.pos.y ++)
    abfa:	01 96       	adiw	r24, 0x01	; 1
    abfc:	25 2d       	mov	r18, r5
    abfe:	33 27       	eor	r19, r19
    ac00:	27 fd       	sbrc	r18, 7
    ac02:	30 95       	com	r19
    ac04:	82 17       	cp	r24, r18
    ac06:	93 07       	cpc	r25, r19
    ac08:	0c f4       	brge	.+2      	; 0xac0c <maze_matchStages+0x6a>
    ac0a:	93 c0       	rjmp	.+294    	; 0xad32 <maze_matchStages+0x190>
    ac0c:	3f 80       	ldd	r3, Y+7	; 0x07
    ac0e:	8c 81       	ldd	r24, Y+4	; 0x04
    ac10:	99 27       	eor	r25, r25
    ac12:	87 fd       	sbrc	r24, 7
    ac14:	90 95       	com	r25
		{
			for(stage_a.pos.x = stage_a_innerSize.x; stage_a.pos.x <= stage_a_outerSize.x+1; stage_a.pos.x ++)
    ac16:	01 96       	adiw	r24, 0x01	; 1
    ac18:	23 2d       	mov	r18, r3
    ac1a:	33 27       	eor	r19, r19
    ac1c:	27 fd       	sbrc	r18, 7
    ac1e:	30 95       	com	r19
    ac20:	82 17       	cp	r24, r18
    ac22:	93 07       	cpc	r25, r19
    ac24:	0c f4       	brge	.+2      	; 0xac28 <maze_matchStages+0x86>
    ac26:	83 c0       	rjmp	.+262    	; 0xad2e <maze_matchStages+0x18c>
    ac28:	39 82       	std	Y+1, r3	; 0x01
    ac2a:	5a 82       	std	Y+2, r5	; 0x02
    ac2c:	7b 82       	std	Y+3, r7	; 0x03
    ac2e:	8e 85       	ldd	r24, Y+14	; 0x0e
			{
				COORD stage_a_save = stage_a.pos;
    ac30:	89 8b       	std	Y+17, r24	; 0x11
    ac32:	21 2c       	mov	r2, r1
    ac34:	e1 2c       	mov	r14, r1
				stage_b_visitedTiles = 0;

				for(stage_b.y = stage_b_innerSize.y; stage_b.y <= stage_b_outerSize.y+1; stage_b.y ++)
    ac36:	f1 2c       	mov	r15, r1
    ac38:	49 89       	ldd	r20, Y+17	; 0x11
		for(stage_a.pos.y = stage_a_innerSize.y; stage_a.pos.y <= stage_a_outerSize.y+1; stage_a.pos.y ++)
		{
			for(stage_a.pos.x = stage_a_innerSize.x; stage_a.pos.x <= stage_a_outerSize.x+1; stage_a.pos.x ++)
			{
				COORD stage_a_save = stage_a.pos;
				stage_b_visitedTiles = 0;
    ac3a:	24 2f       	mov	r18, r20

				for(stage_b.y = stage_b_innerSize.y; stage_b.y <= stage_b_outerSize.y+1; stage_b.y ++)
    ac3c:	33 27       	eor	r19, r19
    ac3e:	27 fd       	sbrc	r18, 7
    ac40:	30 95       	com	r19
    ac42:	8b 85       	ldd	r24, Y+11	; 0x0b
    ac44:	99 27       	eor	r25, r25
    ac46:	87 fd       	sbrc	r24, 7
    ac48:	90 95       	com	r25
    ac4a:	01 96       	adiw	r24, 0x01	; 1
    ac4c:	82 17       	cp	r24, r18
    ac4e:	93 07       	cpc	r25, r19
    ac50:	0c f4       	brge	.+2      	; 0xac54 <maze_matchStages+0xb2>
    ac52:	53 c0       	rjmp	.+166    	; 0xacfa <maze_matchStages+0x158>
    ac54:	8e ef       	ldi	r24, 0xFE	; 254
    ac56:	84 0f       	add	r24, r20
    ac58:	85 0d       	add	r24, r5
    ac5a:	8a 83       	std	Y+2, r24	; 0x02
				{
					stage_a_save.y = stage_a.pos.y + stage_b.y - 1- ROB_POS_Y_MIN;
    ac5c:	8d 30       	cpi	r24, 0x0D	; 13
    ac5e:	0c f0       	brlt	.+2      	; 0xac62 <maze_matchStages+0xc0>
    ac60:	4a c0       	rjmp	.+148    	; 0xacf6 <maze_matchStages+0x154>
    ac62:	8d 85       	ldd	r24, Y+13	; 0x0d
					if(stage_a_save.y > MAZE_SIZE_Y_USABLE)
    ac64:	88 8b       	std	Y+16, r24	; 0x10
    ac66:	48 89       	ldd	r20, Y+16	; 0x10
    ac68:	24 2f       	mov	r18, r20
					{
						matches = 0;
						break;
					}

					for(stage_b.x = stage_b_innerSize.x; stage_b.x <= stage_b_outerSize.x+1; stage_b.x ++)
    ac6a:	33 27       	eor	r19, r19
    ac6c:	27 fd       	sbrc	r18, 7
    ac6e:	30 95       	com	r19
    ac70:	8a 85       	ldd	r24, Y+10	; 0x0a
    ac72:	99 27       	eor	r25, r25
    ac74:	87 fd       	sbrc	r24, 7
    ac76:	90 95       	com	r25
    ac78:	01 96       	adiw	r24, 0x01	; 1
    ac7a:	82 17       	cp	r24, r18
    ac7c:	93 07       	cpc	r25, r19
    ac7e:	bc f1       	brlt	.+110    	; 0xacee <maze_matchStages+0x14c>
    ac80:	8e ef       	ldi	r24, 0xFE	; 254
    ac82:	84 0f       	add	r24, r20
    ac84:	83 0d       	add	r24, r3
    ac86:	89 83       	std	Y+1, r24	; 0x01
					{
						stage_a_save.x = stage_a.pos.x + stage_b.x - 1-ROB_POS_X_MIN;
    ac88:	8d 30       	cpi	r24, 0x0D	; 13
    ac8a:	7c f5       	brge	.+94     	; 0xacea <maze_matchStages+0x148>
    ac8c:	60 e0       	ldi	r22, 0x00	; 0
    ac8e:	ce 01       	movw	r24, r28
						if(stage_a_save.x > MAZE_SIZE_X_USABLE)
    ac90:	40 96       	adiw	r24, 0x10	; 16
    ac92:	16 dd       	rcall	.-1492   	; 0xa6c0 <maze_getBeenthere>
						{
							matches = 0;
							break;
						}

						if(maze_getBeenthere(&stage_b, NONE) &&
    ac94:	88 23       	and	r24, r24
    ac96:	31 f1       	breq	.+76     	; 0xace4 <maze_matchStages+0x142>
    ac98:	60 e0       	ldi	r22, 0x00	; 0
    ac9a:	ce 01       	movw	r24, r28
    ac9c:	01 96       	adiw	r24, 0x01	; 1
    ac9e:	10 dd       	rcall	.-1504   	; 0xa6c0 <maze_getBeenthere>
    aca0:	88 23       	and	r24, r24
							 maze_getBeenthere(&stage_a_save, NONE))
    aca2:	01 f1       	breq	.+64     	; 0xace4 <maze_matchStages+0x142>
    aca4:	23 94       	inc	r2
    aca6:	44 24       	eor	r4, r4
    aca8:	43 94       	inc	r4
    acaa:	64 2d       	mov	r22, r4
						{
							matches = 0;
							break;
						}

						if(maze_getBeenthere(&stage_b, NONE) &&
    acac:	ce 01       	movw	r24, r28
    acae:	40 96       	adiw	r24, 0x10	; 16
							 maze_getBeenthere(&stage_a_save, NONE))
						{
							stage_b_visitedTiles ++;
    acb0:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>

							for(int8_t dir = NORTH; dir <= WEST; dir ++)
    acb4:	38 2f       	mov	r19, r24
							{
								int8_t wall_save = maze_getWall(&stage_b, dir);
    acb6:	64 2d       	mov	r22, r4
    acb8:	ce 01       	movw	r24, r28
    acba:	01 96       	adiw	r24, 0x01	; 1
    acbc:	3b 8b       	std	Y+19, r19	; 0x13
    acbe:	0e 94 af 4b 	call	0x975e	; 0x975e <maze_getWall>
								int8_t wall_orig = maze_getWall(&stage_a_save, dir);
    acc2:	3b 89       	ldd	r19, Y+19	; 0x13
    acc4:	13 16       	cp	r1, r19
    acc6:	1c f4       	brge	.+6      	; 0xacce <maze_matchStages+0x12c>
    acc8:	18 16       	cp	r1, r24
    acca:	2c f0       	brlt	.+10     	; 0xacd6 <maze_matchStages+0x134>
    accc:	07 c0       	rjmp	.+14     	; 0xacdc <maze_matchStages+0x13a>

								if(((wall_save > 0) && (wall_orig > 0)) ||
    acce:	33 23       	and	r19, r19
    acd0:	29 f0       	breq	.+10     	; 0xacdc <maze_matchStages+0x13a>
    acd2:	87 ff       	sbrs	r24, 7
    acd4:	03 c0       	rjmp	.+6      	; 0xacdc <maze_matchStages+0x13a>
    acd6:	ff ef       	ldi	r31, 0xFF	; 255
    acd8:	ef 1a       	sub	r14, r31
    acda:	ff 0a       	sbc	r15, r31
    acdc:	43 94       	inc	r4
									 ((wall_save < 0) && (wall_orig < 0)))
    acde:	25 e0       	ldi	r18, 0x05	; 5
    ace0:	42 12       	cpse	r4, r18
								{
									matches ++;
    ace2:	e3 cf       	rjmp	.-58     	; 0xacaa <maze_matchStages+0x108>
    ace4:	88 89       	ldd	r24, Y+16	; 0x10
    ace6:	8f 5f       	subi	r24, 0xFF	; 255
    ace8:	bd cf       	rjmp	.-134    	; 0xac64 <maze_matchStages+0xc2>
						if(maze_getBeenthere(&stage_b, NONE) &&
							 maze_getBeenthere(&stage_a_save, NONE))
						{
							stage_b_visitedTiles ++;

							for(int8_t dir = NORTH; dir <= WEST; dir ++)
    acea:	e1 2c       	mov	r14, r1
    acec:	f1 2c       	mov	r15, r1
    acee:	89 89       	ldd	r24, Y+17	; 0x11
					{
						matches = 0;
						break;
					}

					for(stage_b.x = stage_b_innerSize.x; stage_b.x <= stage_b_outerSize.x+1; stage_b.x ++)
    acf0:	8f 5f       	subi	r24, 0xFF	; 255
    acf2:	89 8b       	std	Y+17, r24	; 0x11
    acf4:	a1 cf       	rjmp	.-190    	; 0xac38 <maze_matchStages+0x96>
					{
						stage_a_save.x = stage_a.pos.x + stage_b.x - 1-ROB_POS_X_MIN;
						if(stage_a_save.x > MAZE_SIZE_X_USABLE)
						{
							matches = 0;
    acf6:	e1 2c       	mov	r14, r1
    acf8:	f1 2c       	mov	r15, r1
			for(stage_a.pos.x = stage_a_innerSize.x; stage_a.pos.x <= stage_a_outerSize.x+1; stage_a.pos.x ++)
			{
				COORD stage_a_save = stage_a.pos;
				stage_b_visitedTiles = 0;

				for(stage_b.y = stage_b_innerSize.y; stage_b.y <= stage_b_outerSize.y+1; stage_b.y ++)
    acfa:	e4 e6       	ldi	r30, 0x64	; 100
    acfc:	ee 9d       	mul	r30, r14
    acfe:	c0 01       	movw	r24, r0
    ad00:	ef 9d       	mul	r30, r15
				{
					stage_a_save.y = stage_a.pos.y + stage_b.y - 1- ROB_POS_Y_MIN;
					if(stage_a_save.y > MAZE_SIZE_Y_USABLE)
					{
						matches = 0;
    ad02:	90 0d       	add	r25, r0
    ad04:	11 24       	eor	r1, r1
							}
						}
					}
				}

				accordance = (matches * 100) / (stage_b_visitedTiles * 4);
    ad06:	f4 e0       	ldi	r31, 0x04	; 4
    ad08:	2f 9e       	mul	r2, r31
    ad0a:	b0 01       	movw	r22, r0
    ad0c:	11 24       	eor	r1, r1
    ad0e:	0e 94 6c 6b 	call	0xd6d8	; 0xd6d8 <__divmodhi4>
    ad12:	d6 16       	cp	r13, r22
    ad14:	24 f0       	brlt	.+8      	; 0xad1e <maze_matchStages+0x17c>
    ad16:	6d 11       	cpse	r22, r13
    ad18:	08 c0       	rjmp	.+16     	; 0xad2a <maze_matchStages+0x188>
    ad1a:	c3 94       	inc	r12
    ad1c:	06 c0       	rjmp	.+12     	; 0xad2a <maze_matchStages+0x188>

				if(accordance > accordance_max)
    ad1e:	6b 2c       	mov	r6, r11
    ad20:	a7 2c       	mov	r10, r7
				{
					ambiguity = 0;
					accordance_max = accordance;
					match_coord = stage_a;
				}
				else if(accordance == accordance_max)
    ad22:	95 2c       	mov	r9, r5
    ad24:	83 2c       	mov	r8, r3
				{
					ambiguity ++;
    ad26:	d6 2e       	mov	r13, r22
    ad28:	c1 2c       	mov	r12, r1
    ad2a:	33 94       	inc	r3

				if(accordance > accordance_max)
				{
					ambiguity = 0;
					accordance_max = accordance;
					match_coord = stage_a;
    ad2c:	70 cf       	rjmp	.-288    	; 0xac0e <maze_matchStages+0x6c>
    ad2e:	53 94       	inc	r5
    ad30:	60 cf       	rjmp	.-320    	; 0xabf2 <maze_matchStages+0x50>
    ad32:	f8 01       	movw	r30, r16

				accordance = (matches * 100) / (stage_b_visitedTiles * 4);

				if(accordance > accordance_max)
				{
					ambiguity = 0;
    ad34:	81 81       	ldd	r24, Z+1	; 0x01
    ad36:	27 de       	rcall	.-946    	; 0xa986 <maze_rotateStage>
    ad38:	b3 94       	inc	r11
    ad3a:	f4 e0       	ldi	r31, 0x04	; 4
    ad3c:	bf 12       	cpse	r11, r31
					ambiguity ++;
				}
				matches = 0;
			}
		}
		maze_rotateStage(matchStages->stage_b);
    ad3e:	4c cf       	rjmp	.-360    	; 0xabd8 <maze_matchStages+0x36>
    ad40:	f8 01       	movw	r30, r16
    ad42:	82 82       	std	Z+2, r8	; 0x02
    ad44:	93 82       	std	Z+3, r9	; 0x03
    ad46:	a4 82       	std	Z+4, r10	; 0x04
	stage_b_outerSize.z = matchStages->stage_b;
	maze_stageGetOuterSize(&stage_b_outerSize);

	uint8_t stage_b_visitedTiles;
	
	for(stage_a.dir = NONE; stage_a.dir < WEST; stage_a.dir ++)
    ad48:	65 82       	std	Z+5, r6	; 0x05
    ad4a:	c7 82       	std	Z+7, r12	; 0x07
    ad4c:	d6 82       	std	Z+6, r13	; 0x06
			}
		}
		maze_rotateStage(matchStages->stage_b);
	}
	
	matchStages->match = match_coord;
    ad4e:	63 96       	adiw	r28, 0x13	; 19
    ad50:	e2 e1       	ldi	r30, 0x12	; 18
    ad52:	0c 94 b7 6b 	jmp	0xd76e	; 0xd76e <__epilogue_restores__>

0000ad56 <maze_stageGetVisitedTiles>:
// Calculates the number of visited tiles on the given stage.
//
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_stageGetVisitedTiles(uint8_t stage)
{
    ad56:	a3 e0       	ldi	r26, 0x03	; 3
    ad58:	b0 e0       	ldi	r27, 0x00	; 0
    ad5a:	e1 eb       	ldi	r30, 0xB1	; 177
    ad5c:	f6 e5       	ldi	r31, 0x56	; 86
    ad5e:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
	COORD _maze;
	_maze.z = stage;
    ad62:	8b 83       	std	Y+3, r24	; 0x03
	
	uint8_t cnt = 0;
	
	for(_maze.y = 0; _maze.y < MAZE_SIZE_Y_USABLE; _maze.y ++)
    ad64:	1a 82       	std	Y+2, r1	; 0x02
uint8_t maze_stageGetVisitedTiles(uint8_t stage)
{
	COORD _maze;
	_maze.z = stage;
	
	uint8_t cnt = 0;
    ad66:	10 e0       	ldi	r17, 0x00	; 0
	
	for(_maze.y = 0; _maze.y < MAZE_SIZE_Y_USABLE; _maze.y ++)
    ad68:	8a 81       	ldd	r24, Y+2	; 0x02
    ad6a:	8c 30       	cpi	r24, 0x0C	; 12
    ad6c:	94 f4       	brge	.+36     	; 0xad92 <maze_stageGetVisitedTiles+0x3c>
	{
		for(_maze.x = 0; _maze.x < MAZE_SIZE_X_USABLE; _maze.x ++)
    ad6e:	19 82       	std	Y+1, r1	; 0x01
    ad70:	89 81       	ldd	r24, Y+1	; 0x01
    ad72:	8c 30       	cpi	r24, 0x0C	; 12
    ad74:	54 f4       	brge	.+20     	; 0xad8a <maze_stageGetVisitedTiles+0x34>
		{
			if(maze_getBeenthere(&_maze, NONE))
    ad76:	60 e0       	ldi	r22, 0x00	; 0
    ad78:	ce 01       	movw	r24, r28
    ad7a:	01 96       	adiw	r24, 0x01	; 1
    ad7c:	a1 dc       	rcall	.-1726   	; 0xa6c0 <maze_getBeenthere>
    ad7e:	81 11       	cpse	r24, r1
    ad80:	1f 5f       	subi	r17, 0xFF	; 255
				cnt ++;
    ad82:	89 81       	ldd	r24, Y+1	; 0x01
	
	uint8_t cnt = 0;
	
	for(_maze.y = 0; _maze.y < MAZE_SIZE_Y_USABLE; _maze.y ++)
	{
		for(_maze.x = 0; _maze.x < MAZE_SIZE_X_USABLE; _maze.x ++)
    ad84:	8f 5f       	subi	r24, 0xFF	; 255
    ad86:	89 83       	std	Y+1, r24	; 0x01
    ad88:	f3 cf       	rjmp	.-26     	; 0xad70 <maze_stageGetVisitedTiles+0x1a>
    ad8a:	8a 81       	ldd	r24, Y+2	; 0x02
	COORD _maze;
	_maze.z = stage;
	
	uint8_t cnt = 0;
	
	for(_maze.y = 0; _maze.y < MAZE_SIZE_Y_USABLE; _maze.y ++)
    ad8c:	8f 5f       	subi	r24, 0xFF	; 255
    ad8e:	8a 83       	std	Y+2, r24	; 0x02
    ad90:	eb cf       	rjmp	.-42     	; 0xad68 <maze_stageGetVisitedTiles+0x12>
    ad92:	81 2f       	mov	r24, r17
				cnt ++;
		}
	}
	
	return cnt;
}
    ad94:	23 96       	adiw	r28, 0x03	; 3
    ad96:	e3 e0       	ldi	r30, 0x03	; 3
    ad98:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

0000ad9c <maze_GetVisitedTiles>:
// Calculates the number of visited tiles in the maze.
//
////////////////////////////////////////////////////////////////////////////////

uint16_t maze_GetVisitedTiles(void)
{
    ad9c:	cf 93       	push	r28
	uint16_t visitedTiles = 0;
	for(uint8_t z = 0; z < MAZE_SAVESTAGE; z++)
	{
		visitedTiles += maze_stageGetVisitedTiles(z);
    ad9e:	80 e0       	ldi	r24, 0x00	; 0
    ada0:	da df       	rcall	.-76     	; 0xad56 <maze_stageGetVisitedTiles>
    ada2:	c8 2f       	mov	r28, r24
    ada4:	81 e0       	ldi	r24, 0x01	; 1
    ada6:	d7 df       	rcall	.-82     	; 0xad56 <maze_stageGetVisitedTiles>
    ada8:	2c 2f       	mov	r18, r28
    adaa:	30 e0       	ldi	r19, 0x00	; 0
    adac:	a9 01       	movw	r20, r18
    adae:	48 0f       	add	r20, r24
	}
	
	return visitedTiles;
}
    adb0:	51 1d       	adc	r21, r1
    adb2:	ca 01       	movw	r24, r20
    adb4:	cf 91       	pop	r28
    adb6:	08 95       	ret

0000adb8 <maze_getDepthsearch>:
//						robot visited this tile yet?), in case something went wrong
//						0xff
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getDepthsearch(COORD *_coord, int8_t dir) 
{
    adb8:	a4 e0       	ldi	r26, 0x04	; 4
    adba:	b0 e0       	ldi	r27, 0x00	; 0
    adbc:	e2 ee       	ldi	r30, 0xE2	; 226
    adbe:	f6 e5       	ldi	r31, 0x56	; 86
    adc0:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
    adc4:	8c 01       	movw	r16, r24
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    adc6:	65 30       	cpi	r22, 0x05	; 5
    adc8:	10 f0       	brcs	.+4      	; 0xadce <maze_getDepthsearch+0x16>
		dir -= WEST;
    adca:	64 50       	subi	r22, 0x04	; 4
    adcc:	fc cf       	rjmp	.-8      	; 0xadc6 <maze_getDepthsearch+0xe>
uint8_t maze_getDepthsearch(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
    adce:	66 23       	and	r22, r22
    add0:	19 f1       	breq	.+70     	; 0xae18 <maze_getDepthsearch+0x60>
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
    add2:	c8 01       	movw	r24, r16
    add4:	6c 83       	std	Y+4, r22	; 0x04
    add6:	04 dc       	rcall	.-2040   	; 0xa5e0 <maze_getRampPosDir>
    add8:	6c 81       	ldd	r22, Y+4	; 0x04
uint8_t maze_getDepthsearch(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
    adda:	86 13       	cpse	r24, r22
    addc:	1d c0       	rjmp	.+58     	; 0xae18 <maze_getDepthsearch+0x60>
    adde:	f8 01       	movw	r30, r16
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
		COORD _ramp = *_coord;
    ade0:	80 81       	ld	r24, Z
    ade2:	91 81       	ldd	r25, Z+1	; 0x01
    ade4:	a2 81       	ldd	r26, Z+2	; 0x02
    ade6:	89 83       	std	Y+1, r24	; 0x01
    ade8:	9a 83       	std	Y+2, r25	; 0x02
    adea:	ab 83       	std	Y+3, r26	; 0x03
    adec:	8b 81       	ldd	r24, Y+3	; 0x03
		
		_ramp.z ++; //Works only in arenas with two stages...
    adee:	8f 5f       	subi	r24, 0xFF	; 255
    adf0:	82 30       	cpi	r24, 0x02	; 2
		if(_ramp.z >= MAZE_SAVESTAGE)
    adf2:	14 f4       	brge	.+4      	; 0xadf8 <maze_getDepthsearch+0x40>
    adf4:	8b 83       	std	Y+3, r24	; 0x03
	if((dir != NONE) &&
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
		COORD _ramp = *_coord;
		
		_ramp.z ++; //Works only in arenas with two stages...
    adf6:	01 c0       	rjmp	.+2      	; 0xadfa <maze_getDepthsearch+0x42>
    adf8:	1b 82       	std	Y+3, r1	; 0x03
		if(_ramp.z >= MAZE_SAVESTAGE)
			_ramp.z = 0;
    adfa:	8b 81       	ldd	r24, Y+3	; 0x03
			
		_ramp = *maze_getRamp(_ramp.z);
    adfc:	0e 94 f4 47 	call	0x8fe8	; 0x8fe8 <maze_getRamp>
    ae00:	fc 01       	movw	r30, r24
    ae02:	80 81       	ld	r24, Z
    ae04:	91 81       	ldd	r25, Z+1	; 0x01
    ae06:	a2 81       	ldd	r26, Z+2	; 0x02
    ae08:	89 83       	std	Y+1, r24	; 0x01
    ae0a:	9a 83       	std	Y+2, r25	; 0x02
    ae0c:	ab 83       	std	Y+3, r26	; 0x03
    ae0e:	60 e0       	ldi	r22, 0x00	; 0
		returnvar = maze_getDepthsearch(&_ramp, NONE);
    ae10:	ce 01       	movw	r24, r28
    ae12:	01 96       	adiw	r24, 0x01	; 1
    ae14:	d1 df       	rcall	.-94     	; 0xadb8 <maze_getDepthsearch>
    ae16:	b9 c0       	rjmp	.+370    	; 0xaf8a <maze_getDepthsearch+0x1d2>
    ae18:	f8 01       	movw	r30, r16
	int8_t returnvar = MAZE_ERROR;
	dir = maze_alignDir(dir);
			
	if((dir != NONE) &&
		 ((int8_t)maze_getRampPosDir(_coord) == dir))
	{
    ae1a:	80 81       	ld	r24, Z
		_ramp = *maze_getRamp(_ramp.z);
		returnvar = maze_getDepthsearch(&_ramp, NONE);
	}
	else
	{
		COORD c = *_coord;
    ae1c:	91 81       	ldd	r25, Z+1	; 0x01
    ae1e:	a2 81       	ldd	r26, Z+2	; 0x02
    ae20:	89 83       	std	Y+1, r24	; 0x01
    ae22:	9a 83       	std	Y+2, r25	; 0x02
    ae24:	ab 83       	std	Y+3, r26	; 0x03
    ae26:	ce 01       	movw	r24, r28
    ae28:	01 96       	adiw	r24, 0x01	; 1
		
		if(maze_adaptOffset(&c)) //Positionen fr Speicher an Offset anpassen
    ae2a:	6c 83       	std	Y+4, r22	; 0x04
    ae2c:	0e 94 63 48 	call	0x90c6	; 0x90c6 <maze_adaptOffset>
    ae30:	6c 81       	ldd	r22, Y+4	; 0x04
    ae32:	88 23       	and	r24, r24
    ae34:	09 f4       	brne	.+2      	; 0xae38 <maze_getDepthsearch+0x80>
    ae36:	a8 c0       	rjmp	.+336    	; 0xaf88 <maze_getDepthsearch+0x1d0>
    ae38:	2b 81       	ldd	r18, Y+3	; 0x03
    ae3a:	ea 81       	ldd	r30, Y+2	; 0x02
    ae3c:	79 81       	ldd	r23, Y+1	; 0x01
    ae3e:	62 30       	cpi	r22, 0x02	; 2
    ae40:	b9 f1       	breq	.+110    	; 0xaeb0 <maze_getDepthsearch+0xf8>
		{
			switch(dir)
    ae42:	1c f4       	brge	.+6      	; 0xae4a <maze_getDepthsearch+0x92>
    ae44:	61 30       	cpi	r22, 0x01	; 1
    ae46:	d1 f0       	breq	.+52     	; 0xae7c <maze_getDepthsearch+0xc4>
    ae48:	06 c0       	rjmp	.+12     	; 0xae56 <maze_getDepthsearch+0x9e>
    ae4a:	63 30       	cpi	r22, 0x03	; 3
    ae4c:	09 f4       	brne	.+2      	; 0xae50 <maze_getDepthsearch+0x98>
    ae4e:	42 c0       	rjmp	.+132    	; 0xaed4 <maze_getDepthsearch+0x11c>
    ae50:	64 30       	cpi	r22, 0x04	; 4
    ae52:	09 f4       	brne	.+2      	; 0xae56 <maze_getDepthsearch+0x9e>
    ae54:	6d c0       	rjmp	.+218    	; 0xaf30 <maze_getDepthsearch+0x178>
    ae56:	35 e1       	ldi	r19, 0x15	; 21
    ae58:	e3 02       	muls	r30, r19
			{
				case NONE:
								returnvar = maze[c.x][c.y][c.z].depthsearch;
    ae5a:	f0 01       	movw	r30, r0
    ae5c:	11 24       	eor	r1, r1
    ae5e:	87 e0       	ldi	r24, 0x07	; 7
    ae60:	28 02       	muls	r18, r24
    ae62:	e0 0d       	add	r30, r0
    ae64:	f1 1d       	adc	r31, r1
    ae66:	11 24       	eor	r1, r1
    ae68:	21 e1       	ldi	r18, 0x11	; 17
    ae6a:	31 e0       	ldi	r19, 0x01	; 1
    ae6c:	72 03       	mulsu	r23, r18
    ae6e:	c0 01       	movw	r24, r0
    ae70:	73 9f       	mul	r23, r19
    ae72:	90 0d       	add	r25, r0
    ae74:	11 24       	eor	r1, r1
    ae76:	e8 0f       	add	r30, r24
    ae78:	f9 1f       	adc	r31, r25
    ae7a:	75 c0       	rjmp	.+234    	; 0xaf66 <maze_getDepthsearch+0x1ae>
    ae7c:	ec 30       	cpi	r30, 0x0C	; 12
    ae7e:	84 f4       	brge	.+32     	; 0xaea0 <maze_getDepthsearch+0xe8>
							break;
				case NORTH:
								if((c.y + 1) <= (MAZE_SIZE_Y-1))	returnvar = maze[c.x][c.y + 1][c.z].depthsearch;
    ae80:	ff 27       	eor	r31, r31
    ae82:	e7 fd       	sbrc	r30, 7
    ae84:	f0 95       	com	r31
    ae86:	31 96       	adiw	r30, 0x01	; 1
    ae88:	85 e1       	ldi	r24, 0x15	; 21
    ae8a:	8e 9f       	mul	r24, r30
    ae8c:	d0 01       	movw	r26, r0
    ae8e:	8f 9f       	mul	r24, r31
    ae90:	b0 0d       	add	r27, r0
    ae92:	11 24       	eor	r1, r1
    ae94:	e7 e0       	ldi	r30, 0x07	; 7
    ae96:	2e 02       	muls	r18, r30
    ae98:	a0 0d       	add	r26, r0
    ae9a:	b1 1d       	adc	r27, r1
    ae9c:	11 24       	eor	r1, r1
    ae9e:	2b c0       	rjmp	.+86     	; 0xaef6 <maze_getDepthsearch+0x13e>
    aea0:	41 e1       	ldi	r20, 0x11	; 17
    aea2:	51 e0       	ldi	r21, 0x01	; 1
								else								returnvar = maze[c.x][0		 ][c.z].depthsearch;
    aea4:	74 03       	mulsu	r23, r20
    aea6:	f0 01       	movw	r30, r0
    aea8:	75 9f       	mul	r23, r21
    aeaa:	f0 0d       	add	r31, r0
    aeac:	11 24       	eor	r1, r1
    aeae:	0c c0       	rjmp	.+24     	; 0xaec8 <maze_getDepthsearch+0x110>
    aeb0:	7c 30       	cpi	r23, 0x0C	; 12
    aeb2:	34 f4       	brge	.+12     	; 0xaec0 <maze_getDepthsearch+0x108>
							break;
				case EAST:
								if((c.x + 1) <= (MAZE_SIZE_X-1))	returnvar = maze[c.x + 1][c.y][c.z].depthsearch;
    aeb4:	87 2f       	mov	r24, r23
    aeb6:	99 27       	eor	r25, r25
    aeb8:	87 fd       	sbrc	r24, 7
    aeba:	90 95       	com	r25
    aebc:	01 96       	adiw	r24, 0x01	; 1
    aebe:	3f c0       	rjmp	.+126    	; 0xaf3e <maze_getDepthsearch+0x186>
    aec0:	85 e1       	ldi	r24, 0x15	; 21
    aec2:	e8 02       	muls	r30, r24
								else								returnvar = maze[0		][c.y][c.z].depthsearch;
    aec4:	f0 01       	movw	r30, r0
    aec6:	11 24       	eor	r1, r1
    aec8:	37 e0       	ldi	r19, 0x07	; 7
    aeca:	23 02       	muls	r18, r19
    aecc:	e0 0d       	add	r30, r0
    aece:	f1 1d       	adc	r31, r1
    aed0:	11 24       	eor	r1, r1
    aed2:	49 c0       	rjmp	.+146    	; 0xaf66 <maze_getDepthsearch+0x1ae>
    aed4:	1e 16       	cp	r1, r30
    aed6:	ec f4       	brge	.+58     	; 0xaf12 <maze_getDepthsearch+0x15a>
							break;
				case SOUTH:
								if((c.y - 1) >= 0)					returnvar = maze[c.x][c.y - 1	   ][c.z].depthsearch;
    aed8:	ff 27       	eor	r31, r31
    aeda:	e7 fd       	sbrc	r30, 7
    aedc:	f0 95       	com	r31
    aede:	31 97       	sbiw	r30, 0x01	; 1
    aee0:	85 e1       	ldi	r24, 0x15	; 21
    aee2:	8e 9f       	mul	r24, r30
    aee4:	d0 01       	movw	r26, r0
    aee6:	8f 9f       	mul	r24, r31
    aee8:	b0 0d       	add	r27, r0
    aeea:	11 24       	eor	r1, r1
    aeec:	87 e0       	ldi	r24, 0x07	; 7
    aeee:	28 02       	muls	r18, r24
    aef0:	a0 0d       	add	r26, r0
    aef2:	b1 1d       	adc	r27, r1
    aef4:	11 24       	eor	r1, r1
    aef6:	41 e1       	ldi	r20, 0x11	; 17
    aef8:	51 e0       	ldi	r21, 0x01	; 1
    aefa:	74 03       	mulsu	r23, r20
    aefc:	90 01       	movw	r18, r0
    aefe:	75 9f       	mul	r23, r21
    af00:	30 0d       	add	r19, r0
    af02:	11 24       	eor	r1, r1
    af04:	a2 0f       	add	r26, r18
    af06:	b3 1f       	adc	r27, r19
    af08:	a5 5a       	subi	r26, 0xA5	; 165
    af0a:	b7 4f       	sbci	r27, 0xF7	; 247
    af0c:	16 96       	adiw	r26, 0x06	; 6
    af0e:	8c 91       	ld	r24, X
    af10:	3c c0       	rjmp	.+120    	; 0xaf8a <maze_getDepthsearch+0x1d2>
    af12:	41 e1       	ldi	r20, 0x11	; 17
    af14:	51 e0       	ldi	r21, 0x01	; 1
								else								returnvar = maze[c.x][MAZE_SIZE_Y-1][c.z].depthsearch;
    af16:	74 03       	mulsu	r23, r20
    af18:	f0 01       	movw	r30, r0
    af1a:	75 9f       	mul	r23, r21
    af1c:	f0 0d       	add	r31, r0
    af1e:	11 24       	eor	r1, r1
    af20:	37 e0       	ldi	r19, 0x07	; 7
    af22:	23 02       	muls	r18, r19
    af24:	e0 0d       	add	r30, r0
    af26:	f1 1d       	adc	r31, r1
    af28:	11 24       	eor	r1, r1
    af2a:	e3 5a       	subi	r30, 0xA3	; 163
    af2c:	f6 4f       	sbci	r31, 0xF6	; 246
    af2e:	2a c0       	rjmp	.+84     	; 0xaf84 <maze_getDepthsearch+0x1cc>
    af30:	17 16       	cp	r1, r23
    af32:	ec f4       	brge	.+58     	; 0xaf6e <maze_getDepthsearch+0x1b6>
							break;
				case WEST:
								if((c.x - 1) >= 0)					returnvar = maze[c.x - 1	  ][c.y][c.z].depthsearch;
    af34:	87 2f       	mov	r24, r23
    af36:	99 27       	eor	r25, r25
    af38:	87 fd       	sbrc	r24, 7
    af3a:	90 95       	com	r25
    af3c:	01 97       	sbiw	r24, 0x01	; 1
    af3e:	35 e1       	ldi	r19, 0x15	; 21
    af40:	e3 02       	muls	r30, r19
    af42:	f0 01       	movw	r30, r0
    af44:	11 24       	eor	r1, r1
    af46:	37 e0       	ldi	r19, 0x07	; 7
    af48:	23 02       	muls	r18, r19
    af4a:	e0 0d       	add	r30, r0
    af4c:	f1 1d       	adc	r31, r1
    af4e:	11 24       	eor	r1, r1
    af50:	41 e1       	ldi	r20, 0x11	; 17
    af52:	51 e0       	ldi	r21, 0x01	; 1
    af54:	84 9f       	mul	r24, r20
    af56:	90 01       	movw	r18, r0
    af58:	85 9f       	mul	r24, r21
    af5a:	30 0d       	add	r19, r0
    af5c:	94 9f       	mul	r25, r20
    af5e:	30 0d       	add	r19, r0
    af60:	11 24       	eor	r1, r1
    af62:	e2 0f       	add	r30, r18
    af64:	f3 1f       	adc	r31, r19
    af66:	e5 5a       	subi	r30, 0xA5	; 165
    af68:	f7 4f       	sbci	r31, 0xF7	; 247
    af6a:	86 81       	ldd	r24, Z+6	; 0x06
    af6c:	0e c0       	rjmp	.+28     	; 0xaf8a <maze_getDepthsearch+0x1d2>
    af6e:	85 e1       	ldi	r24, 0x15	; 21
    af70:	e8 02       	muls	r30, r24
								else								returnvar = maze[MAZE_SIZE_X-1][c.y][c.z].depthsearch;
    af72:	f0 01       	movw	r30, r0
    af74:	11 24       	eor	r1, r1
    af76:	37 e0       	ldi	r19, 0x07	; 7
    af78:	23 02       	muls	r18, r19
    af7a:	e0 0d       	add	r30, r0
    af7c:	f1 1d       	adc	r31, r1
    af7e:	11 24       	eor	r1, r1
    af80:	e3 5d       	subi	r30, 0xD3	; 211
    af82:	fa 4e       	sbci	r31, 0xEA	; 234
    af84:	80 81       	ld	r24, Z
    af86:	01 c0       	rjmp	.+2      	; 0xaf8a <maze_getDepthsearch+0x1d2>
    af88:	8f e7       	ldi	r24, 0x7F	; 127
    af8a:	24 96       	adiw	r28, 0x04	; 4
//						0xff
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_getDepthsearch(COORD *_coord, int8_t dir) 
{
	int8_t returnvar = MAZE_ERROR;
    af8c:	e4 e0       	ldi	r30, 0x04	; 4
			}
		}
	}
	
	return returnvar;
}
    af8e:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000af92 <maze_findNearestTile>:
// @return: When a route was found the time in ms needed to find the route,
//					otherwise -1.
////////////////////////////////////////////////////////////////////////////////

int16_t maze_findNearestTile(COORD *_pos_start, COORD *_pos_goal)
{
    af92:	a9 e0       	ldi	r26, 0x09	; 9
    af94:	b0 e0       	ldi	r27, 0x00	; 0
    af96:	ef ec       	ldi	r30, 0xCF	; 207
    af98:	f7 e5       	ldi	r31, 0x57	; 87
    af9a:	0c 94 a1 6b 	jmp	0xd742	; 0xd742 <__prologue_saves__+0xc>
    af9e:	8c 01       	movw	r16, r24
    afa0:	5b 01       	movw	r10, r22
	uint32_t timer_findNearestTile = timer;
    afa2:	c0 90 47 05 	lds	r12, 0x0547
    afa6:	d0 90 48 05 	lds	r13, 0x0548
    afaa:	e0 90 49 05 	lds	r14, 0x0549
    afae:	f0 90 4a 05 	lds	r15, 0x054A
	static COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
	{
		maze_size[i].z = i;
    afb2:	1b 82       	std	Y+3, r1	; 0x03
		maze_stageGetSize(&maze_size[i]);
    afb4:	ce 01       	movw	r24, r28
    afb6:	01 96       	adiw	r24, 0x01	; 1
    afb8:	c8 dc       	rcall	.-1648   	; 0xa94a <maze_stageGetSize>
    afba:	81 e0       	ldi	r24, 0x01	; 1
	static COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
	{
		maze_size[i].z = i;
    afbc:	8e 83       	std	Y+6, r24	; 0x06
    afbe:	ce 01       	movw	r24, r28
		maze_stageGetSize(&maze_size[i]);
    afc0:	04 96       	adiw	r24, 0x04	; 4
    afc2:	c3 dc       	rcall	.-1658   	; 0xa94a <maze_stageGetSize>
    afc4:	82 e0       	ldi	r24, 0x02	; 2
    afc6:	89 87       	std	Y+9, r24	; 0x09
	static COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++)
	{
		maze_size[i].z = i;
    afc8:	ce 01       	movw	r24, r28
    afca:	07 96       	adiw	r24, 0x07	; 7
		maze_stageGetSize(&maze_size[i]);
    afcc:	be dc       	rcall	.-1668   	; 0xa94a <maze_stageGetSize>
    afce:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
    afd2:	40 e0       	ldi	r20, 0x00	; 0
	}

	maze_clearDepthsearch();
    afd4:	60 e0       	ldi	r22, 0x00	; 0
    afd6:	c8 01       	movw	r24, r16
	maze_setDepthsearch(_pos_start, NONE, 0);
    afd8:	0e 94 1f 4f 	call	0x9e3e	; 0x9e3e <maze_setDepthsearch>
    afdc:	00 e0       	ldi	r16, 0x00	; 0
    afde:	10 e0       	ldi	r17, 0x00	; 0
    afe0:	10 92 d6 05 	sts	0x05D6, r1
    afe4:	99 24       	eor	r9, r9
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
    afe6:	93 94       	inc	r9
    afe8:	90 0e       	add	r9, r16
    afea:	80 91 d6 05 	lds	r24, 0x05D6
    afee:	83 30       	cpi	r24, 0x03	; 3
    aff0:	0c f0       	brlt	.+2      	; 0xaff4 <maze_findNearestTile+0x62>
    aff2:	9e c0       	rjmp	.+316    	; 0xb130 <maze_findNearestTile+0x19e>
    aff4:	10 92 d5 05 	sts	0x05D5, r1
    aff8:	40 91 d6 05 	lds	r20, 0x05D6
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each line...
    affc:	20 91 d5 05 	lds	r18, 0x05D5
    b000:	33 27       	eor	r19, r19
    b002:	27 fd       	sbrc	r18, 7
    b004:	30 95       	com	r19
    b006:	84 2f       	mov	r24, r20
    b008:	99 27       	eor	r25, r25
    b00a:	87 fd       	sbrc	r24, 7
    b00c:	90 95       	com	r25
    b00e:	fc 01       	movw	r30, r24
    b010:	ee 0f       	add	r30, r30
    b012:	ff 1f       	adc	r31, r31
    b014:	e8 0f       	add	r30, r24
    b016:	f9 1f       	adc	r31, r25
    b018:	81 e0       	ldi	r24, 0x01	; 1
    b01a:	90 e0       	ldi	r25, 0x00	; 0
    b01c:	8c 0f       	add	r24, r28
    b01e:	9d 1f       	adc	r25, r29
    b020:	e8 0f       	add	r30, r24
    b022:	f9 1f       	adc	r31, r25
    b024:	81 81       	ldd	r24, Z+1	; 0x01
    b026:	99 27       	eor	r25, r25
    b028:	87 fd       	sbrc	r24, 7
    b02a:	90 95       	com	r25
    b02c:	02 96       	adiw	r24, 0x02	; 2
    b02e:	82 17       	cp	r24, r18
    b030:	93 07       	cpc	r25, r19
    b032:	0c f4       	brge	.+2      	; 0xb036 <maze_findNearestTile+0xa4>
    b034:	79 c0       	rjmp	.+242    	; 0xb128 <maze_findNearestTile+0x196>
    b036:	10 92 d4 05 	sts	0x05D4, r1
    b03a:	20 91 d4 05 	lds	r18, 0x05D4
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each column...
    b03e:	33 27       	eor	r19, r19
    b040:	27 fd       	sbrc	r18, 7
    b042:	30 95       	com	r19
    b044:	80 91 d6 05 	lds	r24, 0x05D6
    b048:	99 27       	eor	r25, r25
    b04a:	87 fd       	sbrc	r24, 7
    b04c:	90 95       	com	r25
    b04e:	fc 01       	movw	r30, r24
    b050:	ee 0f       	add	r30, r30
    b052:	ff 1f       	adc	r31, r31
    b054:	e8 0f       	add	r30, r24
    b056:	f9 1f       	adc	r31, r25
    b058:	81 e0       	ldi	r24, 0x01	; 1
    b05a:	90 e0       	ldi	r25, 0x00	; 0
    b05c:	8c 0f       	add	r24, r28
    b05e:	9d 1f       	adc	r25, r29
    b060:	e8 0f       	add	r30, r24
    b062:	f9 1f       	adc	r31, r25
    b064:	80 81       	ld	r24, Z
    b066:	99 27       	eor	r25, r25
    b068:	87 fd       	sbrc	r24, 7
    b06a:	90 95       	com	r25
    b06c:	02 96       	adiw	r24, 0x02	; 2
    b06e:	82 17       	cp	r24, r18
    b070:	93 07       	cpc	r25, r19
    b072:	0c f4       	brge	.+2      	; 0xb076 <maze_findNearestTile+0xe4>
    b074:	53 c0       	rjmp	.+166    	; 0xb11c <maze_findNearestTile+0x18a>
    b076:	88 24       	eor	r8, r8
    b078:	83 94       	inc	r8
    b07a:	68 2d       	mov	r22, r8
    b07c:	84 ed       	ldi	r24, 0xD4	; 212
    b07e:	95 e0       	ldi	r25, 0x05	; 5
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
    b080:	9b de       	rcall	.-714    	; 0xadb8 <maze_getDepthsearch>
    b082:	90 e0       	ldi	r25, 0x00	; 0
    b084:	80 17       	cp	r24, r16
    b086:	91 07       	cpc	r25, r17
    b088:	09 f0       	breq	.+2      	; 0xb08c <maze_findNearestTile+0xfa>
    b08a:	3e c0       	rjmp	.+124    	; 0xb108 <maze_findNearestTile+0x176>
    b08c:	68 2d       	mov	r22, r8
    b08e:	84 ed       	ldi	r24, 0xD4	; 212
    b090:	95 e0       	ldi	r25, 0x05	; 5
    b092:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
							maze_tileIsVisitable(&_maze, maze_dir) &&
    b096:	88 23       	and	r24, r24
    b098:	b9 f1       	breq	.+110    	; 0xb108 <maze_findNearestTile+0x176>
    b09a:	68 2d       	mov	r22, r8
    b09c:	84 ed       	ldi	r24, 0xD4	; 212
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each column...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
    b09e:	95 e0       	ldi	r25, 0x05	; 5
    b0a0:	c8 da       	rcall	.-2672   	; 0xa632 <maze_getRampPosDirAtDir>
							maze_tileIsVisitable(&_maze, maze_dir) &&
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) == NONE))//!= maze_alignDir(maze_dir + 2)))
    b0a2:	81 11       	cpse	r24, r1
    b0a4:	31 c0       	rjmp	.+98     	; 0xb108 <maze_findNearestTile+0x176>
    b0a6:	60 e0       	ldi	r22, 0x00	; 0
    b0a8:	84 ed       	ldi	r24, 0xD4	; 212
    b0aa:	95 e0       	ldi	r25, 0x05	; 5
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each column...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
							maze_tileIsVisitable(&_maze, maze_dir) &&
    b0ac:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <maze_getGround>
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) == NONE))//!= maze_alignDir(maze_dir + 2)))
						{
							if(maze_getGround(&_maze, NONE) < MAZE_ISBLTILE)
    b0b0:	18 16       	cp	r1, r24
    b0b2:	54 f1       	brlt	.+84     	; 0xb108 <maze_findNearestTile+0x176>
    b0b4:	60 e0       	ldi	r22, 0x00	; 0
    b0b6:	84 ed       	ldi	r24, 0xD4	; 212
    b0b8:	95 e0       	ldi	r25, 0x05	; 5
    b0ba:	02 db       	rcall	.-2556   	; 0xa6c0 <maze_getBeenthere>
    b0bc:	81 30       	cpi	r24, 0x01	; 1
							{
								if((maze_getBeenthere(&_maze, NONE) == TRUE) &&
    b0be:	69 f4       	brne	.+26     	; 0xb0da <maze_findNearestTile+0x148>
    b0c0:	60 e0       	ldi	r22, 0x00	; 0
    b0c2:	84 ed       	ldi	r24, 0xD4	; 212
    b0c4:	95 e0       	ldi	r25, 0x05	; 5
    b0c6:	78 de       	rcall	.-784    	; 0xadb8 <maze_getDepthsearch>
    b0c8:	8f 3f       	cpi	r24, 0xFF	; 255
    b0ca:	39 f4       	brne	.+14     	; 0xb0da <maze_findNearestTile+0x148>
									 (maze_getDepthsearch(&_maze, NONE) == 0xff))
    b0cc:	49 2d       	mov	r20, r9
    b0ce:	60 e0       	ldi	r22, 0x00	; 0
    b0d0:	84 ed       	ldi	r24, 0xD4	; 212
    b0d2:	95 e0       	ldi	r25, 0x05	; 5
    b0d4:	0e 94 1f 4f 	call	0x9e3e	; 0x9e3e <maze_setDepthsearch>
							maze_tileIsVisitable(&_maze, maze_dir) &&
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) == NONE))//!= maze_alignDir(maze_dir + 2)))
						{
							if(maze_getGround(&_maze, NONE) < MAZE_ISBLTILE)
							{
								if((maze_getBeenthere(&_maze, NONE) == TRUE) &&
    b0d8:	17 c0       	rjmp	.+46     	; 0xb108 <maze_findNearestTile+0x176>
									 (maze_getDepthsearch(&_maze, NONE) == 0xff))
								{
									maze_setDepthsearch(&_maze, NONE, i+1);
    b0da:	60 e0       	ldi	r22, 0x00	; 0
    b0dc:	84 ed       	ldi	r24, 0xD4	; 212
    b0de:	95 e0       	ldi	r25, 0x05	; 5
    b0e0:	ef da       	rcall	.-2594   	; 0xa6c0 <maze_getBeenthere>
    b0e2:	81 11       	cpse	r24, r1
    b0e4:	11 c0       	rjmp	.+34     	; 0xb108 <maze_findNearestTile+0x176>
    b0e6:	80 91 d4 05 	lds	r24, 0x05D4
								}
								else if(maze_getBeenthere(&_maze, NONE) == FALSE)
    b0ea:	f5 01       	movw	r30, r10
    b0ec:	80 83       	st	Z, r24
    b0ee:	80 91 d5 05 	lds	r24, 0x05D5
    b0f2:	81 83       	std	Z+1, r24	; 0x01
    b0f4:	80 91 d6 05 	lds	r24, 0x05D6
								{
									_pos_goal->x = _maze.x; //Save the nearest tile in the overgiven var
    b0f8:	82 83       	std	Z+2, r24	; 0x02
    b0fa:	80 91 47 05 	lds	r24, 0x0547
									_pos_goal->y = _maze.y;
    b0fe:	90 91 48 05 	lds	r25, 0x0548
    b102:	8c 19       	sub	r24, r12
									_pos_goal->z = _maze.z;
    b104:	9d 09       	sbc	r25, r13
    b106:	1c c0       	rjmp	.+56     	; 0xb140 <maze_findNearestTile+0x1ae>
    b108:	83 94       	inc	r8
		if(solutionFound)
			break;
	}
	
	if(solutionFound)
		return((int16_t)(timer - timer_findNearestTile));
    b10a:	f5 e0       	ldi	r31, 0x05	; 5
    b10c:	8f 12       	cpse	r8, r31
    b10e:	b5 cf       	rjmp	.-150    	; 0xb07a <maze_findNearestTile+0xe8>
    b110:	80 91 d4 05 	lds	r24, 0x05D4
    b114:	8f 5f       	subi	r24, 0xFF	; 255
    b116:	80 93 d4 05 	sts	0x05D4, r24
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each line...
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each column...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
    b11a:	8f cf       	rjmp	.-226    	; 0xb03a <maze_findNearestTile+0xa8>
    b11c:	80 91 d5 05 	lds	r24, 0x05D5
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each line...
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each column...
    b120:	8f 5f       	subi	r24, 0xFF	; 255
    b122:	80 93 d5 05 	sts	0x05D5, r24
    b126:	68 cf       	rjmp	.-304    	; 0xaff8 <maze_findNearestTile+0x66>
    b128:	4f 5f       	subi	r20, 0xFF	; 255
    b12a:	40 93 d6 05 	sts	0x05D6, r20
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each line...
    b12e:	5d cf       	rjmp	.-326    	; 0xafea <maze_findNearestTile+0x58>
    b130:	0f 5f       	subi	r16, 0xFF	; 255
    b132:	1f 4f       	sbci	r17, 0xFF	; 255
    b134:	06 34       	cpi	r16, 0x46	; 70
    b136:	11 05       	cpc	r17, r1
	maze_clearDepthsearch();
	maze_setDepthsearch(_pos_start, NONE, 0);
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
    b138:	09 f0       	breq	.+2      	; 0xb13c <maze_findNearestTile+0x1aa>
    b13a:	52 cf       	rjmp	.-348    	; 0xafe0 <maze_findNearestTile+0x4e>
    b13c:	8f ef       	ldi	r24, 0xFF	; 255
    b13e:	9f ef       	ldi	r25, 0xFF	; 255
    b140:	29 96       	adiw	r28, 0x09	; 9
    b142:	ec e0       	ldi	r30, 0x0C	; 12
	}

	maze_clearDepthsearch();
	maze_setDepthsearch(_pos_start, NONE, 0);
	
	for(int8_t i = 0; i < 70; i++) //Index
    b144:	0c 94 bd 6b 	jmp	0xd77a	; 0xd77a <__epilogue_restores__+0xc>

0000b148 <maze_findPath>:
// @return: When a route was found the time in ms needed to find the route,
//					otherwise -1.
////////////////////////////////////////////////////////////////////////////////

int16_t maze_findPath(COORD *_start, COORD *_goal)
{
    b148:	ac e0       	ldi	r26, 0x0C	; 12
    b14a:	b0 e0       	ldi	r27, 0x00	; 0
    b14c:	ea ea       	ldi	r30, 0xAA	; 170
    b14e:	f8 e5       	ldi	r31, 0x58	; 88
    b150:	0c 94 a0 6b 	jmp	0xd740	; 0xd740 <__prologue_saves__+0xa>
    b154:	5c 01       	movw	r10, r24
    b156:	8b 01       	movw	r16, r22
	uint32_t timer_findNearestTile = timer;
    b158:	c0 90 47 05 	lds	r12, 0x0547
    b15c:	d0 90 48 05 	lds	r13, 0x0548
    b160:	e0 90 49 05 	lds	r14, 0x0549
    b164:	f0 90 4a 05 	lds	r15, 0x054A
	COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++) //Calculate the size of all stages
	{
		maze_size[i].z = i;
    b168:	1b 82       	std	Y+3, r1	; 0x03
		maze_stageGetSize(&maze_size[i]);
    b16a:	ce 01       	movw	r24, r28
    b16c:	01 96       	adiw	r24, 0x01	; 1
    b16e:	ed db       	rcall	.-2086   	; 0xa94a <maze_stageGetSize>
    b170:	81 e0       	ldi	r24, 0x01	; 1
	COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++) //Calculate the size of all stages
	{
		maze_size[i].z = i;
    b172:	8e 83       	std	Y+6, r24	; 0x06
    b174:	ce 01       	movw	r24, r28
		maze_stageGetSize(&maze_size[i]);
    b176:	04 96       	adiw	r24, 0x04	; 4
    b178:	e8 db       	rcall	.-2096   	; 0xa94a <maze_stageGetSize>
    b17a:	82 e0       	ldi	r24, 0x02	; 2
    b17c:	89 87       	std	Y+9, r24	; 0x09
	COORD _maze;
	
	COORD maze_size[MAZE_SIZE_Z];
	for(uint8_t i = 0; i < MAZE_SIZE_Z; i++) //Calculate the size of all stages
	{
		maze_size[i].z = i;
    b17e:	ce 01       	movw	r24, r28
    b180:	07 96       	adiw	r24, 0x07	; 7
		maze_stageGetSize(&maze_size[i]);
    b182:	e3 db       	rcall	.-2106   	; 0xa94a <maze_stageGetSize>
    b184:	0e 94 c2 47 	call	0x8f84	; 0x8f84 <maze_clearDepthsearch>
    b188:	40 e0       	ldi	r20, 0x00	; 0
	}

	maze_clearDepthsearch();
    b18a:	60 e0       	ldi	r22, 0x00	; 0
    b18c:	c8 01       	movw	r24, r16
	
	maze_setDepthsearch(_goal, NONE, 0); //Set goal as root
    b18e:	0e 94 1f 4f 	call	0x9e3e	; 0x9e3e <maze_setDepthsearch>
    b192:	00 e0       	ldi	r16, 0x00	; 0
    b194:	10 e0       	ldi	r17, 0x00	; 0
    b196:	1c 86       	std	Y+12, r1	; 0x0c
    b198:	99 24       	eor	r9, r9
    b19a:	93 94       	inc	r9
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
    b19c:	90 0e       	add	r9, r16
    b19e:	8c 85       	ldd	r24, Y+12	; 0x0c
    b1a0:	83 30       	cpi	r24, 0x03	; 3
    b1a2:	0c f0       	brlt	.+2      	; 0xb1a6 <maze_findPath+0x5e>
    b1a4:	95 c0       	rjmp	.+298    	; 0xb2d0 <maze_findPath+0x188>
    b1a6:	1b 86       	std	Y+11, r1	; 0x0b
    b1a8:	4c 85       	ldd	r20, Y+12	; 0x0c
    b1aa:	2b 85       	ldd	r18, Y+11	; 0x0b
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each column...
    b1ac:	33 27       	eor	r19, r19
    b1ae:	27 fd       	sbrc	r18, 7
    b1b0:	30 95       	com	r19
    b1b2:	84 2f       	mov	r24, r20
    b1b4:	99 27       	eor	r25, r25
    b1b6:	87 fd       	sbrc	r24, 7
    b1b8:	90 95       	com	r25
    b1ba:	fc 01       	movw	r30, r24
    b1bc:	ee 0f       	add	r30, r30
    b1be:	ff 1f       	adc	r31, r31
    b1c0:	e8 0f       	add	r30, r24
    b1c2:	f9 1f       	adc	r31, r25
    b1c4:	81 e0       	ldi	r24, 0x01	; 1
    b1c6:	90 e0       	ldi	r25, 0x00	; 0
    b1c8:	8c 0f       	add	r24, r28
    b1ca:	9d 1f       	adc	r25, r29
    b1cc:	e8 0f       	add	r30, r24
    b1ce:	f9 1f       	adc	r31, r25
    b1d0:	81 81       	ldd	r24, Z+1	; 0x01
    b1d2:	99 27       	eor	r25, r25
    b1d4:	87 fd       	sbrc	r24, 7
    b1d6:	90 95       	com	r25
    b1d8:	02 96       	adiw	r24, 0x02	; 2
    b1da:	82 17       	cp	r24, r18
    b1dc:	93 07       	cpc	r25, r19
    b1de:	0c f4       	brge	.+2      	; 0xb1e2 <maze_findPath+0x9a>
    b1e0:	74 c0       	rjmp	.+232    	; 0xb2ca <maze_findPath+0x182>
    b1e2:	1a 86       	std	Y+10, r1	; 0x0a
    b1e4:	2a 85       	ldd	r18, Y+10	; 0x0a
    b1e6:	33 27       	eor	r19, r19
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each line...
    b1e8:	27 fd       	sbrc	r18, 7
    b1ea:	30 95       	com	r19
    b1ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    b1ee:	99 27       	eor	r25, r25
    b1f0:	87 fd       	sbrc	r24, 7
    b1f2:	90 95       	com	r25
    b1f4:	fc 01       	movw	r30, r24
    b1f6:	ee 0f       	add	r30, r30
    b1f8:	ff 1f       	adc	r31, r31
    b1fa:	e8 0f       	add	r30, r24
    b1fc:	f9 1f       	adc	r31, r25
    b1fe:	81 e0       	ldi	r24, 0x01	; 1
    b200:	90 e0       	ldi	r25, 0x00	; 0
    b202:	8c 0f       	add	r24, r28
    b204:	9d 1f       	adc	r25, r29
    b206:	e8 0f       	add	r30, r24
    b208:	f9 1f       	adc	r31, r25
    b20a:	80 81       	ld	r24, Z
    b20c:	99 27       	eor	r25, r25
    b20e:	87 fd       	sbrc	r24, 7
    b210:	90 95       	com	r25
    b212:	02 96       	adiw	r24, 0x02	; 2
    b214:	82 17       	cp	r24, r18
    b216:	93 07       	cpc	r25, r19
    b218:	0c f4       	brge	.+2      	; 0xb21c <maze_findPath+0xd4>
    b21a:	53 c0       	rjmp	.+166    	; 0xb2c2 <maze_findPath+0x17a>
    b21c:	63 e0       	ldi	r22, 0x03	; 3
    b21e:	86 2e       	mov	r8, r22
    b220:	ee ef       	ldi	r30, 0xFE	; 254
    b222:	7e 2e       	mov	r7, r30
    b224:	78 0c       	add	r7, r8
    b226:	67 2d       	mov	r22, r7
    b228:	ce 01       	movw	r24, r28
    b22a:	0a 96       	adiw	r24, 0x0a	; 10
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
    b22c:	c5 dd       	rcall	.-1142   	; 0xadb8 <maze_getDepthsearch>
    b22e:	90 e0       	ldi	r25, 0x00	; 0
    b230:	80 17       	cp	r24, r16
    b232:	91 07       	cpc	r25, r17
    b234:	39 f0       	breq	.+14     	; 0xb244 <maze_findPath+0xfc>
    b236:	81 e0       	ldi	r24, 0x01	; 1
    b238:	88 0d       	add	r24, r8
    b23a:	87 30       	cpi	r24, 0x07	; 7
    b23c:	09 f4       	brne	.+2      	; 0xb240 <maze_findPath+0xf8>
    b23e:	3d c0       	rjmp	.+122    	; 0xb2ba <maze_findPath+0x172>
    b240:	88 2e       	mov	r8, r24
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each column...
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each line...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
    b242:	ee cf       	rjmp	.-36     	; 0xb220 <maze_findPath+0xd8>
    b244:	67 2d       	mov	r22, r7
    b246:	ce 01       	movw	r24, r28
    b248:	0a 96       	adiw	r24, 0x0a	; 10
    b24a:	0e 94 57 4e 	call	0x9cae	; 0x9cae <maze_tileIsVisitable>
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
						   maze_tileIsVisitable(&_maze, maze_dir) &&
    b24e:	88 23       	and	r24, r24
    b250:	91 f3       	breq	.-28     	; 0xb236 <maze_findPath+0xee>
    b252:	67 2d       	mov	r22, r7
    b254:	ce 01       	movw	r24, r28
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each line...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
    b256:	0a 96       	adiw	r24, 0x0a	; 10
    b258:	ec d9       	rcall	.-3112   	; 0xa632 <maze_getRampPosDirAtDir>
						   maze_tileIsVisitable(&_maze, maze_dir) &&
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) != maze_alignDir(maze_dir + 2)))
    b25a:	94 e0       	ldi	r25, 0x04	; 4
    b25c:	98 15       	cp	r25, r8
    b25e:	18 f4       	brcc	.+6      	; 0xb266 <maze_findPath+0x11e>
    b260:	9c ef       	ldi	r25, 0xFC	; 252
    b262:	98 0d       	add	r25, r8
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    b264:	01 c0       	rjmp	.+2      	; 0xb268 <maze_findPath+0x120>
    b266:	98 2d       	mov	r25, r8
    b268:	89 17       	cp	r24, r25
		dir -= WEST;
    b26a:	29 f3       	breq	.-54     	; 0xb236 <maze_findPath+0xee>
    b26c:	60 e0       	ldi	r22, 0x00	; 0
    b26e:	ce 01       	movw	r24, r28
// @return: adapted direction
////////////////////////////////////////////////////////////////////////////////

uint8_t maze_alignDir(uint8_t dir)
{
	while(dir > WEST)
    b270:	0a 96       	adiw	r24, 0x0a	; 10
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each line...
				{
					for(uint8_t maze_dir = NORTH; maze_dir <= WEST; maze_dir ++) //each direction...
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
						   maze_tileIsVisitable(&_maze, maze_dir) &&
    b272:	26 da       	rcall	.-2996   	; 0xa6c0 <maze_getBeenthere>
    b274:	81 30       	cpi	r24, 0x01	; 1
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) != maze_alignDir(maze_dir + 2)))
						{
							if((maze_getBeenthere(&_maze, NONE) == TRUE) &&
    b276:	f9 f6       	brne	.-66     	; 0xb236 <maze_findPath+0xee>
    b278:	60 e0       	ldi	r22, 0x00	; 0
    b27a:	ce 01       	movw	r24, r28
    b27c:	0a 96       	adiw	r24, 0x0a	; 10
    b27e:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <maze_getGround>
    b282:	18 16       	cp	r1, r24
							   (maze_getGround(&_maze, NONE) < MAZE_ISBLTILE))
    b284:	c4 f2       	brlt	.-80     	; 0xb236 <maze_findPath+0xee>
    b286:	60 e0       	ldi	r22, 0x00	; 0
    b288:	ce 01       	movw	r24, r28
    b28a:	0a 96       	adiw	r24, 0x0a	; 10
    b28c:	95 dd       	rcall	.-1238   	; 0xadb8 <maze_getDepthsearch>
					{
						if((maze_getDepthsearch(&_maze, maze_dir) == i) &&
						   maze_tileIsVisitable(&_maze, maze_dir) &&
						   (maze_getRampPosDirAtDir(&_maze, maze_dir) != maze_alignDir(maze_dir + 2)))
						{
							if((maze_getBeenthere(&_maze, NONE) == TRUE) &&
    b28e:	8f 3f       	cpi	r24, 0xFF	; 255
    b290:	31 f4       	brne	.+12     	; 0xb29e <maze_findPath+0x156>
							   (maze_getGround(&_maze, NONE) < MAZE_ISBLTILE))
							{
								if(maze_getDepthsearch(&_maze, NONE) == 0xff)
    b292:	49 2d       	mov	r20, r9
    b294:	60 e0       	ldi	r22, 0x00	; 0
    b296:	ce 01       	movw	r24, r28
    b298:	0a 96       	adiw	r24, 0x0a	; 10
    b29a:	0e 94 1f 4f 	call	0x9e3e	; 0x9e3e <maze_setDepthsearch>
    b29e:	b5 01       	movw	r22, r10
								{
									maze_setDepthsearch(&_maze, NONE, i+1);
    b2a0:	ce 01       	movw	r24, r28
    b2a2:	0a 96       	adiw	r24, 0x0a	; 10
    b2a4:	0e 94 af 47 	call	0x8f5e	; 0x8f5e <maze_cmpCoords>
    b2a8:	88 23       	and	r24, r24
    b2aa:	29 f2       	breq	.-118    	; 0xb236 <maze_findPath+0xee>
								}
						
								if(maze_cmpCoords(&_maze, _start)) //Compare the two structs
    b2ac:	80 91 47 05 	lds	r24, 0x0547
    b2b0:	90 91 48 05 	lds	r25, 0x0548
    b2b4:	8c 19       	sub	r24, r12
    b2b6:	9d 09       	sbc	r25, r13
    b2b8:	13 c0       	rjmp	.+38     	; 0xb2e0 <maze_findPath+0x198>
		if(solutionFound)
			break;
	}
	
	if(solutionFound)
		return((int16_t)(timer - timer_findNearestTile));
    b2ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    b2bc:	8f 5f       	subi	r24, 0xFF	; 255
    b2be:	8a 87       	std	Y+10, r24	; 0x0a
    b2c0:	91 cf       	rjmp	.-222    	; 0xb1e4 <maze_findPath+0x9c>
    b2c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    b2c4:	8f 5f       	subi	r24, 0xFF	; 255
    b2c6:	8b 87       	std	Y+11, r24	; 0x0b
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each column...
			{
				for(_maze.x = ROB_POS_Y_MIN - 1; _maze.x <= maze_size[_maze.z].x + ROB_POS_Y_MIN + 1; _maze.x++) //each line...
    b2c8:	6f cf       	rjmp	.-290    	; 0xb1a8 <maze_findPath+0x60>
    b2ca:	4f 5f       	subi	r20, 0xFF	; 255
    b2cc:	4c 87       	std	Y+12, r20	; 0x0c
    b2ce:	67 cf       	rjmp	.-306    	; 0xb19e <maze_findPath+0x56>
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
		{
			for(_maze.y = ROB_POS_X_MIN - 1; _maze.y <= maze_size[_maze.z].y + ROB_POS_X_MIN + 1; _maze.y++) //each column...
    b2d0:	0f 5f       	subi	r16, 0xFF	; 255
    b2d2:	1f 4f       	sbci	r17, 0xFF	; 255
    b2d4:	06 34       	cpi	r16, 0x46	; 70
    b2d6:	11 05       	cpc	r17, r1
	
	maze_setDepthsearch(_goal, NONE, 0); //Set goal as root
	
	for(int8_t i = 0; i < 70; i++) //Index
	{
		for(_maze.z = 0; _maze.z < MAZE_SIZE_Z; _maze.z++) //check for each stage...
    b2d8:	09 f0       	breq	.+2      	; 0xb2dc <maze_findPath+0x194>
    b2da:	5d cf       	rjmp	.-326    	; 0xb196 <maze_findPath+0x4e>
    b2dc:	8f ef       	ldi	r24, 0xFF	; 255
    b2de:	9f ef       	ldi	r25, 0xFF	; 255
    b2e0:	2c 96       	adiw	r28, 0x0c	; 12

	maze_clearDepthsearch();
	
	maze_setDepthsearch(_goal, NONE, 0); //Set goal as root
	
	for(int8_t i = 0; i < 70; i++) //Index
    b2e2:	ed e0       	ldi	r30, 0x0D	; 13
    b2e4:	0c 94 bc 6b 	jmp	0xd778	; 0xd778 <__epilogue_restores__+0xa>

0000b2e8 <maze_chgOffset>:
	wall_size_part = 8;
}

//////////////////////////////////////////////////
void maze_chgOffset(int8_t whichOff, int8_t pos_z, int8_t cnt)
{
    b2e8:	a4 e0       	ldi	r26, 0x04	; 4
    b2ea:	b0 e0       	ldi	r27, 0x00	; 0
    b2ec:	ea e7       	ldi	r30, 0x7A	; 122
    b2ee:	f9 e5       	ldi	r31, 0x59	; 89
    b2f0:	0c 94 aa 6b 	jmp	0xd754	; 0xd754 <__prologue_saves__+0x1e>
    b2f4:	18 2f       	mov	r17, r24
	COORD c;
	c.x = 0;
    b2f6:	19 82       	std	Y+1, r1	; 0x01
	c.y = 0;
    b2f8:	1a 82       	std	Y+2, r1	; 0x02
	c.z = pos_z;
    b2fa:	6b 83       	std	Y+3, r22	; 0x03
	
	if(maze_adaptOffset(&c))
    b2fc:	ce 01       	movw	r24, r28
    b2fe:	01 96       	adiw	r24, 0x01	; 1
    b300:	4c 83       	std	Y+4, r20	; 0x04
    b302:	0e 94 63 48 	call	0x90c6	; 0x90c6 <maze_adaptOffset>
    b306:	4c 81       	ldd	r20, Y+4	; 0x04
    b308:	88 23       	and	r24, r24
    b30a:	09 f4       	brne	.+2      	; 0xb30e <maze_chgOffset+0x26>
    b30c:	ca c0       	rjmp	.+404    	; 0xb4a2 <maze_chgOffset+0x1ba>
	{
		switch(whichOff)
    b30e:	12 30       	cpi	r17, 0x02	; 2
    b310:	99 f0       	breq	.+38     	; 0xb338 <maze_chgOffset+0x50>
    b312:	13 30       	cpi	r17, 0x03	; 3
    b314:	d1 f0       	breq	.+52     	; 0xb34a <maze_chgOffset+0x62>
    b316:	11 30       	cpi	r17, 0x01	; 1
    b318:	f1 f4       	brne	.+60     	; 0xb356 <maze_chgOffset+0x6e>
		{
			case X: offset[c.z].x += cnt; break;
    b31a:	eb 81       	ldd	r30, Y+3	; 0x03
    b31c:	ee 0f       	add	r30, r30
    b31e:	ff 0b       	sbc	r31, r31
    b320:	e0 5b       	subi	r30, 0xB0	; 176
    b322:	f9 4e       	sbci	r31, 0xE9	; 233
    b324:	80 81       	ld	r24, Z
    b326:	84 0f       	add	r24, r20
    b328:	80 83       	st	Z, r24
			case Z: offset_z += cnt; 			break;
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.14]:DEFAULT_CASE"));}
								fatal_err = 1;
		}
	
		while(offset[c.z].x >= MAZE_SIZE_X)
    b32a:	2b 81       	ldd	r18, Y+3	; 0x03
    b32c:	22 0f       	add	r18, r18
    b32e:	33 0b       	sbc	r19, r19
    b330:	f9 01       	movw	r30, r18
    b332:	e0 5b       	subi	r30, 0xB0	; 176
    b334:	f9 4e       	sbci	r31, 0xE9	; 233
    b336:	29 c0       	rjmp	.+82     	; 0xb38a <maze_chgOffset+0xa2>
	if(maze_adaptOffset(&c))
	{
		switch(whichOff)
		{
			case X: offset[c.z].x += cnt; break;
			case Y: offset[c.z].y += cnt; break;
    b338:	eb 81       	ldd	r30, Y+3	; 0x03
    b33a:	ee 0f       	add	r30, r30
    b33c:	ff 0b       	sbc	r31, r31
    b33e:	e0 5b       	subi	r30, 0xB0	; 176
    b340:	f9 4e       	sbci	r31, 0xE9	; 233
    b342:	81 81       	ldd	r24, Z+1	; 0x01
    b344:	84 0f       	add	r24, r20
    b346:	81 83       	std	Z+1, r24	; 0x01
    b348:	f0 cf       	rjmp	.-32     	; 0xb32a <maze_chgOffset+0x42>
			case Z: offset_z += cnt; 			break;
    b34a:	80 91 5a 16 	lds	r24, 0x165A
    b34e:	84 0f       	add	r24, r20
    b350:	80 93 5a 16 	sts	0x165A, r24
    b354:	ea cf       	rjmp	.-44     	; 0xb32a <maze_chgOffset+0x42>
			default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.14]:DEFAULT_CASE"));}
    b356:	80 91 53 05 	lds	r24, 0x0553
    b35a:	82 30       	cpi	r24, 0x02	; 2
    b35c:	90 f0       	brcs	.+36     	; 0xb382 <maze_chgOffset+0x9a>
    b35e:	8c e4       	ldi	r24, 0x4C	; 76
    b360:	9b e2       	ldi	r25, 0x2B	; 43
    b362:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b366:	60 91 47 05 	lds	r22, 0x0547
    b36a:	70 91 48 05 	lds	r23, 0x0548
    b36e:	80 91 49 05 	lds	r24, 0x0549
    b372:	90 91 4a 05 	lds	r25, 0x054A
    b376:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    b37a:	86 e1       	ldi	r24, 0x16	; 22
    b37c:	9b e2       	ldi	r25, 0x2B	; 43
    b37e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
								fatal_err = 1;
    b382:	81 e0       	ldi	r24, 0x01	; 1
    b384:	80 93 63 05 	sts	0x0563, r24
    b388:	d0 cf       	rjmp	.-96     	; 0xb32a <maze_chgOffset+0x42>
		}
	
		while(offset[c.z].x >= MAZE_SIZE_X)
    b38a:	80 81       	ld	r24, Z
    b38c:	8d 30       	cpi	r24, 0x0D	; 13
    b38e:	1c f0       	brlt	.+6      	; 0xb396 <maze_chgOffset+0xae>
			offset[c.z].x -= MAZE_SIZE_X;
    b390:	8d 50       	subi	r24, 0x0D	; 13
    b392:	80 83       	st	Z, r24
    b394:	fa cf       	rjmp	.-12     	; 0xb38a <maze_chgOffset+0xa2>
		while(offset[c.z].x <= -MAZE_SIZE_X)
    b396:	f9 01       	movw	r30, r18
    b398:	e0 5b       	subi	r30, 0xB0	; 176
    b39a:	f9 4e       	sbci	r31, 0xE9	; 233
    b39c:	80 81       	ld	r24, Z
    b39e:	84 3f       	cpi	r24, 0xF4	; 244
    b3a0:	1c f4       	brge	.+6      	; 0xb3a8 <maze_chgOffset+0xc0>
			offset[c.z].x += MAZE_SIZE_X;
    b3a2:	83 5f       	subi	r24, 0xF3	; 243
    b3a4:	80 83       	st	Z, r24
    b3a6:	fa cf       	rjmp	.-12     	; 0xb39c <maze_chgOffset+0xb4>
			
		while(offset[c.z].y >= MAZE_SIZE_Y)
    b3a8:	f9 01       	movw	r30, r18
    b3aa:	ef 5a       	subi	r30, 0xAF	; 175
    b3ac:	f9 4e       	sbci	r31, 0xE9	; 233
    b3ae:	80 81       	ld	r24, Z
    b3b0:	8d 30       	cpi	r24, 0x0D	; 13
    b3b2:	1c f0       	brlt	.+6      	; 0xb3ba <maze_chgOffset+0xd2>
			offset[c.z].y -= MAZE_SIZE_Y;
    b3b4:	8d 50       	subi	r24, 0x0D	; 13
    b3b6:	80 83       	st	Z, r24
    b3b8:	fa cf       	rjmp	.-12     	; 0xb3ae <maze_chgOffset+0xc6>
		while(offset[c.z].y <= -MAZE_SIZE_Y)
    b3ba:	f9 01       	movw	r30, r18
    b3bc:	ef 5a       	subi	r30, 0xAF	; 175
    b3be:	f9 4e       	sbci	r31, 0xE9	; 233
    b3c0:	80 81       	ld	r24, Z
    b3c2:	84 3f       	cpi	r24, 0xF4	; 244
    b3c4:	1c f4       	brge	.+6      	; 0xb3cc <maze_chgOffset+0xe4>
			offset[c.z].y += MAZE_SIZE_Y;
    b3c6:	83 5f       	subi	r24, 0xF3	; 243
    b3c8:	80 83       	st	Z, r24
    b3ca:	fa cf       	rjmp	.-12     	; 0xb3c0 <maze_chgOffset+0xd8>
    b3cc:	80 91 5a 16 	lds	r24, 0x165A
			
		while(offset_z >= MAZE_SIZE_Z_USABLE)
    b3d0:	83 30       	cpi	r24, 0x03	; 3
    b3d2:	14 f0       	brlt	.+4      	; 0xb3d8 <maze_chgOffset+0xf0>
    b3d4:	83 50       	subi	r24, 0x03	; 3
    b3d6:	fc cf       	rjmp	.-8      	; 0xb3d0 <maze_chgOffset+0xe8>
			offset_z -= MAZE_SIZE_Z_USABLE;
		while(offset_z <= -MAZE_SIZE_Z_USABLE)
    b3d8:	8e 3f       	cpi	r24, 0xFE	; 254
    b3da:	14 f4       	brge	.+4      	; 0xb3e0 <maze_chgOffset+0xf8>
    b3dc:	8d 5f       	subi	r24, 0xFD	; 253
    b3de:	fc cf       	rjmp	.-8      	; 0xb3d8 <maze_chgOffset+0xf0>
    b3e0:	80 93 5a 16 	sts	0x165A, r24
			offset_z += MAZE_SIZE_Z_USABLE;
		
		if(debug > 0)
    b3e4:	80 91 53 05 	lds	r24, 0x0553
    b3e8:	88 23       	and	r24, r24
    b3ea:	09 f4       	brne	.+2      	; 0xb3ee <maze_chgOffset+0x106>
    b3ec:	73 c0       	rjmp	.+230    	; 0xb4d4 <maze_chgOffset+0x1ec>
		{
			bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": new::offset[")); bt_putLong(robot.pos.z); 
    b3ee:	83 e1       	ldi	r24, 0x13	; 19
    b3f0:	9b e2       	ldi	r25, 0x2B	; 43
    b3f2:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b3f6:	60 91 47 05 	lds	r22, 0x0547
    b3fa:	70 91 48 05 	lds	r23, 0x0548
    b3fe:	80 91 49 05 	lds	r24, 0x0549
    b402:	90 91 4a 05 	lds	r25, 0x054A
    b406:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    b40a:	84 e0       	ldi	r24, 0x04	; 4
    b40c:	9b e2       	ldi	r25, 0x2B	; 43
    b40e:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b412:	60 91 4a 16 	lds	r22, 0x164A
    b416:	77 27       	eor	r23, r23
    b418:	67 fd       	sbrc	r22, 7
    b41a:	70 95       	com	r23
    b41c:	87 2f       	mov	r24, r23
    b41e:	97 2f       	mov	r25, r23
    b420:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
			switch(whichOff)
    b424:	12 30       	cpi	r17, 0x02	; 2
    b426:	79 f0       	breq	.+30     	; 0xb446 <maze_chgOffset+0x15e>
    b428:	13 30       	cpi	r17, 0x03	; 3
    b42a:	c1 f0       	breq	.+48     	; 0xb45c <maze_chgOffset+0x174>
    b42c:	11 30       	cpi	r17, 0x01	; 1
    b42e:	21 f5       	brne	.+72     	; 0xb478 <maze_chgOffset+0x190>
			{
				case X: bt_putStr_P(PSTR("].x: "));bt_putLong(offset[c.z].x); break;
    b430:	8e ef       	ldi	r24, 0xFE	; 254
    b432:	9a e2       	ldi	r25, 0x2A	; 42
    b434:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b438:	eb 81       	ldd	r30, Y+3	; 0x03
    b43a:	ee 0f       	add	r30, r30
    b43c:	ff 0b       	sbc	r31, r31
    b43e:	e0 5b       	subi	r30, 0xB0	; 176
    b440:	f9 4e       	sbci	r31, 0xE9	; 233
    b442:	60 81       	ld	r22, Z
    b444:	11 c0       	rjmp	.+34     	; 0xb468 <maze_chgOffset+0x180>
				case Y: bt_putStr_P(PSTR("].y: "));bt_putLong(offset[c.z].y); break;
    b446:	88 ef       	ldi	r24, 0xF8	; 248
    b448:	9a e2       	ldi	r25, 0x2A	; 42
    b44a:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b44e:	eb 81       	ldd	r30, Y+3	; 0x03
    b450:	ee 0f       	add	r30, r30
    b452:	ff 0b       	sbc	r31, r31
    b454:	e0 5b       	subi	r30, 0xB0	; 176
    b456:	f9 4e       	sbci	r31, 0xE9	; 233
    b458:	61 81       	ldd	r22, Z+1	; 0x01
    b45a:	06 c0       	rjmp	.+12     	; 0xb468 <maze_chgOffset+0x180>
				case Z: bt_putStr_P(PSTR("]_z: "));bt_putLong(offset_z); 				break;
    b45c:	82 ef       	ldi	r24, 0xF2	; 242
    b45e:	9a e2       	ldi	r25, 0x2A	; 42
    b460:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b464:	60 91 5a 16 	lds	r22, 0x165A
    b468:	77 27       	eor	r23, r23
    b46a:	67 fd       	sbrc	r22, 7
    b46c:	70 95       	com	r23
    b46e:	87 2f       	mov	r24, r23
    b470:	97 2f       	mov	r25, r23
    b472:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    b476:	2e c0       	rjmp	.+92     	; 0xb4d4 <maze_chgOffset+0x1ec>
				default: 	if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:switch[maze.15]:DEFAULT_CASE"));}
    b478:	80 91 53 05 	lds	r24, 0x0553
    b47c:	82 30       	cpi	r24, 0x02	; 2
    b47e:	38 f1       	brcs	.+78     	; 0xb4ce <maze_chgOffset+0x1e6>
    b480:	8f ee       	ldi	r24, 0xEF	; 239
    b482:	9a e2       	ldi	r25, 0x2A	; 42
    b484:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b488:	60 91 47 05 	lds	r22, 0x0547
    b48c:	70 91 48 05 	lds	r23, 0x0548
    b490:	80 91 49 05 	lds	r24, 0x0549
    b494:	90 91 4a 05 	lds	r25, 0x054A
    b498:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    b49c:	89 eb       	ldi	r24, 0xB9	; 185
    b49e:	9a e2       	ldi	r25, 0x2A	; 42
    b4a0:	14 c0       	rjmp	.+40     	; 0xb4ca <maze_chgOffset+0x1e2>
			}
		}
	}
	else
	{
		if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:maze_chgOffset():CANT"));}
    b4a2:	80 91 53 05 	lds	r24, 0x0553
    b4a6:	82 30       	cpi	r24, 0x02	; 2
    b4a8:	90 f0       	brcs	.+36     	; 0xb4ce <maze_chgOffset+0x1e6>
    b4aa:	86 eb       	ldi	r24, 0xB6	; 182
    b4ac:	9a e2       	ldi	r25, 0x2A	; 42
    b4ae:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    b4b2:	60 91 47 05 	lds	r22, 0x0547
    b4b6:	70 91 48 05 	lds	r23, 0x0548
    b4ba:	80 91 49 05 	lds	r24, 0x0549
    b4be:	90 91 4a 05 	lds	r25, 0x054A
    b4c2:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    b4c6:	81 e9       	ldi	r24, 0x91	; 145
    b4c8:	9a e2       	ldi	r25, 0x2A	; 42
    b4ca:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
		fatal_err = 1;
    b4ce:	81 e0       	ldi	r24, 0x01	; 1
    b4d0:	80 93 63 05 	sts	0x0563, r24
	}
}
    b4d4:	24 96       	adiw	r28, 0x04	; 4
    b4d6:	e3 e0       	ldi	r30, 0x03	; 3
    b4d8:	0c 94 c6 6b 	jmp	0xd78c	; 0xd78c <__epilogue_restores__+0x1e>

0000b4dc <get_mem_unused>:
// !!! because it allocates on stack.

//  Get minimum of free memory (in bytes) up to now.
unsigned short 
get_mem_unused (void)
{
    b4dc:	e0 ed       	ldi	r30, 0xD0	; 208
    b4de:	f7 e1       	ldi	r31, 0x17	; 23
   unsigned short unused = 0;
    b4e0:	80 e0       	ldi	r24, 0x00	; 0
    b4e2:	90 e0       	ldi	r25, 0x00	; 0
   unsigned char *p = &__heap_start;

   do
   {
      if (*p++ != MASK)
    b4e4:	21 91       	ld	r18, Z+
    b4e6:	2a 3a       	cpi	r18, 0xAA	; 170
    b4e8:	29 f4       	brne	.+10     	; 0xb4f4 <get_mem_unused+0x18>
         break;

      unused++;
    b4ea:	01 96       	adiw	r24, 0x01	; 1
   } while (p <= (unsigned char*) RAMEND);
    b4ec:	e1 15       	cp	r30, r1
    b4ee:	22 e2       	ldi	r18, 0x22	; 34
    b4f0:	f2 07       	cpc	r31, r18
    b4f2:	c0 f3       	brcs	.-16     	; 0xb4e4 <get_mem_unused+0x8>

   return unused;
}
    b4f4:	08 95       	ret

0000b4f6 <init_sys>:
//System
uint8_t mcusr_mirror = 0;

void init_sys(void)
{
	mcusr_mirror = MCUSR;	//Watchdog
    b4f6:	84 b7       	in	r24, 0x34	; 52
    b4f8:	80 93 d7 05 	sts	0x05D7, r24
	MCUSR = 0;
    b4fc:	14 be       	out	0x34, r1	; 52
	wdt_disable();
    b4fe:	88 e1       	ldi	r24, 0x18	; 24
    b500:	0f b6       	in	r0, 0x3f	; 63
    b502:	f8 94       	cli
    b504:	80 93 60 00 	sts	0x0060, r24
    b508:	10 92 60 00 	sts	0x0060, r1
    b50c:	0f be       	out	0x3f, r0	; 63


	//Pins bzw. Ports als Ein-/Ausgnge konfigurieren
	DDRA |= 0xfc; //Encoder (nur 2 Pins!), Zeilenkamera
    b50e:	81 b1       	in	r24, 0x01	; 1
    b510:	8c 6f       	ori	r24, 0xFC	; 252
    b512:	81 b9       	out	0x01, r24	; 1
		PORTA |= 0x03; //Pullups an
    b514:	82 b1       	in	r24, 0x02	; 2
    b516:	83 60       	ori	r24, 0x03	; 3
    b518:	82 b9       	out	0x02, r24	; 2
	DDRA &= ~(1<<PA5); //Bumper
    b51a:	0d 98       	cbi	0x01, 5	; 1
	DDRA &= ~(1<<PA6); //Bumper
    b51c:	0e 98       	cbi	0x01, 6	; 1
		PORTA |= (1<<PA5); //Pullups
    b51e:	15 9a       	sbi	0x02, 5	; 2
		PORTA |= (1<<PA6);
    b520:	16 9a       	sbi	0x02, 6	; 2
	DDRB |= 0xff;	//SPI, PWM
    b522:	84 b1       	in	r24, 0x04	; 4
    b524:	8f ef       	ldi	r24, 0xFF	; 255
    b526:	84 b9       	out	0x04, r24	; 4
	DDRC |= 0xf0;	//Taster (LCD), LCD Hintergund LED, SS1/SS2
    b528:	97 b1       	in	r25, 0x07	; 7
    b52a:	90 6f       	ori	r25, 0xF0	; 240
    b52c:	97 b9       	out	0x07, r25	; 7
		PORTC |= 0x0f; //Pullups fr Eingnge
    b52e:	98 b1       	in	r25, 0x08	; 8
    b530:	9f 60       	ori	r25, 0x0F	; 15
    b532:	98 b9       	out	0x08, r25	; 8
	DDRD |= 0xff;	//UART1, IC, LED RNmega2560
    b534:	9a b1       	in	r25, 0x0a	; 10
    b536:	8a b9       	out	0x0a, r24	; 10
	DDRE |= 0x18;	//00011000 => PWM, INT4, ENC M1/M2
    b538:	9d b1       	in	r25, 0x0d	; 13
    b53a:	98 61       	ori	r25, 0x18	; 24
    b53c:	9d b9       	out	0x0d, r25	; 13
		PORTE |= 0xe7; //Pullups fr Eingnge
    b53e:	9e b1       	in	r25, 0x0e	; 14
    b540:	97 6e       	ori	r25, 0xE7	; 231
    b542:	9e b9       	out	0x0e, r25	; 14
	DDRF |= 0x00; //herausgefhrt auf Micromatch
    b544:	90 b3       	in	r25, 0x10	; 16
    b546:	90 bb       	out	0x10, r25	; 16
	DDRG |= 0x20; //00100000 => NC, Opfer LED
    b548:	9d 9a       	sbi	0x13, 5	; 19
	DDRH |= 0xff; //UART2 (Bluetooth), RGB LED, PWM (RGB LED)
    b54a:	e1 e0       	ldi	r30, 0x01	; 1
    b54c:	f1 e0       	ldi	r31, 0x01	; 1
    b54e:	90 81       	ld	r25, Z
    b550:	80 83       	st	Z, r24
	//PORT K ADC
	DDRL |= 0xff; //Motortreiber
    b552:	ea e0       	ldi	r30, 0x0A	; 10
    b554:	f1 e0       	ldi	r31, 0x01	; 1
    b556:	90 81       	ld	r25, Z
    b558:	80 83       	st	Z, r24

	//Initialisierung der Datenstruktur fr die Motoren:
	mot.off = 1;
    b55a:	81 e0       	ldi	r24, 0x01	; 1
    b55c:	80 93 7f 16 	sts	0x167F, r24
	for(uint8_t i = 0; i < 2; i++)
	{
		mot.d[i].enc = 0;
    b560:	10 92 6b 16 	sts	0x166B, r1
    b564:	10 92 6c 16 	sts	0x166C, r1
    b568:	10 92 6d 16 	sts	0x166D, r1
    b56c:	10 92 6e 16 	sts	0x166E, r1
		mot.d[i].speed.is = 0;
    b570:	10 92 68 16 	sts	0x1668, r1
    b574:	10 92 67 16 	sts	0x1667, r1
		mot.d[i].speed.to = 0;
    b578:	10 92 6a 16 	sts	0x166A, r1
    b57c:	10 92 69 16 	sts	0x1669, r1

	//Initialisierung der Datenstruktur fr die Motoren:
	mot.off = 1;
	for(uint8_t i = 0; i < 2; i++)
	{
		mot.d[i].enc = 0;
    b580:	10 92 77 16 	sts	0x1677, r1
    b584:	10 92 78 16 	sts	0x1678, r1
    b588:	10 92 79 16 	sts	0x1679, r1
    b58c:	10 92 7a 16 	sts	0x167A, r1
		mot.d[i].speed.is = 0;
    b590:	10 92 74 16 	sts	0x1674, r1
    b594:	10 92 73 16 	sts	0x1673, r1
		mot.d[i].speed.to = 0;
    b598:	10 92 76 16 	sts	0x1676, r1
    b59c:	10 92 75 16 	sts	0x1675, r1
	}
	
	//Initialisierung der Datenstruktur fr die IR Sensoren:
	mlx90614[LEFT].is = 0;
    b5a0:	10 92 05 08 	sts	0x0805, r1
    b5a4:	10 92 04 08 	sts	0x0804, r1
	mlx90614[RIGHT].is = 0;
    b5a8:	10 92 09 08 	sts	0x0809, r1
    b5ac:	10 92 08 08 	sts	0x0808, r1
	
	//EEPROM
	mlx90614[LEFT].th = eeprom_read_word((uint16_t*)0); //Schwellwerte, werden aus EEPROM gelesen
    b5b0:	80 e0       	ldi	r24, 0x00	; 0
    b5b2:	90 e0       	ldi	r25, 0x00	; 0
    b5b4:	0e 94 4c 6c 	call	0xd898	; 0xd898 <__eerd_word_m2560>
    b5b8:	90 93 07 08 	sts	0x0807, r25
    b5bc:	80 93 06 08 	sts	0x0806, r24
	mlx90614[RIGHT].th = eeprom_read_word((uint16_t*)2);
    b5c0:	82 e0       	ldi	r24, 0x02	; 2
    b5c2:	90 e0       	ldi	r25, 0x00	; 0
    b5c4:	0e 94 4c 6c 	call	0xd898	; 0xd898 <__eerd_word_m2560>
    b5c8:	90 93 0b 08 	sts	0x080B, r25
    b5cc:	80 93 0a 08 	sts	0x080A, r24
	//use_tarry = eeprom_read_byte((uint8_t*)4); //Algo oder rechte Hand? Wird aus EEPROM gelesen
	debug = eeprom_read_byte((uint8_t*)5);
    b5d0:	85 e0       	ldi	r24, 0x05	; 5
    b5d2:	90 e0       	ldi	r25, 0x00	; 0
    b5d4:	0e 94 44 6c 	call	0xd888	; 0xd888 <__eerd_byte_m2560>
    b5d8:	80 93 53 05 	sts	0x0553, r24
	ground_th = eeprom_read_word((uint16_t*)6); //tsl_th...
    b5dc:	86 e0       	ldi	r24, 0x06	; 6
    b5de:	90 e0       	ldi	r25, 0x00	; 0
    b5e0:	0e 94 4c 6c 	call	0xd898	; 0xd898 <__eerd_word_m2560>
    b5e4:	90 93 4d 16 	sts	0x164D, r25
    b5e8:	80 93 4c 16 	sts	0x164C, r24
	//ground_th = 900;//eeprom_read_word((uint16_t*)8);
	tsl_th_ground = tsl_th + TSL_GROUNDSENS_DIFF;//eeprom_read_word((uint16_t*)10);
    b5ec:	80 91 4e 16 	lds	r24, 0x164E
    b5f0:	90 91 4f 16 	lds	r25, 0x164F
    b5f4:	c2 96       	adiw	r24, 0x32	; 50
    b5f6:	90 93 44 16 	sts	0x1644, r25
    b5fa:	80 93 43 16 	sts	0x1643, r24
    b5fe:	08 95       	ret

0000b600 <init_adc>:

void init_adc(void)
{
	//http://bennthomsen.wordpress.com/embedded-design/peripherals/analogue-input/
	//16MHz/128 = 125kHz the ADC reference clock
	ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));
    b600:	ea e7       	ldi	r30, 0x7A	; 122
    b602:	f0 e0       	ldi	r31, 0x00	; 0
    b604:	80 81       	ld	r24, Z
    b606:	87 60       	ori	r24, 0x07	; 7
    b608:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0);       //Set Voltage reference to Avcc (5v)
    b60a:	ac e7       	ldi	r26, 0x7C	; 124
    b60c:	b0 e0       	ldi	r27, 0x00	; 0
    b60e:	8c 91       	ld	r24, X
    b610:	80 64       	ori	r24, 0x40	; 64
    b612:	8c 93       	st	X, r24
	ADCSRA |= (1<<ADEN);       //Turn on ADC
    b614:	80 81       	ld	r24, Z
    b616:	80 68       	ori	r24, 0x80	; 128
    b618:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADSC);       //Do an initial conversion
    b61a:	80 81       	ld	r24, Z
    b61c:	80 64       	ori	r24, 0x40	; 64
    b61e:	80 83       	st	Z, r24
    b620:	08 95       	ret

0000b622 <init_pwm>:
//Initialisierung der PWM/ des Timers
void init_pwm(void)	//Initialisierung des Timers fr Erzeugung des PWM-Signals
{
  //OC0A/B:
	//normale 8-bit PWM aktivieren
  TCCR0A = (1<<COM0A1)
    b622:	81 ea       	ldi	r24, 0xA1	; 161
    b624:	84 bd       	out	0x24, r24	; 36
					|(1<<COM0B1) //nicht invertierend
					|(1<<WGM00);   //Fast PWM 8bit
		 			
  //Einstellen der PWM-Frequenz
  TCCR0B = (1<<CS02); //Clk/256 (122,5Hz)
    b626:	84 e0       	ldi	r24, 0x04	; 4
    b628:	85 bd       	out	0x25, r24	; 37
	
	//OC4A/B/C:
	TCCR4A = (1<<COM4A1)
    b62a:	99 ea       	ldi	r25, 0xA9	; 169
    b62c:	90 93 a0 00 	sts	0x00A0, r25
					|(1<<COM4B1)
					|(1<<COM4C1)
					|(1<<WGM40);

	TCCR4B = (1<<CS42); //Clk/256
    b630:	80 93 a1 00 	sts	0x00A1, r24

	//OC3A (PWM/Servo)
	TCCR3A = (1<<COM3A1)
    b634:	82 e8       	ldi	r24, 0x82	; 130
    b636:	80 93 90 00 	sts	0x0090, r24
			|(1<<WGM31);

	TCCR3B = (1<<WGM33)
    b63a:	8a e1       	ldi	r24, 0x1A	; 26
    b63c:	80 93 91 00 	sts	0x0091, r24
			|(1<<WGM32)
			|(1<<CS31);

	ICR3 = 40000;
    b640:	80 e4       	ldi	r24, 0x40	; 64
    b642:	9c e9       	ldi	r25, 0x9C	; 156
    b644:	90 93 97 00 	sts	0x0097, r25
    b648:	80 93 96 00 	sts	0x0096, r24

	//OC5A/B:
	TCCR5A = (1<<COM5B1)
    b64c:	89 e2       	ldi	r24, 0x29	; 41
    b64e:	80 93 20 01 	sts	0x0120, r24
					|(1<<COM5C1)
					|(1<<WGM50);

	TCCR5B = (1<<CS50); //Clk/1
    b652:	81 e0       	ldi	r24, 0x01	; 1
    b654:	80 93 21 01 	sts	0x0121, r24

	///////////////////////////////////
	OCR0A = 0; //Zeilenkamera
    b658:	17 bc       	out	0x27, r1	; 39
	OCR0B = 0; //Opfer LED
    b65a:	18 bc       	out	0x28, r1	; 40
	OCR3A = SERVO_T_LOW; //Servo (0)
    b65c:	80 ea       	ldi	r24, 0xA0	; 160
    b65e:	9f e0       	ldi	r25, 0x0F	; 15
    b660:	90 93 99 00 	sts	0x0099, r25
    b664:	80 93 98 00 	sts	0x0098, r24
	OCR5B = 0; //PWM B
    b668:	10 92 2b 01 	sts	0x012B, r1
    b66c:	10 92 2a 01 	sts	0x012A, r1
	OCR5C = 0; //PWM A
    b670:	10 92 2d 01 	sts	0x012D, r1
    b674:	10 92 2c 01 	sts	0x012C, r1
    b678:	08 95       	ret

0000b67a <init_timer>:
}

void init_timer(void)
{
	//OC1: Scheduler
	TCCR1B = (1<<WGM12) //CTC
    b67a:	8b e0       	ldi	r24, 0x0B	; 11
    b67c:	80 93 81 00 	sts	0x0081, r24
			|(1<<CS10)
			|(1<<CS11); //Prescaler 64

	TIMSK1 |= (1<<OCIE1A);
    b680:	ef e6       	ldi	r30, 0x6F	; 111
    b682:	f0 e0       	ldi	r31, 0x00	; 0
    b684:	80 81       	ld	r24, Z
    b686:	82 60       	ori	r24, 0x02	; 2
    b688:	80 83       	st	Z, r24
	
	OCR1A = 250; //1kHz; Scheduler
    b68a:	8a ef       	ldi	r24, 0xFA	; 250
    b68c:	90 e0       	ldi	r25, 0x00	; 0
    b68e:	90 93 89 00 	sts	0x0089, r25
    b692:	80 93 88 00 	sts	0x0088, r24
	
	//OC2A: ADC
	TCCR2A = (1<<WGM21);
    b696:	82 e0       	ldi	r24, 0x02	; 2
    b698:	80 93 b0 00 	sts	0x00B0, r24
					
	TCCR2B = (1<<CS21); //Presc. 8
    b69c:	80 93 b1 00 	sts	0x00B1, r24

	TIMSK2 = (1<<OCIE2A);
    b6a0:	80 93 70 00 	sts	0x0070, r24

	OCR2A = 250; //8kHz 250
    b6a4:	8a ef       	ldi	r24, 0xFA	; 250
    b6a6:	80 93 b3 00 	sts	0x00B3, r24
    b6aa:	08 95       	ret

0000b6ac <get_t1>:
}
////////////////////////////Taster, Bumper//////////////////////////////////////

uint8_t get_t1(void) //Taster neben Power
{
	return (PINC & (1<<PC3));
    b6ac:	86 b1       	in	r24, 0x06	; 6
}
    b6ae:	88 70       	andi	r24, 0x08	; 8
    b6b0:	08 95       	ret

0000b6b2 <get_incrOk>:

uint8_t get_incrOk(void) //incrementalOk
{
	return !(PINC & (1<<PC0));
    b6b2:	86 b1       	in	r24, 0x06	; 6
    b6b4:	80 95       	com	r24
}
    b6b6:	81 70       	andi	r24, 0x01	; 1
    b6b8:	08 95       	ret

0000b6ba <servo_setPos>:

//////////////////////////////Servo////////////

void servo_setPos(uint8_t angle)
{
	uint16_t servo_time = -21*angle+SERVO_T_LOW;
    b6ba:	28 2f       	mov	r18, r24
    b6bc:	3b ee       	ldi	r19, 0xEB	; 235
    b6be:	32 03       	mulsu	r19, r18
    b6c0:	c0 01       	movw	r24, r0
    b6c2:	11 24       	eor	r1, r1
    b6c4:	80 56       	subi	r24, 0x60	; 96
    b6c6:	90 4f       	sbci	r25, 0xF0	; 240
	if(servo_time < SERVO_T_MIN)
    b6c8:	88 30       	cpi	r24, 0x08	; 8
    b6ca:	27 e0       	ldi	r18, 0x07	; 7
    b6cc:	92 07       	cpc	r25, r18
    b6ce:	38 f0       	brcs	.+14     	; 0xb6de <servo_setPos+0x24>
    b6d0:	85 30       	cpi	r24, 0x05	; 5
    b6d2:	30 e1       	ldi	r19, 0x10	; 16
    b6d4:	93 07       	cpc	r25, r19
    b6d6:	28 f0       	brcs	.+10     	; 0xb6e2 <servo_setPos+0x28>
    b6d8:	84 e0       	ldi	r24, 0x04	; 4
    b6da:	90 e1       	ldi	r25, 0x10	; 16
    b6dc:	02 c0       	rjmp	.+4      	; 0xb6e2 <servo_setPos+0x28>
		servo_time = SERVO_T_MIN;
    b6de:	88 e0       	ldi	r24, 0x08	; 8
    b6e0:	97 e0       	ldi	r25, 0x07	; 7
	else if(servo_time > SERVO_T_MAX)
		servo_time = SERVO_T_MAX;
	OCR3A = servo_time;
    b6e2:	90 93 99 00 	sts	0x0099, r25
    b6e6:	80 93 98 00 	sts	0x0098, r24
    b6ea:	08 95       	ret

0000b6ec <motor_activate>:

////////////////////////////////////////////////////////////////////////////////

void motor_activate(uint8_t activate)
{
	if(activate)
    b6ec:	88 23       	and	r24, r24
    b6ee:	21 f0       	breq	.+8      	; 0xb6f8 <motor_activate+0xc>
		PORTL |= (1<<6); //No Standby
    b6f0:	80 91 0b 01 	lds	r24, 0x010B
    b6f4:	80 64       	ori	r24, 0x40	; 64
    b6f6:	03 c0       	rjmp	.+6      	; 0xb6fe <motor_activate+0x12>
	else
		PORTL &= ~(1<<6);
    b6f8:	80 91 0b 01 	lds	r24, 0x010B
    b6fc:	8f 7b       	andi	r24, 0xBF	; 191
    b6fe:	80 93 0b 01 	sts	0x010B, r24
    b702:	08 95       	ret

0000b704 <set_speed>:
}

int16_t pwr[2];

void set_speed(void)
{
    b704:	a4 e0       	ldi	r26, 0x04	; 4
    b706:	b0 e0       	ldi	r27, 0x00	; 0
    b708:	e8 e8       	ldi	r30, 0x88	; 136
    b70a:	fb e5       	ldi	r31, 0x5B	; 91
    b70c:	0c 94 ab 6b 	jmp	0xd756	; 0xd756 <__prologue_saves__+0x20>
	int16_t pwrvar_left = pwr[LEFT];
    b710:	80 91 63 16 	lds	r24, 0x1663
    b714:	90 91 64 16 	lds	r25, 0x1664
    b718:	9c 83       	std	Y+4, r25	; 0x04
    b71a:	8b 83       	std	Y+3, r24	; 0x03
	int16_t pwrvar_right = pwr[RIGHT];
    b71c:	20 91 65 16 	lds	r18, 0x1665
    b720:	30 91 66 16 	lds	r19, 0x1666
    b724:	3a 83       	std	Y+2, r19	; 0x02
    b726:	29 83       	std	Y+1, r18	; 0x01

	if(pwrvar_left > 0)
    b728:	18 16       	cp	r1, r24
    b72a:	19 06       	cpc	r1, r25
    b72c:	24 f4       	brge	.+8      	; 0xb736 <set_speed+0x32>
	{
		PORTL &= ~(1<<2); //DIRA1
    b72e:	80 91 0b 01 	lds	r24, 0x010B
    b732:	8b 7f       	andi	r24, 0xFB	; 251
    b734:	05 c0       	rjmp	.+10     	; 0xb740 <set_speed+0x3c>
		PORTL |= (1<<3); //DIRA2
	}
	else if(pwrvar_left == 0)
    b736:	89 2b       	or	r24, r25
    b738:	49 f4       	brne	.+18     	; 0xb74c <set_speed+0x48>
	{
		PORTL |= (1<<2); //DIRA1
    b73a:	80 91 0b 01 	lds	r24, 0x010B
    b73e:	84 60       	ori	r24, 0x04	; 4
    b740:	80 93 0b 01 	sts	0x010B, r24
		PORTL |= (1<<3); //DIRA2
    b744:	80 91 0b 01 	lds	r24, 0x010B
    b748:	88 60       	ori	r24, 0x08	; 8
    b74a:	08 c0       	rjmp	.+16     	; 0xb75c <set_speed+0x58>
	}
	else if(pwrvar_left < 0)
	{
		PORTL |= (1<<2); //DIRA1
    b74c:	80 91 0b 01 	lds	r24, 0x010B
    b750:	84 60       	ori	r24, 0x04	; 4
    b752:	80 93 0b 01 	sts	0x010B, r24
		PORTL &= ~(1<<3); //DIRA2
    b756:	80 91 0b 01 	lds	r24, 0x010B
    b75a:	87 7f       	andi	r24, 0xF7	; 247
    b75c:	80 93 0b 01 	sts	0x010B, r24
	}

	if(pwrvar_right > 0)
    b760:	89 81       	ldd	r24, Y+1	; 0x01
    b762:	9a 81       	ldd	r25, Y+2	; 0x02
    b764:	18 16       	cp	r1, r24
    b766:	19 06       	cpc	r1, r25
    b768:	4c f4       	brge	.+18     	; 0xb77c <set_speed+0x78>
	{
		PORTL |= (1<<1); //DIRB1 //rechter Motor rckwrts
    b76a:	80 91 0b 01 	lds	r24, 0x010B
    b76e:	82 60       	ori	r24, 0x02	; 2
    b770:	80 93 0b 01 	sts	0x010B, r24
		PORTL &= ~(1<<0); //DIRB2
    b774:	80 91 0b 01 	lds	r24, 0x010B
    b778:	8e 7f       	andi	r24, 0xFE	; 254
    b77a:	0e c0       	rjmp	.+28     	; 0xb798 <set_speed+0x94>
	}
	else if(pwrvar_right == 0)
    b77c:	89 2b       	or	r24, r25
    b77e:	21 f4       	brne	.+8      	; 0xb788 <set_speed+0x84>
	{
		PORTL |= (1<<1); //DIRB1
    b780:	80 91 0b 01 	lds	r24, 0x010B
    b784:	82 60       	ori	r24, 0x02	; 2
    b786:	03 c0       	rjmp	.+6      	; 0xb78e <set_speed+0x8a>
		PORTL |= (1<<0); //DIRB2 Motor aus
	}
	else if(pwrvar_right < 0)
	{
		PORTL &= ~(1<<1); //DIRB1
    b788:	80 91 0b 01 	lds	r24, 0x010B
    b78c:	8d 7f       	andi	r24, 0xFD	; 253
    b78e:	80 93 0b 01 	sts	0x010B, r24
		PORTL |= (1<<0); //DIRB2; //Rechter Motor vorwrts
    b792:	80 91 0b 01 	lds	r24, 0x010B
    b796:	81 60       	ori	r24, 0x01	; 1
    b798:	80 93 0b 01 	sts	0x010B, r24
	}

	abs_ptr(&pwrvar_left);
    b79c:	ce 01       	movw	r24, r28
    b79e:	03 96       	adiw	r24, 0x03	; 3
    b7a0:	0e 94 e8 34 	call	0x69d0	; 0x69d0 <abs_ptr>
	abs_ptr(&pwrvar_right);
    b7a4:	ce 01       	movw	r24, r28
    b7a6:	01 96       	adiw	r24, 0x01	; 1
    b7a8:	0e 94 e8 34 	call	0x69d0	; 0x69d0 <abs_ptr>
	
	if(pwrvar_left > 255)
    b7ac:	8b 81       	ldd	r24, Y+3	; 0x03
    b7ae:	9c 81       	ldd	r25, Y+4	; 0x04
    b7b0:	8f 3f       	cpi	r24, 0xFF	; 255
    b7b2:	91 05       	cpc	r25, r1
    b7b4:	29 f0       	breq	.+10     	; 0xb7c0 <set_speed+0xbc>
    b7b6:	24 f0       	brlt	.+8      	; 0xb7c0 <set_speed+0xbc>
		pwrvar_left = 255;
    b7b8:	8f ef       	ldi	r24, 0xFF	; 255
    b7ba:	90 e0       	ldi	r25, 0x00	; 0
    b7bc:	9c 83       	std	Y+4, r25	; 0x04
    b7be:	8b 83       	std	Y+3, r24	; 0x03
	if(pwrvar_right > 255)
    b7c0:	89 81       	ldd	r24, Y+1	; 0x01
    b7c2:	9a 81       	ldd	r25, Y+2	; 0x02
    b7c4:	8f 3f       	cpi	r24, 0xFF	; 255
    b7c6:	91 05       	cpc	r25, r1
    b7c8:	29 f0       	breq	.+10     	; 0xb7d4 <set_speed+0xd0>
    b7ca:	24 f0       	brlt	.+8      	; 0xb7d4 <set_speed+0xd0>
		pwrvar_right = 255;
    b7cc:	8f ef       	ldi	r24, 0xFF	; 255
    b7ce:	90 e0       	ldi	r25, 0x00	; 0
    b7d0:	9a 83       	std	Y+2, r25	; 0x02
    b7d2:	89 83       	std	Y+1, r24	; 0x01

	if(pwrvar_left == 0)
    b7d4:	6b 81       	ldd	r22, Y+3	; 0x03
    b7d6:	7c 81       	ldd	r23, Y+4	; 0x04
    b7d8:	61 15       	cp	r22, r1
    b7da:	71 05       	cpc	r23, r1
    b7dc:	29 f4       	brne	.+10     	; 0xb7e8 <set_speed+0xe4>
		OCR5C = 0;
    b7de:	10 92 2d 01 	sts	0x012D, r1
    b7e2:	10 92 2c 01 	sts	0x012C, r1
    b7e6:	18 c0       	rjmp	.+48     	; 0xb818 <set_speed+0x114>
	else
		 OCR5C = ((0.84*pwrvar_left)+40); //PWMB (Geschwindigkeit) linker Motor
    b7e8:	88 27       	eor	r24, r24
    b7ea:	77 fd       	sbrc	r23, 7
    b7ec:	80 95       	com	r24
    b7ee:	98 2f       	mov	r25, r24
    b7f0:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    b7f4:	2d e3       	ldi	r18, 0x3D	; 61
    b7f6:	3a e0       	ldi	r19, 0x0A	; 10
    b7f8:	47 e5       	ldi	r20, 0x57	; 87
    b7fa:	5f e3       	ldi	r21, 0x3F	; 63
    b7fc:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    b800:	20 e0       	ldi	r18, 0x00	; 0
    b802:	30 e0       	ldi	r19, 0x00	; 0
    b804:	40 e2       	ldi	r20, 0x20	; 32
    b806:	52 e4       	ldi	r21, 0x42	; 66
    b808:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    b80c:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    b810:	70 93 2d 01 	sts	0x012D, r23
    b814:	60 93 2c 01 	sts	0x012C, r22

	if(pwrvar_right == 0)
    b818:	69 81       	ldd	r22, Y+1	; 0x01
    b81a:	7a 81       	ldd	r23, Y+2	; 0x02
    b81c:	61 15       	cp	r22, r1
    b81e:	71 05       	cpc	r23, r1
    b820:	29 f4       	brne	.+10     	; 0xb82c <set_speed+0x128>
		OCR5B = 0;
    b822:	10 92 2b 01 	sts	0x012B, r1
    b826:	10 92 2a 01 	sts	0x012A, r1
    b82a:	18 c0       	rjmp	.+48     	; 0xb85c <set_speed+0x158>
	else
		OCR5B = ((0.84*pwrvar_right)+40); //PWMA (Geschwindigkeit) rechter Motor
    b82c:	88 27       	eor	r24, r24
    b82e:	77 fd       	sbrc	r23, 7
    b830:	80 95       	com	r24
    b832:	98 2f       	mov	r25, r24
    b834:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    b838:	2d e3       	ldi	r18, 0x3D	; 61
    b83a:	3a e0       	ldi	r19, 0x0A	; 10
    b83c:	47 e5       	ldi	r20, 0x57	; 87
    b83e:	5f e3       	ldi	r21, 0x3F	; 63
    b840:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    b844:	20 e0       	ldi	r18, 0x00	; 0
    b846:	30 e0       	ldi	r19, 0x00	; 0
    b848:	40 e2       	ldi	r20, 0x20	; 32
    b84a:	52 e4       	ldi	r21, 0x42	; 66
    b84c:	0e 94 15 69 	call	0xd22a	; 0xd22a <__addsf3>
    b850:	0e 94 ea 69 	call	0xd3d4	; 0xd3d4 <__fixunssfsi>
    b854:	70 93 2b 01 	sts	0x012B, r23
    b858:	60 93 2a 01 	sts	0x012A, r22
}
    b85c:	24 96       	adiw	r28, 0x04	; 4
    b85e:	e2 e0       	ldi	r30, 0x02	; 2
    b860:	0c 94 c7 6b 	jmp	0xd78e	; 0xd78e <__epilogue_restores__+0x20>

0000b864 <display_setBGLED>:
//Einzelne IOs

//Hintergrundbeleuchtung Display
void display_setBGLED(uint8_t state)
{
	if(state == 1)	PORTC |= (1<<4);
    b864:	81 30       	cpi	r24, 0x01	; 1
    b866:	11 f4       	brne	.+4      	; 0xb86c <display_setBGLED+0x8>
    b868:	44 9a       	sbi	0x08, 4	; 8
    b86a:	08 95       	ret
	else						PORTC &= ~(1<<4);
    b86c:	44 98       	cbi	0x08, 4	; 8
    b86e:	08 95       	ret

0000b870 <init_display>:
	OCR2A = 250; //8kHz 250
}

///////////////////////////////////Display//////////////////////////////////////
void init_display(uint8_t ledstate)
{
    b870:	0f 93       	push	r16
	u8g_InitHWSPI(&u8g, &u8g_dev_st7920_128x64_hw_spi, PN(1, 0), U8G_PIN_NONE, U8G_PIN_NONE);
    b872:	60 e0       	ldi	r22, 0x00	; 0
    b874:	81 e0       	ldi	r24, 0x01	; 1
    b876:	b8 d7       	rcall	.+3952   	; 0xc7e8 <u8g_Pin>
    b878:	0f ef       	ldi	r16, 0xFF	; 255
    b87a:	2f ef       	ldi	r18, 0xFF	; 255
    b87c:	48 2f       	mov	r20, r24
    b87e:	66 ec       	ldi	r22, 0xC6	; 198
    b880:	72 e0       	ldi	r23, 0x02	; 2
    b882:	8b e1       	ldi	r24, 0x1B	; 27
    b884:	97 e0       	ldi	r25, 0x07	; 7
    b886:	0e 94 77 1e 	call	0x3cee	; 0x3cee <u8g_InitHWSPI>
    b88a:	8b e1       	ldi	r24, 0x1B	; 27
	u8g_SetRot180(&u8g);
    b88c:	97 e0       	ldi	r25, 0x07	; 7
    b88e:	0e 94 c5 67 	call	0xcf8a	; 0xcf8a <u8g_SetRot180>
    b892:	81 e0       	ldi	r24, 0x01	; 1
	display_setBGLED(1);	  //Hintergrundbeleuchtung
    b894:	e7 df       	rcall	.-50     	; 0xb864 <display_setBGLED>
    b896:	0f 91       	pop	r16
    b898:	08 95       	ret

0000b89a <groundSens_setLED>:
}

//TSL LED
void groundSens_setLED(uint8_t brightness)
{
	OCR0A = brightness;
    b89a:	87 bd       	out	0x27, r24	; 39
    b89c:	08 95       	ret

0000b89e <controlSpeed>:
MOTOR_ROB_t mot;

#define SPEED_MAX 255

void controlSpeed(void) //eigentliche Geschwindigkeitsregelung, muss mit 40Hz aufgerufen werden!
{
    b89e:	a0 e0       	ldi	r26, 0x00	; 0
    b8a0:	b0 e0       	ldi	r27, 0x00	; 0
    b8a2:	e5 e5       	ldi	r30, 0x55	; 85
    b8a4:	fc e5       	ldi	r31, 0x5C	; 92
    b8a6:	0c 94 a3 6b 	jmp	0xd746	; 0xd746 <__prologue_saves__+0x10>
    b8aa:	c7 e6       	ldi	r28, 0x67	; 103
    b8ac:	d6 e1       	ldi	r29, 0x16	; 22
    b8ae:	8b e5       	ldi	r24, 0x5B	; 91
    b8b0:	e8 2e       	mov	r14, r24
    b8b2:	86 e1       	ldi	r24, 0x16	; 22
    b8b4:	f8 2e       	mov	r15, r24
    b8b6:	03 e6       	ldi	r16, 0x63	; 99
    b8b8:	16 e1       	ldi	r17, 0x16	; 22
		{
			pwr[i] = ((mot.d[i].speed.to - mot.d[i].speed.is)*2.4);
			if(pwr[i] > SPEED_MAX)
				pwr[i] = SPEED_MAX;
			if(pwr[i] < -SPEED_MAX)
				pwr[i] = -SPEED_MAX;
    b8ba:	cc 24       	eor	r12, r12
    b8bc:	c3 94       	inc	r12
    b8be:	dd 24       	eor	r13, r13
    b8c0:	da 94       	dec	r13

		if(mot.d[i].speed.to != 0)
		{
			pwr[i] = ((mot.d[i].speed.to - mot.d[i].speed.is)*2.4);
			if(pwr[i] > SPEED_MAX)
				pwr[i] = SPEED_MAX;
    b8c2:	aa 24       	eor	r10, r10
    b8c4:	aa 94       	dec	r10
    b8c6:	b1 2c       	mov	r11, r1

void controlSpeed(void) //eigentliche Geschwindigkeitsregelung, muss mit 40Hz aufgerufen werden!
{
	for(uint8_t i = 0; i < 2; i++)
	{
		mot.d[i].speed.is = (mot.d[i].enc - enc_start[i]);
    b8c8:	2c 81       	ldd	r18, Y+4	; 0x04
    b8ca:	3d 81       	ldd	r19, Y+5	; 0x05
    b8cc:	f7 01       	movw	r30, r14
    b8ce:	80 81       	ld	r24, Z
    b8d0:	91 81       	ldd	r25, Z+1	; 0x01
    b8d2:	28 1b       	sub	r18, r24
    b8d4:	39 0b       	sbc	r19, r25
    b8d6:	39 83       	std	Y+1, r19	; 0x01
    b8d8:	28 83       	st	Y, r18
		enc_start[i] = mot.d[i].enc;
    b8da:	8c 81       	ldd	r24, Y+4	; 0x04
    b8dc:	9d 81       	ldd	r25, Y+5	; 0x05
    b8de:	ae 81       	ldd	r26, Y+6	; 0x06
    b8e0:	bf 81       	ldd	r27, Y+7	; 0x07
    b8e2:	81 93       	st	Z+, r24
    b8e4:	91 93       	st	Z+, r25
    b8e6:	a1 93       	st	Z+, r26
    b8e8:	b1 93       	st	Z+, r27
    b8ea:	7f 01       	movw	r14, r30

		if(mot.d[i].speed.to != 0)
    b8ec:	6a 81       	ldd	r22, Y+2	; 0x02
    b8ee:	7b 81       	ldd	r23, Y+3	; 0x03
    b8f0:	61 15       	cp	r22, r1
    b8f2:	71 05       	cpc	r23, r1
    b8f4:	21 f1       	breq	.+72     	; 0xb93e <controlSpeed+0xa0>
		{
			pwr[i] = ((mot.d[i].speed.to - mot.d[i].speed.is)*2.4);
    b8f6:	62 1b       	sub	r22, r18
    b8f8:	73 0b       	sbc	r23, r19
    b8fa:	88 27       	eor	r24, r24
    b8fc:	77 fd       	sbrc	r23, 7
    b8fe:	80 95       	com	r24
    b900:	98 2f       	mov	r25, r24
    b902:	0e 94 18 6a 	call	0xd430	; 0xd430 <__floatsisf>
    b906:	2a e9       	ldi	r18, 0x9A	; 154
    b908:	39 e9       	ldi	r19, 0x99	; 153
    b90a:	49 e1       	ldi	r20, 0x19	; 25
    b90c:	50 e4       	ldi	r21, 0x40	; 64
    b90e:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    b912:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
			if(pwr[i] > SPEED_MAX)
				pwr[i] = SPEED_MAX;
    b916:	f8 01       	movw	r30, r16
		enc_start[i] = mot.d[i].enc;

		if(mot.d[i].speed.to != 0)
		{
			pwr[i] = ((mot.d[i].speed.to - mot.d[i].speed.is)*2.4);
			if(pwr[i] > SPEED_MAX)
    b918:	6f 3f       	cpi	r22, 0xFF	; 255
    b91a:	71 05       	cpc	r23, r1
    b91c:	09 f0       	breq	.+2      	; 0xb920 <controlSpeed+0x82>
    b91e:	1c f4       	brge	.+6      	; 0xb926 <controlSpeed+0x88>
		mot.d[i].speed.is = (mot.d[i].enc - enc_start[i]);
		enc_start[i] = mot.d[i].enc;

		if(mot.d[i].speed.to != 0)
		{
			pwr[i] = ((mot.d[i].speed.to - mot.d[i].speed.is)*2.4);
    b920:	71 83       	std	Z+1, r23	; 0x01
    b922:	60 83       	st	Z, r22
    b924:	02 c0       	rjmp	.+4      	; 0xb92a <controlSpeed+0x8c>
			if(pwr[i] > SPEED_MAX)
				pwr[i] = SPEED_MAX;
    b926:	b1 82       	std	Z+1, r11	; 0x01
    b928:	a0 82       	st	Z, r10
			if(pwr[i] < -SPEED_MAX)
    b92a:	f8 01       	movw	r30, r16
    b92c:	80 81       	ld	r24, Z
    b92e:	91 81       	ldd	r25, Z+1	; 0x01
    b930:	81 30       	cpi	r24, 0x01	; 1
    b932:	9f 4f       	sbci	r25, 0xFF	; 255
    b934:	3c f4       	brge	.+14     	; 0xb944 <controlSpeed+0xa6>
				pwr[i] = -SPEED_MAX;
    b936:	f8 01       	movw	r30, r16
    b938:	d1 82       	std	Z+1, r13	; 0x01
    b93a:	c0 82       	st	Z, r12
    b93c:	03 c0       	rjmp	.+6      	; 0xb944 <controlSpeed+0xa6>
		}
		else
		{
			pwr[i] = 0;
    b93e:	f8 01       	movw	r30, r16
    b940:	11 82       	std	Z+1, r1	; 0x01
    b942:	10 82       	st	Z, r1
    b944:	2c 96       	adiw	r28, 0x0c	; 12
    b946:	0e 5f       	subi	r16, 0xFE	; 254
    b948:	1f 4f       	sbci	r17, 0xFF	; 255

#define SPEED_MAX 255

void controlSpeed(void) //eigentliche Geschwindigkeitsregelung, muss mit 40Hz aufgerufen werden!
{
	for(uint8_t i = 0; i < 2; i++)
    b94a:	f6 e1       	ldi	r31, 0x16	; 22
    b94c:	cf 37       	cpi	r28, 0x7F	; 127
    b94e:	df 07       	cpc	r29, r31
    b950:	09 f0       	breq	.+2      	; 0xb954 <controlSpeed+0xb6>
    b952:	ba cf       	rjmp	.-140    	; 0xb8c8 <controlSpeed+0x2a>
		{
			pwr[i] = 0;
		}
	}

	set_speed();
    b954:	d7 de       	rcall	.-594    	; 0xb704 <set_speed>
    b956:	cd b7       	in	r28, 0x3d	; 61
	bt_putLong(i_speed_r);*/
	/*bt_putStr("\n\r");
	bt_putLong(timer);
	bt_putStr(" ");
	bt_putLong(pwr_left);*/
}
    b958:	de b7       	in	r29, 0x3e	; 62
    b95a:	ea e0       	ldi	r30, 0x0A	; 10
    b95c:	0c 94 bf 6b 	jmp	0xd77e	; 0xd77e <__epilogue_restores__+0x10>

0000b960 <__vector_13>:
int16_t tsl_adc_data[ADC_MED_SAMPLES];

int8_t tsl_adc_state = ADC_CAM_IDLE;

ISR(TIMER2_COMPA_vect) //8kHz -> (1/8000*(128/TSL_RES)
{	
    b960:	1f 92       	push	r1
    b962:	0f 92       	push	r0
    b964:	0f b6       	in	r0, 0x3f	; 63
    b966:	0f 92       	push	r0
    b968:	11 24       	eor	r1, r1
    b96a:	0b b6       	in	r0, 0x3b	; 59
    b96c:	0f 92       	push	r0
    b96e:	2f 93       	push	r18
    b970:	3f 93       	push	r19
    b972:	4f 93       	push	r20
    b974:	5f 93       	push	r21
    b976:	6f 93       	push	r22
    b978:	7f 93       	push	r23
    b97a:	8f 93       	push	r24
    b97c:	9f 93       	push	r25
    b97e:	af 93       	push	r26
    b980:	bf 93       	push	r27
    b982:	cf 93       	push	r28
    b984:	df 93       	push	r29
    b986:	ef 93       	push	r30
    b988:	ff 93       	push	r31
	switch(tsl_adc_state)
    b98a:	e0 91 d8 05 	lds	r30, 0x05D8
    b98e:	e6 30       	cpi	r30, 0x06	; 6
    b990:	44 f4       	brge	.+16     	; 0xb9a2 <__vector_13+0x42>
    b992:	e2 30       	cpi	r30, 0x02	; 2
    b994:	24 f5       	brge	.+72     	; 0xb9de <__vector_13+0x7e>
    b996:	ee 23       	and	r30, r30
    b998:	09 f4       	brne	.+2      	; 0xb99c <__vector_13+0x3c>
    b99a:	84 c0       	rjmp	.+264    	; 0xbaa4 <__vector_13+0x144>
    b99c:	e1 30       	cpi	r30, 0x01	; 1
    b99e:	39 f0       	breq	.+14     	; 0xb9ae <__vector_13+0x4e>
    b9a0:	65 c0       	rjmp	.+202    	; 0xba6c <__vector_13+0x10c>
    b9a2:	e6 30       	cpi	r30, 0x06	; 6
    b9a4:	79 f1       	breq	.+94     	; 0xba04 <__vector_13+0xa4>
    b9a6:	e7 30       	cpi	r30, 0x07	; 7
    b9a8:	09 f4       	brne	.+2      	; 0xb9ac <__vector_13+0x4c>
    b9aa:	7c c0       	rjmp	.+248    	; 0xbaa4 <__vector_13+0x144>
    b9ac:	5f c0       	rjmp	.+190    	; 0xba6c <__vector_13+0x10c>
	{
		case ADC_CAM_IDLE: break;
		case ADC_CAM_INIT:
				
				if(!(ADCSRA & (1<<ADSC))) //No running conversions
    b9ae:	80 91 7a 00 	lds	r24, 0x007A
    b9b2:	86 fd       	sbrc	r24, 6
    b9b4:	77 c0       	rjmp	.+238    	; 0xbaa4 <__vector_13+0x144>
				{
					//Set MUX for next channel:
					ADMUX &= 0xE0;						//Clear bits MUX0-4
    b9b6:	80 91 7c 00 	lds	r24, 0x007C
    b9ba:	80 7e       	andi	r24, 0xE0	; 224
    b9bc:	80 93 7c 00 	sts	0x007C, r24
					ADMUX |= TSL_A0_CH & 0x07;		//Defines the new ADC channel to be read by setting bits MUX0-2
    b9c0:	80 91 7c 00 	lds	r24, 0x007C
    b9c4:	85 60       	ori	r24, 0x05	; 5
    b9c6:	80 93 7c 00 	sts	0x007C, r24
					ADCSRB = TSL_A0_CH & (1<<3);	//Set MUX5
    b9ca:	88 e0       	ldi	r24, 0x08	; 8
    b9cc:	80 93 7b 00 	sts	0x007B, r24
					ADCSRA |= (1<<ADSC); 			//New Conversion for the next Channel
    b9d0:	80 91 7a 00 	lds	r24, 0x007A
    b9d4:	80 64       	ori	r24, 0x40	; 64
    b9d6:	80 93 7a 00 	sts	0x007A, r24
				
					tsl_adc_state = MEASURE_1;
    b9da:	82 e0       	ldi	r24, 0x02	; 2
    b9dc:	3f c0       	rjmp	.+126    	; 0xba5c <__vector_13+0xfc>
		case MEASURE_1:
		case MEASURE_2:
		case MEASURE_3:
		case MEASURE_4:
		
				tsl_adc_data[tsl_adc_state - MEASURE_1] = ADCW;
    b9de:	80 91 78 00 	lds	r24, 0x0078
    b9e2:	90 91 79 00 	lds	r25, 0x0079
    b9e6:	ee 0f       	add	r30, r30
    b9e8:	ff 0b       	sbc	r31, r31
    b9ea:	e2 51       	subi	r30, 0x12	; 18
    b9ec:	f9 4e       	sbci	r31, 0xE9	; 233
    b9ee:	91 83       	std	Z+1, r25	; 0x01
    b9f0:	80 83       	st	Z, r24
				ADCSRA |= (1<<ADSC);	//Start new Conversion
    b9f2:	80 91 7a 00 	lds	r24, 0x007A
    b9f6:	80 64       	ori	r24, 0x40	; 64
    b9f8:	80 93 7a 00 	sts	0x007A, r24

				tsl_adc_state ++;
    b9fc:	80 91 d8 05 	lds	r24, 0x05D8
    ba00:	8f 5f       	subi	r24, 0xFF	; 255
    ba02:	2c c0       	rjmp	.+88     	; 0xba5c <__vector_13+0xfc>

			break;
		case MEASURE_5_RES:

				tsl_adc_data[4] = ADCW;
    ba04:	80 91 78 00 	lds	r24, 0x0078
    ba08:	90 91 79 00 	lds	r25, 0x0079
    ba0c:	90 93 fb 16 	sts	0x16FB, r25
    ba10:	80 93 fa 16 	sts	0x16FA, r24
				
				tslData[tsl_resolutionCnt] = *get_sorted(ADC_MED_SAMPLES, tsl_adc_data, ADC_MED_SAMPLES/2);	//Median-filter
    ba14:	c0 91 fc 16 	lds	r28, 0x16FC
    ba18:	d0 e0       	ldi	r29, 0x00	; 0
    ba1a:	42 e0       	ldi	r20, 0x02	; 2
    ba1c:	62 ef       	ldi	r22, 0xF2	; 242
    ba1e:	76 e1       	ldi	r23, 0x16	; 22
    ba20:	85 e0       	ldi	r24, 0x05	; 5
    ba22:	0e 94 50 36 	call	0x6ca0	; 0x6ca0 <get_sorted>
    ba26:	fc 01       	movw	r30, r24
    ba28:	80 81       	ld	r24, Z
    ba2a:	91 81       	ldd	r25, Z+1	; 0x01
    ba2c:	fe 01       	movw	r30, r28
    ba2e:	ee 0f       	add	r30, r30
    ba30:	ff 1f       	adc	r31, r31
    ba32:	ef 54       	subi	r30, 0x4F	; 79
    ba34:	f9 4e       	sbci	r31, 0xE9	; 233
    ba36:	91 83       	std	Z+1, r25	; 0x01
    ba38:	80 83       	st	Z, r24
				
				tsl_resolutionCnt --;
    ba3a:	80 91 fc 16 	lds	r24, 0x16FC
    ba3e:	81 50       	subi	r24, 0x01	; 1
    ba40:	80 93 fc 16 	sts	0x16FC, r24
    ba44:	94 e0       	ldi	r25, 0x04	; 4
						tsl_adc_state = ADC_CAM_DONE;
						break;
					}
					else
					{
						tsl_adc_state = MEASURE_1;
    ba46:	22 e0       	ldi	r18, 0x02	; 2
				
				tsl_resolutionCnt --;
	
				for(uint8_t i = 0; i < TSL_RESOLUTION; i ++)
				{
					TSL_CK_PORT &= ~(1<<TSL_CK_PIN);
    ba48:	15 98       	cbi	0x02, 5	; 2
					TSL_CK_PORT |= (1<<TSL_CK_PIN);
    ba4a:	15 9a       	sbi	0x02, 5	; 2
		
					tsl_pixCnt ++;
    ba4c:	80 91 fd 16 	lds	r24, 0x16FD
    ba50:	8f 5f       	subi	r24, 0xFF	; 255
    ba52:	80 93 fd 16 	sts	0x16FD, r24
					
					if(tsl_pixCnt >= 129) //Ready
    ba56:	81 38       	cpi	r24, 0x81	; 129
    ba58:	20 f0       	brcs	.+8      	; 0xba62 <__vector_13+0x102>
					{
						tsl_adc_state = ADC_CAM_DONE;
    ba5a:	87 e0       	ldi	r24, 0x07	; 7
    ba5c:	80 93 d8 05 	sts	0x05D8, r24
						break;
    ba60:	21 c0       	rjmp	.+66     	; 0xbaa4 <__vector_13+0x144>
					}
					else
					{
						tsl_adc_state = MEASURE_1;
    ba62:	20 93 d8 05 	sts	0x05D8, r18
    ba66:	91 50       	subi	r25, 0x01	; 1
				
				tslData[tsl_resolutionCnt] = *get_sorted(ADC_MED_SAMPLES, tsl_adc_data, ADC_MED_SAMPLES/2);	//Median-filter
				
				tsl_resolutionCnt --;
	
				for(uint8_t i = 0; i < TSL_RESOLUTION; i ++)
    ba68:	79 f7       	brne	.-34     	; 0xba48 <__vector_13+0xe8>
    ba6a:	1c c0       	rjmp	.+56     	; 0xbaa4 <__vector_13+0x144>
				}
			break;
			
		case ADC_CAM_DONE: break;
		default:
				if(debug > 1){bt_putStr_P(PSTR("\n\r")); bt_putLong(timer); bt_putStr_P(PSTR(": ERROR::FATAL:WENT_INTO:ISR(TIMER2_COMPA_vect)[task_adc]::case:default"));}
    ba6c:	80 91 53 05 	lds	r24, 0x0553
    ba70:	82 30       	cpi	r24, 0x02	; 2
    ba72:	90 f0       	brcs	.+36     	; 0xba98 <__vector_13+0x138>
    ba74:	84 eb       	ldi	r24, 0xB4	; 180
    ba76:	9c e2       	ldi	r25, 0x2C	; 44
    ba78:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
    ba7c:	60 91 47 05 	lds	r22, 0x0547
    ba80:	70 91 48 05 	lds	r23, 0x0548
    ba84:	80 91 49 05 	lds	r24, 0x0549
    ba88:	90 91 4a 05 	lds	r25, 0x054A
    ba8c:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <bt_putLong>
    ba90:	8c e6       	ldi	r24, 0x6C	; 108
    ba92:	9c e2       	ldi	r25, 0x2C	; 44
    ba94:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <bt_putStr_P>
				tsl_adc_state = -1;
    ba98:	8f ef       	ldi	r24, 0xFF	; 255
    ba9a:	80 93 d8 05 	sts	0x05D8, r24
				fatal_err = 1;
    ba9e:	81 e0       	ldi	r24, 0x01	; 1
    baa0:	80 93 63 05 	sts	0x0563, r24
	}
}
    baa4:	ff 91       	pop	r31
    baa6:	ef 91       	pop	r30
    baa8:	df 91       	pop	r29
    baaa:	cf 91       	pop	r28
    baac:	bf 91       	pop	r27
    baae:	af 91       	pop	r26
    bab0:	9f 91       	pop	r25
    bab2:	8f 91       	pop	r24
    bab4:	7f 91       	pop	r23
    bab6:	6f 91       	pop	r22
    bab8:	5f 91       	pop	r21
    baba:	4f 91       	pop	r20
    babc:	3f 91       	pop	r19
    babe:	2f 91       	pop	r18
    bac0:	0f 90       	pop	r0
    bac2:	0b be       	out	0x3b, r0	; 59
    bac4:	0f 90       	pop	r0
    bac6:	0f be       	out	0x3f, r0	; 63
    bac8:	0f 90       	pop	r0
    baca:	1f 90       	pop	r1
    bacc:	18 95       	reti

0000bace <init_i2c>:
*************************************************************************/
void init_i2c(void)
{
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  
  TWSR = 0;                         /* no prescaler */
    bace:	10 92 b9 00 	sts	0x00B9, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
    bad2:	88 e4       	ldi	r24, 0x48	; 72
    bad4:	80 93 b8 00 	sts	0x00B8, r24
    bad8:	08 95       	ret

0000bada <i2c_start>:
/*************************************************************************	
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
    bada:	48 2f       	mov	r20, r24
    uint8_t   twst;

	uint8_t returnvar = 0;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    badc:	84 ea       	ldi	r24, 0xA4	; 164
    bade:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	i2c_killCounter = 0;
    bae2:	10 92 df 05 	sts	0x05DF, r1
    bae6:	10 92 de 05 	sts	0x05DE, r1
	while(!(TWCR & (1<<TWINT)))
    baea:	80 91 bc 00 	lds	r24, 0x00BC
    baee:	87 fd       	sbrc	r24, 7
    baf0:	15 c0       	rjmp	.+42     	; 0xbb1c <i2c_start+0x42>
	{
		i2c_killCounter ++;
    baf2:	20 91 de 05 	lds	r18, 0x05DE
    baf6:	30 91 df 05 	lds	r19, 0x05DF
    bafa:	2f 5f       	subi	r18, 0xFF	; 255
    bafc:	3f 4f       	sbci	r19, 0xFF	; 255
    bafe:	30 93 df 05 	sts	0x05DF, r19
    bb02:	20 93 de 05 	sts	0x05DE, r18
		if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bb06:	29 3e       	cpi	r18, 0xE9	; 233
    bb08:	33 40       	sbci	r19, 0x03	; 3
    bb0a:	28 f0       	brcs	.+10     	; 0xbb16 <i2c_start+0x3c>
		{
			i2c_killCounterCheck = 1;
    bb0c:	81 e0       	ldi	r24, 0x01	; 1
    bb0e:	80 93 dd 05 	sts	0x05DD, r24
			returnvar = 2;
    bb12:	82 e0       	ldi	r24, 0x02	; 2
			break;
    bb14:	04 c0       	rjmp	.+8      	; 0xbb1e <i2c_start+0x44>
		}
		else
		{
			i2c_killCounterCheck = 0;
    bb16:	10 92 dd 05 	sts	0x05DD, r1
    bb1a:	e7 cf       	rjmp	.-50     	; 0xbaea <i2c_start+0x10>
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
    uint8_t   twst;

	uint8_t returnvar = 0;
    bb1c:	80 e0       	ldi	r24, 0x00	; 0
		{
			i2c_killCounterCheck = 0;
		}
	}

	if(i2c_killCounterCheck == 0)
    bb1e:	90 91 dd 05 	lds	r25, 0x05DD
    bb22:	91 11       	cpse	r25, r1
    bb24:	36 c0       	rjmp	.+108    	; 0xbb92 <i2c_start+0xb8>
	{
		// check value of TWI Status Register. Mask prescaler bits.
		twst = TW_STATUS & 0xF8;
    bb26:	90 91 b9 00 	lds	r25, 0x00B9
    bb2a:	98 7f       	andi	r25, 0xF8	; 248
		if ( (twst != TW_START) && (twst != TW_REP_START)) returnvar = 1;
    bb2c:	98 30       	cpi	r25, 0x08	; 8
    bb2e:	19 f0       	breq	.+6      	; 0xbb36 <i2c_start+0x5c>
    bb30:	90 31       	cpi	r25, 0x10	; 16
    bb32:	09 f0       	breq	.+2      	; 0xbb36 <i2c_start+0x5c>
    bb34:	81 e0       	ldi	r24, 0x01	; 1

		// send device address
		TWDR = address;
    bb36:	40 93 bb 00 	sts	0x00BB, r20
		TWCR = (1<<TWINT) | (1<<TWEN);
    bb3a:	94 e8       	ldi	r25, 0x84	; 132
    bb3c:	90 93 bc 00 	sts	0x00BC, r25

		// wail until transmission completed and ACK/NACK has been received
		i2c_killCounter = 0;
    bb40:	10 92 df 05 	sts	0x05DF, r1
    bb44:	10 92 de 05 	sts	0x05DE, r1
		while(!(TWCR & (1<<TWINT)))
    bb48:	90 91 bc 00 	lds	r25, 0x00BC
    bb4c:	97 fd       	sbrc	r25, 7
    bb4e:	15 c0       	rjmp	.+42     	; 0xbb7a <i2c_start+0xa0>
		{
			i2c_killCounter ++;
    bb50:	20 91 de 05 	lds	r18, 0x05DE
    bb54:	30 91 df 05 	lds	r19, 0x05DF
    bb58:	2f 5f       	subi	r18, 0xFF	; 255
    bb5a:	3f 4f       	sbci	r19, 0xFF	; 255
    bb5c:	30 93 df 05 	sts	0x05DF, r19
    bb60:	20 93 de 05 	sts	0x05DE, r18
			if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bb64:	29 3e       	cpi	r18, 0xE9	; 233
    bb66:	33 40       	sbci	r19, 0x03	; 3
    bb68:	28 f0       	brcs	.+10     	; 0xbb74 <i2c_start+0x9a>
			{
				i2c_killCounterCheck = 1;
    bb6a:	81 e0       	ldi	r24, 0x01	; 1
    bb6c:	80 93 dd 05 	sts	0x05DD, r24
				returnvar = 3;
    bb70:	83 e0       	ldi	r24, 0x03	; 3
				break;
    bb72:	03 c0       	rjmp	.+6      	; 0xbb7a <i2c_start+0xa0>
			}
			else
			{
				i2c_killCounterCheck = 0;
    bb74:	10 92 dd 05 	sts	0x05DD, r1
    bb78:	e7 cf       	rjmp	.-50     	; 0xbb48 <i2c_start+0x6e>
			}
		}

		if(i2c_killCounterCheck == 0)
    bb7a:	90 91 dd 05 	lds	r25, 0x05DD
    bb7e:	91 11       	cpse	r25, r1
    bb80:	08 c0       	rjmp	.+16     	; 0xbb92 <i2c_start+0xb8>
		{
			// check value of TWI Status Register. Mask prescaler bits.
			twst = TW_STATUS & 0xF8;
    bb82:	90 91 b9 00 	lds	r25, 0x00B9
    bb86:	98 7f       	andi	r25, 0xF8	; 248
			if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) returnvar = 1;
    bb88:	98 31       	cpi	r25, 0x18	; 24
    bb8a:	19 f0       	breq	.+6      	; 0xbb92 <i2c_start+0xb8>
    bb8c:	90 34       	cpi	r25, 0x40	; 64
    bb8e:	09 f0       	breq	.+2      	; 0xbb92 <i2c_start+0xb8>
    bb90:	81 e0       	ldi	r24, 0x01	; 1
		}
	}

	return returnvar;

}/* i2c_start */
    bb92:	08 95       	ret

0000bb94 <i2c_rep_start>:
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );
    bb94:	a2 cf       	rjmp	.-188    	; 0xbada <i2c_start>
    bb96:	08 95       	ret

0000bb98 <i2c_stop>:
uint8_t i2c_stop(void)
{
  uint8_t returnvar = 0;

	  /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    bb98:	84 e9       	ldi	r24, 0x94	; 148
    bb9a:	80 93 bc 00 	sts	0x00BC, r24
	
	// wait until stop condition is executed and bus released
	i2c_killCounter = 0;
    bb9e:	10 92 df 05 	sts	0x05DF, r1
    bba2:	10 92 de 05 	sts	0x05DE, r1
	while(TWCR & (1<<TWSTO))
    bba6:	80 91 bc 00 	lds	r24, 0x00BC
    bbaa:	84 ff       	sbrs	r24, 4
    bbac:	0c c0       	rjmp	.+24     	; 0xbbc6 <i2c_stop+0x2e>
	{
		i2c_killCounter ++;
    bbae:	80 91 de 05 	lds	r24, 0x05DE
    bbb2:	90 91 df 05 	lds	r25, 0x05DF
    bbb6:	01 96       	adiw	r24, 0x01	; 1
    bbb8:	90 93 df 05 	sts	0x05DF, r25
    bbbc:	80 93 de 05 	sts	0x05DE, r24
		if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bbc0:	89 3e       	cpi	r24, 0xE9	; 233
    bbc2:	93 40       	sbci	r25, 0x03	; 3
    bbc4:	80 f3       	brcs	.-32     	; 0xbba6 <i2c_stop+0xe>
			returnvar = 1;
		}
	}

	return returnvar;
}/* i2c_stop */
    bbc6:	80 e0       	ldi	r24, 0x00	; 0
    bbc8:	08 95       	ret

0000bbca <i2c_write>:
{	
    uint8_t   twst;
		uint8_t returnvar = 0;
    
	// send data to the previously addressed device
	TWDR = data;
    bbca:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
    bbce:	84 e8       	ldi	r24, 0x84	; 132
    bbd0:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	i2c_killCounter = 0;
    bbd4:	10 92 df 05 	sts	0x05DF, r1
    bbd8:	10 92 de 05 	sts	0x05DE, r1
	while(!(TWCR & (1<<TWINT)))
    bbdc:	80 91 bc 00 	lds	r24, 0x00BC
    bbe0:	87 fd       	sbrc	r24, 7
    bbe2:	14 c0       	rjmp	.+40     	; 0xbc0c <i2c_write+0x42>
	{
		i2c_killCounter ++;
    bbe4:	80 91 de 05 	lds	r24, 0x05DE
    bbe8:	90 91 df 05 	lds	r25, 0x05DF
    bbec:	01 96       	adiw	r24, 0x01	; 1
    bbee:	90 93 df 05 	sts	0x05DF, r25
    bbf2:	80 93 de 05 	sts	0x05DE, r24
		if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bbf6:	89 3e       	cpi	r24, 0xE9	; 233
    bbf8:	93 40       	sbci	r25, 0x03	; 3
    bbfa:	28 f0       	brcs	.+10     	; 0xbc06 <i2c_write+0x3c>
		{
			i2c_killCounterCheck = 1;
    bbfc:	81 e0       	ldi	r24, 0x01	; 1
    bbfe:	80 93 dd 05 	sts	0x05DD, r24
			returnvar = 2;
    bc02:	82 e0       	ldi	r24, 0x02	; 2
			break;
    bc04:	04 c0       	rjmp	.+8      	; 0xbc0e <i2c_write+0x44>
		}
		else
		{
			i2c_killCounterCheck = 0;
    bc06:	10 92 dd 05 	sts	0x05DD, r1
    bc0a:	e8 cf       	rjmp	.-48     	; 0xbbdc <i2c_write+0x12>
            1 write failed
*************************************************************************/
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
		uint8_t returnvar = 0;
    bc0c:	80 e0       	ldi	r24, 0x00	; 0
		{
			i2c_killCounterCheck = 0;
		}
	}

	if(i2c_killCounterCheck == 0)
    bc0e:	90 91 dd 05 	lds	r25, 0x05DD
    bc12:	91 11       	cpse	r25, r1
    bc14:	06 c0       	rjmp	.+12     	; 0xbc22 <i2c_write+0x58>
	{
		// check value of TWI Status Register. Mask prescaler bits
		twst = TW_STATUS & 0xF8;
    bc16:	90 91 b9 00 	lds	r25, 0x00B9
    bc1a:	98 7f       	andi	r25, 0xF8	; 248
		if( twst != TW_MT_DATA_ACK) returnvar = 1;
    bc1c:	98 32       	cpi	r25, 0x28	; 40
    bc1e:	09 f0       	breq	.+2      	; 0xbc22 <i2c_write+0x58>
    bc20:	81 e0       	ldi	r24, 0x01	; 1
	}

	return returnvar;

}/* i2c_write */
    bc22:	08 95       	ret

0000bc24 <i2c_readAck>:
*************************************************************************/
unsigned char i2c_readAck(void)
{
	uint8_t returnvar = 0;

	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    bc24:	84 ec       	ldi	r24, 0xC4	; 196
    bc26:	80 93 bc 00 	sts	0x00BC, r24

	i2c_killCounter = 0;
    bc2a:	10 92 df 05 	sts	0x05DF, r1
    bc2e:	10 92 de 05 	sts	0x05DE, r1
	while(!(TWCR & (1<<TWINT)))
    bc32:	80 91 bc 00 	lds	r24, 0x00BC
    bc36:	87 fd       	sbrc	r24, 7
    bc38:	13 c0       	rjmp	.+38     	; 0xbc60 <i2c_readAck+0x3c>
	{
		i2c_killCounter ++;
    bc3a:	80 91 de 05 	lds	r24, 0x05DE
    bc3e:	90 91 df 05 	lds	r25, 0x05DF
    bc42:	01 96       	adiw	r24, 0x01	; 1
    bc44:	90 93 df 05 	sts	0x05DF, r25
    bc48:	80 93 de 05 	sts	0x05DE, r24
		if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bc4c:	89 3e       	cpi	r24, 0xE9	; 233
    bc4e:	93 40       	sbci	r25, 0x03	; 3
    bc50:	20 f0       	brcs	.+8      	; 0xbc5a <i2c_readAck+0x36>
		{
			i2c_killCounterCheck = 1;
    bc52:	81 e0       	ldi	r24, 0x01	; 1
    bc54:	80 93 dd 05 	sts	0x05DD, r24
			break;
    bc58:	03 c0       	rjmp	.+6      	; 0xbc60 <i2c_readAck+0x3c>
		}
		else
		{
			i2c_killCounterCheck = 0;
    bc5a:	10 92 dd 05 	sts	0x05DD, r1
    bc5e:	e9 cf       	rjmp	.-46     	; 0xbc32 <i2c_readAck+0xe>
		}
	} 

  if(i2c_killCounterCheck == 0)
    bc60:	80 91 dd 05 	lds	r24, 0x05DD
    bc64:	81 11       	cpse	r24, r1
    bc66:	03 c0       	rjmp	.+6      	; 0xbc6e <i2c_readAck+0x4a>
	{
		returnvar = TWDR;
    bc68:	80 91 bb 00 	lds	r24, 0x00BB
    bc6c:	08 95       	ret
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
	uint8_t returnvar = 0;
    bc6e:	80 e0       	ldi	r24, 0x00	; 0
		returnvar = TWDR;
	}

	return returnvar;

}/* i2c_readAck */
    bc70:	08 95       	ret

0000bc72 <i2c_readNak>:
*************************************************************************/
unsigned char i2c_readNak(void)
{
	uint8_t returnvar = 0;

	TWCR = (1<<TWINT) | (1<<TWEN);
    bc72:	84 e8       	ldi	r24, 0x84	; 132
    bc74:	80 93 bc 00 	sts	0x00BC, r24

	i2c_killCounter = 0;
    bc78:	10 92 df 05 	sts	0x05DF, r1
    bc7c:	10 92 de 05 	sts	0x05DE, r1
	while(!(TWCR & (1<<TWINT)))
    bc80:	80 91 bc 00 	lds	r24, 0x00BC
    bc84:	87 fd       	sbrc	r24, 7
    bc86:	13 c0       	rjmp	.+38     	; 0xbcae <i2c_readNak+0x3c>
	{
		i2c_killCounter ++;
    bc88:	80 91 de 05 	lds	r24, 0x05DE
    bc8c:	90 91 df 05 	lds	r25, 0x05DF
    bc90:	01 96       	adiw	r24, 0x01	; 1
    bc92:	90 93 df 05 	sts	0x05DF, r25
    bc96:	80 93 de 05 	sts	0x05DE, r24
		if(i2c_killCounter > I2C_KILLCOUNTER_THRESHOLD)
    bc9a:	89 3e       	cpi	r24, 0xE9	; 233
    bc9c:	93 40       	sbci	r25, 0x03	; 3
    bc9e:	20 f0       	brcs	.+8      	; 0xbca8 <i2c_readNak+0x36>
		{
			i2c_killCounterCheck = 1;
    bca0:	81 e0       	ldi	r24, 0x01	; 1
    bca2:	80 93 dd 05 	sts	0x05DD, r24
			break;
    bca6:	03 c0       	rjmp	.+6      	; 0xbcae <i2c_readNak+0x3c>
		}
		else
		{
			i2c_killCounterCheck = 0;
    bca8:	10 92 dd 05 	sts	0x05DD, r1
    bcac:	e9 cf       	rjmp	.-46     	; 0xbc80 <i2c_readNak+0xe>
		}
	} 

  if(i2c_killCounterCheck == 0)
    bcae:	80 91 dd 05 	lds	r24, 0x05DD
    bcb2:	81 11       	cpse	r24, r1
    bcb4:	03 c0       	rjmp	.+6      	; 0xbcbc <i2c_readNak+0x4a>
	{
		returnvar = TWDR;
    bcb6:	80 91 bb 00 	lds	r24, 0x00BB
    bcba:	08 95       	ret
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	uint8_t returnvar = 0;
    bcbc:	80 e0       	ldi	r24, 0x00	; 0
		returnvar = TWDR;
	}

	return returnvar;

}/* i2c_readNak */
    bcbe:	08 95       	ret

0000bcc0 <__vector_25>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    bcc0:	1f 92       	push	r1
    bcc2:	0f 92       	push	r0
    bcc4:	0f b6       	in	r0, 0x3f	; 63
    bcc6:	0f 92       	push	r0
    bcc8:	11 24       	eor	r1, r1
    bcca:	0b b6       	in	r0, 0x3b	; 59
    bccc:	0f 92       	push	r0
    bcce:	2f 93       	push	r18
    bcd0:	8f 93       	push	r24
    bcd2:	9f 93       	push	r25
    bcd4:	ef 93       	push	r30
    bcd6:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    bcd8:	80 91 c0 00 	lds	r24, 0x00C0
    data = UART0_DATA;
    bcdc:	90 91 c6 00 	lds	r25, 0x00C6
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART0 )
    lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
    bce0:	88 71       	andi	r24, 0x18	; 24
#elif defined ( ATMEGA_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    bce2:	e0 91 27 06 	lds	r30, 0x0627
    bce6:	ef 5f       	subi	r30, 0xFF	; 255
    bce8:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART_RxTail ) {
    bcea:	20 91 26 06 	lds	r18, 0x0626
    bcee:	e2 17       	cp	r30, r18
    bcf0:	39 f0       	breq	.+14     	; 0xbd00 <__vector_25+0x40>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    bcf2:	e0 93 27 06 	sts	0x0627, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    bcf6:	f0 e0       	ldi	r31, 0x00	; 0
    bcf8:	e6 5d       	subi	r30, 0xD6	; 214
    bcfa:	f9 4f       	sbci	r31, 0xF9	; 249
    bcfc:	90 83       	st	Z, r25
    bcfe:	01 c0       	rjmp	.+2      	; 0xbd02 <__vector_25+0x42>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    bd00:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    bd02:	90 91 25 06 	lds	r25, 0x0625
    bd06:	98 2b       	or	r25, r24
    bd08:	90 93 25 06 	sts	0x0625, r25
}
    bd0c:	ff 91       	pop	r31
    bd0e:	ef 91       	pop	r30
    bd10:	9f 91       	pop	r25
    bd12:	8f 91       	pop	r24
    bd14:	2f 91       	pop	r18
    bd16:	0f 90       	pop	r0
    bd18:	0b be       	out	0x3b, r0	; 59
    bd1a:	0f 90       	pop	r0
    bd1c:	0f be       	out	0x3f, r0	; 63
    bd1e:	0f 90       	pop	r0
    bd20:	1f 90       	pop	r1
    bd22:	18 95       	reti

0000bd24 <__vector_26>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    bd24:	1f 92       	push	r1
    bd26:	0f 92       	push	r0
    bd28:	0f b6       	in	r0, 0x3f	; 63
    bd2a:	0f 92       	push	r0
    bd2c:	11 24       	eor	r1, r1
    bd2e:	0b b6       	in	r0, 0x3b	; 59
    bd30:	0f 92       	push	r0
    bd32:	8f 93       	push	r24
    bd34:	9f 93       	push	r25
    bd36:	ef 93       	push	r30
    bd38:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
    bd3a:	90 91 29 06 	lds	r25, 0x0629
    bd3e:	80 91 28 06 	lds	r24, 0x0628
    bd42:	98 17       	cp	r25, r24
    bd44:	69 f0       	breq	.+26     	; 0xbd60 <__vector_26+0x3c>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    bd46:	e0 91 28 06 	lds	r30, 0x0628
    bd4a:	ef 5f       	subi	r30, 0xFF	; 255
    bd4c:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
    bd4e:	e0 93 28 06 	sts	0x0628, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    bd52:	f0 e0       	ldi	r31, 0x00	; 0
    bd54:	e6 5b       	subi	r30, 0xB6	; 182
    bd56:	f9 4f       	sbci	r31, 0xF9	; 249
    bd58:	80 81       	ld	r24, Z
    bd5a:	80 93 c6 00 	sts	0x00C6, r24
    bd5e:	05 c0       	rjmp	.+10     	; 0xbd6a <__vector_26+0x46>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    bd60:	80 91 c1 00 	lds	r24, 0x00C1
    bd64:	8f 7d       	andi	r24, 0xDF	; 223
    bd66:	80 93 c1 00 	sts	0x00C1, r24
    }
}
    bd6a:	ff 91       	pop	r31
    bd6c:	ef 91       	pop	r30
    bd6e:	9f 91       	pop	r25
    bd70:	8f 91       	pop	r24
    bd72:	0f 90       	pop	r0
    bd74:	0b be       	out	0x3b, r0	; 59
    bd76:	0f 90       	pop	r0
    bd78:	0f be       	out	0x3f, r0	; 63
    bd7a:	0f 90       	pop	r0
    bd7c:	1f 90       	pop	r1
    bd7e:	18 95       	reti

0000bd80 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    bd80:	10 92 29 06 	sts	0x0629, r1
    UART_TxTail = 0;
    bd84:	10 92 28 06 	sts	0x0628, r1
    UART_RxHead = 0;
    bd88:	10 92 27 06 	sts	0x0627, r1
    UART_RxTail = 0;
    bd8c:	10 92 26 06 	sts	0x0626, r1
    UCSRC = (3<<UCSZ0);
    #endif 
    
#elif defined (ATMEGA_USART0 )
    /* Set baud rate */
    if ( baudrate & 0x8000 ) 
    bd90:	97 ff       	sbrs	r25, 7
    bd92:	04 c0       	rjmp	.+8      	; 0xbd9c <uart_init+0x1c>
    {
   		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
    bd94:	22 e0       	ldi	r18, 0x02	; 2
    bd96:	20 93 c0 00 	sts	0x00C0, r18
   		baudrate &= ~0x8000;
    bd9a:	9f 77       	andi	r25, 0x7F	; 127
   	}
    UBRR0H = (unsigned char)(baudrate>>8);
    bd9c:	90 93 c5 00 	sts	0x00C5, r25
    UBRR0L = (unsigned char) baudrate;
    bda0:	80 93 c4 00 	sts	0x00C4, r24

    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
    bda4:	88 e9       	ldi	r24, 0x98	; 152
    bda6:	80 93 c1 00 	sts	0x00C1, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL0
    UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
    #else
    UCSR0C = (3<<UCSZ00);
    bdaa:	86 e0       	ldi	r24, 0x06	; 6
    bdac:	80 93 c2 00 	sts	0x00C2, r24
    bdb0:	08 95       	ret

0000bdb2 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    bdb2:	90 91 29 06 	lds	r25, 0x0629
    bdb6:	9f 5f       	subi	r25, 0xFF	; 255
    bdb8:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
    bdba:	20 91 28 06 	lds	r18, 0x0628
    bdbe:	92 17       	cp	r25, r18
    bdc0:	e1 f3       	breq	.-8      	; 0xbdba <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    bdc2:	e9 2f       	mov	r30, r25
    bdc4:	f0 e0       	ldi	r31, 0x00	; 0
    bdc6:	e6 5b       	subi	r30, 0xB6	; 182
    bdc8:	f9 4f       	sbci	r31, 0xF9	; 249
    bdca:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    bdcc:	90 93 29 06 	sts	0x0629, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    bdd0:	80 91 c1 00 	lds	r24, 0x00C1
    bdd4:	80 62       	ori	r24, 0x20	; 32
    bdd6:	80 93 c1 00 	sts	0x00C1, r24
    bdda:	08 95       	ret

0000bddc <__vector_36>:
ISR(UART1_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART1 Receive Complete interrupt
Purpose:  called when the UART1 has received a character
**************************************************************************/
{
    bddc:	1f 92       	push	r1
    bdde:	0f 92       	push	r0
    bde0:	0f b6       	in	r0, 0x3f	; 63
    bde2:	0f 92       	push	r0
    bde4:	11 24       	eor	r1, r1
    bde6:	0b b6       	in	r0, 0x3b	; 59
    bde8:	0f 92       	push	r0
    bdea:	2f 93       	push	r18
    bdec:	8f 93       	push	r24
    bdee:	9f 93       	push	r25
    bdf0:	ef 93       	push	r30
    bdf2:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART1_STATUS;
    bdf4:	80 91 c8 00 	lds	r24, 0x00C8
    data = UART1_DATA;
    bdf8:	90 91 ce 00 	lds	r25, 0x00CE
    
    /* */
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
    bdfc:	88 71       	andi	r24, 0x18	; 24
        
    /* calculate buffer index */ 
    tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;
    bdfe:	e0 91 e2 05 	lds	r30, 0x05E2
    be02:	ef 5f       	subi	r30, 0xFF	; 255
    be04:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART1_RxTail ) {
    be06:	20 91 e1 05 	lds	r18, 0x05E1
    be0a:	e2 17       	cp	r30, r18
    be0c:	39 f0       	breq	.+14     	; 0xbe1c <__vector_36+0x40>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART1_RxHead = tmphead;
    be0e:	e0 93 e2 05 	sts	0x05E2, r30
        /* store received data in buffer */
        UART1_RxBuf[tmphead] = data;
    be12:	f0 e0       	ldi	r31, 0x00	; 0
    be14:	eb 51       	subi	r30, 0x1B	; 27
    be16:	fa 4f       	sbci	r31, 0xFA	; 250
    be18:	90 83       	st	Z, r25
    be1a:	01 c0       	rjmp	.+2      	; 0xbe1e <__vector_36+0x42>
    /* calculate buffer index */ 
    tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART1_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    be1c:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART1_RxHead = tmphead;
        /* store received data in buffer */
        UART1_RxBuf[tmphead] = data;
    }
    UART1_LastRxError |= lastRxError;   
    be1e:	90 91 e0 05 	lds	r25, 0x05E0
    be22:	98 2b       	or	r25, r24
    be24:	90 93 e0 05 	sts	0x05E0, r25
}
    be28:	ff 91       	pop	r31
    be2a:	ef 91       	pop	r30
    be2c:	9f 91       	pop	r25
    be2e:	8f 91       	pop	r24
    be30:	2f 91       	pop	r18
    be32:	0f 90       	pop	r0
    be34:	0b be       	out	0x3b, r0	; 59
    be36:	0f 90       	pop	r0
    be38:	0f be       	out	0x3f, r0	; 63
    be3a:	0f 90       	pop	r0
    be3c:	1f 90       	pop	r1
    be3e:	18 95       	reti

0000be40 <__vector_37>:
ISR(UART1_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART1 Data Register Empty interrupt
Purpose:  called when the UART1 is ready to transmit the next byte
**************************************************************************/
{
    be40:	1f 92       	push	r1
    be42:	0f 92       	push	r0
    be44:	0f b6       	in	r0, 0x3f	; 63
    be46:	0f 92       	push	r0
    be48:	11 24       	eor	r1, r1
    be4a:	0b b6       	in	r0, 0x3b	; 59
    be4c:	0f 92       	push	r0
    be4e:	8f 93       	push	r24
    be50:	9f 93       	push	r25
    be52:	ef 93       	push	r30
    be54:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART1_TxHead != UART1_TxTail) {
    be56:	90 91 e4 05 	lds	r25, 0x05E4
    be5a:	80 91 e3 05 	lds	r24, 0x05E3
    be5e:	98 17       	cp	r25, r24
    be60:	69 f0       	breq	.+26     	; 0xbe7c <__vector_37+0x3c>
        /* calculate and store new buffer index */
        tmptail = (UART1_TxTail + 1) & UART_TX_BUFFER_MASK;
    be62:	e0 91 e3 05 	lds	r30, 0x05E3
    be66:	ef 5f       	subi	r30, 0xFF	; 255
    be68:	ef 71       	andi	r30, 0x1F	; 31
        UART1_TxTail = tmptail;
    be6a:	e0 93 e3 05 	sts	0x05E3, r30
        /* get one byte from buffer and write it to UART */
        UART1_DATA = UART1_TxBuf[tmptail];  /* start transmission */
    be6e:	f0 e0       	ldi	r31, 0x00	; 0
    be70:	eb 5f       	subi	r30, 0xFB	; 251
    be72:	f9 4f       	sbci	r31, 0xF9	; 249
    be74:	80 81       	ld	r24, Z
    be76:	80 93 ce 00 	sts	0x00CE, r24
    be7a:	05 c0       	rjmp	.+10     	; 0xbe86 <__vector_37+0x46>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART1_CONTROL &= ~_BV(UART1_UDRIE);
    be7c:	80 91 c9 00 	lds	r24, 0x00C9
    be80:	8f 7d       	andi	r24, 0xDF	; 223
    be82:	80 93 c9 00 	sts	0x00C9, r24
    }
}
    be86:	ff 91       	pop	r31
    be88:	ef 91       	pop	r30
    be8a:	9f 91       	pop	r25
    be8c:	8f 91       	pop	r24
    be8e:	0f 90       	pop	r0
    be90:	0b be       	out	0x3b, r0	; 59
    be92:	0f 90       	pop	r0
    be94:	0f be       	out	0x3f, r0	; 63
    be96:	0f 90       	pop	r0
    be98:	1f 90       	pop	r1
    be9a:	18 95       	reti

0000be9c <uart1_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart1_init(unsigned int baudrate)
{
    UART1_TxHead = 0;
    be9c:	10 92 e4 05 	sts	0x05E4, r1
    UART1_TxTail = 0;
    bea0:	10 92 e3 05 	sts	0x05E3, r1
    UART1_RxHead = 0;
    bea4:	10 92 e2 05 	sts	0x05E2, r1
    UART1_RxTail = 0;
    bea8:	10 92 e1 05 	sts	0x05E1, r1
    

    /* Set baud rate */
    if ( baudrate & 0x8000 ) 
    beac:	97 ff       	sbrs	r25, 7
    beae:	04 c0       	rjmp	.+8      	; 0xbeb8 <uart1_init+0x1c>
    {
    	UART1_STATUS = (1<<U2X1);  //Enable 2x speed 
    beb0:	22 e0       	ldi	r18, 0x02	; 2
    beb2:	20 93 c8 00 	sts	0x00C8, r18
      baudrate &= ~0x8000;
    beb6:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRR1H = (unsigned char)(baudrate>>8);
    beb8:	90 93 cd 00 	sts	0x00CD, r25
    UBRR1L = (unsigned char) baudrate;
    bebc:	80 93 cc 00 	sts	0x00CC, r24

    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART1_CONTROL = _BV(RXCIE1)|(1<<RXEN1)|(1<<TXEN1);
    bec0:	88 e9       	ldi	r24, 0x98	; 152
    bec2:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */   
    #ifdef URSEL1
    UCSR1C = (1<<URSEL1)|(3<<UCSZ10);
    #else
    UCSR1C = (3<<UCSZ10);
    bec6:	86 e0       	ldi	r24, 0x06	; 6
    bec8:	80 93 ca 00 	sts	0x00CA, r24
    becc:	08 95       	ret

0000bece <uart1_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART1_RxHead == UART1_RxTail ) {
    bece:	90 91 e2 05 	lds	r25, 0x05E2
    bed2:	80 91 e1 05 	lds	r24, 0x05E1
    bed6:	98 17       	cp	r25, r24
    bed8:	81 f0       	breq	.+32     	; 0xbefa <uart1_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART1_RxTail + 1) & UART_RX_BUFFER_MASK;
    beda:	e0 91 e1 05 	lds	r30, 0x05E1
    bede:	ef 5f       	subi	r30, 0xFF	; 255
    bee0:	ef 71       	andi	r30, 0x1F	; 31
    UART1_RxTail = tmptail; 
    bee2:	e0 93 e1 05 	sts	0x05E1, r30
    
    /* get data from receive buffer */
    data = UART1_RxBuf[tmptail];
    bee6:	f0 e0       	ldi	r31, 0x00	; 0
    bee8:	eb 51       	subi	r30, 0x1B	; 27
    beea:	fa 4f       	sbci	r31, 0xFA	; 250
    beec:	80 81       	ld	r24, Z
    
    data = (UART1_LastRxError << 8) + data;
    beee:	90 91 e0 05 	lds	r25, 0x05E0
    UART_LastRxError = 0;
    bef2:	10 92 25 06 	sts	0x0625, r1
    return data;
    bef6:	90 e0       	ldi	r25, 0x00	; 0
    bef8:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART1_RxHead == UART1_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    befa:	80 e0       	ldi	r24, 0x00	; 0
    befc:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART1_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart1_getc */
    befe:	08 95       	ret

0000bf00 <uart1_putc>:
void uart1_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;
    bf00:	90 91 e4 05 	lds	r25, 0x05E4
    bf04:	9f 5f       	subi	r25, 0xFF	; 255
    bf06:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART1_TxTail ){
    bf08:	20 91 e3 05 	lds	r18, 0x05E3
    bf0c:	92 17       	cp	r25, r18
    bf0e:	e1 f3       	breq	.-8      	; 0xbf08 <uart1_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART1_TxBuf[tmphead] = data;
    bf10:	e9 2f       	mov	r30, r25
    bf12:	f0 e0       	ldi	r31, 0x00	; 0
    bf14:	eb 5f       	subi	r30, 0xFB	; 251
    bf16:	f9 4f       	sbci	r31, 0xF9	; 249
    bf18:	80 83       	st	Z, r24
    UART1_TxHead = tmphead;
    bf1a:	90 93 e4 05 	sts	0x05E4, r25

    /* enable UDRE interrupt */
    UART1_CONTROL    |= _BV(UART1_UDRIE);
    bf1e:	80 91 c9 00 	lds	r24, 0x00C9
    bf22:	80 62       	ori	r24, 0x20	; 32
    bf24:	80 93 c9 00 	sts	0x00C9, r24
    bf28:	08 95       	ret

0000bf2a <flushdata>:

//////////////////////////

//Hilfsfunktion:
void flushdata(void)
{
    bf2a:	cf 93       	push	r28
    bf2c:	c4 e1       	ldi	r28, 0x14	; 20
	for(uint8_t i = 0; i < 20; i++)
		uart1_getc(); 
    bf2e:	cf df       	rcall	.-98     	; 0xbece <uart1_getc>
    bf30:	c1 50       	subi	r28, 0x01	; 1
    bf32:	e9 f7       	brne	.-6      	; 0xbf2e <flushdata+0x4>
//////////////////////////

//Hilfsfunktion:
void flushdata(void)
{
	for(uint8_t i = 0; i < 20; i++)
    bf34:	cf 91       	pop	r28
		uart1_getc(); 
}
    bf36:	08 95       	ret

0000bf38 <um6_rwc>:
//////////////////
uint8_t um6_isBusy = 0; //Wird auf eine Antwort o.. gewartet?

uint8_t um6_rwc(uint8_t um6_register, uint8_t batch, uint8_t r_w_c, uint16_t um6_result[], uint8_t data_size)
{
    bf38:	a8 e0       	ldi	r26, 0x08	; 8
    bf3a:	b0 e0       	ldi	r27, 0x00	; 0
    bf3c:	e2 ea       	ldi	r30, 0xA2	; 162
    bf3e:	ff e5       	ldi	r31, 0x5F	; 95
    bf40:	0c 94 9b 6b 	jmp	0xd736	; 0xd736 <__prologue_saves__>
    bf44:	68 2e       	mov	r6, r24
    bf46:	56 2e       	mov	r5, r22
    bf48:	14 2f       	mov	r17, r20
    bf4a:	42 2e       	mov	r4, r18
    bf4c:	33 2e       	mov	r3, r19
	uint8_t checksum0 = 0;
	uint8_t checksum1 = 0;
	uint16_t checksum = 0;
	uint8_t pt_is_batch = 0;
	if(batch > 0)
    bf4e:	61 11       	cpse	r22, r1
    bf50:	02 c0       	rjmp	.+4      	; 0xbf56 <um6_rwc+0x1e>
uint8_t um6_rwc(uint8_t um6_register, uint8_t batch, uint8_t r_w_c, uint16_t um6_result[], uint8_t data_size)
{
	uint8_t checksum0 = 0;
	uint8_t checksum1 = 0;
	uint16_t checksum = 0;
	uint8_t pt_is_batch = 0;
    bf52:	b1 2c       	mov	r11, r1
    bf54:	02 c0       	rjmp	.+4      	; 0xbf5a <um6_rwc+0x22>
	if(batch > 0)
		pt_is_batch = PT_IS_BATCH;
    bf56:	50 e4       	ldi	r21, 0x40	; 64
    bf58:	b5 2e       	mov	r11, r21
	
	if(r_w_c == UM6_DATA_READ)
    bf5a:	11 11       	cpse	r17, r1
    bf5c:	03 c0       	rjmp	.+6      	; 0xbf64 <um6_rwc+0x2c>
		checksum = ('s'+'n'+'p' + (pt_is_batch | batch) + um6_register);
    bf5e:	2b 2d       	mov	r18, r11
    bf60:	25 29       	or	r18, r5
    bf62:	05 c0       	rjmp	.+10     	; 0xbf6e <um6_rwc+0x36>
	else if(r_w_c == UM6_DATA_WRITE)
    bf64:	11 30       	cpi	r17, 0x01	; 1
    bf66:	49 f4       	brne	.+18     	; 0xbf7a <um6_rwc+0x42>
		checksum = ('s'+'n'+'p' + (PT_HAS_DATA | pt_is_batch | batch) + um6_register);
    bf68:	25 2d       	mov	r18, r5
    bf6a:	20 68       	ori	r18, 0x80	; 128
    bf6c:	2b 29       	or	r18, r11
    bf6e:	30 e0       	ldi	r19, 0x00	; 0
    bf70:	2f 5a       	subi	r18, 0xAF	; 175
    bf72:	3e 4f       	sbci	r19, 0xFE	; 254
    bf74:	26 0d       	add	r18, r6
    bf76:	31 1d       	adc	r19, r1
    bf78:	09 c0       	rjmp	.+18     	; 0xbf8c <um6_rwc+0x54>
	else if(r_w_c == UM6_DATA_CMD)
    bf7a:	12 30       	cpi	r17, 0x02	; 2
    bf7c:	29 f4       	brne	.+10     	; 0xbf88 <um6_rwc+0x50>
		checksum = ('s'+'n'+'p' + um6_register);
    bf7e:	26 2d       	mov	r18, r6
    bf80:	30 e0       	ldi	r19, 0x00	; 0
    bf82:	2f 5a       	subi	r18, 0xAF	; 175
    bf84:	3e 4f       	sbci	r19, 0xFE	; 254
    bf86:	02 c0       	rjmp	.+4      	; 0xbf8c <um6_rwc+0x54>

uint8_t um6_rwc(uint8_t um6_register, uint8_t batch, uint8_t r_w_c, uint16_t um6_result[], uint8_t data_size)
{
	uint8_t checksum0 = 0;
	uint8_t checksum1 = 0;
	uint16_t checksum = 0;
    bf88:	20 e0       	ldi	r18, 0x00	; 0
    bf8a:	30 e0       	ldi	r19, 0x00	; 0
		checksum = ('s'+'n'+'p' + (pt_is_batch | batch) + um6_register);
	else if(r_w_c == UM6_DATA_WRITE)
		checksum = ('s'+'n'+'p' + (PT_HAS_DATA | pt_is_batch | batch) + um6_register);
	else if(r_w_c == UM6_DATA_CMD)
		checksum = ('s'+'n'+'p' + um6_register);
	checksum1 = checksum >> 8;
    bf8c:	c3 2e       	mov	r12, r19
	checksum0 = checksum & 0xff;
    bf8e:	d2 2e       	mov	r13, r18

	uart1_putc('s');
    bf90:	83 e7       	ldi	r24, 0x73	; 115
    bf92:	b6 df       	rcall	.-148    	; 0xbf00 <uart1_putc>
    bf94:	8e e6       	ldi	r24, 0x6E	; 110
	uart1_putc('n');
    bf96:	b4 df       	rcall	.-152    	; 0xbf00 <uart1_putc>
    bf98:	80 e7       	ldi	r24, 0x70	; 112
    bf9a:	b2 df       	rcall	.-156    	; 0xbf00 <uart1_putc>
	uart1_putc('p');
    bf9c:	11 11       	cpse	r17, r1
    bf9e:	03 c0       	rjmp	.+6      	; 0xbfa6 <um6_rwc+0x6e>
    bfa0:	8b 2d       	mov	r24, r11
	if(r_w_c == UM6_DATA_READ)
    bfa2:	85 29       	or	r24, r5
    bfa4:	07 c0       	rjmp	.+14     	; 0xbfb4 <um6_rwc+0x7c>
		uart1_putc(pt_is_batch | batch); //PT
    bfa6:	11 30       	cpi	r17, 0x01	; 1
    bfa8:	21 f4       	brne	.+8      	; 0xbfb2 <um6_rwc+0x7a>
    bfaa:	85 2d       	mov	r24, r5
	else if(r_w_c == UM6_DATA_WRITE)
    bfac:	80 68       	ori	r24, 0x80	; 128
    bfae:	8b 29       	or	r24, r11
		uart1_putc(PT_HAS_DATA | pt_is_batch | batch);
    bfb0:	01 c0       	rjmp	.+2      	; 0xbfb4 <um6_rwc+0x7c>
    bfb2:	80 e0       	ldi	r24, 0x00	; 0
    bfb4:	a5 df       	rcall	.-182    	; 0xbf00 <uart1_putc>
    bfb6:	86 2d       	mov	r24, r6
	else //if(r_w_c == UM6_DATA_CMD)
		uart1_putc(0);
    bfb8:	a3 df       	rcall	.-186    	; 0xbf00 <uart1_putc>
    bfba:	8c 2d       	mov	r24, r12
    bfbc:	a1 df       	rcall	.-190    	; 0xbf00 <uart1_putc>
	uart1_putc(um6_register); //ADR
    bfbe:	8d 2d       	mov	r24, r13
    bfc0:	9f df       	rcall	.-194    	; 0xbf00 <uart1_putc>
    bfc2:	ce 01       	movw	r24, r28
	uart1_putc(checksum1); //Checksum1
    bfc4:	01 96       	adiw	r24, 0x01	; 1
    bfc6:	6c 01       	movw	r12, r24
    bfc8:	88 e0       	ldi	r24, 0x08	; 8
	uart1_putc(checksum0); //Checksum1
    bfca:	d6 01       	movw	r26, r12
    bfcc:	1d 92       	st	X+, r1
    bfce:	8a 95       	dec	r24

	uint8_t data[8] = {0};
    bfd0:	e9 f7       	brne	.-6      	; 0xbfcc <um6_rwc+0x94>
    bfd2:	7d df       	rcall	.-262    	; 0xbece <uart1_getc>
    bfd4:	83 37       	cpi	r24, 0x73	; 115
    bfd6:	09 f0       	breq	.+2      	; 0xbfda <um6_rwc+0xa2>
    bfd8:	76 c0       	rjmp	.+236    	; 0xc0c6 <um6_rwc+0x18e>
    bfda:	79 df       	rcall	.-270    	; 0xbece <uart1_getc>
    bfdc:	8e 36       	cpi	r24, 0x6E	; 110
    bfde:	91 05       	cpc	r25, r1
	uint16_t data_sum = 0;

	//if((r_w_c == UM6_DATA_CMD) || (r_w_c == UM6_DATA_WRITE))
	//	_delay_ms(25); //UM6 braucht dann etwas Zeit zum Antworten

	uint8_t new_dat = uart1_getc();
    bfe0:	09 f0       	breq	.+2      	; 0xbfe4 <um6_rwc+0xac>
    bfe2:	6e c0       	rjmp	.+220    	; 0xc0c0 <um6_rwc+0x188>
	if(new_dat & UART_NO_DATA)
	{
		//no data
		return 7;
	}
	else if(new_dat == 's')
    bfe4:	74 df       	rcall	.-280    	; 0xbece <uart1_getc>
    bfe6:	80 37       	cpi	r24, 0x70	; 112
    bfe8:	91 05       	cpc	r25, r1
	{
		if(uart1_getc() == 'n')
    bfea:	09 f0       	breq	.+2      	; 0xbfee <um6_rwc+0xb6>
    bfec:	66 c0       	rjmp	.+204    	; 0xc0ba <um6_rwc+0x182>
    bfee:	6f df       	rcall	.-290    	; 0xbece <uart1_getc>
    bff0:	b5 2d       	mov	r27, r5
    bff2:	b0 68       	ori	r27, 0x80	; 128
    bff4:	2b 2e       	mov	r2, r27
		{
			if(uart1_getc() == 'p')
    bff6:	2b 28       	or	r2, r11
    bff8:	82 11       	cpse	r24, r2
    bffa:	03 c0       	rjmp	.+6      	; 0xc002 <um6_rwc+0xca>
    bffc:	11 23       	and	r17, r17
    bffe:	41 f0       	breq	.+16     	; 0xc010 <um6_rwc+0xd8>
    c000:	59 c0       	rjmp	.+178    	; 0xc0b4 <um6_rwc+0x17c>
			{
				uint8_t r_w_c_batch = uart1_getc();
    c002:	81 11       	cpse	r24, r1
    c004:	57 c0       	rjmp	.+174    	; 0xc0b4 <um6_rwc+0x17c>
				if( ((r_w_c_batch == (PT_HAS_DATA | pt_is_batch | batch)) && (r_w_c == UM6_DATA_READ)) ||
    c006:	8f ef       	ldi	r24, 0xFF	; 255
    c008:	81 0f       	add	r24, r17
    c00a:	82 30       	cpi	r24, 0x02	; 2
    c00c:	08 f0       	brcs	.+2      	; 0xc010 <um6_rwc+0xd8>
    c00e:	52 c0       	rjmp	.+164    	; 0xc0b4 <um6_rwc+0x17c>
    c010:	5e df       	rcall	.-324    	; 0xbece <uart1_getc>
    c012:	71 2c       	mov	r7, r1
    c014:	86 15       	cp	r24, r6
    c016:	97 05       	cpc	r25, r7
    c018:	09 f0       	breq	.+2      	; 0xc01c <um6_rwc+0xe4>
    c01a:	49 c0       	rjmp	.+146    	; 0xc0ae <um6_rwc+0x176>
						((r_w_c_batch == 0) && (r_w_c == UM6_DATA_WRITE)) || //== 0 wegen COMMAND_COMPLETE
    c01c:	51 10       	cpse	r5, r1
    c01e:	02 c0       	rjmp	.+4      	; 0xc024 <um6_rwc+0xec>
    c020:	44 e0       	ldi	r20, 0x04	; 4
    c022:	54 2e       	mov	r5, r20
    c024:	46 01       	movw	r8, r12
						((r_w_c_batch == 0) && (r_w_c == UM6_DATA_CMD)))
				{
					if(uart1_getc() == um6_register)
    c026:	a1 2c       	mov	r10, r1
    c028:	b1 2c       	mov	r11, r1
    c02a:	88 2d       	mov	r24, r8
    c02c:	8c 19       	sub	r24, r12
    c02e:	85 15       	cp	r24, r5
    c030:	38 f4       	brcc	.+14     	; 0xc040 <um6_rwc+0x108>
    c032:	4d df       	rcall	.-358    	; 0xbece <uart1_getc>
					{	
						uint8_t i_stop = 0;
						if(batch > 0)
    c034:	f4 01       	movw	r30, r8
    c036:	81 93       	st	Z+, r24
							i_stop = batch;
						else
							i_stop = 4; //1 Register
    c038:	4f 01       	movw	r8, r30
    c03a:	a8 0e       	add	r10, r24
						
						for(uint8_t i = 0; i<i_stop; i++)
    c03c:	b1 1c       	adc	r11, r1
	uart1_putc(um6_register); //ADR
	uart1_putc(checksum1); //Checksum1
	uart1_putc(checksum0); //Checksum1

	uint8_t data[8] = {0};
	uint16_t data_sum = 0;
    c03e:	f5 cf       	rjmp	.-22     	; 0xc02a <um6_rwc+0xf2>
    c040:	46 df       	rcall	.-372    	; 0xbece <uart1_getc>
    c042:	d8 2e       	mov	r13, r24
    c044:	44 df       	rcall	.-376    	; 0xbece <uart1_getc>
						if(batch > 0)
							i_stop = batch;
						else
							i_stop = 4; //1 Register
						
						for(uint8_t i = 0; i<i_stop; i++)
    c046:	fd 2c       	mov	r15, r13
    c048:	e1 2c       	mov	r14, r1
						{
							data[i] = uart1_getc();
    c04a:	e8 2a       	or	r14, r24
    c04c:	82 2d       	mov	r24, r2
    c04e:	90 e0       	ldi	r25, 0x00	; 0
    c050:	8f 5a       	subi	r24, 0xAF	; 175
    c052:	9e 4f       	sbci	r25, 0xFE	; 254
							data_sum += data[i];
    c054:	86 0d       	add	r24, r6
    c056:	97 1d       	adc	r25, r7
    c058:	8a 0d       	add	r24, r10
						}
						checksum1 = uart1_getc();
    c05a:	9b 1d       	adc	r25, r11
    c05c:	e8 16       	cp	r14, r24
    c05e:	f9 06       	cpc	r15, r25
						checksum0 = uart1_getc();
    c060:	41 f4       	brne	.+16     	; 0xc072 <um6_rwc+0x13a>
    c062:	11 11       	cpse	r17, r1
						checksum = ((checksum1 << 8) | checksum0);
    c064:	06 c0       	rjmp	.+12     	; 0xc072 <um6_rwc+0x13a>
    c066:	fe 01       	movw	r30, r28
    c068:	32 96       	adiw	r30, 0x02	; 2
						if( ((checksum == ('s' + 'n' + 'p' + (PT_HAS_DATA | pt_is_batch | batch) + um6_register + data_sum)) && (r_w_c == UM6_DATA_READ)) ||
    c06a:	44 2d       	mov	r20, r4
    c06c:	53 2d       	mov	r21, r3
    c06e:	20 e0       	ldi	r18, 0x00	; 0
    c070:	07 c0       	rjmp	.+14     	; 0xc080 <um6_rwc+0x148>
    c072:	e1 14       	cp	r14, r1
    c074:	f1 04       	cpc	r15, r1
    c076:	c1 f4       	brne	.+48     	; 0xc0a8 <um6_rwc+0x170>
    c078:	11 50       	subi	r17, 0x01	; 1
    c07a:	12 30       	cpi	r17, 0x02	; 2
    c07c:	a8 f4       	brcc	.+42     	; 0xc0a8 <um6_rwc+0x170>
    c07e:	f3 cf       	rjmp	.-26     	; 0xc066 <um6_rwc+0x12e>
    c080:	20 17       	cp	r18, r16
    c082:	81 f0       	breq	.+32     	; 0xc0a4 <um6_rwc+0x16c>
    c084:	cf 01       	movw	r24, r30
    c086:	01 97       	sbiw	r24, 0x01	; 1
    c088:	dc 01       	movw	r26, r24
    c08a:	8c 91       	ld	r24, X
	uart1_putc(um6_register); //ADR
	uart1_putc(checksum1); //Checksum1
	uart1_putc(checksum0); //Checksum1

	uint8_t data[8] = {0};
	uint16_t data_sum = 0;
    c08c:	90 e0       	ldi	r25, 0x00	; 0
    c08e:	98 2f       	mov	r25, r24
							data_sum += data[i];
						}
						checksum1 = uart1_getc();
						checksum0 = uart1_getc();
						checksum = ((checksum1 << 8) | checksum0);
						if( ((checksum == ('s' + 'n' + 'p' + (PT_HAS_DATA | pt_is_batch | batch) + um6_register + data_sum)) && (r_w_c == UM6_DATA_READ)) ||
    c090:	88 27       	eor	r24, r24
    c092:	30 81       	ld	r19, Z
    c094:	83 2b       	or	r24, r19
								((checksum == 0) && (r_w_c == UM6_DATA_WRITE)) ||
    c096:	da 01       	movw	r26, r20
    c098:	8d 93       	st	X+, r24
    c09a:	9d 93       	st	X+, r25
    c09c:	ad 01       	movw	r20, r26
								((checksum == 0) && (r_w_c == UM6_DATA_CMD)))
						{
							for(uint8_t i = 0; i < data_size; i++)
    c09e:	2f 5f       	subi	r18, 0xFF	; 255
    c0a0:	32 96       	adiw	r30, 0x02	; 2
    c0a2:	ee cf       	rjmp	.-36     	; 0xc080 <um6_rwc+0x148>
    c0a4:	80 e0       	ldi	r24, 0x00	; 0
								um6_result[i] = (data[(i*2)+1] | (data[(i*2)]<<8));
    c0a6:	11 c0       	rjmp	.+34     	; 0xc0ca <um6_rwc+0x192>
    c0a8:	40 df       	rcall	.-384    	; 0xbf2a <flushdata>
    c0aa:	81 e0       	ldi	r24, 0x01	; 1
    c0ac:	0e c0       	rjmp	.+28     	; 0xc0ca <um6_rwc+0x192>
    c0ae:	3d df       	rcall	.-390    	; 0xbf2a <flushdata>
    c0b0:	82 e0       	ldi	r24, 0x02	; 2
    c0b2:	0b c0       	rjmp	.+22     	; 0xc0ca <um6_rwc+0x192>
    c0b4:	3a df       	rcall	.-396    	; 0xbf2a <flushdata>
    c0b6:	83 e0       	ldi	r24, 0x03	; 3
    c0b8:	08 c0       	rjmp	.+16     	; 0xc0ca <um6_rwc+0x192>
    c0ba:	37 df       	rcall	.-402    	; 0xbf2a <flushdata>
						checksum = ((checksum1 << 8) | checksum0);
						if( ((checksum == ('s' + 'n' + 'p' + (PT_HAS_DATA | pt_is_batch | batch) + um6_register + data_sum)) && (r_w_c == UM6_DATA_READ)) ||
								((checksum == 0) && (r_w_c == UM6_DATA_WRITE)) ||
								((checksum == 0) && (r_w_c == UM6_DATA_CMD)))
						{
							for(uint8_t i = 0; i < data_size; i++)
    c0bc:	84 e0       	ldi	r24, 0x04	; 4
    c0be:	05 c0       	rjmp	.+10     	; 0xc0ca <um6_rwc+0x192>
    c0c0:	34 df       	rcall	.-408    	; 0xbf2a <flushdata>
								um6_result[i] = (data[(i*2)+1] | (data[(i*2)]<<8));
							
							return 0;
    c0c2:	85 e0       	ldi	r24, 0x05	; 5
    c0c4:	02 c0       	rjmp	.+4      	; 0xc0ca <um6_rwc+0x192>
						}
						else
						{
							flushdata();
    c0c6:	31 df       	rcall	.-414    	; 0xbf2a <flushdata>
    c0c8:	86 e0       	ldi	r24, 0x06	; 6
							return 1;
    c0ca:	28 96       	adiw	r28, 0x08	; 8
    c0cc:	e2 e1       	ldi	r30, 0x12	; 18
						}
					}
					else
					{
						flushdata();
    c0ce:	0c 94 b7 6b 	jmp	0xd76e	; 0xd76e <__epilogue_restores__>

0000c0d2 <um6_getUM6>:
int16_t um6_theta_old;

UM6_t um6; //Globale Datenstruktur deklarieren

uint8_t um6_getUM6(void)
{
    c0d2:	a8 e0       	ldi	r26, 0x08	; 8
    c0d4:	b0 e0       	ldi	r27, 0x00	; 0
    c0d6:	ef e6       	ldi	r30, 0x6F	; 111
    c0d8:	f0 e6       	ldi	r31, 0x60	; 96
    c0da:	0c 94 a9 6b 	jmp	0xd752	; 0xd752 <__prologue_saves__+0x1c>
		um6_accl_x = (um6_data[0]*UM6_ACCL_SCALE_FACTOR);
		um6_accl_y = (um6_data[1]*UM6_ACCL_SCALE_FACTOR);
	}*/
	
/////////////////////////////
	if(um6_rwc(UM6_EULER_PHI_THETA, 8, UM6_DATA_READ, um6_data, UM6_DATA_BUFFER_SIZE) != 0)
    c0de:	04 e0       	ldi	r16, 0x04	; 4
    c0e0:	9e 01       	movw	r18, r28
    c0e2:	2f 5f       	subi	r18, 0xFF	; 255
    c0e4:	3f 4f       	sbci	r19, 0xFF	; 255
    c0e6:	40 e0       	ldi	r20, 0x00	; 0
    c0e8:	68 e0       	ldi	r22, 0x08	; 8
    c0ea:	82 e6       	ldi	r24, 0x62	; 98
    c0ec:	25 df       	rcall	.-438    	; 0xbf38 <um6_rwc>
    c0ee:	81 11       	cpse	r24, r1
    c0f0:	0d c1       	rjmp	.+538    	; 0xc30c <um6_getUM6+0x23a>
    c0f2:	69 81       	ldd	r22, Y+1	; 0x01
	{
		returnvar |= (1<<0);
	}
	else
	{
		um6.phi = (um6_data[0]*UM6_EULER_SCALE_FACTOR);
    c0f4:	7a 81       	ldd	r23, Y+2	; 0x02
    c0f6:	80 e0       	ldi	r24, 0x00	; 0
    c0f8:	90 e0       	ldi	r25, 0x00	; 0
    c0fa:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c0fe:	22 ee       	ldi	r18, 0xE2	; 226
    c100:	3f ef       	ldi	r19, 0xFF	; 255
    c102:	43 e3       	ldi	r20, 0x33	; 51
    c104:	5c e3       	ldi	r21, 0x3C	; 60
    c106:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c10a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c10e:	65 3b       	cpi	r22, 0xB5	; 181
		if(um6.phi > 180)
    c110:	71 05       	cpc	r23, r1
    c112:	14 f0       	brlt	.+4      	; 0xc118 <um6_getUM6+0x46>
    c114:	68 56       	subi	r22, 0x68	; 104
			um6.phi -= 360;
    c116:	71 40       	sbci	r23, 0x01	; 1
    c118:	70 93 03 17 	sts	0x1703, r23
    c11c:	60 93 02 17 	sts	0x1702, r22
    c120:	6b 81       	ldd	r22, Y+3	; 0x03

		um6.theta = (um6_data[1]*UM6_EULER_SCALE_FACTOR);
    c122:	7c 81       	ldd	r23, Y+4	; 0x04
    c124:	80 e0       	ldi	r24, 0x00	; 0
    c126:	90 e0       	ldi	r25, 0x00	; 0
    c128:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c12c:	22 ee       	ldi	r18, 0xE2	; 226
    c12e:	3f ef       	ldi	r19, 0xFF	; 255
    c130:	43 e3       	ldi	r20, 0x33	; 51
    c132:	5c e3       	ldi	r21, 0x3C	; 60
    c134:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c138:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c13c:	65 3b       	cpi	r22, 0xB5	; 181
		if(um6.theta > 180)
    c13e:	71 05       	cpc	r23, r1
    c140:	14 f0       	brlt	.+4      	; 0xc146 <um6_getUM6+0x74>
    c142:	68 56       	subi	r22, 0x68	; 104
			um6.theta -= 360;
    c144:	71 40       	sbci	r23, 0x01	; 1
    c146:	70 93 09 17 	sts	0x1709, r23
    c14a:	60 93 08 17 	sts	0x1708, r22
    c14e:	6d 81       	ldd	r22, Y+5	; 0x05

		um6.psi = (um6_data[2]*UM6_EULER_SCALE_FACTOR);
    c150:	7e 81       	ldd	r23, Y+6	; 0x06
    c152:	80 e0       	ldi	r24, 0x00	; 0
    c154:	90 e0       	ldi	r25, 0x00	; 0
    c156:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c15a:	22 ee       	ldi	r18, 0xE2	; 226
    c15c:	3f ef       	ldi	r19, 0xFF	; 255
    c15e:	43 e3       	ldi	r20, 0x33	; 51
    c160:	5c e3       	ldi	r21, 0x3C	; 60
    c162:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c166:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c16a:	65 3b       	cpi	r22, 0xB5	; 181
		if(um6.psi > 180)
    c16c:	71 05       	cpc	r23, r1
    c16e:	14 f0       	brlt	.+4      	; 0xc174 <um6_getUM6+0xa2>
    c170:	68 56       	subi	r22, 0x68	; 104
			um6.psi -= 360;
    c172:	71 40       	sbci	r23, 0x01	; 1
    c174:	70 93 0d 17 	sts	0x170D, r23
    c178:	60 93 0c 17 	sts	0x170C, r22
    c17c:	40 91 fe 16 	lds	r20, 0x16FE
	////////////

		if((um6_phi_old - um6.phi) > UM6_T_ROTDIFF)
    c180:	50 91 ff 16 	lds	r21, 0x16FF
    c184:	20 91 02 17 	lds	r18, 0x1702
    c188:	30 91 03 17 	lds	r19, 0x1703
    c18c:	ba 01       	movw	r22, r20
    c18e:	62 1b       	sub	r22, r18
    c190:	73 0b       	sbc	r23, r19
    c192:	80 91 04 17 	lds	r24, 0x1704
    c196:	90 91 05 17 	lds	r25, 0x1705
    c19a:	a0 91 06 17 	lds	r26, 0x1706
    c19e:	b0 91 07 17 	lds	r27, 0x1707
    c1a2:	6d 32       	cpi	r22, 0x2D	; 45
    c1a4:	e1 e0       	ldi	r30, 0x01	; 1
    c1a6:	7e 07       	cpc	r23, r30
    c1a8:	2c f0       	brlt	.+10     	; 0xc1b4 <um6_getUM6+0xe2>
    c1aa:	88 59       	subi	r24, 0x98	; 152
			um6.phi_t += 360;
    c1ac:	9e 4f       	sbci	r25, 0xFE	; 254
    c1ae:	af 4f       	sbci	r26, 0xFF	; 255
    c1b0:	bf 4f       	sbci	r27, 0xFF	; 255
    c1b2:	07 c0       	rjmp	.+14     	; 0xc1c2 <um6_getUM6+0xf0>
    c1b4:	64 3d       	cpi	r22, 0xD4	; 212
		else if((um6_phi_old - um6.phi) < -(UM6_T_ROTDIFF))
    c1b6:	7e 4f       	sbci	r23, 0xFE	; 254
    c1b8:	64 f4       	brge	.+24     	; 0xc1d2 <um6_getUM6+0x100>
    c1ba:	88 56       	subi	r24, 0x68	; 104
			um6.phi_t -= 360;
    c1bc:	91 40       	sbci	r25, 0x01	; 1
    c1be:	a1 09       	sbc	r26, r1
    c1c0:	b1 09       	sbc	r27, r1
    c1c2:	80 93 04 17 	sts	0x1704, r24
    c1c6:	90 93 05 17 	sts	0x1705, r25
    c1ca:	a0 93 06 17 	sts	0x1706, r26
    c1ce:	b0 93 07 17 	sts	0x1707, r27
    c1d2:	c9 01       	movw	r24, r18
		um6.phi_t += (um6.phi - um6_phi_old);
    c1d4:	84 1b       	sub	r24, r20
    c1d6:	95 0b       	sbc	r25, r21
    c1d8:	ac 01       	movw	r20, r24
    c1da:	66 27       	eor	r22, r22
    c1dc:	57 fd       	sbrc	r21, 7
    c1de:	60 95       	com	r22
    c1e0:	76 2f       	mov	r23, r22
    c1e2:	80 91 04 17 	lds	r24, 0x1704
    c1e6:	90 91 05 17 	lds	r25, 0x1705
    c1ea:	a0 91 06 17 	lds	r26, 0x1706
    c1ee:	b0 91 07 17 	lds	r27, 0x1707
    c1f2:	84 0f       	add	r24, r20
    c1f4:	95 1f       	adc	r25, r21
    c1f6:	a6 1f       	adc	r26, r22
    c1f8:	b7 1f       	adc	r27, r23
    c1fa:	80 93 04 17 	sts	0x1704, r24
    c1fe:	90 93 05 17 	sts	0x1705, r25
    c202:	a0 93 06 17 	sts	0x1706, r26
    c206:	b0 93 07 17 	sts	0x1707, r27
    c20a:	30 93 ff 16 	sts	0x16FF, r19
		um6_phi_old = um6.phi;
    c20e:	20 93 fe 16 	sts	0x16FE, r18
    c212:	20 91 00 17 	lds	r18, 0x1700
		
		if((um6_theta_old - um6.theta) > UM6_T_ROTDIFF)
    c216:	30 91 01 17 	lds	r19, 0x1701
    c21a:	80 91 08 17 	lds	r24, 0x1708
    c21e:	90 91 09 17 	lds	r25, 0x1709
    c222:	b9 01       	movw	r22, r18
    c224:	68 1b       	sub	r22, r24
    c226:	79 0b       	sbc	r23, r25
    c228:	40 91 0a 17 	lds	r20, 0x170A
    c22c:	50 91 0b 17 	lds	r21, 0x170B
    c230:	6d 32       	cpi	r22, 0x2D	; 45
    c232:	e1 e0       	ldi	r30, 0x01	; 1
    c234:	7e 07       	cpc	r23, r30
    c236:	1c f0       	brlt	.+6      	; 0xc23e <um6_getUM6+0x16c>
    c238:	48 59       	subi	r20, 0x98	; 152
			um6.theta_t += 360;
    c23a:	5e 4f       	sbci	r21, 0xFE	; 254
    c23c:	05 c0       	rjmp	.+10     	; 0xc248 <um6_getUM6+0x176>
    c23e:	64 3d       	cpi	r22, 0xD4	; 212
		else if((um6_theta_old - um6.theta) < -(UM6_T_ROTDIFF))
    c240:	7e 4f       	sbci	r23, 0xFE	; 254
    c242:	34 f4       	brge	.+12     	; 0xc250 <um6_getUM6+0x17e>
    c244:	48 56       	subi	r20, 0x68	; 104
			um6.theta_t -= 360;
    c246:	51 40       	sbci	r21, 0x01	; 1
    c248:	50 93 0b 17 	sts	0x170B, r21
    c24c:	40 93 0a 17 	sts	0x170A, r20
    c250:	ac 01       	movw	r20, r24
		um6.theta_t += (um6.theta - um6_theta_old);
    c252:	42 1b       	sub	r20, r18
    c254:	53 0b       	sbc	r21, r19
    c256:	20 91 0a 17 	lds	r18, 0x170A
    c25a:	30 91 0b 17 	lds	r19, 0x170B
    c25e:	24 0f       	add	r18, r20
    c260:	35 1f       	adc	r19, r21
    c262:	30 93 0b 17 	sts	0x170B, r19
    c266:	20 93 0a 17 	sts	0x170A, r18
    c26a:	90 93 01 17 	sts	0x1701, r25
		um6_theta_old = um6.theta;
    c26e:	80 93 00 17 	sts	0x1700, r24
    c272:	40 91 1c 17 	lds	r20, 0x171C
		
		if((um6_psi_old - um6.psi) > UM6_T_ROTDIFF)
    c276:	50 91 1d 17 	lds	r21, 0x171D
    c27a:	20 91 0c 17 	lds	r18, 0x170C
    c27e:	30 91 0d 17 	lds	r19, 0x170D
    c282:	ba 01       	movw	r22, r20
    c284:	62 1b       	sub	r22, r18
    c286:	73 0b       	sbc	r23, r19
    c288:	80 91 0e 17 	lds	r24, 0x170E
    c28c:	90 91 0f 17 	lds	r25, 0x170F
    c290:	a0 91 10 17 	lds	r26, 0x1710
    c294:	b0 91 11 17 	lds	r27, 0x1711
    c298:	6d 32       	cpi	r22, 0x2D	; 45
    c29a:	e1 e0       	ldi	r30, 0x01	; 1
    c29c:	7e 07       	cpc	r23, r30
    c29e:	2c f0       	brlt	.+10     	; 0xc2aa <um6_getUM6+0x1d8>
    c2a0:	88 59       	subi	r24, 0x98	; 152
			um6.psi_t += 360;
    c2a2:	9e 4f       	sbci	r25, 0xFE	; 254
    c2a4:	af 4f       	sbci	r26, 0xFF	; 255
    c2a6:	bf 4f       	sbci	r27, 0xFF	; 255
    c2a8:	07 c0       	rjmp	.+14     	; 0xc2b8 <um6_getUM6+0x1e6>
    c2aa:	64 3d       	cpi	r22, 0xD4	; 212
		else if((um6_psi_old - um6.psi) < -(UM6_T_ROTDIFF))
    c2ac:	7e 4f       	sbci	r23, 0xFE	; 254
    c2ae:	64 f4       	brge	.+24     	; 0xc2c8 <um6_getUM6+0x1f6>
    c2b0:	88 56       	subi	r24, 0x68	; 104
			um6.psi_t -= 360;
    c2b2:	91 40       	sbci	r25, 0x01	; 1
    c2b4:	a1 09       	sbc	r26, r1
    c2b6:	b1 09       	sbc	r27, r1
    c2b8:	80 93 0e 17 	sts	0x170E, r24
    c2bc:	90 93 0f 17 	sts	0x170F, r25
    c2c0:	a0 93 10 17 	sts	0x1710, r26
    c2c4:	b0 93 11 17 	sts	0x1711, r27
    c2c8:	c9 01       	movw	r24, r18
		um6.psi_t += (um6.psi - um6_psi_old);
    c2ca:	84 1b       	sub	r24, r20
    c2cc:	95 0b       	sbc	r25, r21
    c2ce:	ac 01       	movw	r20, r24
    c2d0:	66 27       	eor	r22, r22
    c2d2:	57 fd       	sbrc	r21, 7
    c2d4:	60 95       	com	r22
    c2d6:	76 2f       	mov	r23, r22
    c2d8:	80 91 0e 17 	lds	r24, 0x170E
    c2dc:	90 91 0f 17 	lds	r25, 0x170F
    c2e0:	a0 91 10 17 	lds	r26, 0x1710
    c2e4:	b0 91 11 17 	lds	r27, 0x1711
    c2e8:	84 0f       	add	r24, r20
    c2ea:	95 1f       	adc	r25, r21
    c2ec:	a6 1f       	adc	r26, r22
    c2ee:	b7 1f       	adc	r27, r23
    c2f0:	80 93 0e 17 	sts	0x170E, r24
    c2f4:	90 93 0f 17 	sts	0x170F, r25
    c2f8:	a0 93 10 17 	sts	0x1710, r26
    c2fc:	b0 93 11 17 	sts	0x1711, r27
    c300:	30 93 1d 17 	sts	0x171D, r19
		um6_psi_old = um6.psi;
    c304:	20 93 1c 17 	sts	0x171C, r18
    c308:	10 e0       	ldi	r17, 0x00	; 0

uint8_t um6_getUM6(void)
{
	uint16_t um6_data[UM6_DATA_BUFFER_SIZE]; //Wenn batch abgefragt wird, werden hier hintereinander die Daten abgelegt
	
	uint8_t returnvar = 0;
    c30a:	01 c0       	rjmp	.+2      	; 0xc30e <um6_getUM6+0x23c>
    c30c:	11 e0       	ldi	r17, 0x01	; 1
	}*/
	
/////////////////////////////
	if(um6_rwc(UM6_EULER_PHI_THETA, 8, UM6_DATA_READ, um6_data, UM6_DATA_BUFFER_SIZE) != 0)
	{
		returnvar |= (1<<0);
    c30e:	04 e0       	ldi	r16, 0x04	; 4
		um6.psi_t += (um6.psi - um6_psi_old);
		um6_psi_old = um6.psi;
	}
////////////////////////////////

	if(um6_rwc(UM6_GYRO_PROC_XY, 8, UM6_DATA_READ, um6_data, UM6_DATA_BUFFER_SIZE) == 0)
    c310:	9e 01       	movw	r18, r28
    c312:	2f 5f       	subi	r18, 0xFF	; 255
    c314:	3f 4f       	sbci	r19, 0xFF	; 255
    c316:	40 e0       	ldi	r20, 0x00	; 0
    c318:	68 e0       	ldi	r22, 0x08	; 8
    c31a:	8c e5       	ldi	r24, 0x5C	; 92
    c31c:	0d de       	rcall	.-998    	; 0xbf38 <um6_rwc>
    c31e:	81 11       	cpse	r24, r1
    c320:	68 c0       	rjmp	.+208    	; 0xc3f2 <um6_getUM6+0x320>
    c322:	69 81       	ldd	r22, Y+1	; 0x01
    c324:	7a 81       	ldd	r23, Y+2	; 0x02
	{
		um6.gyr.x = (um6_data[0]*UM6_GYRO_SCALE_FACTOR);
    c326:	80 e0       	ldi	r24, 0x00	; 0
    c328:	90 e0       	ldi	r25, 0x00	; 0
    c32a:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c32e:	2c e0       	ldi	r18, 0x0C	; 12
    c330:	30 e0       	ldi	r19, 0x00	; 0
    c332:	4a e7       	ldi	r20, 0x7A	; 122
    c334:	5d e3       	ldi	r21, 0x3D	; 61
    c336:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c33a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c33e:	61 3d       	cpi	r22, 0xD1	; 209
    c340:	e7 e0       	ldi	r30, 0x07	; 7
		if(um6.gyr.x > 2000)
    c342:	7e 07       	cpc	r23, r30
    c344:	14 f0       	brlt	.+4      	; 0xc34a <um6_getUM6+0x278>
    c346:	60 5a       	subi	r22, 0xA0	; 160
    c348:	7f 40       	sbci	r23, 0x0F	; 15
			um6.gyr.x = -(4000 - um6.gyr.x);
    c34a:	70 93 17 17 	sts	0x1717, r23
    c34e:	60 93 16 17 	sts	0x1716, r22
    c352:	6b 81       	ldd	r22, Y+3	; 0x03
    c354:	7c 81       	ldd	r23, Y+4	; 0x04
			
		um6.gyr.y = (um6_data[1]*UM6_GYRO_SCALE_FACTOR);
    c356:	80 e0       	ldi	r24, 0x00	; 0
    c358:	90 e0       	ldi	r25, 0x00	; 0
    c35a:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c35e:	2c e0       	ldi	r18, 0x0C	; 12
    c360:	30 e0       	ldi	r19, 0x00	; 0
    c362:	4a e7       	ldi	r20, 0x7A	; 122
    c364:	5d e3       	ldi	r21, 0x3D	; 61
    c366:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c36a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c36e:	61 3d       	cpi	r22, 0xD1	; 209
    c370:	27 e0       	ldi	r18, 0x07	; 7
		if(um6.gyr.y > 2000)
    c372:	72 07       	cpc	r23, r18
    c374:	14 f0       	brlt	.+4      	; 0xc37a <um6_getUM6+0x2a8>
    c376:	60 5a       	subi	r22, 0xA0	; 160
    c378:	7f 40       	sbci	r23, 0x0F	; 15
			um6.gyr.y = -(4000 - um6.gyr.y);
    c37a:	70 93 19 17 	sts	0x1719, r23
    c37e:	60 93 18 17 	sts	0x1718, r22
    c382:	6d 81       	ldd	r22, Y+5	; 0x05
    c384:	7e 81       	ldd	r23, Y+6	; 0x06
			
		um6.gyr.z = (um6_data[2]*UM6_GYRO_SCALE_FACTOR);
    c386:	80 e0       	ldi	r24, 0x00	; 0
    c388:	90 e0       	ldi	r25, 0x00	; 0
    c38a:	0e 94 16 6a 	call	0xd42c	; 0xd42c <__floatunsisf>
    c38e:	2c e0       	ldi	r18, 0x0C	; 12
    c390:	30 e0       	ldi	r19, 0x00	; 0
    c392:	4a e7       	ldi	r20, 0x7A	; 122
    c394:	5d e3       	ldi	r21, 0x3D	; 61
    c396:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c39a:	0e 94 e5 69 	call	0xd3ca	; 0xd3ca <__fixsfsi>
    c39e:	61 3d       	cpi	r22, 0xD1	; 209
    c3a0:	e7 e0       	ldi	r30, 0x07	; 7
		if(um6.gyr.z > 2000)
    c3a2:	7e 07       	cpc	r23, r30
    c3a4:	14 f0       	brlt	.+4      	; 0xc3aa <um6_getUM6+0x2d8>
    c3a6:	60 5a       	subi	r22, 0xA0	; 160
    c3a8:	7f 40       	sbci	r23, 0x0F	; 15
			um6.gyr.z = -(4000 - um6.gyr.z);
    c3aa:	70 93 1b 17 	sts	0x171B, r23
    c3ae:	60 93 1a 17 	sts	0x171A, r22
    c3b2:	80 91 1a 17 	lds	r24, 0x171A
		
		if(((um6.gyr.z < -UM6_GYR_MAXDRIFT) || (um6.gyr.z > UM6_GYR_MAXDRIFT)) &&
    c3b6:	90 91 1b 17 	lds	r25, 0x171B
    c3ba:	02 96       	adiw	r24, 0x02	; 2
    c3bc:	05 97       	sbiw	r24, 0x05	; 5
    c3be:	b0 f0       	brcs	.+44     	; 0xc3ec <um6_getUM6+0x31a>
    c3c0:	80 91 67 16 	lds	r24, 0x1667
    c3c4:	90 91 68 16 	lds	r25, 0x1668
    c3c8:	89 2b       	or	r24, r25
    c3ca:	81 f4       	brne	.+32     	; 0xc3ec <um6_getUM6+0x31a>
    c3cc:	80 91 73 16 	lds	r24, 0x1673
				(mot.d[LEFT].speed.is == 0) && (mot.d[RIGHT].speed.is == 0)) //Gyrobewegung trotz Drift
    c3d0:	90 91 74 16 	lds	r25, 0x1674
    c3d4:	89 2b       	or	r24, r25
    c3d6:	51 f4       	brne	.+20     	; 0xc3ec <um6_getUM6+0x31a>
    c3d8:	80 91 6a 06 	lds	r24, 0x066A
		{
			if(um6_gyr_drift_cnt > UM6_GYR_DRIFT_CNT_TOP)
    c3dc:	81 35       	cpi	r24, 0x51	; 81
    c3de:	10 f0       	brcs	.+4      	; 0xc3e4 <um6_getUM6+0x312>
    c3e0:	14 60       	ori	r17, 0x04	; 4
    c3e2:	08 c0       	rjmp	.+16     	; 0xc3f4 <um6_getUM6+0x322>
				returnvar |= (1<<2);
    c3e4:	8f 5f       	subi	r24, 0xFF	; 255
    c3e6:	80 93 6a 06 	sts	0x066A, r24
			else
				um6_gyr_drift_cnt++;
    c3ea:	04 c0       	rjmp	.+8      	; 0xc3f4 <um6_getUM6+0x322>
    c3ec:	10 92 6a 06 	sts	0x066A, r1
		}
		else	um6_gyr_drift_cnt = 0;
    c3f0:	01 c0       	rjmp	.+2      	; 0xc3f4 <um6_getUM6+0x322>
    c3f2:	12 60       	ori	r17, 0x02	; 2
    c3f4:	81 2f       	mov	r24, r17
	}
	else returnvar |= (1<<1);
    c3f6:	28 96       	adiw	r28, 0x08	; 8

	return returnvar;
}
    c3f8:	e4 e0       	ldi	r30, 0x04	; 4
    c3fa:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <__epilogue_restores__+0x1c>

0000c3fe <victim_init>:
VICTIMBUFFER victimBuf[NUMBER_OF_MLX];

uint32_t victim_enc_zero[NUMBER_OF_MLX];

void victim_init(void)
{
    c3fe:	e6 e2       	ldi	r30, 0x26	; 38
    c400:	f7 e1       	ldi	r31, 0x17	; 23
	for(uint8_t dir = 0; dir < 2; dir++)
	{
		for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
		{
			victimBuf[dir].value[j] = VICTIMBUF_UNUSED;
    c402:	8f ef       	ldi	r24, 0xFF	; 255
    c404:	9f e7       	ldi	r25, 0x7F	; 127
    c406:	81 93       	st	Z+, r24
    c408:	91 93       	st	Z+, r25

void victim_init(void)
{
	for(uint8_t dir = 0; dir < 2; dir++)
	{
		for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
    c40a:	27 e1       	ldi	r18, 0x17	; 23
    c40c:	e6 37       	cpi	r30, 0x76	; 118
    c40e:	f2 07       	cpc	r31, r18
    c410:	d1 f7       	brne	.-12     	; 0xc406 <victim_init+0x8>
		{
			victimBuf[dir].value[j] = VICTIMBUF_UNUSED;
		}
		victimBuf[dir].next = 0;
    c412:	10 92 76 17 	sts	0x1776, r1
		victimBuf[dir].lowest = VICTIMBUF_UNUSED;
    c416:	8f ef       	ldi	r24, 0xFF	; 255
    c418:	9f e7       	ldi	r25, 0x7F	; 127
    c41a:	90 93 78 17 	sts	0x1778, r25
    c41e:	80 93 77 17 	sts	0x1777, r24
		victimBuf[dir].highest = 0;
    c422:	10 92 7a 17 	sts	0x177A, r1
    c426:	10 92 79 17 	sts	0x1779, r1
		victim_enc_zero[dir] = 0;
    c42a:	10 92 1e 17 	sts	0x171E, r1
    c42e:	10 92 1f 17 	sts	0x171F, r1
    c432:	10 92 20 17 	sts	0x1720, r1
    c436:	10 92 21 17 	sts	0x1721, r1
    c43a:	eb e7       	ldi	r30, 0x7B	; 123
    c43c:	f7 e1       	ldi	r31, 0x17	; 23
{
	for(uint8_t dir = 0; dir < 2; dir++)
	{
		for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
		{
			victimBuf[dir].value[j] = VICTIMBUF_UNUSED;
    c43e:	81 93       	st	Z+, r24
    c440:	91 93       	st	Z+, r25

void victim_init(void)
{
	for(uint8_t dir = 0; dir < 2; dir++)
	{
		for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
    c442:	27 e1       	ldi	r18, 0x17	; 23
    c444:	eb 3c       	cpi	r30, 0xCB	; 203
    c446:	f2 07       	cpc	r31, r18
    c448:	d1 f7       	brne	.-12     	; 0xc43e <victim_init+0x40>
		{
			victimBuf[dir].value[j] = VICTIMBUF_UNUSED;
		}
		victimBuf[dir].next = 0;
    c44a:	10 92 cb 17 	sts	0x17CB, r1
		victimBuf[dir].lowest = VICTIMBUF_UNUSED;
    c44e:	8f ef       	ldi	r24, 0xFF	; 255
    c450:	9f e7       	ldi	r25, 0x7F	; 127
    c452:	90 93 cd 17 	sts	0x17CD, r25
    c456:	80 93 cc 17 	sts	0x17CC, r24
		victimBuf[dir].highest = 0;
    c45a:	10 92 cf 17 	sts	0x17CF, r1
    c45e:	10 92 ce 17 	sts	0x17CE, r1
		victim_enc_zero[dir] = 0;
    c462:	10 92 22 17 	sts	0x1722, r1
    c466:	10 92 23 17 	sts	0x1723, r1
    c46a:	10 92 24 17 	sts	0x1724, r1
    c46e:	10 92 25 17 	sts	0x1725, r1
    c472:	08 95       	ret

0000c474 <victim_scan>:
}

//Has to be called when there are new temperature infos (after the temperature sensors were read out)

void victim_scan(void)
{
    c474:	ab e0       	ldi	r26, 0x0B	; 11
    c476:	b0 e0       	ldi	r27, 0x00	; 0
    c478:	e0 e4       	ldi	r30, 0x40	; 64
    c47a:	f2 e6       	ldi	r31, 0x62	; 98
    c47c:	0c 94 9b 6b 	jmp	0xd736	; 0xd736 <__prologue_saves__>
	if((maze_solve_state_path != VIC_DEPL_L) && (maze_solve_state_path != VIC_DEPL_R)) //No kit deployment
    c480:	80 91 cd 05 	lds	r24, 0x05CD
    c484:	8d 50       	subi	r24, 0x0D	; 13
    c486:	82 30       	cpi	r24, 0x02	; 2
    c488:	08 f4       	brcc	.+2      	; 0xc48c <victim_scan+0x18>
    c48a:	fc c0       	rjmp	.+504    	; 0xc684 <victim_scan+0x210>
    c48c:	44 e0       	ldi	r20, 0x04	; 4
    c48e:	58 e0       	ldi	r21, 0x08	; 8
    c490:	5e 83       	std	Y+6, r21	; 0x06
    c492:	4d 83       	std	Y+5, r20	; 0x05
    c494:	86 e7       	ldi	r24, 0x76	; 118
    c496:	97 e1       	ldi	r25, 0x17	; 23
    c498:	9b 87       	std	Y+11, r25	; 0x0b
    c49a:	8a 87       	std	Y+10, r24	; 0x0a
    c49c:	36 e2       	ldi	r19, 0x26	; 38
    c49e:	23 2e       	mov	r2, r19
    c4a0:	37 e1       	ldi	r19, 0x17	; 23
    c4a2:	33 2e       	mov	r3, r19
    c4a4:	af e6       	ldi	r26, 0x6F	; 111
    c4a6:	b6 e1       	ldi	r27, 0x16	; 22
    c4a8:	b8 87       	std	Y+8, r27	; 0x08
    c4aa:	af 83       	std	Y+7, r26	; 0x07
    c4ac:	ee e1       	ldi	r30, 0x1E	; 30
    c4ae:	f7 e1       	ldi	r31, 0x17	; 23
    c4b0:	fa 83       	std	Y+2, r31	; 0x02
    c4b2:	e9 83       	std	Y+1, r30	; 0x01
    c4b4:	00 e0       	ldi	r16, 0x00	; 0
    c4b6:	10 e0       	ldi	r17, 0x00	; 0
	{
		for(uint8_t dir = 0; dir < NUMBER_OF_MLX; dir++)
		{
			if((mlx90614[dir].is > victimBuf[dir].value[victimBuf[dir].next]) || (victimBuf[dir].value[victimBuf[dir].next] == VICTIMBUF_UNUSED))
    c4b8:	ad 81       	ldd	r26, Y+5	; 0x05
    c4ba:	be 81       	ldd	r27, Y+6	; 0x06
    c4bc:	0d 90       	ld	r0, X+
    c4be:	bc 91       	ld	r27, X
    c4c0:	a0 2d       	mov	r26, r0
    c4c2:	bc 83       	std	Y+4, r27	; 0x04
    c4c4:	ab 83       	std	Y+3, r26	; 0x03
    c4c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    c4c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    c4ca:	80 81       	ld	r24, Z
    c4cc:	90 e0       	ldi	r25, 0x00	; 0
    c4ce:	88 0f       	add	r24, r24
    c4d0:	99 1f       	adc	r25, r25
    c4d2:	25 e5       	ldi	r18, 0x55	; 85
    c4d4:	20 9f       	mul	r18, r16
    c4d6:	f0 01       	movw	r30, r0
    c4d8:	21 9f       	mul	r18, r17
    c4da:	f0 0d       	add	r31, r0
    c4dc:	11 24       	eor	r1, r1
    c4de:	e8 0f       	add	r30, r24
    c4e0:	f9 1f       	adc	r31, r25
    c4e2:	ea 5d       	subi	r30, 0xDA	; 218
    c4e4:	f8 4e       	sbci	r31, 0xE8	; 232
    c4e6:	20 81       	ld	r18, Z
    c4e8:	31 81       	ldd	r19, Z+1	; 0x01
    c4ea:	2a 17       	cp	r18, r26
    c4ec:	3b 07       	cpc	r19, r27
    c4ee:	1c f0       	brlt	.+6      	; 0xc4f6 <victim_scan+0x82>
    c4f0:	2f 3f       	cpi	r18, 0xFF	; 255
    c4f2:	3f 47       	sbci	r19, 0x7F	; 127
    c4f4:	71 f4       	brne	.+28     	; 0xc512 <victim_scan+0x9e>
			{
				victimBuf[dir].value[victimBuf[dir].next] = mlx90614[dir].is;
    c4f6:	55 e5       	ldi	r21, 0x55	; 85
    c4f8:	50 9f       	mul	r21, r16
    c4fa:	f0 01       	movw	r30, r0
    c4fc:	51 9f       	mul	r21, r17
    c4fe:	f0 0d       	add	r31, r0
    c500:	11 24       	eor	r1, r1
    c502:	e8 0f       	add	r30, r24
    c504:	f9 1f       	adc	r31, r25
    c506:	ea 5d       	subi	r30, 0xDA	; 218
    c508:	f8 4e       	sbci	r31, 0xE8	; 232
    c50a:	8b 81       	ldd	r24, Y+3	; 0x03
    c50c:	9c 81       	ldd	r25, Y+4	; 0x04
    c50e:	91 83       	std	Z+1, r25	; 0x01
    c510:	80 83       	st	Z, r24
			}

			if(mot.d[dir].enc_abs > (victim_enc_zero[dir] + victimBuf[dir].next * ENC_FAC_CM_LR)) //1cm driven
    c512:	af 81       	ldd	r26, Y+7	; 0x07
    c514:	b8 85       	ldd	r27, Y+8	; 0x08
    c516:	4d 90       	ld	r4, X+
    c518:	5d 90       	ld	r5, X+
    c51a:	6d 90       	ld	r6, X+
    c51c:	7c 90       	ld	r7, X
    c51e:	ea 85       	ldd	r30, Y+10	; 0x0a
    c520:	fb 85       	ldd	r31, Y+11	; 0x0b
    c522:	f0 81       	ld	r31, Z
    c524:	f9 87       	std	Y+9, r31	; 0x09
    c526:	c3 01       	movw	r24, r6
    c528:	b2 01       	movw	r22, r4
    c52a:	82 d7       	rcall	.+3844   	; 0xd430 <__floatsisf>
    c52c:	6b 01       	movw	r12, r22
    c52e:	7c 01       	movw	r14, r24
    c530:	a9 81       	ldd	r26, Y+1	; 0x01
    c532:	ba 81       	ldd	r27, Y+2	; 0x02
    c534:	6d 91       	ld	r22, X+
    c536:	7d 91       	ld	r23, X+
    c538:	8d 91       	ld	r24, X+
    c53a:	9c 91       	ld	r25, X
    c53c:	77 d7       	rcall	.+3822   	; 0xd42c <__floatunsisf>
    c53e:	4b 01       	movw	r8, r22
    c540:	5c 01       	movw	r10, r24
    c542:	b9 85       	ldd	r27, Y+9	; 0x09
    c544:	6b 2f       	mov	r22, r27
    c546:	70 e0       	ldi	r23, 0x00	; 0
    c548:	80 e0       	ldi	r24, 0x00	; 0
    c54a:	90 e0       	ldi	r25, 0x00	; 0
    c54c:	71 d7       	rcall	.+3810   	; 0xd430 <__floatsisf>
    c54e:	20 e0       	ldi	r18, 0x00	; 0
    c550:	30 e0       	ldi	r19, 0x00	; 0
    c552:	44 eb       	ldi	r20, 0xB4	; 180
    c554:	51 e4       	ldi	r21, 0x41	; 65
    c556:	0e 94 cc 6a 	call	0xd598	; 0xd598 <__mulsf3>
    c55a:	9b 01       	movw	r18, r22
    c55c:	ac 01       	movw	r20, r24
    c55e:	c5 01       	movw	r24, r10
    c560:	b4 01       	movw	r22, r8
    c562:	63 d6       	rcall	.+3270   	; 0xd22a <__addsf3>
    c564:	9b 01       	movw	r18, r22
    c566:	ac 01       	movw	r20, r24
    c568:	c7 01       	movw	r24, r14
    c56a:	b6 01       	movw	r22, r12
    c56c:	0e 94 c8 6a 	call	0xd590	; 0xd590 <__gesf2>
    c570:	18 16       	cp	r1, r24
    c572:	24 f5       	brge	.+72     	; 0xc5bc <victim_scan+0x148>
    c574:	89 85       	ldd	r24, Y+9	; 0x09
    c576:	8f 5f       	subi	r24, 0xFF	; 255
    c578:	88 32       	cpi	r24, 0x28	; 40
    c57a:	20 f4       	brcc	.+8      	; 0xc584 <victim_scan+0x110>
			{
				victimBuf[dir].next ++;
    c57c:	ea 85       	ldd	r30, Y+10	; 0x0a
    c57e:	fb 85       	ldd	r31, Y+11	; 0x0b
				if(victimBuf[dir].next >= VICTIMBUFFER_SIZE)
    c580:	80 83       	st	Z, r24
    c582:	09 c0       	rjmp	.+18     	; 0xc596 <victim_scan+0x122>
				victimBuf[dir].value[victimBuf[dir].next] = mlx90614[dir].is;
			}

			if(mot.d[dir].enc_abs > (victim_enc_zero[dir] + victimBuf[dir].next * ENC_FAC_CM_LR)) //1cm driven
			{
				victimBuf[dir].next ++;
    c584:	aa 85       	ldd	r26, Y+10	; 0x0a
    c586:	bb 85       	ldd	r27, Y+11	; 0x0b
    c588:	1c 92       	st	X, r1
    c58a:	e9 81       	ldd	r30, Y+1	; 0x01
				if(victimBuf[dir].next >= VICTIMBUFFER_SIZE)
				{
					victimBuf[dir].next = 0;
    c58c:	fa 81       	ldd	r31, Y+2	; 0x02
    c58e:	40 82       	st	Z, r4
    c590:	51 82       	std	Z+1, r5	; 0x01
					victim_enc_zero[dir] = mot.d[dir].enc_abs;
    c592:	62 82       	std	Z+2, r6	; 0x02
    c594:	73 82       	std	Z+3, r7	; 0x03
    c596:	aa 85       	ldd	r26, Y+10	; 0x0a
    c598:	bb 85       	ldd	r27, Y+11	; 0x0b
    c59a:	8c 91       	ld	r24, X
    c59c:	b5 e5       	ldi	r27, 0x55	; 85
				}

				victimBuf[dir].value[victimBuf[dir].next] = mlx90614[dir].is;
    c59e:	b0 9f       	mul	r27, r16
    c5a0:	f0 01       	movw	r30, r0
    c5a2:	b1 9f       	mul	r27, r17
    c5a4:	f0 0d       	add	r31, r0
    c5a6:	11 24       	eor	r1, r1
    c5a8:	e8 0f       	add	r30, r24
    c5aa:	f1 1d       	adc	r31, r1
    c5ac:	e8 0f       	add	r30, r24
    c5ae:	f1 1d       	adc	r31, r1
    c5b0:	ea 5d       	subi	r30, 0xDA	; 218
    c5b2:	f8 4e       	sbci	r31, 0xE8	; 232
    c5b4:	4b 81       	ldd	r20, Y+3	; 0x03
    c5b6:	5c 81       	ldd	r21, Y+4	; 0x04
    c5b8:	51 83       	std	Z+1, r21	; 0x01
    c5ba:	40 83       	st	Z, r20
    c5bc:	ef ef       	ldi	r30, 0xFF	; 255
    c5be:	ff e7       	ldi	r31, 0x7F	; 127
    c5c0:	aa 85       	ldd	r26, Y+10	; 0x0a
    c5c2:	bb 85       	ldd	r27, Y+11	; 0x0b
			}

			victimBuf[dir].lowest = VICTIMBUF_UNUSED;
    c5c4:	12 96       	adiw	r26, 0x02	; 2
    c5c6:	fc 93       	st	X, r31
    c5c8:	ee 93       	st	-X, r30
    c5ca:	11 97       	sbiw	r26, 0x01	; 1
    c5cc:	80 e0       	ldi	r24, 0x00	; 0
    c5ce:	90 e0       	ldi	r25, 0x00	; 0
    c5d0:	f1 01       	movw	r30, r2
    c5d2:	e8 0f       	add	r30, r24
    c5d4:	f9 1f       	adc	r31, r25
    c5d6:	20 81       	ld	r18, Z
    c5d8:	31 81       	ldd	r19, Z+1	; 0x01
    c5da:	aa 85       	ldd	r26, Y+10	; 0x0a
    c5dc:	bb 85       	ldd	r27, Y+11	; 0x0b
			for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
			{
				if((victimBuf[dir].value[j] < victimBuf[dir].lowest) && (victimBuf[dir].value[j] != VICTIMBUF_UNUSED))
    c5de:	11 96       	adiw	r26, 0x01	; 1
    c5e0:	4d 91       	ld	r20, X+
    c5e2:	5c 91       	ld	r21, X
    c5e4:	12 97       	sbiw	r26, 0x02	; 2
    c5e6:	24 17       	cp	r18, r20
    c5e8:	35 07       	cpc	r19, r21
    c5ea:	44 f4       	brge	.+16     	; 0xc5fc <victim_scan+0x188>
    c5ec:	2f 3f       	cpi	r18, 0xFF	; 255
    c5ee:	bf e7       	ldi	r27, 0x7F	; 127
    c5f0:	3b 07       	cpc	r19, r27
    c5f2:	21 f0       	breq	.+8      	; 0xc5fc <victim_scan+0x188>
    c5f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    c5f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    c5f8:	32 83       	std	Z+2, r19	; 0x02
    c5fa:	21 83       	std	Z+1, r18	; 0x01
					victimBuf[dir].lowest = victimBuf[dir].value[j];
    c5fc:	02 96       	adiw	r24, 0x02	; 2
    c5fe:	80 35       	cpi	r24, 0x50	; 80
    c600:	91 05       	cpc	r25, r1
    c602:	31 f7       	brne	.-52     	; 0xc5d0 <victim_scan+0x15c>
    c604:	aa 85       	ldd	r26, Y+10	; 0x0a

				victimBuf[dir].value[victimBuf[dir].next] = mlx90614[dir].is;
			}

			victimBuf[dir].lowest = VICTIMBUF_UNUSED;
			for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
    c606:	bb 85       	ldd	r27, Y+11	; 0x0b
    c608:	14 96       	adiw	r26, 0x04	; 4
    c60a:	1c 92       	st	X, r1
			{
				if((victimBuf[dir].value[j] < victimBuf[dir].lowest) && (victimBuf[dir].value[j] != VICTIMBUF_UNUSED))
					victimBuf[dir].lowest = victimBuf[dir].value[j];
			}

			victimBuf[dir].highest = -VICTIMBUF_UNUSED;
    c60c:	1e 92       	st	-X, r1
    c60e:	13 97       	sbiw	r26, 0x03	; 3
    c610:	80 e0       	ldi	r24, 0x00	; 0
    c612:	90 e0       	ldi	r25, 0x00	; 0
    c614:	f1 01       	movw	r30, r2
    c616:	e8 0f       	add	r30, r24
    c618:	f9 1f       	adc	r31, r25
    c61a:	20 81       	ld	r18, Z
    c61c:	31 81       	ldd	r19, Z+1	; 0x01
    c61e:	ea 85       	ldd	r30, Y+10	; 0x0a
    c620:	fb 85       	ldd	r31, Y+11	; 0x0b
			for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
			{
				if((victimBuf[dir].value[j] > victimBuf[dir].highest) && (victimBuf[dir].value[j] != VICTIMBUF_UNUSED))
    c622:	43 81       	ldd	r20, Z+3	; 0x03
    c624:	54 81       	ldd	r21, Z+4	; 0x04
    c626:	42 17       	cp	r20, r18
    c628:	53 07       	cpc	r21, r19
    c62a:	54 f4       	brge	.+20     	; 0xc640 <victim_scan+0x1cc>
    c62c:	2f 3f       	cpi	r18, 0xFF	; 255
    c62e:	ff e7       	ldi	r31, 0x7F	; 127
    c630:	3f 07       	cpc	r19, r31
    c632:	31 f0       	breq	.+12     	; 0xc640 <victim_scan+0x1cc>
    c634:	aa 85       	ldd	r26, Y+10	; 0x0a
    c636:	bb 85       	ldd	r27, Y+11	; 0x0b
    c638:	14 96       	adiw	r26, 0x04	; 4
    c63a:	3c 93       	st	X, r19
					victimBuf[dir].highest = victimBuf[dir].value[j];
    c63c:	2e 93       	st	-X, r18
    c63e:	13 97       	sbiw	r26, 0x03	; 3
    c640:	02 96       	adiw	r24, 0x02	; 2
    c642:	80 35       	cpi	r24, 0x50	; 80
    c644:	91 05       	cpc	r25, r1
    c646:	31 f7       	brne	.-52     	; 0xc614 <victim_scan+0x1a0>
    c648:	0f 5f       	subi	r16, 0xFF	; 255
				if((victimBuf[dir].value[j] < victimBuf[dir].lowest) && (victimBuf[dir].value[j] != VICTIMBUF_UNUSED))
					victimBuf[dir].lowest = victimBuf[dir].value[j];
			}

			victimBuf[dir].highest = -VICTIMBUF_UNUSED;
			for(uint8_t j = 0; j < VICTIMBUFFER_SIZE; j++)
    c64a:	1f 4f       	sbci	r17, 0xFF	; 255
    c64c:	ed 81       	ldd	r30, Y+5	; 0x05
    c64e:	fe 81       	ldd	r31, Y+6	; 0x06
    c650:	34 96       	adiw	r30, 0x04	; 4
    c652:	fe 83       	std	Y+6, r31	; 0x06
    c654:	ed 83       	std	Y+5, r30	; 0x05
    c656:	4a 85       	ldd	r20, Y+10	; 0x0a
    c658:	5b 85       	ldd	r21, Y+11	; 0x0b
    c65a:	4b 5a       	subi	r20, 0xAB	; 171
    c65c:	5f 4f       	sbci	r21, 0xFF	; 255
    c65e:	5b 87       	std	Y+11, r21	; 0x0b
    c660:	4a 87       	std	Y+10, r20	; 0x0a
    c662:	55 e5       	ldi	r21, 0x55	; 85
    c664:	25 0e       	add	r2, r21
    c666:	31 1c       	adc	r3, r1
    c668:	8f 81       	ldd	r24, Y+7	; 0x07
    c66a:	98 85       	ldd	r25, Y+8	; 0x08
    c66c:	0c 96       	adiw	r24, 0x0c	; 12
    c66e:	98 87       	std	Y+8, r25	; 0x08
    c670:	8f 83       	std	Y+7, r24	; 0x07
    c672:	a9 81       	ldd	r26, Y+1	; 0x01
    c674:	ba 81       	ldd	r27, Y+2	; 0x02
    c676:	14 96       	adiw	r26, 0x04	; 4
    c678:	ba 83       	std	Y+2, r27	; 0x02
    c67a:	a9 83       	std	Y+1, r26	; 0x01
    c67c:	02 30       	cpi	r16, 0x02	; 2
    c67e:	11 05       	cpc	r17, r1
    c680:	09 f0       	breq	.+2      	; 0xc684 <victim_scan+0x210>
    c682:	1a cf       	rjmp	.-460    	; 0xc4b8 <victim_scan+0x44>

void victim_scan(void)
{
	if((maze_solve_state_path != VIC_DEPL_L) && (maze_solve_state_path != VIC_DEPL_R)) //No kit deployment
	{
		for(uint8_t dir = 0; dir < NUMBER_OF_MLX; dir++)
    c684:	2b 96       	adiw	r28, 0x0b	; 11
    c686:	e2 e1       	ldi	r30, 0x12	; 18
    c688:	0c 94 b7 6b 	jmp	0xd76e	; 0xd76e <__epilogue_restores__>

0000c68c <victim_BufGetMaxDiff>:
	return victimBuf[dir].value[victimBuf[dir].next] - victimBuf[dir].lowest;
}

int16_t victim_BufGetMaxDiff(uint8_t dir)
{
	return victimBuf[dir].highest - victimBuf[dir].lowest;
    c68c:	25 e5       	ldi	r18, 0x55	; 85
    c68e:	82 9f       	mul	r24, r18
    c690:	c0 01       	movw	r24, r0
    c692:	11 24       	eor	r1, r1
    c694:	8a 5d       	subi	r24, 0xDA	; 218
    c696:	98 4e       	sbci	r25, 0xE8	; 232
    c698:	dc 01       	movw	r26, r24
    c69a:	ad 5a       	subi	r26, 0xAD	; 173
    c69c:	bf 4f       	sbci	r27, 0xFF	; 255
    c69e:	fc 01       	movw	r30, r24
    c6a0:	ef 5a       	subi	r30, 0xAF	; 175
    c6a2:	ff 4f       	sbci	r31, 0xFF	; 255
    c6a4:	8d 91       	ld	r24, X+
    c6a6:	9c 91       	ld	r25, X
    c6a8:	20 81       	ld	r18, Z
    c6aa:	31 81       	ldd	r19, Z+1	; 0x01
}
    c6ac:	82 1b       	sub	r24, r18
    c6ae:	93 0b       	sbc	r25, r19
    c6b0:	08 95       	ret

0000c6b2 <u8g_DrawXBMP>:
    } while ( w > 0 );
  }
}

void u8g_DrawXBMP(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h, const u8g_pgm_uint8_t *bitmap)
{
    c6b2:	a3 e0       	ldi	r26, 0x03	; 3
    c6b4:	b0 e0       	ldi	r27, 0x00	; 0
    c6b6:	ef e5       	ldi	r30, 0x5F	; 95
    c6b8:	f3 e6       	ldi	r31, 0x63	; 99
    c6ba:	0c 94 9b 6b 	jmp	0xd736	; 0xd736 <__prologue_saves__>
    c6be:	9b 83       	std	Y+3, r25	; 0x03
    c6c0:	8a 83       	std	Y+2, r24	; 0x02
    c6c2:	36 2e       	mov	r3, r22
    c6c4:	14 2f       	mov	r17, r20
    c6c6:	32 2f       	mov	r19, r18
    c6c8:	70 2e       	mov	r7, r16
  u8g_uint_t b;
  b = w;
  b += 7;
  b >>= 3;
  
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    c6ca:	39 83       	std	Y+1, r19	; 0x01
    c6cc:	56 d0       	rcall	.+172    	; 0xc77a <u8g_IsBBXIntersection>
    c6ce:	39 81       	ldd	r19, Y+1	; 0x01
    c6d0:	88 23       	and	r24, r24
    c6d2:	09 f4       	brne	.+2      	; 0xc6d6 <u8g_DrawXBMP+0x24>
    c6d4:	4f c0       	rjmp	.+158    	; 0xc774 <u8g_DrawXBMP+0xc2>
    c6d6:	87 e0       	ldi	r24, 0x07	; 7

void u8g_DrawXBMP(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h, const u8g_pgm_uint8_t *bitmap)
{
  u8g_uint_t b;
  b = w;
  b += 7;
    c6d8:	83 0f       	add	r24, r19
    c6da:	86 95       	lsr	r24
  b >>= 3;
    c6dc:	86 95       	lsr	r24
    c6de:	86 95       	lsr	r24
    c6e0:	a8 2e       	mov	r10, r24
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    return;
  while( h > 0 )
  {
    u8g_DrawHXBMP(u8g, x, y, w, bitmap);
    bitmap += b;
    c6e2:	b1 2c       	mov	r11, r1
    c6e4:	71 0e       	add	r7, r17
    c6e6:	27 e0       	ldi	r18, 0x07	; 7
}

static void u8g_DrawHXBMP(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, const u8g_pgm_uint8_t *bitmap)
{
  uint8_t d;
  x+=7;
    c6e8:	32 0e       	add	r3, r18
    c6ea:	83 2f       	mov	r24, r19
    c6ec:	86 95       	lsr	r24
    c6ee:	86 95       	lsr	r24
    c6f0:	86 95       	lsr	r24
    c6f2:	88 2e       	mov	r8, r24
    c6f4:	91 2c       	mov	r9, r1
    c6f6:	e3 2d       	mov	r30, r3
    c6f8:	98 e0       	ldi	r25, 0x08	; 8
    c6fa:	89 9f       	mul	r24, r25
    c6fc:	e0 0d       	add	r30, r0
    c6fe:	11 24       	eor	r1, r1
    c700:	49 ef       	ldi	r20, 0xF9	; 249
    x+=8;
  }
  if ( w > 0 )
  {
    d = u8g_pgm_read(bitmap);
    x -= 7;
    c702:	64 2e       	mov	r6, r20
    c704:	6e 0e       	add	r6, r30
    c706:	53 2c       	mov	r5, r3
    c708:	53 0e       	add	r5, r19
    c70a:	37 70       	andi	r19, 0x07	; 7
    c70c:	43 2e       	mov	r4, r19
    c70e:	59 ef       	ldi	r21, 0xF9	; 249
    c710:	25 2e       	mov	r2, r21
    c712:	23 0e       	add	r2, r19
    c714:	2e 0e       	add	r2, r30
    c716:	17 15       	cp	r17, r7
  b += 7;
  b >>= 3;
  
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    return;
  while( h > 0 )
    c718:	69 f1       	breq	.+90     	; 0xc774 <u8g_DrawXBMP+0xc2>
    c71a:	67 01       	movw	r12, r14
    c71c:	33 2d       	mov	r19, r3
}

static void u8g_DrawHXBMP(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, const u8g_pgm_uint8_t *bitmap)
{
  uint8_t d;
  x+=7;
    c71e:	85 2d       	mov	r24, r5
    c720:	83 1b       	sub	r24, r19
    c722:	88 30       	cpi	r24, 0x08	; 8
  while( w >= 8 )
    c724:	80 f0       	brcs	.+32     	; 0xc746 <u8g_DrawXBMP+0x94>
    c726:	f6 01       	movw	r30, r12
  {
    u8g_Draw8Pixel(u8g, x, y, 2, u8g_pgm_read(bitmap));
    c728:	04 91       	lpm	r16, Z
    c72a:	22 e0       	ldi	r18, 0x02	; 2
    c72c:	41 2f       	mov	r20, r17
    c72e:	63 2f       	mov	r22, r19
    c730:	8a 81       	ldd	r24, Y+2	; 0x02
    c732:	9b 81       	ldd	r25, Y+3	; 0x03
    c734:	39 83       	std	Y+1, r19	; 0x01
    c736:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <u8g_Draw8Pixel>
    c73a:	ff ef       	ldi	r31, 0xFF	; 255
    bitmap++;
    c73c:	cf 1a       	sub	r12, r31
    c73e:	df 0a       	sbc	r13, r31
    c740:	39 81       	ldd	r19, Y+1	; 0x01
    w-= 8;
    x+=8;
    c742:	38 5f       	subi	r19, 0xF8	; 248
    c744:	ec cf       	rjmp	.-40     	; 0xc71e <u8g_DrawXBMP+0x6c>
    c746:	f7 01       	movw	r30, r14
    c748:	e8 0d       	add	r30, r8
    c74a:	f9 1d       	adc	r31, r9
    c74c:	44 20       	and	r4, r4
  }
  if ( w > 0 )
    c74e:	71 f0       	breq	.+28     	; 0xc76c <u8g_DrawXBMP+0xba>
    c750:	c4 90       	lpm	r12, Z
  {
    d = u8g_pgm_read(bitmap);
    c752:	d6 2c       	mov	r13, r6
    x -= 7;
    c754:	c0 fe       	sbrs	r12, 0
    do
    {
      if ( d & 1 )
    c756:	06 c0       	rjmp	.+12     	; 0xc764 <u8g_DrawXBMP+0xb2>
    c758:	41 2f       	mov	r20, r17
        u8g_DrawPixel(u8g, x, y);
    c75a:	6d 2d       	mov	r22, r13
    c75c:	8a 81       	ldd	r24, Y+2	; 0x02
    c75e:	9b 81       	ldd	r25, Y+3	; 0x03
    c760:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    c764:	d3 94       	inc	r13
      x++;
    c766:	c6 94       	lsr	r12
      w--;
      d >>= 1;      
    c768:	2d 10       	cpse	r2, r13
    } while ( w > 0 );
    c76a:	f4 cf       	rjmp	.-24     	; 0xc754 <u8g_DrawXBMP+0xa2>
    c76c:	ea 0c       	add	r14, r10
  if ( u8g_IsBBXIntersection(u8g, x, y, w, h) == 0 )
    return;
  while( h > 0 )
  {
    u8g_DrawHXBMP(u8g, x, y, w, bitmap);
    bitmap += b;
    c76e:	fb 1c       	adc	r15, r11
    c770:	1f 5f       	subi	r17, 0xFF	; 255
    y++;
    c772:	d1 cf       	rjmp	.-94     	; 0xc716 <u8g_DrawXBMP+0x64>
    c774:	23 96       	adiw	r28, 0x03	; 3
    h--;
  }
}
    c776:	e2 e1       	ldi	r30, 0x12	; 18
    c778:	fa c7       	rjmp	.+4084   	; 0xd76e <__epilogue_restores__>

0000c77a <u8g_IsBBXIntersection>:
  }
}


uint8_t u8g_IsBBXIntersection(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t w, u8g_uint_t h)
{
    c77a:	0f 93       	push	r16
    c77c:	fc 01       	movw	r30, r24
  register u8g_uint_t tmp;
  tmp = y;
  tmp += h;
    c77e:	01 50       	subi	r16, 0x01	; 1
  tmp--;
    c780:	04 0f       	add	r16, r20
  if ( u8g_is_intersection_decision_tree(u8g->current_page.y0, u8g->current_page.y1, y, tmp) == 0 )
    c782:	84 a9       	ldd	r24, Z+52	; 0x34
//static uint8_t u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1) U8G_ALWAYS_INLINE;
static uint8_t U8G_ALWAYS_INLINE u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1) 
{
  /* surprisingly the macro leads to larger code */
  /* return U8G_IS_INTERSECTION_MACRO(a0,a1,v0,v1); */
  if ( v0 <= a1 )
    c784:	96 a9       	ldd	r25, Z+54	; 0x36
    c786:	94 17       	cp	r25, r20
    c788:	18 f0       	brcs	.+6      	; 0xc790 <u8g_IsBBXIntersection+0x16>
  {
    if ( v1 >= a0 )
    c78a:	08 17       	cp	r16, r24
    c78c:	28 f4       	brcc	.+10     	; 0xc798 <u8g_IsBBXIntersection+0x1e>
    c78e:	02 c0       	rjmp	.+4      	; 0xc794 <u8g_IsBBXIntersection+0x1a>
      }
    }
  }
  else
  {
    if ( v1 >= a0 )
    c790:	08 17       	cp	r16, r24
    c792:	50 f0       	brcs	.+20     	; 0xc7a8 <u8g_IsBBXIntersection+0x2e>
    {
      if ( v0 > v1 )
    c794:	04 17       	cp	r16, r20
    c796:	40 f4       	brcc	.+16     	; 0xc7a8 <u8g_IsBBXIntersection+0x2e>
  tmp--;
  if ( u8g_is_intersection_decision_tree(u8g->current_page.y0, u8g->current_page.y1, y, tmp) == 0 )
    return 0; 
  
  tmp = x;
  tmp += w;
    c798:	21 50       	subi	r18, 0x01	; 1
  tmp--;
    c79a:	26 0f       	add	r18, r22
  return u8g_is_intersection_decision_tree(u8g->current_page.x0, u8g->current_page.x1, x, tmp);
    c79c:	83 a9       	ldd	r24, Z+51	; 0x33
//static uint8_t u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1) U8G_ALWAYS_INLINE;
static uint8_t U8G_ALWAYS_INLINE u8g_is_intersection_decision_tree(u8g_uint_t a0, u8g_uint_t a1, u8g_uint_t v0, u8g_uint_t v1) 
{
  /* surprisingly the macro leads to larger code */
  /* return U8G_IS_INTERSECTION_MACRO(a0,a1,v0,v1); */
  if ( v0 <= a1 )
    c79e:	95 a9       	ldd	r25, Z+53	; 0x35
    c7a0:	96 17       	cp	r25, r22
    c7a2:	20 f4       	brcc	.+8      	; 0xc7ac <u8g_IsBBXIntersection+0x32>
      }
    }
  }
  else
  {
    if ( v1 >= a0 )
    c7a4:	28 17       	cp	r18, r24
    c7a6:	20 f4       	brcc	.+8      	; 0xc7b0 <u8g_IsBBXIntersection+0x36>
  register u8g_uint_t tmp;
  tmp = y;
  tmp += h;
  tmp--;
  if ( u8g_is_intersection_decision_tree(u8g->current_page.y0, u8g->current_page.y1, y, tmp) == 0 )
    return 0; 
    c7a8:	80 e0       	ldi	r24, 0x00	; 0
    c7aa:	07 c0       	rjmp	.+14     	; 0xc7ba <u8g_IsBBXIntersection+0x40>
{
  /* surprisingly the macro leads to larger code */
  /* return U8G_IS_INTERSECTION_MACRO(a0,a1,v0,v1); */
  if ( v0 <= a1 )
  {
    if ( v1 >= a0 )
    c7ac:	28 17       	cp	r18, r24
    c7ae:	20 f4       	brcc	.+8      	; 0xc7b8 <u8g_IsBBXIntersection+0x3e>
  }
  else
  {
    if ( v1 >= a0 )
    {
      if ( v0 > v1 )
    c7b0:	81 e0       	ldi	r24, 0x01	; 1
    c7b2:	26 17       	cp	r18, r22
    c7b4:	10 f0       	brcs	.+4      	; 0xc7ba <u8g_IsBBXIntersection+0x40>
    c7b6:	f8 cf       	rjmp	.-16     	; 0xc7a8 <u8g_IsBBXIntersection+0x2e>
  /* return U8G_IS_INTERSECTION_MACRO(a0,a1,v0,v1); */
  if ( v0 <= a1 )
  {
    if ( v1 >= a0 )
    {
      return 1;
    c7b8:	81 e0       	ldi	r24, 0x01	; 1
  
  tmp = x;
  tmp += w;
  tmp--;
  return u8g_is_intersection_decision_tree(u8g->current_page.x0, u8g->current_page.x1, x, tmp);
}
    c7ba:	0f 91       	pop	r16
    c7bc:	08 95       	ret

0000c7be <u8g_get_avr_io_ptr>:
#endif
#endif
};

static volatile uint8_t *u8g_get_avr_io_ptr(const IO_PTR *base, uint8_t offset)
{
    c7be:	a2 e0       	ldi	r26, 0x02	; 2
    c7c0:	b0 e0       	ldi	r27, 0x00	; 0
    c7c2:	e4 ee       	ldi	r30, 0xE4	; 228
    c7c4:	f3 e6       	ldi	r31, 0x63	; 99
    c7c6:	c7 c7       	rjmp	.+3982   	; 0xd756 <__prologue_saves__+0x20>
    c7c8:	86 0f       	add	r24, r22
  volatile uint8_t * tmp;
  base += offset;
    c7ca:	91 1d       	adc	r25, r1
    c7cc:	86 0f       	add	r24, r22
    c7ce:	91 1d       	adc	r25, r1
    c7d0:	42 e0       	ldi	r20, 0x02	; 2
  memcpy_P(&tmp, base, sizeof(volatile uint8_t * PROGMEM));
    c7d2:	50 e0       	ldi	r21, 0x00	; 0
    c7d4:	bc 01       	movw	r22, r24
    c7d6:	ce 01       	movw	r24, r28
    c7d8:	01 96       	adiw	r24, 0x01	; 1
    c7da:	0e 94 09 6c 	call	0xd812	; 0xd812 <memcpy_P>
    c7de:	89 81       	ldd	r24, Y+1	; 0x01
  return tmp; 
}
    c7e0:	9a 81       	ldd	r25, Y+2	; 0x02
    c7e2:	22 96       	adiw	r28, 0x02	; 2
    c7e4:	e2 e0       	ldi	r30, 0x02	; 2
    c7e6:	d3 c7       	rjmp	.+4006   	; 0xd78e <__epilogue_restores__+0x20>

0000c7e8 <u8g_Pin>:
uint8_t u8g_Pin(uint8_t port, uint8_t bitpos)
{
  port <<= 3;
  port += bitpos;
  return port;
}
    c7e8:	98 e0       	ldi	r25, 0x08	; 8
    c7ea:	89 9f       	mul	r24, r25
    c7ec:	60 0d       	add	r22, r0
    c7ee:	11 24       	eor	r1, r1
    c7f0:	86 2f       	mov	r24, r22
    c7f2:	08 95       	ret

0000c7f4 <u8g_SetPinOutput>:
  return tmp; 
}

/* set direction to output of the specified pin (internal pin number) */
void u8g_SetPinOutput(uint8_t internal_pin_number)
{
    c7f4:	cf 93       	push	r28
    c7f6:	c8 2f       	mov	r28, r24
  *u8g_get_avr_io_ptr(u8g_avr_ddr_P, internal_pin_number>>3) |= _BV(internal_pin_number&7);
    c7f8:	68 2f       	mov	r22, r24
    c7fa:	66 95       	lsr	r22
    c7fc:	66 95       	lsr	r22
    c7fe:	66 95       	lsr	r22
    c800:	87 ec       	ldi	r24, 0xC7	; 199
    c802:	9c e2       	ldi	r25, 0x2C	; 44
    c804:	dc df       	rcall	.-72     	; 0xc7be <u8g_get_avr_io_ptr>
    c806:	fc 01       	movw	r30, r24
    c808:	90 81       	ld	r25, Z
    c80a:	c7 70       	andi	r28, 0x07	; 7
    c80c:	21 e0       	ldi	r18, 0x01	; 1
    c80e:	30 e0       	ldi	r19, 0x00	; 0
    c810:	01 c0       	rjmp	.+2      	; 0xc814 <u8g_SetPinOutput+0x20>
    c812:	22 0f       	add	r18, r18
    c814:	ca 95       	dec	r28
    c816:	ea f7       	brpl	.-6      	; 0xc812 <u8g_SetPinOutput+0x1e>
    c818:	92 2b       	or	r25, r18
    c81a:	90 83       	st	Z, r25
    c81c:	cf 91       	pop	r28
}
    c81e:	08 95       	ret

0000c820 <u8g_SetPinLevel>:
{
  *u8g_get_avr_io_ptr(u8g_avr_ddr_P, internal_pin_number>>3) &= ~_BV(internal_pin_number&7);
}

void u8g_SetPinLevel(uint8_t internal_pin_number, uint8_t level)
{
    c820:	cf 93       	push	r28
    c822:	df 93       	push	r29
    c824:	c8 2f       	mov	r28, r24
    c826:	d6 2f       	mov	r29, r22
  volatile uint8_t * tmp = u8g_get_avr_io_ptr(u8g_avr_port_P, internal_pin_number>>3);
    c828:	68 2f       	mov	r22, r24
    c82a:	66 95       	lsr	r22
    c82c:	66 95       	lsr	r22
    c82e:	66 95       	lsr	r22
    c830:	87 eb       	ldi	r24, 0xB7	; 183
    c832:	9c e2       	ldi	r25, 0x2C	; 44
    c834:	c4 df       	rcall	.-120    	; 0xc7be <u8g_get_avr_io_ptr>
    c836:	fc 01       	movw	r30, r24
    c838:	c7 70       	andi	r28, 0x07	; 7
    c83a:	8f b7       	in	r24, 0x3f	; 63
  
  if ( level == 0 )
  {
    U8G_ATOMIC_AND(tmp, ~_BV(internal_pin_number&7));
    c83c:	d1 11       	cpse	r29, r1

void u8g_SetPinLevel(uint8_t internal_pin_number, uint8_t level)
{
  volatile uint8_t * tmp = u8g_get_avr_io_ptr(u8g_avr_port_P, internal_pin_number>>3);
  
  if ( level == 0 )
    c83e:	0c c0       	rjmp	.+24     	; 0xc858 <u8g_SetPinLevel+0x38>
    c840:	f8 94       	cli
  {
    U8G_ATOMIC_AND(tmp, ~_BV(internal_pin_number&7));
    c842:	90 81       	ld	r25, Z
    c844:	21 e0       	ldi	r18, 0x01	; 1
    c846:	30 e0       	ldi	r19, 0x00	; 0
    c848:	0c 2e       	mov	r0, r28
    c84a:	01 c0       	rjmp	.+2      	; 0xc84e <u8g_SetPinLevel+0x2e>
    c84c:	22 0f       	add	r18, r18
    c84e:	0a 94       	dec	r0
    c850:	ea f7       	brpl	.-6      	; 0xc84c <u8g_SetPinLevel+0x2c>
    c852:	20 95       	com	r18
    c854:	92 23       	and	r25, r18
    c856:	09 c0       	rjmp	.+18     	; 0xc86a <u8g_SetPinLevel+0x4a>
    c858:	f8 94       	cli
   // *tmp &= ~_BV(internal_pin_number&7);
  }
  else
  {
    U8G_ATOMIC_OR(tmp, _BV(internal_pin_number&7));
    c85a:	90 81       	ld	r25, Z
    c85c:	21 e0       	ldi	r18, 0x01	; 1
    c85e:	30 e0       	ldi	r19, 0x00	; 0
    c860:	01 c0       	rjmp	.+2      	; 0xc864 <u8g_SetPinLevel+0x44>
    c862:	22 0f       	add	r18, r18
    c864:	ca 95       	dec	r28
    c866:	ea f7       	brpl	.-6      	; 0xc862 <u8g_SetPinLevel+0x42>
    c868:	92 2b       	or	r25, r18
    c86a:	90 83       	st	Z, r25
    c86c:	8f bf       	out	0x3f, r24	; 63
    c86e:	df 91       	pop	r29
    //*tmp |= _BV(internal_pin_number&7);
  }
  
}
    c870:	cf 91       	pop	r28
    c872:	08 95       	ret

0000c874 <u8g_SetPIOutput>:
#if defined(U8G_WITH_PINLIST)

void u8g_SetPIOutput(u8g_t *u8g, uint8_t pi)
{
  uint8_t pin;
  pin = u8g->pin_list[pi];
    c874:	86 0f       	add	r24, r22
    c876:	91 1d       	adc	r25, r1
    c878:	fc 01       	movw	r30, r24
    c87a:	83 a1       	ldd	r24, Z+35	; 0x23
  if ( pin != U8G_PIN_NONE )
    c87c:	8f 3f       	cpi	r24, 0xFF	; 255
    c87e:	09 f0       	breq	.+2      	; 0xc882 <u8g_SetPIOutput+0xe>
    u8g_SetPinOutput(pin);
    c880:	b9 cf       	rjmp	.-142    	; 0xc7f4 <u8g_SetPinOutput>
    c882:	08 95       	ret

0000c884 <u8g_SetPILevel>:
}

void u8g_SetPILevel(u8g_t *u8g, uint8_t pi, uint8_t level)
{
  uint8_t pin;
  pin = u8g->pin_list[pi];
    c884:	86 0f       	add	r24, r22
    c886:	91 1d       	adc	r25, r1
    c888:	fc 01       	movw	r30, r24
    c88a:	83 a1       	ldd	r24, Z+35	; 0x23
  if ( pin != U8G_PIN_NONE )
    c88c:	8f 3f       	cpi	r24, 0xFF	; 255
    c88e:	11 f0       	breq	.+4      	; 0xc894 <u8g_SetPILevel+0x10>
    u8g_SetPinLevel(pin, level);
    c890:	64 2f       	mov	r22, r20
    c892:	c6 cf       	rjmp	.-116    	; 0xc820 <u8g_SetPinLevel>
    c894:	08 95       	ret

0000c896 <u8g_dev_st7920_128x64_fn>:
  U8G_ESC_CS(0),             /* disable chip */
  U8G_ESC_END                /* end of sequence */
};

uint8_t u8g_dev_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
    c896:	a0 e0       	ldi	r26, 0x00	; 0
    c898:	b0 e0       	ldi	r27, 0x00	; 0
    c89a:	e0 e5       	ldi	r30, 0x50	; 80
    c89c:	f4 e6       	ldi	r31, 0x64	; 100
    c89e:	52 c7       	rjmp	.+3748   	; 0xd744 <__prologue_saves__+0xe>
    c8a0:	8c 01       	movw	r16, r24
    c8a2:	eb 01       	movw	r28, r22
    c8a4:	a4 2e       	mov	r10, r20
    c8a6:	69 01       	movw	r12, r18
    c8a8:	8a e0       	ldi	r24, 0x0A	; 10
  switch(msg)
    c8aa:	48 17       	cp	r20, r24
    c8ac:	a1 f0       	breq	.+40     	; 0xc8d6 <u8g_dev_st7920_128x64_fn+0x40>
    c8ae:	e5 e1       	ldi	r30, 0x15	; 21
    c8b0:	4e 13       	cpse	r20, r30
    c8b2:	49 c0       	rjmp	.+146    	; 0xc946 <u8g_dev_st7920_128x64_fn+0xb0>
    c8b4:	ea 80       	ldd	r14, Y+2	; 0x02
      break;
    case U8G_DEV_MSG_PAGE_NEXT:
      {
        uint8_t y, i;
        uint8_t *ptr;
        u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
    c8b6:	fb 80       	ldd	r15, Y+3	; 0x03
    c8b8:	40 e0       	ldi	r20, 0x00	; 0
        
        u8g_SetAddress(u8g, dev, 0);           /* cmd mode */
    c8ba:	c8 01       	movw	r24, r16
    c8bc:	a8 d3       	rcall	.+1872   	; 0xd00e <u8g_SetAddress>
    c8be:	41 e0       	ldi	r20, 0x01	; 1
    c8c0:	be 01       	movw	r22, r28
        u8g_SetChipSelect(u8g, dev, 1);
    c8c2:	c8 01       	movw	r24, r16
    c8c4:	84 d3       	rcall	.+1800   	; 0xcfce <u8g_SetChipSelect>
    c8c6:	f7 01       	movw	r30, r14
    c8c8:	b2 80       	ldd	r11, Z+2	; 0x02
    c8ca:	e6 80       	ldd	r14, Z+6	; 0x06
        y = pb->p.page_y0;
    c8cc:	f7 80       	ldd	r15, Z+7	; 0x07
    c8ce:	88 e0       	ldi	r24, 0x08	; 8
        ptr = pb->buf;
    c8d0:	98 2e       	mov	r9, r24
    c8d2:	9b 0c       	add	r9, r11
    c8d4:	09 c0       	rjmp	.+18     	; 0xc8e8 <u8g_dev_st7920_128x64_fn+0x52>
    c8d6:	43 e0       	ldi	r20, 0x03	; 3
    c8d8:	c8 01       	movw	r24, r16
    c8da:	6f d3       	rcall	.+1758   	; 0xcfba <u8g_InitCom>
uint8_t u8g_dev_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
  switch(msg)
  {
    case U8G_DEV_MSG_INIT:
      u8g_InitCom(u8g, dev, U8G_SPI_CLK_CYCLE_400NS);
    c8dc:	47 ed       	ldi	r20, 0xD7	; 215
    c8de:	5c e2       	ldi	r21, 0x2C	; 44
    c8e0:	be 01       	movw	r22, r28
    c8e2:	c8 01       	movw	r24, r16
      u8g_WriteEscSeqP(u8g, dev, u8g_dev_st7920_128x64_init_seq);
    c8e4:	b0 d3       	rcall	.+1888   	; 0xd046 <u8g_WriteEscSeqP>
    c8e6:	2f c0       	rjmp	.+94     	; 0xc946 <u8g_dev_st7920_128x64_fn+0xb0>
    c8e8:	40 e0       	ldi	r20, 0x00	; 0
    c8ea:	be 01       	movw	r22, r28
    c8ec:	c8 01       	movw	r24, r16
    c8ee:	8f d3       	rcall	.+1822   	; 0xd00e <u8g_SetAddress>
      break;
    c8f0:	4e e3       	ldi	r20, 0x3E	; 62
        u8g_SetChipSelect(u8g, dev, 1);
        y = pb->p.page_y0;
        ptr = pb->buf;
        for( i = 0; i < 8; i ++ )
        {
          u8g_SetAddress(u8g, dev, 0);           /* cmd mode */
    c8f2:	be 01       	movw	r22, r28
    c8f4:	c8 01       	movw	r24, r16
    c8f6:	95 d3       	rcall	.+1834   	; 0xd022 <u8g_WriteByte>
    c8f8:	ff e1       	ldi	r31, 0x1F	; 31
    c8fa:	fb 15       	cp	r31, r11
          u8g_WriteByte(u8g, dev, 0x03e );      /* enable extended mode */
    c8fc:	38 f0       	brcs	.+14     	; 0xc90c <u8g_dev_st7920_128x64_fn+0x76>
    c8fe:	4b 2d       	mov	r20, r11
    c900:	40 68       	ori	r20, 0x80	; 128
    c902:	be 01       	movw	r22, r28
    c904:	c8 01       	movw	r24, r16

          if ( y < 32 )
    c906:	8d d3       	rcall	.+1818   	; 0xd022 <u8g_WriteByte>
    c908:	40 e8       	ldi	r20, 0x80	; 128
    c90a:	07 c0       	rjmp	.+14     	; 0xc91a <u8g_dev_st7920_128x64_fn+0x84>
          {
                  u8g_WriteByte(u8g, dev, 0x080 | y );      /* y pos  */
    c90c:	40 ee       	ldi	r20, 0xE0	; 224
    c90e:	4b 0d       	add	r20, r11
    c910:	40 68       	ori	r20, 0x80	; 128
    c912:	be 01       	movw	r22, r28
    c914:	c8 01       	movw	r24, r16
    c916:	85 d3       	rcall	.+1802   	; 0xd022 <u8g_WriteByte>
                  u8g_WriteByte(u8g, dev, 0x080  );      /* set x pos to 0*/
    c918:	48 e8       	ldi	r20, 0x88	; 136
    c91a:	be 01       	movw	r22, r28
    c91c:	c8 01       	movw	r24, r16
    c91e:	81 d3       	rcall	.+1794   	; 0xd022 <u8g_WriteByte>
          }
          else
          {
                  u8g_WriteByte(u8g, dev, 0x080 | (y-32) );      /* y pos  */
    c920:	41 e0       	ldi	r20, 0x01	; 1
    c922:	be 01       	movw	r22, r28
    c924:	c8 01       	movw	r24, r16
    c926:	73 d3       	rcall	.+1766   	; 0xd00e <u8g_SetAddress>
    c928:	97 01       	movw	r18, r14
                  u8g_WriteByte(u8g, dev, 0x080 | 8);      /* set x pos to 64*/
    c92a:	40 e1       	ldi	r20, 0x10	; 16
    c92c:	be 01       	movw	r22, r28
    c92e:	c8 01       	movw	r24, r16
    c930:	82 d3       	rcall	.+1796   	; 0xd036 <u8g_WriteSequence>
    c932:	80 e1       	ldi	r24, 0x10	; 16
          }
          
          u8g_SetAddress(u8g, dev, 1);                  /* data mode */
    c934:	e8 0e       	add	r14, r24
    c936:	f1 1c       	adc	r15, r1
    c938:	b3 94       	inc	r11
    c93a:	b9 10       	cpse	r11, r9
    c93c:	d5 cf       	rjmp	.-86     	; 0xc8e8 <u8g_dev_st7920_128x64_fn+0x52>
          u8g_WriteSequence(u8g, dev, WIDTH/8, ptr);
    c93e:	40 e0       	ldi	r20, 0x00	; 0
    c940:	be 01       	movw	r22, r28
    c942:	c8 01       	movw	r24, r16
    c944:	44 d3       	rcall	.+1672   	; 0xcfce <u8g_SetChipSelect>
    c946:	96 01       	movw	r18, r12
    c948:	4a 2d       	mov	r20, r10
          ptr += WIDTH/8;
    c94a:	be 01       	movw	r22, r28
    c94c:	c8 01       	movw	r24, r16
    c94e:	f7 d1       	rcall	.+1006   	; 0xcd3e <u8g_dev_pb8h1_base_fn>
          y++;
    c950:	cd b7       	in	r28, 0x3d	; 61
        
        u8g_SetAddress(u8g, dev, 0);           /* cmd mode */
        u8g_SetChipSelect(u8g, dev, 1);
        y = pb->p.page_y0;
        ptr = pb->buf;
        for( i = 0; i < 8; i ++ )
    c952:	de b7       	in	r29, 0x3e	; 62
    c954:	eb e0       	ldi	r30, 0x0B	; 11
          u8g_SetAddress(u8g, dev, 1);                  /* data mode */
          u8g_WriteSequence(u8g, dev, WIDTH/8, ptr);
          ptr += WIDTH/8;
          y++;
        }
        u8g_SetChipSelect(u8g, dev, 0);
    c956:	12 c7       	rjmp	.+3620   	; 0xd77c <__epilogue_restores__+0xe>

0000c958 <u8g_draw_ellipse_section>:
    ftp://pc.fk0.name/pub/books/programming/bezier-ellipse.pdf
    Foley, Computer Graphics, p 90
*/
static void u8g_draw_ellipse_section(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t x0, u8g_uint_t y0, uint8_t option) U8G_NOINLINE;
static void u8g_draw_ellipse_section(u8g_t *u8g, u8g_uint_t x, u8g_uint_t y, u8g_uint_t x0, u8g_uint_t y0, uint8_t option)
{
    c958:	df 92       	push	r13
    c95a:	ef 92       	push	r14
    c95c:	ff 92       	push	r15
    c95e:	0f 93       	push	r16
    c960:	1f 93       	push	r17
    c962:	cf 93       	push	r28
    c964:	df 93       	push	r29
    c966:	ec 01       	movw	r28, r24
    c968:	16 2f       	mov	r17, r22
    c96a:	f4 2e       	mov	r15, r20
    c96c:	d2 2e       	mov	r13, r18
    /* upper right */
    if ( option & U8G_DRAW_UPPER_RIGHT )
    c96e:	e0 fe       	sbrs	r14, 0
    c970:	06 c0       	rjmp	.+12     	; 0xc97e <u8g_draw_ellipse_section+0x26>
    {
      u8g_DrawPixel(u8g, x0 + x, y0 - y);
    c972:	40 2f       	mov	r20, r16
    c974:	4f 19       	sub	r20, r15
    c976:	62 2f       	mov	r22, r18
    c978:	61 0f       	add	r22, r17
    c97a:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    }
    
    /* upper left */
    if ( option & U8G_DRAW_UPPER_LEFT )
    c97e:	e1 fe       	sbrs	r14, 1
    c980:	07 c0       	rjmp	.+14     	; 0xc990 <u8g_draw_ellipse_section+0x38>
    {
      u8g_DrawPixel(u8g, x0 - x, y0 - y);
    c982:	40 2f       	mov	r20, r16
    c984:	4f 19       	sub	r20, r15
    c986:	6d 2d       	mov	r22, r13
    c988:	61 1b       	sub	r22, r17
    c98a:	ce 01       	movw	r24, r28
    c98c:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    }
    
    /* lower right */
    if ( option & U8G_DRAW_LOWER_RIGHT )
    c990:	e3 fe       	sbrs	r14, 3
    c992:	07 c0       	rjmp	.+14     	; 0xc9a2 <u8g_draw_ellipse_section+0x4a>
    {
      u8g_DrawPixel(u8g, x0 + x, y0 + y);
    c994:	40 2f       	mov	r20, r16
    c996:	4f 0d       	add	r20, r15
    c998:	6d 2d       	mov	r22, r13
    c99a:	61 0f       	add	r22, r17
    c99c:	ce 01       	movw	r24, r28
    c99e:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    }
    
    /* lower left */
    if ( option & U8G_DRAW_LOWER_LEFT )
    c9a2:	e2 fe       	sbrs	r14, 2
    c9a4:	07 c0       	rjmp	.+14     	; 0xc9b4 <u8g_draw_ellipse_section+0x5c>
    {
      u8g_DrawPixel(u8g, x0 - x, y0 + y);
    c9a6:	40 2f       	mov	r20, r16
    c9a8:	4f 0d       	add	r20, r15
    c9aa:	6d 2d       	mov	r22, r13
    c9ac:	61 1b       	sub	r22, r17
    c9ae:	ce 01       	movw	r24, r28
    c9b0:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    }
}
    c9b4:	cd b7       	in	r28, 0x3d	; 61
    c9b6:	de b7       	in	r29, 0x3e	; 62
    c9b8:	e7 e0       	ldi	r30, 0x07	; 7
    c9ba:	e4 c6       	rjmp	.+3528   	; 0xd784 <__epilogue_restores__+0x16>

0000c9bc <u8g_draw_ellipse>:

void u8g_draw_ellipse(u8g_t *u8g, u8g_uint_t x0, u8g_uint_t y0, u8g_uint_t rx, u8g_uint_t ry, uint8_t option)
{
    c9bc:	a0 e1       	ldi	r26, 0x10	; 16
    c9be:	b0 e0       	ldi	r27, 0x00	; 0
    c9c0:	e3 ee       	ldi	r30, 0xE3	; 227
    c9c2:	f4 e6       	ldi	r31, 0x64	; 100
    c9c4:	b8 c6       	rjmp	.+3440   	; 0xd736 <__prologue_saves__>
    c9c6:	9a 87       	std	Y+10, r25	; 0x0a
    c9c8:	89 87       	std	Y+9, r24	; 0x09
    c9ca:	16 2f       	mov	r17, r22
    c9cc:	f4 2e       	mov	r15, r20
    c9ce:	32 2f       	mov	r19, r18
    c9d0:	40 2e       	mov	r4, r16
    c9d2:	5e 2c       	mov	r5, r14
    c9d4:	c2 2e       	mov	r12, r18
  u8g_long_t err;
  u8g_long_t rxrx2;
  u8g_long_t ryry2;
  u8g_long_t stopx, stopy;
  
  rxrx2 = rx;
    c9d6:	d1 2c       	mov	r13, r1
    c9d8:	22 9f       	mul	r18, r18
  rxrx2 *= rx;
    c9da:	a0 01       	movw	r20, r0
    c9dc:	11 24       	eor	r1, r1
    c9de:	5e 83       	std	Y+6, r21	; 0x06
    c9e0:	4d 83       	std	Y+5, r20	; 0x05
    c9e2:	1a 01       	movw	r2, r20
  rxrx2 *= 2;
    c9e4:	22 0c       	add	r2, r2
    c9e6:	33 1c       	adc	r3, r3
    c9e8:	60 2f       	mov	r22, r16
  
  ryry2 = ry;
    c9ea:	70 e0       	ldi	r23, 0x00	; 0
    c9ec:	78 8b       	std	Y+16, r23	; 0x10
    c9ee:	6f 87       	std	Y+15, r22	; 0x0f
    c9f0:	00 9f       	mul	r16, r16
  ryry2 *= ry;
    c9f2:	c0 01       	movw	r24, r0
    c9f4:	11 24       	eor	r1, r1
    c9f6:	98 87       	std	Y+8, r25	; 0x08
    c9f8:	8f 83       	std	Y+7, r24	; 0x07
    c9fa:	88 0f       	add	r24, r24
  ryry2 *= 2;
    c9fc:	99 1f       	adc	r25, r25
    c9fe:	9a 83       	std	Y+2, r25	; 0x02
    ca00:	89 83       	std	Y+1, r24	; 0x01
    ca02:	81 e0       	ldi	r24, 0x01	; 1
  
  x = rx;
  y = 0;
  
  xchg = 1;
  xchg -= rx;
    ca04:	90 e0       	ldi	r25, 0x00	; 0
    ca06:	8c 19       	sub	r24, r12
    ca08:	9d 09       	sbc	r25, r13
    ca0a:	8c 19       	sub	r24, r12
  xchg -= rx;
    ca0c:	9d 09       	sbc	r25, r13
    ca0e:	86 9f       	mul	r24, r22
  xchg *= ry;
    ca10:	a0 01       	movw	r20, r0
    ca12:	87 9f       	mul	r24, r23
    ca14:	50 0d       	add	r21, r0
    ca16:	96 9f       	mul	r25, r22
    ca18:	50 0d       	add	r21, r0
    ca1a:	11 24       	eor	r1, r1
    ca1c:	46 9f       	mul	r20, r22
  xchg *= ry;
    ca1e:	f0 01       	movw	r30, r0
    ca20:	47 9f       	mul	r20, r23
    ca22:	f0 0d       	add	r31, r0
    ca24:	56 9f       	mul	r21, r22
    ca26:	f0 0d       	add	r31, r0
    ca28:	11 24       	eor	r1, r1
    ca2a:	fc 83       	std	Y+4, r31	; 0x04
    ca2c:	eb 83       	std	Y+3, r30	; 0x03
    ca2e:	49 81       	ldd	r20, Y+1	; 0x01
  ychg *= rx;
  
  err = 0;
  
  stopx = ryry2;
  stopx *= rx;
    ca30:	5a 81       	ldd	r21, Y+2	; 0x02
    ca32:	4c 9d       	mul	r20, r12
    ca34:	50 01       	movw	r10, r0
    ca36:	4d 9d       	mul	r20, r13
    ca38:	b0 0c       	add	r11, r0
    ca3a:	5c 9d       	mul	r21, r12
    ca3c:	b0 0c       	add	r11, r0
    ca3e:	11 24       	eor	r1, r1
    ca40:	61 2c       	mov	r6, r1
  stopy = 0;
    ca42:	71 2c       	mov	r7, r1
    ca44:	81 2c       	mov	r8, r1
  xchg *= ry;
  
  ychg = rx;
  ychg *= rx;
  
  err = 0;
    ca46:	91 2c       	mov	r9, r1
    ca48:	50 e0       	ldi	r21, 0x00	; 0
  ryry2 = ry;
  ryry2 *= ry;
  ryry2 *= 2;
  
  x = rx;
  y = 0;
    ca4a:	ed 81       	ldd	r30, Y+5	; 0x05
    ca4c:	fe 81       	ldd	r31, Y+6	; 0x06
    ca4e:	e6 0d       	add	r30, r6
    ca50:	f7 1d       	adc	r31, r7
    ca52:	fc 87       	std	Y+12, r31	; 0x0c
    ca54:	eb 87       	std	Y+11, r30	; 0x0b
    ca56:	a6 14       	cp	r10, r6
  
  stopx = ryry2;
  stopx *= rx;
  stopy = 0;
  
  while( stopx >= stopy )
    ca58:	b7 04       	cpc	r11, r7
    ca5a:	6c f1       	brlt	.+90     	; 0xcab6 <u8g_draw_ellipse+0xfa>
    ca5c:	e5 2c       	mov	r14, r5
  {
    u8g_draw_ellipse_section(u8g, x, y, x0, y0, option);
    ca5e:	0f 2d       	mov	r16, r15
    ca60:	21 2f       	mov	r18, r17
    ca62:	45 2f       	mov	r20, r21
    ca64:	63 2f       	mov	r22, r19
    ca66:	89 85       	ldd	r24, Y+9	; 0x09
    ca68:	9a 85       	ldd	r25, Y+10	; 0x0a
    ca6a:	3e 87       	std	Y+14, r19	; 0x0e
    ca6c:	5d 87       	std	Y+13, r21	; 0x0d
    ca6e:	74 df       	rcall	.-280    	; 0xc958 <u8g_draw_ellipse_section>
    ca70:	5d 85       	ldd	r21, Y+13	; 0x0d
    ca72:	5f 5f       	subi	r21, 0xFF	; 255
    y++;
    ca74:	62 0c       	add	r6, r2
    ca76:	73 1c       	adc	r7, r3
    stopy += rxrx2;
    ca78:	6b 85       	ldd	r22, Y+11	; 0x0b
    ca7a:	7c 85       	ldd	r23, Y+12	; 0x0c
    err += ychg;
    ca7c:	86 0e       	add	r8, r22
    ca7e:	97 1e       	adc	r9, r23
    ca80:	c4 01       	movw	r24, r8
    ca82:	88 0f       	add	r24, r24
    ychg += rxrx2;
    if ( 2*err+xchg > 0 )
    ca84:	99 1f       	adc	r25, r25
    ca86:	eb 81       	ldd	r30, Y+3	; 0x03
    ca88:	fc 81       	ldd	r31, Y+4	; 0x04
    ca8a:	8e 0f       	add	r24, r30
    ca8c:	9f 1f       	adc	r25, r31
    ca8e:	3e 85       	ldd	r19, Y+14	; 0x0e
    ca90:	18 16       	cp	r1, r24
    ca92:	19 06       	cpc	r1, r25
    ca94:	d4 f6       	brge	.-76     	; 0xca4a <u8g_draw_ellipse+0x8e>
    ca96:	31 50       	subi	r19, 0x01	; 1
    ca98:	69 81       	ldd	r22, Y+1	; 0x01
    {
      x--;
    ca9a:	7a 81       	ldd	r23, Y+2	; 0x02
      stopx -= ryry2;
    ca9c:	a6 1a       	sub	r10, r22
    ca9e:	b7 0a       	sbc	r11, r23
    caa0:	fc 01       	movw	r30, r24
    caa2:	e8 19       	sub	r30, r8
      err += xchg;
    caa4:	f9 09       	sbc	r31, r9
    caa6:	4f 01       	movw	r8, r30
    caa8:	8b 81       	ldd	r24, Y+3	; 0x03
    caaa:	9c 81       	ldd	r25, Y+4	; 0x04
      xchg += ryry2;      
    caac:	86 0f       	add	r24, r22
    caae:	97 1f       	adc	r25, r23
    cab0:	9c 83       	std	Y+4, r25	; 0x04
    cab2:	8b 83       	std	Y+3, r24	; 0x03
    cab4:	ca cf       	rjmp	.-108    	; 0xca4a <u8g_draw_ellipse+0x8e>
    cab6:	81 e0       	ldi	r24, 0x01	; 1
    cab8:	90 e0       	ldi	r25, 0x00	; 0
  
  xchg = ry;
  xchg *= ry;
  
  ychg = 1;
  ychg -= ry;
    caba:	2f 85       	ldd	r18, Y+15	; 0x0f
    cabc:	38 89       	ldd	r19, Y+16	; 0x10
    cabe:	82 1b       	sub	r24, r18
    cac0:	93 0b       	sbc	r25, r19
    cac2:	82 1b       	sub	r24, r18
    cac4:	93 0b       	sbc	r25, r19
  ychg -= ry;
    cac6:	8c 9d       	mul	r24, r12
    cac8:	90 01       	movw	r18, r0
  ychg *= rx;
    caca:	8d 9d       	mul	r24, r13
    cacc:	30 0d       	add	r19, r0
    cace:	9c 9d       	mul	r25, r12
    cad0:	30 0d       	add	r19, r0
    cad2:	11 24       	eor	r1, r1
    cad4:	2c 9d       	mul	r18, r12
    cad6:	40 01       	movw	r8, r0
  ychg *= rx;
    cad8:	2d 9d       	mul	r18, r13
    cada:	90 0c       	add	r9, r0
    cadc:	3c 9d       	mul	r19, r12
    cade:	90 0c       	add	r9, r0
    cae0:	11 24       	eor	r1, r1
    cae2:	4f 85       	ldd	r20, Y+15	; 0x0f
    cae4:	58 89       	ldd	r21, Y+16	; 0x10
  err = 0;
  
  stopx = 0;

  stopy = rxrx2;
  stopy *= ry;
    cae6:	24 9e       	mul	r2, r20
    cae8:	50 01       	movw	r10, r0
    caea:	25 9e       	mul	r2, r21
    caec:	b0 0c       	add	r11, r0
    caee:	34 9e       	mul	r3, r20
    caf0:	b0 0c       	add	r11, r0
    caf2:	11 24       	eor	r1, r1
    caf4:	c1 2c       	mov	r12, r1
    caf6:	d1 2c       	mov	r13, r1
  ychg *= rx;
  ychg *= rx;
  
  err = 0;
  
  stopx = 0;
    caf8:	1c 82       	std	Y+4, r1	; 0x04
    cafa:	1b 82       	std	Y+3, r1	; 0x03
  ychg -= ry;
  ychg -= ry;
  ychg *= rx;
  ychg *= rx;
  
  err = 0;
    cafc:	30 e0       	ldi	r19, 0x00	; 0
    cafe:	6f 80       	ldd	r6, Y+7	; 0x07
      err += xchg;
      xchg += ryry2;      
    }
  }

  x = 0;
    cb00:	78 84       	ldd	r7, Y+8	; 0x08
    cb02:	6c 0c       	add	r6, r12
    cb04:	7d 1c       	adc	r7, r13
    cb06:	ac 14       	cp	r10, r12
    cb08:	bd 04       	cpc	r11, r13

  stopy = rxrx2;
  stopy *= ry;
  

  while( stopx <= stopy )
    cb0a:	4c f1       	brlt	.+82     	; 0xcb5e <u8g_draw_ellipse+0x1a2>
    cb0c:	e5 2c       	mov	r14, r5
    cb0e:	0f 2d       	mov	r16, r15
  {
    u8g_draw_ellipse_section(u8g, x, y, x0, y0, option);
    cb10:	21 2f       	mov	r18, r17
    cb12:	44 2d       	mov	r20, r4
    cb14:	63 2f       	mov	r22, r19
    cb16:	89 85       	ldd	r24, Y+9	; 0x09
    cb18:	9a 85       	ldd	r25, Y+10	; 0x0a
    cb1a:	3e 87       	std	Y+14, r19	; 0x0e
    cb1c:	1d df       	rcall	.-454    	; 0xc958 <u8g_draw_ellipse_section>
    cb1e:	3e 85       	ldd	r19, Y+14	; 0x0e
    cb20:	3f 5f       	subi	r19, 0xFF	; 255
    cb22:	69 81       	ldd	r22, Y+1	; 0x01
    x++;
    cb24:	7a 81       	ldd	r23, Y+2	; 0x02
    cb26:	c6 0e       	add	r12, r22
    stopx += ryry2;
    cb28:	d7 1e       	adc	r13, r23
    cb2a:	8b 81       	ldd	r24, Y+3	; 0x03
    cb2c:	9c 81       	ldd	r25, Y+4	; 0x04
    cb2e:	86 0d       	add	r24, r6
    err += xchg;
    cb30:	97 1d       	adc	r25, r7
    cb32:	9c 83       	std	Y+4, r25	; 0x04
    cb34:	8b 83       	std	Y+3, r24	; 0x03
    cb36:	88 0f       	add	r24, r24
    cb38:	99 1f       	adc	r25, r25
    cb3a:	88 0d       	add	r24, r8
    xchg += ryry2;
    if ( 2*err+ychg > 0 )
    cb3c:	99 1d       	adc	r25, r9
    cb3e:	18 16       	cp	r1, r24
    cb40:	19 06       	cpc	r1, r25
    cb42:	ec f6       	brge	.-70     	; 0xcafe <u8g_draw_ellipse+0x142>
    cb44:	4a 94       	dec	r4
    cb46:	a2 18       	sub	r10, r2
    cb48:	b3 08       	sbc	r11, r3
    {
      y--;
    cb4a:	fc 01       	movw	r30, r24
      stopy -= rxrx2;
    cb4c:	4b 81       	ldd	r20, Y+3	; 0x03
    cb4e:	5c 81       	ldd	r21, Y+4	; 0x04
      err += ychg;
    cb50:	e4 1b       	sub	r30, r20
    cb52:	f5 0b       	sbc	r31, r21
    cb54:	fc 83       	std	Y+4, r31	; 0x04
    cb56:	eb 83       	std	Y+3, r30	; 0x03
    cb58:	82 0c       	add	r8, r2
    cb5a:	93 1c       	adc	r9, r3
    cb5c:	d0 cf       	rjmp	.-96     	; 0xcafe <u8g_draw_ellipse+0x142>
      ychg += rxrx2;
    cb5e:	60 96       	adiw	r28, 0x10	; 16
    cb60:	e2 e1       	ldi	r30, 0x12	; 18
    cb62:	05 c6       	rjmp	.+3082   	; 0xd76e <__epilogue_restores__>

0000cb64 <u8g_DrawEllipse>:
  }
  
}

void u8g_DrawEllipse(u8g_t *u8g, u8g_uint_t x0, u8g_uint_t y0, u8g_uint_t rx, u8g_uint_t ry, uint8_t option)
{
    cb64:	a0 e0       	ldi	r26, 0x00	; 0
    cb66:	b0 e0       	ldi	r27, 0x00	; 0
    cb68:	e7 eb       	ldi	r30, 0xB7	; 183
    cb6a:	f5 e6       	ldi	r31, 0x65	; 101
    cb6c:	ee c5       	rjmp	.+3036   	; 0xd74a <__prologue_saves__+0x14>
    cb6e:	ec 01       	movw	r28, r24
    cb70:	16 2f       	mov	r17, r22
    cb72:	f4 2e       	mov	r15, r20
    cb74:	d2 2e       	mov	r13, r18
    cb76:	c0 2e       	mov	r12, r16
    cb78:	81 e0       	ldi	r24, 0x01	; 1
  {
    u8g_uint_t rxp, rxp2;
    u8g_uint_t ryp, ryp2;
    
    rxp = rx;
    rxp++;
    cb7a:	82 0f       	add	r24, r18
    cb7c:	91 e0       	ldi	r25, 0x01	; 1
    rxp2 = rxp;
    rxp2 *= 2;

    ryp = ry;
    ryp++;
    cb7e:	90 0f       	add	r25, r16
    cb80:	09 2f       	mov	r16, r25
    ryp2 = ryp;
    ryp2 *= 2;
    cb82:	00 0f       	add	r16, r16
    cb84:	28 2f       	mov	r18, r24
    u8g_uint_t ryp, ryp2;
    
    rxp = rx;
    rxp++;
    rxp2 = rxp;
    rxp2 *= 2;
    cb86:	22 0f       	add	r18, r18
    cb88:	49 1b       	sub	r20, r25
    ryp = ry;
    ryp++;
    ryp2 = ryp;
    ryp2 *= 2;
    
    if ( u8g_IsBBXIntersection(u8g, x0-rxp, y0-ryp, rxp2, ryp2) == 0)
    cb8a:	68 1b       	sub	r22, r24
    cb8c:	ce 01       	movw	r24, r28
    cb8e:	f5 dd       	rcall	.-1046   	; 0xc77a <u8g_IsBBXIntersection>
    cb90:	88 23       	and	r24, r24
    cb92:	31 f0       	breq	.+12     	; 0xcba0 <u8g_DrawEllipse+0x3c>
    cb94:	0c 2d       	mov	r16, r12
    cb96:	2d 2d       	mov	r18, r13
      return;    
  }
  
  u8g_draw_ellipse(u8g, x0, y0, rx, ry, option);
    cb98:	4f 2d       	mov	r20, r15
    cb9a:	61 2f       	mov	r22, r17
    cb9c:	ce 01       	movw	r24, r28
    cb9e:	0e df       	rcall	.-484    	; 0xc9bc <u8g_draw_ellipse>
    cba0:	cd b7       	in	r28, 0x3d	; 61
    cba2:	de b7       	in	r29, 0x3e	; 62
    cba4:	e8 e0       	ldi	r30, 0x08	; 8
}
    cba6:	ed c5       	rjmp	.+3034   	; 0xd782 <__epilogue_restores__+0x14>

0000cba8 <u8g_DrawLine>:
*/

#include "u8g.h"

void u8g_DrawLine(u8g_t *u8g, u8g_uint_t x1, u8g_uint_t y1, u8g_uint_t x2, u8g_uint_t y2)
{
    cba8:	a0 e0       	ldi	r26, 0x00	; 0
    cbaa:	b0 e0       	ldi	r27, 0x00	; 0
    cbac:	e9 ed       	ldi	r30, 0xD9	; 217
    cbae:	f5 e6       	ldi	r31, 0x65	; 101
    cbb0:	ca c5       	rjmp	.+2964   	; 0xd746 <__prologue_saves__+0x10>
    cbb2:	ec 01       	movw	r28, r24
    cbb4:	16 2f       	mov	r17, r22
    cbb6:	f4 2e       	mov	r15, r20
    cbb8:	e2 2e       	mov	r14, r18
    cbba:	26 17       	cp	r18, r22

  uint8_t swapxy = 0;
  
  /* no BBX intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    cbbc:	18 f4       	brcc	.+6      	; 0xcbc4 <u8g_DrawLine+0x1c>
    cbbe:	c6 2e       	mov	r12, r22
    cbc0:	c2 1a       	sub	r12, r18
    cbc2:	02 c0       	rjmp	.+4      	; 0xcbc8 <u8g_DrawLine+0x20>
    cbc4:	c2 2e       	mov	r12, r18
    cbc6:	c6 1a       	sub	r12, r22
    cbc8:	0f 15       	cp	r16, r15
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    cbca:	18 f4       	brcc	.+6      	; 0xcbd2 <u8g_DrawLine+0x2a>
    cbcc:	df 2c       	mov	r13, r15
    cbce:	d0 1a       	sub	r13, r16
    cbd0:	02 c0       	rjmp	.+4      	; 0xcbd6 <u8g_DrawLine+0x2e>
    cbd2:	d0 2e       	mov	r13, r16
    cbd4:	df 18       	sub	r13, r15
    cbd6:	cd 14       	cp	r12, r13

  if ( dy > dx ) 
    cbd8:	28 f0       	brcs	.+10     	; 0xcbe4 <u8g_DrawLine+0x3c>
    cbda:	8d 2d       	mov	r24, r13
    cbdc:	dc 2c       	mov	r13, r12
    cbde:	c8 2e       	mov	r12, r24
    cbe0:	a1 2c       	mov	r10, r1
  u8g_uint_t x,y;
  u8g_uint_t dx, dy;
  u8g_int_t err;
  u8g_int_t ystep;

  uint8_t swapxy = 0;
    cbe2:	08 c0       	rjmp	.+16     	; 0xcbf4 <u8g_DrawLine+0x4c>
    cbe4:	8e 2d       	mov	r24, r14
    cbe6:	e0 2e       	mov	r14, r16
    cbe8:	08 2f       	mov	r16, r24
    cbea:	81 2f       	mov	r24, r17
    cbec:	1f 2d       	mov	r17, r15
    cbee:	f8 2e       	mov	r15, r24
    cbf0:	aa 24       	eor	r10, r10
  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;

  if ( dy > dx ) 
  {
    swapxy = 1;
    cbf2:	a3 94       	inc	r10
    cbf4:	e1 16       	cp	r14, r17
    tmp = dx; dx =dy; dy = tmp;
    tmp = x1; x1 =y1; y1 = tmp;
    tmp = x2; x2 =y2; y2 = tmp;
  }
  if ( x1 > x2 ) 
    cbf6:	30 f4       	brcc	.+12     	; 0xcc04 <u8g_DrawLine+0x5c>
    cbf8:	8f 2d       	mov	r24, r15
    cbfa:	f0 2e       	mov	r15, r16
  {
    tmp = x1; x1 =x2; x2 = tmp;
    tmp = y1; y1 =y2; y2 = tmp;
    cbfc:	08 2f       	mov	r16, r24
    cbfe:	81 2f       	mov	r24, r17
    cc00:	1e 2d       	mov	r17, r14
    cc02:	e8 2e       	mov	r14, r24
    cc04:	bd 2c       	mov	r11, r13
  }
  err = dx >> 1;
    cc06:	b6 94       	lsr	r11
    cc08:	f0 16       	cp	r15, r16
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    cc0a:	10 f4       	brcc	.+4      	; 0xcc10 <u8g_DrawLine+0x68>
    cc0c:	01 e0       	ldi	r16, 0x01	; 1
    cc0e:	0f c0       	rjmp	.+30     	; 0xcc2e <u8g_DrawLine+0x86>
    cc10:	0f ef       	ldi	r16, 0xFF	; 255
    cc12:	0d c0       	rjmp	.+26     	; 0xcc2e <u8g_DrawLine+0x86>
  y = y1;
  for( x = x1; x <= x2; x++ )
    cc14:	a1 10       	cpse	r10, r1
  {
    if ( swapxy == 0 ) 
    cc16:	0e c0       	rjmp	.+28     	; 0xcc34 <u8g_DrawLine+0x8c>
    cc18:	4f 2d       	mov	r20, r15
      u8g_DrawPixel(u8g, x, y); 
    cc1a:	61 2f       	mov	r22, r17
    cc1c:	ce 01       	movw	r24, r28
    else 
      u8g_DrawPixel(u8g, y, x); 
    cc1e:	0e 94 ae 1e 	call	0x3d5c	; 0x3d5c <u8g_DrawPixel>
    cc22:	bc 18       	sub	r11, r12
    err -= (uint8_t)dy;
    cc24:	b7 fe       	sbrs	r11, 7
    if ( err < 0 ) 
    cc26:	02 c0       	rjmp	.+4      	; 0xcc2c <u8g_DrawLine+0x84>
    cc28:	f0 0e       	add	r15, r16
    {
      y += (u8g_uint_t)ystep;
    cc2a:	bd 0c       	add	r11, r13
      err += (u8g_uint_t)dx;
    cc2c:	1f 5f       	subi	r17, 0xFF	; 255
    tmp = y1; y1 =y2; y2 = tmp;
  }
  err = dx >> 1;
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
  y = y1;
  for( x = x1; x <= x2; x++ )
    cc2e:	e1 16       	cp	r14, r17
    cc30:	88 f7       	brcc	.-30     	; 0xcc14 <u8g_DrawLine+0x6c>
    cc32:	03 c0       	rjmp	.+6      	; 0xcc3a <u8g_DrawLine+0x92>
    cc34:	41 2f       	mov	r20, r17
  {
    if ( swapxy == 0 ) 
      u8g_DrawPixel(u8g, x, y); 
    else 
      u8g_DrawPixel(u8g, y, x); 
    cc36:	6f 2d       	mov	r22, r15
    cc38:	f1 cf       	rjmp	.-30     	; 0xcc1c <u8g_DrawLine+0x74>
    cc3a:	cd b7       	in	r28, 0x3d	; 61
    {
      y += (u8g_uint_t)ystep;
      err += (u8g_uint_t)dx;
    }
  }
}
    cc3c:	de b7       	in	r29, 0x3e	; 62
    cc3e:	ea e0       	ldi	r30, 0x0A	; 10
    cc40:	9e c5       	rjmp	.+2876   	; 0xd77e <__epilogue_restores__+0x10>

0000cc42 <u8g_pb8h1_set_pixel>:
  u8g_pb_Clear(b);
}

/* limitation: total buffer must not exceed 256 bytes */
void u8g_pb8h1_set_pixel(u8g_pb_t *b, u8g_uint_t x, u8g_uint_t y, uint8_t color_index)
{
    cc42:	dc 01       	movw	r26, r24
//    return;
//  u8g_pb8h1_state_set_pixel(&s, color_index);
#else
  register uint8_t mask;
  u8g_uint_t tmp;
  uint8_t *ptr = b->buf;
    cc44:	16 96       	adiw	r26, 0x06	; 6
    cc46:	ed 91       	ld	r30, X+
    cc48:	fc 91       	ld	r31, X
    cc4a:	17 97       	sbiw	r26, 0x07	; 7
  
  y -= b->p.page_y0;
  tmp = b->width;
    cc4c:	15 96       	adiw	r26, 0x05	; 5
    cc4e:	8c 91       	ld	r24, X
    cc50:	15 97       	sbiw	r26, 0x05	; 5
  tmp >>= 3;
    cc52:	86 95       	lsr	r24
    cc54:	86 95       	lsr	r24
    cc56:	86 95       	lsr	r24
#else
  register uint8_t mask;
  u8g_uint_t tmp;
  uint8_t *ptr = b->buf;
  
  y -= b->p.page_y0;
    cc58:	12 96       	adiw	r26, 0x02	; 2
    cc5a:	9c 91       	ld	r25, X
    cc5c:	49 1b       	sub	r20, r25
  tmp = b->width;
  tmp >>= 3;
  tmp *= (uint8_t)y;
    cc5e:	48 9f       	mul	r20, r24
    cc60:	40 2d       	mov	r20, r0
    cc62:	11 24       	eor	r1, r1
  ptr += tmp;
    cc64:	e4 0f       	add	r30, r20
    cc66:	f1 1d       	adc	r31, r1
  
  mask = 0x080;
  mask >>= x & 7;
    cc68:	36 2f       	mov	r19, r22
    cc6a:	37 70       	andi	r19, 0x07	; 7
    cc6c:	80 e8       	ldi	r24, 0x80	; 128
    cc6e:	90 e0       	ldi	r25, 0x00	; 0
    cc70:	02 c0       	rjmp	.+4      	; 0xcc76 <u8g_pb8h1_set_pixel+0x34>
    cc72:	95 95       	asr	r25
    cc74:	87 95       	ror	r24
    cc76:	3a 95       	dec	r19
    cc78:	e2 f7       	brpl	.-8      	; 0xcc72 <u8g_pb8h1_set_pixel+0x30>
  x >>= 3;
    cc7a:	66 95       	lsr	r22
    cc7c:	66 95       	lsr	r22
    cc7e:	66 95       	lsr	r22
  ptr += x;
    cc80:	e6 0f       	add	r30, r22
    cc82:	f1 1d       	adc	r31, r1
    cc84:	30 81       	ld	r19, Z
  if ( color_index )
    cc86:	22 23       	and	r18, r18
    cc88:	11 f0       	breq	.+4      	; 0xcc8e <u8g_pb8h1_set_pixel+0x4c>
  {
    *ptr |= mask;
    cc8a:	83 2b       	or	r24, r19
    cc8c:	02 c0       	rjmp	.+4      	; 0xcc92 <u8g_pb8h1_set_pixel+0x50>
  }
  else
  {
    mask ^=0xff;
    cc8e:	80 95       	com	r24
    *ptr &= mask;
    cc90:	83 23       	and	r24, r19
    cc92:	80 83       	st	Z, r24
    cc94:	08 95       	ret

0000cc96 <u8g_pb8h1_SetPixel>:
#endif
}


void u8g_pb8h1_SetPixel(u8g_pb_t *b, const u8g_dev_arg_pixel_t * const arg_pixel)
{
    cc96:	fb 01       	movw	r30, r22
  if ( arg_pixel->y < b->p.page_y0 )
    cc98:	41 81       	ldd	r20, Z+1	; 0x01
    cc9a:	dc 01       	movw	r26, r24
    cc9c:	12 96       	adiw	r26, 0x02	; 2
    cc9e:	2c 91       	ld	r18, X
    cca0:	12 97       	sbiw	r26, 0x02	; 2
    cca2:	42 17       	cp	r20, r18
    cca4:	60 f0       	brcs	.+24     	; 0xccbe <u8g_pb8h1_SetPixel+0x28>
    return;
  if ( arg_pixel->y > b->p.page_y1 )
    cca6:	13 96       	adiw	r26, 0x03	; 3
    cca8:	2c 91       	ld	r18, X
    ccaa:	13 97       	sbiw	r26, 0x03	; 3
    ccac:	24 17       	cp	r18, r20
    ccae:	38 f0       	brcs	.+14     	; 0xccbe <u8g_pb8h1_SetPixel+0x28>
    return;
  if ( arg_pixel->x >= b->width )
    ccb0:	60 81       	ld	r22, Z
    ccb2:	15 96       	adiw	r26, 0x05	; 5
    ccb4:	2c 91       	ld	r18, X
    ccb6:	62 17       	cp	r22, r18
    ccb8:	10 f4       	brcc	.+4      	; 0xccbe <u8g_pb8h1_SetPixel+0x28>
    return;
  u8g_pb8h1_set_pixel(b, arg_pixel->x, arg_pixel->y, arg_pixel->color);
    ccba:	24 81       	ldd	r18, Z+4	; 0x04
    ccbc:	c2 cf       	rjmp	.-124    	; 0xcc42 <u8g_pb8h1_set_pixel>
    ccbe:	08 95       	ret

0000ccc0 <u8g_pb8h1_Set8PixelOpt2>:
    pixel <<= 1;
  } while( pixel != 0  );
}

void u8g_pb8h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
    ccc0:	cf 92       	push	r12
    ccc2:	df 92       	push	r13
    ccc4:	ff 92       	push	r15
    ccc6:	0f 93       	push	r16
    ccc8:	1f 93       	push	r17
    ccca:	cf 93       	push	r28
    cccc:	df 93       	push	r29
    ccce:	1f 92       	push	r1
    ccd0:	1f 92       	push	r1
    ccd2:	cd b7       	in	r28, 0x3d	; 61
    ccd4:	de b7       	in	r29, 0x3e	; 62
    ccd6:	8c 01       	movw	r16, r24
    ccd8:	6b 01       	movw	r12, r22
  register uint8_t pixel = arg_pixel->pixel;
    ccda:	fb 01       	movw	r30, r22
    ccdc:	f2 80       	ldd	r15, Z+2	; 0x02
  u8g_uint_t dx = 0;
  u8g_uint_t dy = 0;
  
  switch( arg_pixel->dir )
    ccde:	83 81       	ldd	r24, Z+3	; 0x03
    cce0:	81 30       	cpi	r24, 0x01	; 1
    cce2:	39 f0       	breq	.+14     	; 0xccf2 <u8g_pb8h1_Set8PixelOpt2+0x32>
    cce4:	70 f0       	brcs	.+28     	; 0xcd02 <u8g_pb8h1_Set8PixelOpt2+0x42>
    cce6:	82 30       	cpi	r24, 0x02	; 2
    cce8:	39 f0       	breq	.+14     	; 0xccf8 <u8g_pb8h1_Set8PixelOpt2+0x38>
    ccea:	83 30       	cpi	r24, 0x03	; 3
    ccec:	41 f0       	breq	.+16     	; 0xccfe <u8g_pb8h1_Set8PixelOpt2+0x3e>

void u8g_pb8h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  register uint8_t pixel = arg_pixel->pixel;
  u8g_uint_t dx = 0;
  u8g_uint_t dy = 0;
    ccee:	20 e0       	ldi	r18, 0x00	; 0
    ccf0:	01 c0       	rjmp	.+2      	; 0xccf4 <u8g_pb8h1_Set8PixelOpt2+0x34>
  
  switch( arg_pixel->dir )
  {
    case 0: dx++; break;
    case 1: dy++; break;
    ccf2:	21 e0       	ldi	r18, 0x01	; 1
}

void u8g_pb8h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  register uint8_t pixel = arg_pixel->pixel;
  u8g_uint_t dx = 0;
    ccf4:	30 e0       	ldi	r19, 0x00	; 0
  u8g_uint_t dy = 0;
  
  switch( arg_pixel->dir )
  {
    case 0: dx++; break;
    case 1: dy++; break;
    ccf6:	07 c0       	rjmp	.+14     	; 0xcd06 <u8g_pb8h1_Set8PixelOpt2+0x46>

void u8g_pb8h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  register uint8_t pixel = arg_pixel->pixel;
  u8g_uint_t dx = 0;
  u8g_uint_t dy = 0;
    ccf8:	20 e0       	ldi	r18, 0x00	; 0
  
  switch( arg_pixel->dir )
  {
    case 0: dx++; break;
    case 1: dy++; break;
    case 2: dx--; break;
    ccfa:	3f ef       	ldi	r19, 0xFF	; 255
    ccfc:	04 c0       	rjmp	.+8      	; 0xcd06 <u8g_pb8h1_Set8PixelOpt2+0x46>
    case 3: dy--; break;
    ccfe:	2f ef       	ldi	r18, 0xFF	; 255
    cd00:	f9 cf       	rjmp	.-14     	; 0xccf4 <u8g_pb8h1_Set8PixelOpt2+0x34>

void u8g_pb8h1_Set8PixelOpt2(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  register uint8_t pixel = arg_pixel->pixel;
  u8g_uint_t dx = 0;
  u8g_uint_t dy = 0;
    cd02:	20 e0       	ldi	r18, 0x00	; 0
  
  switch( arg_pixel->dir )
  {
    case 0: dx++; break;
    cd04:	31 e0       	ldi	r19, 0x01	; 1
    case 3: dy--; break;
  }
  
  do
  {
    if ( pixel & 128 )
    cd06:	f7 fe       	sbrs	r15, 7
    cd08:	07 c0       	rjmp	.+14     	; 0xcd18 <u8g_pb8h1_Set8PixelOpt2+0x58>
      u8g_pb8h1_SetPixel(b, arg_pixel);
    cd0a:	b6 01       	movw	r22, r12
    cd0c:	c8 01       	movw	r24, r16
    cd0e:	29 83       	std	Y+1, r18	; 0x01
    cd10:	3a 83       	std	Y+2, r19	; 0x02
    cd12:	c1 df       	rcall	.-126    	; 0xcc96 <u8g_pb8h1_SetPixel>
    cd14:	3a 81       	ldd	r19, Y+2	; 0x02
    cd16:	29 81       	ldd	r18, Y+1	; 0x01
    cd18:	f6 01       	movw	r30, r12
    arg_pixel->x += dx;
    cd1a:	80 81       	ld	r24, Z
    cd1c:	83 0f       	add	r24, r19
    cd1e:	80 83       	st	Z, r24
    cd20:	81 81       	ldd	r24, Z+1	; 0x01
    arg_pixel->y += dy;
    cd22:	82 0f       	add	r24, r18
    cd24:	81 83       	std	Z+1, r24	; 0x01
    cd26:	ff 0c       	add	r15, r15
    pixel <<= 1;
    cd28:	71 f7       	brne	.-36     	; 0xcd06 <u8g_pb8h1_Set8PixelOpt2+0x46>
  } while( pixel != 0  );  
    cd2a:	0f 90       	pop	r0
}
    cd2c:	0f 90       	pop	r0
    cd2e:	df 91       	pop	r29
    cd30:	cf 91       	pop	r28
    cd32:	1f 91       	pop	r17
    cd34:	0f 91       	pop	r16
    cd36:	ff 90       	pop	r15
    cd38:	df 90       	pop	r13
    cd3a:	cf 90       	pop	r12
    cd3c:	08 95       	ret

0000cd3e <u8g_dev_pb8h1_base_fn>:
  }
}
#endif

uint8_t u8g_dev_pb8h1_base_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
    cd3e:	0f 93       	push	r16
    cd40:	1f 93       	push	r17
    cd42:	cf 93       	push	r28
    cd44:	df 93       	push	r29
    cd46:	89 01       	movw	r16, r18
  u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
    cd48:	fb 01       	movw	r30, r22
    cd4a:	c2 81       	ldd	r28, Z+2	; 0x02
    cd4c:	d3 81       	ldd	r29, Z+3	; 0x03
  switch(msg)
    cd4e:	42 33       	cpi	r20, 0x32	; 50
    cd50:	d9 f0       	breq	.+54     	; 0xcd88 <u8g_dev_pb8h1_base_fn+0x4a>
    cd52:	58 f4       	brcc	.+22     	; 0xcd6a <u8g_dev_pb8h1_base_fn+0x2c>
    cd54:	45 31       	cpi	r20, 0x15	; 21
    cd56:	e1 f0       	breq	.+56     	; 0xcd90 <u8g_dev_pb8h1_base_fn+0x52>
    cd58:	47 31       	cpi	r20, 0x17	; 23
    cd5a:	09 f1       	breq	.+66     	; 0xcd9e <u8g_dev_pb8h1_base_fn+0x60>
    cd5c:	44 31       	cpi	r20, 0x14	; 20
    cd5e:	41 f5       	brne	.+80     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    case U8G_DEV_MSG_INIT:
      break;
    case U8G_DEV_MSG_STOP:
      break;
    case U8G_DEV_MSG_PAGE_FIRST:
      u8g_pb_Clear(pb);
    cd60:	ce 01       	movw	r24, r28
    cd62:	2e d0       	rcall	.+92     	; 0xcdc0 <u8g_pb_Clear>
    cd64:	ce 01       	movw	r24, r28
      u8g_page_First(&(pb->p));
    cd66:	43 d2       	rcall	.+1158   	; 0xd1ee <u8g_page_First>
    cd68:	23 c0       	rjmp	.+70     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cd6a:	46 34       	cpi	r20, 0x46	; 70
    cd6c:	e1 f0       	breq	.+56     	; 0xcda6 <u8g_dev_pb8h1_base_fn+0x68>
#endif

uint8_t u8g_dev_pb8h1_base_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
  u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
  switch(msg)
    cd6e:	47 34       	cpi	r20, 0x47	; 71
    cd70:	e1 f0       	breq	.+56     	; 0xcdaa <u8g_dev_pb8h1_base_fn+0x6c>
    cd72:	4b 33       	cpi	r20, 0x3B	; 59
    cd74:	e9 f4       	brne	.+58     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cd76:	b9 01       	movw	r22, r18
    cd78:	ce 01       	movw	r24, r28
    case U8G_DEV_MSG_SET_8PIXEL:
#ifdef NEW_CODE
      if ( u8g_pb_Is8PixelVisible(pb, (u8g_dev_arg_pixel_t *)arg) )
        u8g_pb8h1_Set8PixelState(pb, (u8g_dev_arg_pixel_t *)arg);
#else
      if ( u8g_pb_Is8PixelVisible(pb, (u8g_dev_arg_pixel_t *)arg) )
    cd7a:	57 d0       	rcall	.+174    	; 0xce2a <u8g_pb_Is8PixelVisible>
    cd7c:	88 23       	and	r24, r24
    cd7e:	c1 f0       	breq	.+48     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cd80:	b8 01       	movw	r22, r16
    cd82:	ce 01       	movw	r24, r28
    cd84:	9d df       	rcall	.-198    	; 0xccc0 <u8g_pb8h1_Set8PixelOpt2>
        u8g_pb8h1_Set8PixelOpt2(pb, (u8g_dev_arg_pixel_t *)arg);
    cd86:	14 c0       	rjmp	.+40     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cd88:	b9 01       	movw	r22, r18
    cd8a:	ce 01       	movw	r24, r28
    cd8c:	84 df       	rcall	.-248    	; 0xcc96 <u8g_pb8h1_SetPixel>
    cd8e:	10 c0       	rjmp	.+32     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
#endif
      break;
    case U8G_DEV_MSG_SET_PIXEL:
      u8g_pb8h1_SetPixel(pb, (u8g_dev_arg_pixel_t *)arg);
    cd90:	ce 01       	movw	r24, r28
    cd92:	34 d2       	rcall	.+1128   	; 0xd1fc <u8g_page_Next>
    cd94:	88 23       	and	r24, r24
    cd96:	71 f0       	breq	.+28     	; 0xcdb4 <u8g_dev_pb8h1_base_fn+0x76>
    cd98:	ce 01       	movw	r24, r28
    case U8G_DEV_MSG_PAGE_FIRST:
      u8g_pb_Clear(pb);
      u8g_page_First(&(pb->p));
      break;
    case U8G_DEV_MSG_PAGE_NEXT:
      if ( u8g_page_Next(&(pb->p)) == 0 )
    cd9a:	12 d0       	rcall	.+36     	; 0xcdc0 <u8g_pb_Clear>
    cd9c:	09 c0       	rjmp	.+18     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cd9e:	b9 01       	movw	r22, r18
    cda0:	ce 01       	movw	r24, r28
    cda2:	33 d0       	rcall	.+102    	; 0xce0a <u8g_pb_GetPageBox>
        return 0;
      u8g_pb_Clear(pb);
    cda4:	05 c0       	rjmp	.+10     	; 0xcdb0 <u8g_dev_pb8h1_base_fn+0x72>
    cda6:	8d 81       	ldd	r24, Y+5	; 0x05
    cda8:	01 c0       	rjmp	.+2      	; 0xcdac <u8g_dev_pb8h1_base_fn+0x6e>
    cdaa:	89 81       	ldd	r24, Y+1	; 0x01
#ifdef U8G_DEV_MSG_IS_BBX_INTERSECTION
    case U8G_DEV_MSG_IS_BBX_INTERSECTION:
      return u8g_pb_IsIntersection(pb, (u8g_dev_arg_bbx_t *)arg);
#endif
    case U8G_DEV_MSG_GET_PAGE_BOX:
      u8g_pb_GetPageBox(pb, (u8g_box_t *)arg);
    cdac:	f8 01       	movw	r30, r16
    cdae:	80 83       	st	Z, r24
    cdb0:	81 e0       	ldi	r24, 0x01	; 1
    cdb2:	01 c0       	rjmp	.+2      	; 0xcdb6 <u8g_dev_pb8h1_base_fn+0x78>
    cdb4:	80 e0       	ldi	r24, 0x00	; 0
      break;
    case U8G_DEV_MSG_GET_WIDTH:
      *((u8g_uint_t *)arg) = pb->width;
    cdb6:	df 91       	pop	r29
    cdb8:	cf 91       	pop	r28
      break;
    case U8G_DEV_MSG_GET_HEIGHT:
      *((u8g_uint_t *)arg) = pb->p.total_height;
    cdba:	1f 91       	pop	r17
    cdbc:	0f 91       	pop	r16
    cdbe:	08 95       	ret

0000cdc0 <u8g_pb_Clear>:

#include "u8g.h"

void u8g_pb_Clear(u8g_pb_t *b)
{
  uint8_t *ptr = (uint8_t *)b->buf;
    cdc0:	dc 01       	movw	r26, r24
    cdc2:	16 96       	adiw	r26, 0x06	; 6
    cdc4:	ed 91       	ld	r30, X+
    cdc6:	fc 91       	ld	r31, X
    cdc8:	17 97       	sbiw	r26, 0x07	; 7
  uint8_t *end_ptr = ptr;
  end_ptr += b->width;
    cdca:	15 96       	adiw	r26, 0x05	; 5
    cdcc:	8c 91       	ld	r24, X
    cdce:	9f 01       	movw	r18, r30
    cdd0:	28 0f       	add	r18, r24
    cdd2:	31 1d       	adc	r19, r1
    cdd4:	c9 01       	movw	r24, r18
  do
  {
    *ptr++ = 0;
    cdd6:	11 92       	st	Z+, r1
  } while( ptr != end_ptr );
    cdd8:	e8 17       	cp	r30, r24
    cdda:	f9 07       	cpc	r31, r25
    cddc:	e1 f7       	brne	.-8      	; 0xcdd6 <u8g_pb_Clear+0x16>
}
    cdde:	08 95       	ret

0000cde0 <u8g_pb_IsYIntersection>:
  return 0;
}
*/

uint8_t u8g_pb_IsYIntersection(u8g_pb_t *pb, u8g_uint_t v0, u8g_uint_t v1)
{
    cde0:	fc 01       	movw	r30, r24
  uint8_t c1, c2, c3, tmp;
  c1 = v0 <= pb->p.page_y1;
    cde2:	91 e0       	ldi	r25, 0x01	; 1
    cde4:	83 81       	ldd	r24, Z+3	; 0x03
    cde6:	86 17       	cp	r24, r22
    cde8:	08 f4       	brcc	.+2      	; 0xcdec <u8g_pb_IsYIntersection+0xc>
    cdea:	90 e0       	ldi	r25, 0x00	; 0
  c2 = v1 >= pb->p.page_y0;
  c3 = v0 > v1;
    cdec:	21 e0       	ldi	r18, 0x01	; 1
    cdee:	46 17       	cp	r20, r22
    cdf0:	08 f0       	brcs	.+2      	; 0xcdf4 <u8g_pb_IsYIntersection+0x14>
    cdf2:	20 e0       	ldi	r18, 0x00	; 0
  
  tmp = c1;
  c1 &= c2;
  c2 &= c3;
  c3 &= tmp;
  c1 |= c2;
    cdf4:	32 2f       	mov	r19, r18
    cdf6:	39 2b       	or	r19, r25

uint8_t u8g_pb_IsYIntersection(u8g_pb_t *pb, u8g_uint_t v0, u8g_uint_t v1)
{
  uint8_t c1, c2, c3, tmp;
  c1 = v0 <= pb->p.page_y1;
  c2 = v1 >= pb->p.page_y0;
    cdf8:	81 e0       	ldi	r24, 0x01	; 1
    cdfa:	52 81       	ldd	r21, Z+2	; 0x02
    cdfc:	45 17       	cp	r20, r21
    cdfe:	08 f4       	brcc	.+2      	; 0xce02 <u8g_pb_IsYIntersection+0x22>
    ce00:	80 e0       	ldi	r24, 0x00	; 0
  
  tmp = c1;
  c1 &= c2;
  c2 &= c3;
  c3 &= tmp;
  c1 |= c2;
    ce02:	83 23       	and	r24, r19
  */
  
  tmp = c1;
  c1 &= c2;
  c2 &= c3;
  c3 &= tmp;
    ce04:	92 23       	and	r25, r18
  c1 |= c2;
  c1 |= c3;
  return c1 & 1;
}
    ce06:	89 2b       	or	r24, r25
    ce08:	08 95       	ret

0000ce0a <u8g_pb_GetPageBox>:
    
  return u8g_pb_IsXIntersection(pb, bbx->x, tmp);
}

void u8g_pb_GetPageBox(u8g_pb_t *pb, u8g_box_t *box)
{
    ce0a:	dc 01       	movw	r26, r24
    ce0c:	fb 01       	movw	r30, r22
  box->x0 = 0;
    ce0e:	10 82       	st	Z, r1
  box->y0 = pb->p.page_y0;
    ce10:	12 96       	adiw	r26, 0x02	; 2
    ce12:	8c 91       	ld	r24, X
    ce14:	12 97       	sbiw	r26, 0x02	; 2
    ce16:	81 83       	std	Z+1, r24	; 0x01
  box->x1 = pb->width;
  box->x1--;
    ce18:	15 96       	adiw	r26, 0x05	; 5
    ce1a:	8c 91       	ld	r24, X
    ce1c:	15 97       	sbiw	r26, 0x05	; 5
    ce1e:	81 50       	subi	r24, 0x01	; 1
    ce20:	82 83       	std	Z+2, r24	; 0x02
  box->y1 = pb->p.page_y1;
    ce22:	13 96       	adiw	r26, 0x03	; 3
    ce24:	8c 91       	ld	r24, X
    ce26:	83 83       	std	Z+3, r24	; 0x03
    ce28:	08 95       	ret

0000ce2a <u8g_pb_Is8PixelVisible>:


uint8_t u8g_pb_Is8PixelVisible(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  u8g_uint_t v0, v1;
  v0 = arg_pixel->y;
    ce2a:	fb 01       	movw	r30, r22
    ce2c:	41 81       	ldd	r20, Z+1	; 0x01
  v1 = v0;
  switch( arg_pixel->dir )
    ce2e:	23 81       	ldd	r18, Z+3	; 0x03
    ce30:	21 30       	cpi	r18, 0x01	; 1
    ce32:	29 f0       	breq	.+10     	; 0xce3e <u8g_pb_Is8PixelVisible+0x14>
    ce34:	23 30       	cpi	r18, 0x03	; 3
    ce36:	31 f4       	brne	.+12     	; 0xce44 <u8g_pb_Is8PixelVisible+0x1a>
      v1 += 8;          /* this is independent from the page height */
      break;
    case 2:  
      break;
    case 3: 
      v0 -= 8;
    ce38:	68 ef       	ldi	r22, 0xF8	; 248
    ce3a:	64 0f       	add	r22, r20
      break;
    ce3c:	04 c0       	rjmp	.+8      	; 0xce46 <u8g_pb_Is8PixelVisible+0x1c>


uint8_t u8g_pb_Is8PixelVisible(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  u8g_uint_t v0, v1;
  v0 = arg_pixel->y;
    ce3e:	64 2f       	mov	r22, r20
  switch( arg_pixel->dir )
  {
    case 0:
      break;
    case 1:  
      v1 += 8;          /* this is independent from the page height */
    ce40:	48 5f       	subi	r20, 0xF8	; 248
      break;
    ce42:	01 c0       	rjmp	.+2      	; 0xce46 <u8g_pb_Is8PixelVisible+0x1c>


uint8_t u8g_pb_Is8PixelVisible(u8g_pb_t *b, u8g_dev_arg_pixel_t *arg_pixel)
{
  u8g_uint_t v0, v1;
  v0 = arg_pixel->y;
    ce44:	64 2f       	mov	r22, r20
      break;
    case 3: 
      v0 -= 8;
      break;
  }
  return u8g_pb_IsYIntersection(b, v0, v1);
    ce46:	cc cf       	rjmp	.-104    	; 0xcde0 <u8g_pb_IsYIntersection>

0000ce48 <u8g_dev_rot_dummy_fn>:
uint8_t u8g_dev_rot270_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg);

uint8_t u8g_dev_rot_dummy_fn(void *u8g, void *dev, uint8_t msg, void *arg)
{
  return 0;
}
    ce48:	80 e0       	ldi	r24, 0x00	; 0
    ce4a:	08 95       	ret

0000ce4c <u8g_dev_rot180_fn>:
  }
  return 1;
}

uint8_t u8g_dev_rot180_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
{
    ce4c:	8f 92       	push	r8
    ce4e:	9f 92       	push	r9
    ce50:	bf 92       	push	r11
    ce52:	cf 92       	push	r12
    ce54:	df 92       	push	r13
    ce56:	ef 92       	push	r14
    ce58:	ff 92       	push	r15
    ce5a:	0f 93       	push	r16
    ce5c:	1f 93       	push	r17
    ce5e:	cf 93       	push	r28
    ce60:	df 93       	push	r29
    ce62:	1f 92       	push	r1
    ce64:	cd b7       	in	r28, 0x3d	; 61
    ce66:	de b7       	in	r29, 0x3e	; 62
    ce68:	8c 01       	movw	r16, r24
    ce6a:	49 01       	movw	r8, r18
  u8g_dev_t *rotation_chain = (u8g_dev_t *)(dev->dev_mem);
    ce6c:	fb 01       	movw	r30, r22
    ce6e:	e2 80       	ldd	r14, Z+2	; 0x02
    ce70:	f3 80       	ldd	r15, Z+3	; 0x03
  switch(msg)
    ce72:	42 33       	cpi	r20, 0x32	; 50
    ce74:	09 f4       	brne	.+2      	; 0xce78 <u8g_dev_rot180_fn+0x2c>
    ce76:	4a c0       	rjmp	.+148    	; 0xcf0c <u8g_dev_rot180_fn+0xc0>
    ce78:	48 f4       	brcc	.+18     	; 0xce8c <u8g_dev_rot180_fn+0x40>
    ce7a:	4c 32       	cpi	r20, 0x2C	; 44
    ce7c:	09 f4       	brne	.+2      	; 0xce80 <u8g_dev_rot180_fn+0x34>
    ce7e:	46 c0       	rjmp	.+140    	; 0xcf0c <u8g_dev_rot180_fn+0xc0>
    ce80:	4d 32       	cpi	r20, 0x2D	; 45
    ce82:	09 f4       	brne	.+2      	; 0xce86 <u8g_dev_rot180_fn+0x3a>
    ce84:	57 c0       	rjmp	.+174    	; 0xcf34 <u8g_dev_rot180_fn+0xe8>
    ce86:	47 31       	cpi	r20, 0x17	; 23
    ce88:	71 f0       	breq	.+28     	; 0xcea6 <u8g_dev_rot180_fn+0x5a>
    ce8a:	07 c0       	rjmp	.+14     	; 0xce9a <u8g_dev_rot180_fn+0x4e>
    ce8c:	46 34       	cpi	r20, 0x46	; 70
    ce8e:	a1 f1       	breq	.+104    	; 0xcef8 <u8g_dev_rot180_fn+0xac>
    ce90:	47 34       	cpi	r20, 0x47	; 71
    ce92:	b1 f1       	breq	.+108    	; 0xcf00 <u8g_dev_rot180_fn+0xb4>
    ce94:	4b 33       	cpi	r20, 0x3B	; 59
    ce96:	09 f4       	brne	.+2      	; 0xce9a <u8g_dev_rot180_fn+0x4e>
    ce98:	4d c0       	rjmp	.+154    	; 0xcf34 <u8g_dev_rot180_fn+0xe8>
    case U8G_DEV_MSG_PAGE_FIRST:
    case U8G_DEV_MSG_PAGE_NEXT:
    case U8G_DEV_MSG_SET_COLOR_ENTRY:
    case U8G_DEV_MSG_SET_XY_CB:
    */
      return u8g_call_dev_fn(u8g, rotation_chain, msg, arg);
    ce9a:	94 01       	movw	r18, r8
    ce9c:	b7 01       	movw	r22, r14
    ce9e:	c8 01       	movw	r24, r16
    cea0:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <u8g_call_dev_fn>
    cea4:	65 c0       	rjmp	.+202    	; 0xcf70 <u8g_dev_rot180_fn+0x124>
      }
      return u8g_call_dev_fn(u8g, rotation_chain, msg, arg);
#endif /* U8G_DEV_MSG_IS_BBX_INTERSECTION */
    case U8G_DEV_MSG_GET_PAGE_BOX:
      /* get page size from next device in the chain */
      u8g_call_dev_fn(u8g, rotation_chain, msg, arg);
    cea6:	47 e1       	ldi	r20, 0x17	; 23
    cea8:	b7 01       	movw	r22, r14
    ceaa:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <u8g_call_dev_fn>
      //printf("pre x: %3d..%3d y: %3d..%3d   ", ((u8g_box_t *)arg)->x0, ((u8g_box_t *)arg)->x1, ((u8g_box_t *)arg)->y0, ((u8g_box_t *)arg)->y1);
      {
	u8g_box_t new_box;
	
	new_box.x0 = u8g_GetWidthLL(u8g,rotation_chain) - ((u8g_box_t *)arg)->x1 - 1;
    ceae:	b7 01       	movw	r22, r14
    ceb0:	c8 01       	movw	r24, r16
    ceb2:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <u8g_GetWidthLL>
    ceb6:	f4 01       	movw	r30, r8
    ceb8:	b2 80       	ldd	r11, Z+2	; 0x02
    ceba:	b0 94       	com	r11
    cebc:	b8 0e       	add	r11, r24
	new_box.x1 = u8g_GetWidthLL(u8g,rotation_chain) - ((u8g_box_t *)arg)->x0 - 1;
    cebe:	b7 01       	movw	r22, r14
    cec0:	c8 01       	movw	r24, r16
    cec2:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <u8g_GetWidthLL>
    cec6:	f4 01       	movw	r30, r8
    cec8:	d0 80       	ld	r13, Z
    ceca:	d0 94       	com	r13
    cecc:	d8 0e       	add	r13, r24
	new_box.y0 = u8g_GetHeightLL(u8g,rotation_chain) - ((u8g_box_t *)arg)->y1 - 1;
    cece:	b7 01       	movw	r22, r14
    ced0:	c8 01       	movw	r24, r16
    ced2:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <u8g_GetHeightLL>
    ced6:	f4 01       	movw	r30, r8
    ced8:	c3 80       	ldd	r12, Z+3	; 0x03
    ceda:	c0 94       	com	r12
    cedc:	c8 0e       	add	r12, r24
	new_box.y1 = u8g_GetHeightLL(u8g,rotation_chain) - ((u8g_box_t *)arg)->y0 - 1;
    cede:	b7 01       	movw	r22, r14
    cee0:	c8 01       	movw	r24, r16
    cee2:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <u8g_GetHeightLL>
    cee6:	f4 01       	movw	r30, r8
    cee8:	91 81       	ldd	r25, Z+1	; 0x01
    ceea:	90 95       	com	r25
    ceec:	98 0f       	add	r25, r24
	*((u8g_box_t *)arg) = new_box;
    ceee:	b0 82       	st	Z, r11
    cef0:	c1 82       	std	Z+1, r12	; 0x01
    cef2:	d2 82       	std	Z+2, r13	; 0x02
    cef4:	93 83       	std	Z+3, r25	; 0x03
    cef6:	3b c0       	rjmp	.+118    	; 0xcf6e <u8g_dev_rot180_fn+0x122>
	//printf("post x: %3d..%3d y: %3d..%3d\n", ((u8g_box_t *)arg)->x0, ((u8g_box_t *)arg)->x1, ((u8g_box_t *)arg)->y0, ((u8g_box_t *)arg)->y1);
      }
      break;
    case U8G_DEV_MSG_GET_WIDTH:
      *((u8g_uint_t *)arg) = u8g_GetWidthLL(u8g,rotation_chain);
    cef8:	b7 01       	movw	r22, r14
    cefa:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <u8g_GetWidthLL>
    cefe:	03 c0       	rjmp	.+6      	; 0xcf06 <u8g_dev_rot180_fn+0xba>
      break;
    case U8G_DEV_MSG_GET_HEIGHT:
      *((u8g_uint_t *)arg) = u8g_GetHeightLL(u8g, rotation_chain);
    cf00:	b7 01       	movw	r22, r14
    cf02:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <u8g_GetHeightLL>
    cf06:	f4 01       	movw	r30, r8
    cf08:	80 83       	st	Z, r24
    cf0a:	31 c0       	rjmp	.+98     	; 0xcf6e <u8g_dev_rot180_fn+0x122>
    case U8G_DEV_MSG_SET_PIXEL:
    case U8G_DEV_MSG_SET_TPIXEL:
      {
        u8g_uint_t x, y;

        y = u8g_GetHeightLL(u8g, rotation_chain);
    cf0c:	b7 01       	movw	r22, r14
    cf0e:	c8 01       	movw	r24, r16
    cf10:	49 83       	std	Y+1, r20	; 0x01
    cf12:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <u8g_GetHeightLL>
        y -= ((u8g_dev_arg_pixel_t *)arg)->y; 
    cf16:	f4 01       	movw	r30, r8
    cf18:	d1 80       	ldd	r13, Z+1	; 0x01
    cf1a:	d0 94       	com	r13
        y--;
    cf1c:	d8 0e       	add	r13, r24
        
        x = u8g_GetWidthLL(u8g, rotation_chain);
    cf1e:	b7 01       	movw	r22, r14
    cf20:	c8 01       	movw	r24, r16
    cf22:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <u8g_GetWidthLL>
        x -= ((u8g_dev_arg_pixel_t *)arg)->x; 
    cf26:	f4 01       	movw	r30, r8
    cf28:	90 81       	ld	r25, Z
    cf2a:	90 95       	com	r25
        x--;
    cf2c:	98 0f       	add	r25, r24
        
        ((u8g_dev_arg_pixel_t *)arg)->x = x;
    cf2e:	90 83       	st	Z, r25
        ((u8g_dev_arg_pixel_t *)arg)->y = y;
    cf30:	d1 82       	std	Z+1, r13	; 0x01
    cf32:	17 c0       	rjmp	.+46     	; 0xcf62 <u8g_dev_rot180_fn+0x116>
    case U8G_DEV_MSG_SET_8PIXEL:
    case U8G_DEV_MSG_SET_4TPIXEL:
      {
        u8g_uint_t x, y;
        
        y = u8g_GetHeightLL(u8g, rotation_chain);
    cf34:	b7 01       	movw	r22, r14
    cf36:	c8 01       	movw	r24, r16
    cf38:	49 83       	std	Y+1, r20	; 0x01
    cf3a:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <u8g_GetHeightLL>
        y -= ((u8g_dev_arg_pixel_t *)arg)->y; 
    cf3e:	f4 01       	movw	r30, r8
    cf40:	d1 80       	ldd	r13, Z+1	; 0x01
    cf42:	d0 94       	com	r13
        y--;
    cf44:	d8 0e       	add	r13, r24
        
        x = u8g_GetWidthLL(u8g, rotation_chain);
    cf46:	b7 01       	movw	r22, r14
    cf48:	c8 01       	movw	r24, r16
    cf4a:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <u8g_GetWidthLL>
        x -= ((u8g_dev_arg_pixel_t *)arg)->x; 
    cf4e:	f4 01       	movw	r30, r8
    cf50:	90 81       	ld	r25, Z
    cf52:	90 95       	com	r25
        x--;
    cf54:	98 0f       	add	r25, r24
        
        ((u8g_dev_arg_pixel_t *)arg)->x = x;
    cf56:	90 83       	st	Z, r25
        ((u8g_dev_arg_pixel_t *)arg)->y = y;
    cf58:	d1 82       	std	Z+1, r13	; 0x01
        ((u8g_dev_arg_pixel_t *)arg)->dir+=2;
    cf5a:	83 81       	ldd	r24, Z+3	; 0x03
    cf5c:	8e 5f       	subi	r24, 0xFE	; 254
        ((u8g_dev_arg_pixel_t *)arg)->dir &= 3;
    cf5e:	83 70       	andi	r24, 0x03	; 3
    cf60:	83 83       	std	Z+3, r24	; 0x03
      }
      u8g_call_dev_fn(u8g, rotation_chain, msg, arg);
    cf62:	94 01       	movw	r18, r8
    cf64:	49 81       	ldd	r20, Y+1	; 0x01
    cf66:	b7 01       	movw	r22, r14
    cf68:	c8 01       	movw	r24, r16
    cf6a:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <u8g_call_dev_fn>
      break;
  }
  return 1;
    cf6e:	81 e0       	ldi	r24, 0x01	; 1
}
    cf70:	0f 90       	pop	r0
    cf72:	df 91       	pop	r29
    cf74:	cf 91       	pop	r28
    cf76:	1f 91       	pop	r17
    cf78:	0f 91       	pop	r16
    cf7a:	ff 90       	pop	r15
    cf7c:	ef 90       	pop	r14
    cf7e:	df 90       	pop	r13
    cf80:	cf 90       	pop	r12
    cf82:	bf 90       	pop	r11
    cf84:	9f 90       	pop	r9
    cf86:	8f 90       	pop	r8
    cf88:	08 95       	ret

0000cf8a <u8g_SetRot180>:
  u8g_UpdateDimension(u8g);
}

void u8g_SetRot180(u8g_t *u8g)
{
  if ( u8g->dev != &u8g_dev_rot )
    cf8a:	fc 01       	movw	r30, r24
    cf8c:	22 81       	ldd	r18, Z+2	; 0x02
    cf8e:	33 81       	ldd	r19, Z+3	; 0x03
    cf90:	f2 e0       	ldi	r31, 0x02	; 2
    cf92:	24 3d       	cpi	r18, 0xD4	; 212
    cf94:	3f 07       	cpc	r19, r31
    cf96:	49 f0       	breq	.+18     	; 0xcfaa <u8g_SetRot180+0x20>
  {
    u8g_dev_rot.dev_mem = u8g->dev;
    cf98:	30 93 d7 02 	sts	0x02D7, r19
    cf9c:	20 93 d6 02 	sts	0x02D6, r18
    u8g->dev = &u8g_dev_rot;
    cfa0:	24 ed       	ldi	r18, 0xD4	; 212
    cfa2:	32 e0       	ldi	r19, 0x02	; 2
    cfa4:	fc 01       	movw	r30, r24
    cfa6:	33 83       	std	Z+3, r19	; 0x03
    cfa8:	22 83       	std	Z+2, r18	; 0x02
  }
  u8g_dev_rot.dev_fn = u8g_dev_rot180_fn;
    cfaa:	26 e2       	ldi	r18, 0x26	; 38
    cfac:	37 e6       	ldi	r19, 0x67	; 103
    cfae:	30 93 d5 02 	sts	0x02D5, r19
    cfb2:	20 93 d4 02 	sts	0x02D4, r18
  u8g_UpdateDimension(u8g);
    cfb6:	0c 94 4b 1e 	jmp	0x3c96	; 0x3c96 <u8g_UpdateDimension>

0000cfba <u8g_InitCom>:

#include "u8g.h"

uint8_t u8g_InitCom(u8g_t *u8g, u8g_dev_t *dev, uint8_t clk_cycle_time)
{
  return dev->com_fn(u8g, U8G_COM_MSG_INIT, clk_cycle_time, NULL);
    cfba:	db 01       	movw	r26, r22
    cfbc:	14 96       	adiw	r26, 0x04	; 4
    cfbe:	ed 91       	ld	r30, X+
    cfc0:	fc 91       	ld	r31, X
    cfc2:	15 97       	sbiw	r26, 0x05	; 5
    cfc4:	20 e0       	ldi	r18, 0x00	; 0
    cfc6:	30 e0       	ldi	r19, 0x00	; 0
    cfc8:	61 e0       	ldi	r22, 0x01	; 1
    cfca:	19 95       	eicall
}
    cfcc:	08 95       	ret

0000cfce <u8g_SetChipSelect>:
}

/* cs contains the chip number, which should be enabled */
void u8g_SetChipSelect(u8g_t *u8g, u8g_dev_t *dev, uint8_t cs)
{
  dev->com_fn(u8g, U8G_COM_MSG_CHIP_SELECT, cs, NULL);
    cfce:	db 01       	movw	r26, r22
    cfd0:	14 96       	adiw	r26, 0x04	; 4
    cfd2:	ed 91       	ld	r30, X+
    cfd4:	fc 91       	ld	r31, X
    cfd6:	15 97       	sbiw	r26, 0x05	; 5
    cfd8:	20 e0       	ldi	r18, 0x00	; 0
    cfda:	30 e0       	ldi	r19, 0x00	; 0
    cfdc:	63 e0       	ldi	r22, 0x03	; 3
    cfde:	19 95       	eicall
    cfe0:	08 95       	ret

0000cfe2 <u8g_SetResetLow>:
}

void u8g_SetResetLow(u8g_t *u8g, u8g_dev_t *dev)
{
  dev->com_fn(u8g, U8G_COM_MSG_RESET, 0, NULL);
    cfe2:	db 01       	movw	r26, r22
    cfe4:	14 96       	adiw	r26, 0x04	; 4
    cfe6:	ed 91       	ld	r30, X+
    cfe8:	fc 91       	ld	r31, X
    cfea:	15 97       	sbiw	r26, 0x05	; 5
    cfec:	20 e0       	ldi	r18, 0x00	; 0
    cfee:	30 e0       	ldi	r19, 0x00	; 0
    cff0:	40 e0       	ldi	r20, 0x00	; 0
    cff2:	64 e0       	ldi	r22, 0x04	; 4
    cff4:	19 95       	eicall
    cff6:	08 95       	ret

0000cff8 <u8g_SetResetHigh>:
}

void u8g_SetResetHigh(u8g_t *u8g, u8g_dev_t *dev)
{
  dev->com_fn(u8g, U8G_COM_MSG_RESET, 1, NULL);
    cff8:	db 01       	movw	r26, r22
    cffa:	14 96       	adiw	r26, 0x04	; 4
    cffc:	ed 91       	ld	r30, X+
    cffe:	fc 91       	ld	r31, X
    d000:	15 97       	sbiw	r26, 0x05	; 5
    d002:	20 e0       	ldi	r18, 0x00	; 0
    d004:	30 e0       	ldi	r19, 0x00	; 0
    d006:	41 e0       	ldi	r20, 0x01	; 1
    d008:	64 e0       	ldi	r22, 0x04	; 4
    d00a:	19 95       	eicall
    d00c:	08 95       	ret

0000d00e <u8g_SetAddress>:
}


void u8g_SetAddress(u8g_t *u8g, u8g_dev_t *dev, uint8_t address)
{
  dev->com_fn(u8g, U8G_COM_MSG_ADDRESS, address, NULL);
    d00e:	db 01       	movw	r26, r22
    d010:	14 96       	adiw	r26, 0x04	; 4
    d012:	ed 91       	ld	r30, X+
    d014:	fc 91       	ld	r31, X
    d016:	15 97       	sbiw	r26, 0x05	; 5
    d018:	20 e0       	ldi	r18, 0x00	; 0
    d01a:	30 e0       	ldi	r19, 0x00	; 0
    d01c:	62 e0       	ldi	r22, 0x02	; 2
    d01e:	19 95       	eicall
    d020:	08 95       	ret

0000d022 <u8g_WriteByte>:
}

uint8_t u8g_WriteByte(u8g_t *u8g, u8g_dev_t *dev, uint8_t val)
{
  return dev->com_fn(u8g, U8G_COM_MSG_WRITE_BYTE, val, NULL);
    d022:	db 01       	movw	r26, r22
    d024:	14 96       	adiw	r26, 0x04	; 4
    d026:	ed 91       	ld	r30, X+
    d028:	fc 91       	ld	r31, X
    d02a:	15 97       	sbiw	r26, 0x05	; 5
    d02c:	20 e0       	ldi	r18, 0x00	; 0
    d02e:	30 e0       	ldi	r19, 0x00	; 0
    d030:	65 e0       	ldi	r22, 0x05	; 5
    d032:	19 95       	eicall
}
    d034:	08 95       	ret

0000d036 <u8g_WriteSequence>:

uint8_t u8g_WriteSequence(u8g_t *u8g, u8g_dev_t *dev, uint8_t cnt, uint8_t *seq)
{
  return dev->com_fn(u8g, U8G_COM_MSG_WRITE_SEQ, cnt, seq);
    d036:	db 01       	movw	r26, r22
    d038:	14 96       	adiw	r26, 0x04	; 4
    d03a:	ed 91       	ld	r30, X+
    d03c:	fc 91       	ld	r31, X
    d03e:	15 97       	sbiw	r26, 0x05	; 5
    d040:	66 e0       	ldi	r22, 0x06	; 6
    d042:	19 95       	eicall
}
    d044:	08 95       	ret

0000d046 <u8g_WriteEscSeqP>:
#define U8G_ESC_255 255, 255
#define U8G_ESC_RST(x) 255, (0xc0 | ((x)&0x0f))

*/
uint8_t u8g_WriteEscSeqP(u8g_t *u8g, u8g_dev_t *dev, const uint8_t *esc_seq)
{
    d046:	a1 e0       	ldi	r26, 0x01	; 1
    d048:	b0 e0       	ldi	r27, 0x00	; 0
    d04a:	e8 e2       	ldi	r30, 0x28	; 40
    d04c:	f8 e6       	ldi	r31, 0x68	; 104
    d04e:	7b c3       	rjmp	.+1782   	; 0xd746 <__prologue_saves__+0x10>
    d050:	5c 01       	movw	r10, r24
    d052:	8b 01       	movw	r16, r22
    d054:	7a 01       	movw	r14, r20
    d056:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t is_escape = 0;
    d058:	f7 01       	movw	r30, r14
  uint8_t value;
  for(;;)
  {
    value = u8g_pgm_read(esc_seq);
    d05a:	44 91       	lpm	r20, Z
    d05c:	81 11       	cpse	r24, r1
    if ( is_escape == 0 )
    d05e:	08 c0       	rjmp	.+16     	; 0xd070 <u8g_WriteEscSeqP+0x2a>
    d060:	4f 3f       	cpi	r20, 0xFF	; 255
    {
      if ( value != 255 )
    d062:	a1 f1       	breq	.+104    	; 0xd0cc <u8g_WriteEscSeqP+0x86>
    d064:	b8 01       	movw	r22, r16
      {
        if ( u8g_WriteByte(u8g, dev, value) == 0 )
    d066:	c5 01       	movw	r24, r10
    d068:	dc df       	rcall	.-72     	; 0xd022 <u8g_WriteByte>
    d06a:	81 11       	cpse	r24, r1
    d06c:	28 c0       	rjmp	.+80     	; 0xd0be <u8g_WriteEscSeqP+0x78>
    d06e:	33 c0       	rjmp	.+102    	; 0xd0d6 <u8g_WriteEscSeqP+0x90>
    d070:	4f 3f       	cpi	r20, 0xFF	; 255
    d072:	c1 f3       	breq	.-16     	; 0xd064 <u8g_WriteEscSeqP+0x1e>
        is_escape = 1;
      }
    }
    else
    {
      if ( value == 255 )
    d074:	4e 3f       	cpi	r20, 0xFE	; 254
    d076:	89 f1       	breq	.+98     	; 0xd0da <u8g_WriteEscSeqP+0x94>
      {
        if ( u8g_WriteByte(u8g, dev, value) == 0 )
          return 0;
      }
      else if ( value == 254 )
    d078:	40 3f       	cpi	r20, 0xF0	; 240
    d07a:	08 f5       	brcc	.+66     	; 0xd0be <u8g_WriteEscSeqP+0x78>
      {
        break;
      }
      else if ( value >= 0x0f0 )
    d07c:	40 3e       	cpi	r20, 0xE0	; 224
    d07e:	28 f0       	brcs	.+10     	; 0xd08a <u8g_WriteEscSeqP+0x44>
      {
        /* not yet used, do nothing */
      }
      else if ( value >= 0xe0  )
    d080:	4f 70       	andi	r20, 0x0F	; 15
    d082:	b8 01       	movw	r22, r16
      {
        u8g_SetAddress(u8g, dev, value & 0x0f);
    d084:	c5 01       	movw	r24, r10
    d086:	c3 df       	rcall	.-122    	; 0xd00e <u8g_SetAddress>
    d088:	1a c0       	rjmp	.+52     	; 0xd0be <u8g_WriteEscSeqP+0x78>
    d08a:	40 3d       	cpi	r20, 0xD0	; 208
    d08c:	28 f0       	brcs	.+10     	; 0xd098 <u8g_WriteEscSeqP+0x52>
    d08e:	4f 70       	andi	r20, 0x0F	; 15
      }
      else if ( value >= 0xd0 )
    d090:	b8 01       	movw	r22, r16
    d092:	c5 01       	movw	r24, r10
      {
        u8g_SetChipSelect(u8g, dev, value & 0x0f);
    d094:	9c df       	rcall	.-200    	; 0xcfce <u8g_SetChipSelect>
    d096:	13 c0       	rjmp	.+38     	; 0xd0be <u8g_WriteEscSeqP+0x78>
    d098:	40 3c       	cpi	r20, 0xC0	; 192
    d09a:	98 f0       	brcs	.+38     	; 0xd0c2 <u8g_WriteEscSeqP+0x7c>
    d09c:	b8 01       	movw	r22, r16
    d09e:	c5 01       	movw	r24, r10
      }
      else if ( value >= 0xc0 )
    d0a0:	49 83       	std	Y+1, r20	; 0x01
    d0a2:	9f df       	rcall	.-194    	; 0xcfe2 <u8g_SetResetLow>
      {
        u8g_SetResetLow(u8g, dev);
    d0a4:	49 81       	ldd	r20, Y+1	; 0x01
    d0a6:	42 95       	swap	r20
    d0a8:	40 7f       	andi	r20, 0xF0	; 240
    d0aa:	4e 5f       	subi	r20, 0xFE	; 254
    d0ac:	c4 2e       	mov	r12, r20
        value &= 0x0f;
        value <<= 4;
    d0ae:	d1 2c       	mov	r13, r1
    d0b0:	c6 01       	movw	r24, r12
    d0b2:	8e d0       	rcall	.+284    	; 0xd1d0 <u8g_Delay>
        value+=2;
    d0b4:	b8 01       	movw	r22, r16
        u8g_Delay(value);
    d0b6:	c5 01       	movw	r24, r10
    d0b8:	9f df       	rcall	.-194    	; 0xcff8 <u8g_SetResetHigh>
    d0ba:	c6 01       	movw	r24, r12
    d0bc:	89 d0       	rcall	.+274    	; 0xd1d0 <u8g_Delay>
    d0be:	80 e0       	ldi	r24, 0x00	; 0
        u8g_SetResetHigh(u8g, dev);
    d0c0:	06 c0       	rjmp	.+12     	; 0xd0ce <u8g_WriteEscSeqP+0x88>
    d0c2:	47 fd       	sbrc	r20, 7
    d0c4:	fc cf       	rjmp	.-8      	; 0xd0be <u8g_WriteEscSeqP+0x78>
    d0c6:	84 2f       	mov	r24, r20
        u8g_Delay(value);
    d0c8:	90 e0       	ldi	r25, 0x00	; 0
    d0ca:	f8 cf       	rjmp	.-16     	; 0xd0bc <u8g_WriteEscSeqP+0x76>
    d0cc:	81 e0       	ldi	r24, 0x01	; 1
      }
      else if ( value <= 127 )
      {
        u8g_Delay(value);
      }
      is_escape = 0;
    d0ce:	ff ef       	ldi	r31, 0xFF	; 255
    d0d0:	ef 1a       	sub	r14, r31
      else if ( value >= 0xbe )
      {
	/* not yet implemented */
        /* u8g_SetVCC(u8g, dev, value & 0x01); */
      }
      else if ( value <= 127 )
    d0d2:	ff 0a       	sbc	r15, r31
    d0d4:	c1 cf       	rjmp	.-126    	; 0xd058 <u8g_WriteEscSeqP+0x12>
      {
        u8g_Delay(value);
    d0d6:	80 e0       	ldi	r24, 0x00	; 0
    d0d8:	01 c0       	rjmp	.+2      	; 0xd0dc <u8g_WriteEscSeqP+0x96>
    d0da:	81 e0       	ldi	r24, 0x01	; 1
        if ( u8g_WriteByte(u8g, dev, value) == 0 )
          return 0;
      }
      else
      {
        is_escape = 1;
    d0dc:	21 96       	adiw	r28, 0x01	; 1
      {
        u8g_Delay(value);
      }
      is_escape = 0;
    }
    esc_seq++;
    d0de:	ea e0       	ldi	r30, 0x0A	; 10
    d0e0:	4e c3       	rjmp	.+1692   	; 0xd77e <__epilogue_restores__+0x10>

0000d0e2 <u8g_atmega_st7920_hw_spi_shift_out.isra.0>:

static uint8_t u8g_atmega_st7920_hw_spi_shift_out(u8g_t *u8g, uint8_t val) U8G_NOINLINE;
static uint8_t u8g_atmega_st7920_hw_spi_shift_out(u8g_t *u8g, uint8_t val)
{
  /* send data */
  SPDR = val;
    d0e2:	8e bd       	out	0x2e, r24	; 46
  /* wait for transmission */
  while (!(SPSR & (1<<SPIF))) 
    d0e4:	0d b4       	in	r0, 0x2d	; 45
    d0e6:	07 fe       	sbrs	r0, 7
    d0e8:	fd cf       	rjmp	.-6      	; 0xd0e4 <u8g_atmega_st7920_hw_spi_shift_out.isra.0+0x2>
    ;
  /* clear the SPIF flag by reading SPDR */
  return  SPDR;
    d0ea:	8e b5       	in	r24, 0x2e	; 46
}
    d0ec:	08 95       	ret

0000d0ee <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1>:


static void u8g_com_atmega_st7920_write_byte_hw_spi(u8g_t *u8g, uint8_t rs, uint8_t val) U8G_NOINLINE;
static void u8g_com_atmega_st7920_write_byte_hw_spi(u8g_t *u8g, uint8_t rs, uint8_t val)
    d0ee:	cf 93       	push	r28
    d0f0:	c6 2f       	mov	r28, r22
{
  uint8_t i;

  if ( rs == 0 )
    d0f2:	81 11       	cpse	r24, r1
    d0f4:	02 c0       	rjmp	.+4      	; 0xd0fa <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1+0xc>
  {
    /* command */
    u8g_atmega_st7920_hw_spi_shift_out(u8g, 0x0f8);
    d0f6:	88 ef       	ldi	r24, 0xF8	; 248
    d0f8:	03 c0       	rjmp	.+6      	; 0xd100 <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1+0x12>
  }
  else if ( rs == 1 )
    d0fa:	81 30       	cpi	r24, 0x01	; 1
    d0fc:	11 f4       	brne	.+4      	; 0xd102 <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1+0x14>
  {
    /* data */
    u8g_atmega_st7920_hw_spi_shift_out(u8g, 0x0fa);
    d0fe:	8a ef       	ldi	r24, 0xFA	; 250
    d100:	f0 df       	rcall	.-32     	; 0xd0e2 <u8g_atmega_st7920_hw_spi_shift_out.isra.0>
    d102:	8c 2f       	mov	r24, r28
  }
  
  u8g_atmega_st7920_hw_spi_shift_out(u8g, val & 0x0f0);
    d104:	80 7f       	andi	r24, 0xF0	; 240
    d106:	ed df       	rcall	.-38     	; 0xd0e2 <u8g_atmega_st7920_hw_spi_shift_out.isra.0>
    d108:	8c 2f       	mov	r24, r28
    d10a:	82 95       	swap	r24
  u8g_atmega_st7920_hw_spi_shift_out(u8g, val << 4);
    d10c:	80 7f       	andi	r24, 0xF0	; 240
    d10e:	e9 df       	rcall	.-46     	; 0xd0e2 <u8g_atmega_st7920_hw_spi_shift_out.isra.0>
    d110:	69 d0       	rcall	.+210    	; 0xd1e4 <u8g_10MicroDelay>
    d112:	68 d0       	rcall	.+208    	; 0xd1e4 <u8g_10MicroDelay>
    d114:	67 d0       	rcall	.+206    	; 0xd1e4 <u8g_10MicroDelay>

  for( i = 0; i < 4; i++ )
    u8g_10MicroDelay();
    d116:	66 d0       	rcall	.+204    	; 0xd1e4 <u8g_10MicroDelay>
    d118:	cf 91       	pop	r28
    d11a:	08 95       	ret

0000d11c <u8g_com_atmega_st7920_hw_spi_fn>:
}


uint8_t u8g_com_atmega_st7920_hw_spi_fn(u8g_t *u8g, uint8_t msg, uint8_t arg_val, void *arg_ptr)
{
    d11c:	a1 e0       	ldi	r26, 0x01	; 1
    d11e:	b0 e0       	ldi	r27, 0x00	; 0
    d120:	e3 e9       	ldi	r30, 0x93	; 147
    d122:	f8 e6       	ldi	r31, 0x68	; 104
    d124:	12 c3       	rjmp	.+1572   	; 0xd74a <__prologue_saves__+0x14>
    d126:	6c 01       	movw	r12, r24
    d128:	79 01       	movw	r14, r18
    d12a:	06 2f       	mov	r16, r22
  switch(msg)
    d12c:	10 e0       	ldi	r17, 0x00	; 0
    d12e:	f8 01       	movw	r30, r16
    d130:	31 97       	sbiw	r30, 0x01	; 1
    d132:	e7 30       	cpi	r30, 0x07	; 7
    d134:	f1 05       	cpc	r31, r1
    d136:	08 f0       	brcs	.+2      	; 0xd13a <u8g_com_atmega_st7920_hw_spi_fn+0x1e>
    d138:	47 c0       	rjmp	.+142    	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
    d13a:	e7 54       	subi	r30, 0x47	; 71
    d13c:	ff 4f       	sbci	r31, 0xFF	; 255
    d13e:	32 c3       	rjmp	.+1636   	; 0xd7a4 <__tablejump2__>
    d140:	62 e0       	ldi	r22, 0x02	; 2
    d142:	98 db       	rcall	.-2256   	; 0xc874 <u8g_SetPIOutput>
  {
    case U8G_COM_MSG_INIT:
      u8g_SetPIOutput(u8g, U8G_PI_CS);
    d144:	8f b7       	in	r24, 0x3f	; 63
    d146:	80 93 72 07 	sts	0x0772, r24
      //u8g_SetPIOutput(u8g, U8G_PI_A0);
      
      U8G_ATOMIC_START();
    d14a:	f8 94       	cli
    d14c:	23 9a       	sbi	0x04, 3	; 4
    d14e:	25 9a       	sbi	0x04, 5	; 4
    d150:	22 9a       	sbi	0x04, 2	; 4
      
      DDRB |= _BV(3);          /* D0, MOSI */
    d152:	2b 98       	cbi	0x05, 3	; 5
      DDRB |= _BV(5);          /* SCK */
    d154:	2d 98       	cbi	0x05, 5	; 5
      DDRB |= _BV(2);		/* slave select */
    d156:	80 91 72 07 	lds	r24, 0x0772
    
      PORTB &= ~_BV(3);        /* D0, MOSI = 0 */
      PORTB &= ~_BV(5);        /* SCK = 0 */
    d15a:	8f bf       	out	0x3f, r24	; 63
      U8G_ATOMIC_END();
    d15c:	41 e0       	ldi	r20, 0x01	; 1
    d15e:	62 e0       	ldi	r22, 0x02	; 2
    d160:	c6 01       	movw	r24, r12
      
      u8g_SetPILevel(u8g, U8G_PI_CS, 1);
    d162:	90 db       	rcall	.-2272   	; 0xc884 <u8g_SetPILevel>
    d164:	1c bc       	out	0x2c, r1	; 44
    d166:	8c e5       	ldi	r24, 0x5C	; 92
    d168:	8c bd       	out	0x2c, r24	; 44
    d16a:	f6 01       	movw	r30, r12
            0	0		fclk/4
            0	1		fclk/16 
            1	0		fclk/64  
            1	1		fclk/128
      */
      SPCR = 0;
    d16c:	16 a2       	std	Z+38, r1	; 0x26
      
      /* maybe set CPOL and CPHA to 1 */
      /* 20 Dez 2012: did set CPOL and CPHA to 1 in Arduino variant! */
      /* 24 Jan 2014: implemented, see also issue 221 */
      SPCR =  (1<<SPE) | (1<<MSTR)|(0<<SPR1)|(0<<SPR0)|(1<<CPOL)|(1<<CPHA);
    d16e:	2c c0       	rjmp	.+88     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
    d170:	60 e0       	ldi	r22, 0x00	; 0
#ifdef U8G_HW_SPI_2X
      SPSR = (1 << SPI2X);  /* double speed, issue 89 */
#endif
      u8g->pin_list[U8G_PI_A0_STATE] = 0;       /* inital RS state: command mode */
    d172:	06 c0       	rjmp	.+12     	; 0xd180 <u8g_com_atmega_st7920_hw_spi_fn+0x64>
    d174:	fc 01       	movw	r30, r24
      break;
    d176:	46 a3       	std	Z+38, r20	; 0x26
    
    case U8G_COM_MSG_STOP:
      break;

    case U8G_COM_MSG_RESET:
      u8g_SetPILevel(u8g, U8G_PI_RESET, arg_val);
    d178:	27 c0       	rjmp	.+78     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
    d17a:	41 11       	cpse	r20, r1
      break;
    
    case U8G_COM_MSG_ADDRESS:                     /* define cmd (arg_val = 0) or data mode (arg_val = 1) */
      u8g->pin_list[U8G_PI_A0_STATE] = arg_val;
    d17c:	04 c0       	rjmp	.+8      	; 0xd186 <u8g_com_atmega_st7920_hw_spi_fn+0x6a>
    d17e:	62 e0       	ldi	r22, 0x02	; 2
      break;
    d180:	c6 01       	movw	r24, r12

    case U8G_COM_MSG_CHIP_SELECT:      
      if ( arg_val == 0 )
    d182:	80 db       	rcall	.-2304   	; 0xc884 <u8g_SetPILevel>
    d184:	21 c0       	rjmp	.+66     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
      {
        /* disable, note: the st7920 has an active high chip select */
        u8g_SetPILevel(u8g, U8G_PI_CS, 0);
    d186:	41 e0       	ldi	r20, 0x01	; 1
    d188:	fa cf       	rjmp	.-12     	; 0xd17e <u8g_com_atmega_st7920_hw_spi_fn+0x62>
    d18a:	64 2f       	mov	r22, r20
    d18c:	fc 01       	movw	r30, r24
    d18e:	86 a1       	ldd	r24, Z+38	; 0x26
      }
      else
      {
        /* u8g_SetPILevel(u8g, U8G_PI_SCK, 0 ); */
        /* enable */
        u8g_SetPILevel(u8g, U8G_PI_CS, 1); /* CS = 1 (high active) */
    d190:	ae df       	rcall	.-164    	; 0xd0ee <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1>
    d192:	1a c0       	rjmp	.+52     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
      }
      break;
      

    case U8G_COM_MSG_WRITE_BYTE:
      u8g_com_atmega_st7920_write_byte_hw_spi(u8g, u8g->pin_list[U8G_PI_A0_STATE], arg_val);
    d194:	44 23       	and	r20, r20
    d196:	c1 f0       	breq	.+48     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
    d198:	f7 01       	movw	r30, r14
    d19a:	61 91       	ld	r22, Z+
    d19c:	7f 01       	movw	r14, r30
      //u8g->pin_list[U8G_PI_A0_STATE] = 2; 
      break;
    d19e:	f6 01       	movw	r30, r12
    
    case U8G_COM_MSG_WRITE_SEQ:
      {
        register uint8_t *ptr = arg_ptr;
        while( arg_val > 0 )
    d1a0:	86 a1       	ldd	r24, Z+38	; 0x26
    d1a2:	49 83       	std	Y+1, r20	; 0x01
        {
          u8g_com_atmega_st7920_write_byte_hw_spi(u8g, u8g->pin_list[U8G_PI_A0_STATE], *ptr++);
    d1a4:	a4 df       	rcall	.-184    	; 0xd0ee <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1>
    d1a6:	49 81       	ldd	r20, Y+1	; 0x01
    d1a8:	41 50       	subi	r20, 0x01	; 1
    d1aa:	f4 cf       	rjmp	.-24     	; 0xd194 <u8g_com_atmega_st7920_hw_spi_fn+0x78>
    d1ac:	44 23       	and	r20, r20
    d1ae:	61 f0       	breq	.+24     	; 0xd1c8 <u8g_com_atmega_st7920_hw_spi_fn+0xac>
    d1b0:	f7 01       	movw	r30, r14
    d1b2:	64 91       	lpm	r22, Z
	  //u8g->pin_list[U8G_PI_A0_STATE] = 2; 
          arg_val--;
    d1b4:	f6 01       	movw	r30, r12
    d1b6:	86 a1       	ldd	r24, Z+38	; 0x26
    d1b8:	49 83       	std	Y+1, r20	; 0x01
      break;

      case U8G_COM_MSG_WRITE_SEQ_P:
      {
        register uint8_t *ptr = arg_ptr;
        while( arg_val > 0 )
    d1ba:	99 df       	rcall	.-206    	; 0xd0ee <u8g_com_atmega_st7920_write_byte_hw_spi.isra.1>
    d1bc:	ff ef       	ldi	r31, 0xFF	; 255
        {
          u8g_com_atmega_st7920_write_byte_hw_spi(u8g, u8g->pin_list[U8G_PI_A0_STATE], u8g_pgm_read(ptr));
    d1be:	ef 1a       	sub	r14, r31
    d1c0:	ff 0a       	sbc	r15, r31
    d1c2:	49 81       	ldd	r20, Y+1	; 0x01
    d1c4:	41 50       	subi	r20, 0x01	; 1
    d1c6:	f2 cf       	rjmp	.-28     	; 0xd1ac <u8g_com_atmega_st7920_hw_spi_fn+0x90>
    d1c8:	81 e0       	ldi	r24, 0x01	; 1
    d1ca:	21 96       	adiw	r28, 0x01	; 1
	  //u8g->pin_list[U8G_PI_A0_STATE] = 2; 
          ptr++;
    d1cc:	e8 e0       	ldi	r30, 0x08	; 8
    d1ce:	d9 c2       	rjmp	.+1458   	; 0xd782 <__epilogue_restores__+0x14>

0000d1d0 <u8g_Delay>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    d1d0:	2e e9       	ldi	r18, 0x9E	; 158
    d1d2:	3f e0       	ldi	r19, 0x0F	; 15
  ==> must be devided by 4, rounded up 7/4 = 2
*/
void u8g_Delay(uint16_t val)
{
  /* old version did a call to the arduino lib: delay(val); */
  while( val != 0 )
    d1d4:	00 97       	sbiw	r24, 0x00	; 0
    d1d6:	29 f0       	breq	.+10     	; 0xd1e2 <u8g_Delay+0x12>
    d1d8:	f9 01       	movw	r30, r18
    d1da:	31 97       	sbiw	r30, 0x01	; 1
    d1dc:	f1 f7       	brne	.-4      	; 0xd1da <u8g_Delay+0xa>
  {
    _delay_loop_2( (F_CPU / 4000 ) -2);
    val--;
    d1de:	01 97       	sbiw	r24, 0x01	; 1
    d1e0:	f9 cf       	rjmp	.-14     	; 0xd1d4 <u8g_Delay+0x4>
  }
}
    d1e2:	08 95       	ret

0000d1e4 <u8g_10MicroDelay>:
    d1e4:	88 e2       	ldi	r24, 0x28	; 40
    d1e6:	90 e0       	ldi	r25, 0x00	; 0
    d1e8:	01 97       	sbiw	r24, 0x01	; 1
    d1ea:	f1 f7       	brne	.-4      	; 0xd1e8 <u8g_10MicroDelay+0x4>
    d1ec:	08 95       	ret

0000d1ee <u8g_page_First>:
  p->page = 0;
  u8g_page_First(p);
}

void u8g_page_First(u8g_page_t *p)
{
    d1ee:	fc 01       	movw	r30, r24
  p->page_y0 = 0;
    d1f0:	12 82       	std	Z+2, r1	; 0x02
  p->page_y1 = p->page_height;
  p->page_y1--;
    d1f2:	80 81       	ld	r24, Z
    d1f4:	81 50       	subi	r24, 0x01	; 1
    d1f6:	83 83       	std	Z+3, r24	; 0x03
  p->page = 0;
    d1f8:	14 82       	std	Z+4, r1	; 0x04
    d1fa:	08 95       	ret

0000d1fc <u8g_page_Next>:
}

uint8_t u8g_page_Next(u8g_page_t * p)
{
    d1fc:	fc 01       	movw	r30, r24
  register u8g_uint_t y1;
  p->page_y0 += p->page_height;
    d1fe:	20 81       	ld	r18, Z
    d200:	82 81       	ldd	r24, Z+2	; 0x02
    d202:	82 0f       	add	r24, r18
    d204:	82 83       	std	Z+2, r24	; 0x02
  if ( p->page_y0 >= p->total_height )
    d206:	91 81       	ldd	r25, Z+1	; 0x01
    d208:	89 17       	cp	r24, r25
    d20a:	60 f4       	brcc	.+24     	; 0xd224 <u8g_page_Next+0x28>
    return 0;
  p->page++;
    d20c:	84 81       	ldd	r24, Z+4	; 0x04
    d20e:	8f 5f       	subi	r24, 0xFF	; 255
    d210:	84 83       	std	Z+4, r24	; 0x04
  y1 = p->page_y1;
    d212:	83 81       	ldd	r24, Z+3	; 0x03
  y1 += p->page_height;
    d214:	82 0f       	add	r24, r18
  if ( y1 >= p->total_height )
    d216:	89 17       	cp	r24, r25
    d218:	10 f0       	brcs	.+4      	; 0xd21e <u8g_page_Next+0x22>
  {
    y1 = p->total_height;
    y1--;
    d21a:	8f ef       	ldi	r24, 0xFF	; 255
    d21c:	89 0f       	add	r24, r25
  }
  p->page_y1 = y1;
    d21e:	83 83       	std	Z+3, r24	; 0x03
  
  return 1;
    d220:	81 e0       	ldi	r24, 0x01	; 1
    d222:	08 95       	ret
uint8_t u8g_page_Next(u8g_page_t * p)
{
  register u8g_uint_t y1;
  p->page_y0 += p->page_height;
  if ( p->page_y0 >= p->total_height )
    return 0;
    d224:	80 e0       	ldi	r24, 0x00	; 0
    y1--;
  }
  p->page_y1 = y1;
  
  return 1;
}
    d226:	08 95       	ret

0000d228 <__subsf3>:
    d228:	50 58       	subi	r21, 0x80	; 128

0000d22a <__addsf3>:
    d22a:	bb 27       	eor	r27, r27
    d22c:	aa 27       	eor	r26, r26
    d22e:	0e d0       	rcall	.+28     	; 0xd24c <__addsf3x>
    d230:	75 c1       	rjmp	.+746    	; 0xd51c <__fp_round>
    d232:	66 d1       	rcall	.+716    	; 0xd500 <__fp_pscA>
    d234:	30 f0       	brcs	.+12     	; 0xd242 <__addsf3+0x18>
    d236:	6b d1       	rcall	.+726    	; 0xd50e <__fp_pscB>
    d238:	20 f0       	brcs	.+8      	; 0xd242 <__addsf3+0x18>
    d23a:	31 f4       	brne	.+12     	; 0xd248 <__addsf3+0x1e>
    d23c:	9f 3f       	cpi	r25, 0xFF	; 255
    d23e:	11 f4       	brne	.+4      	; 0xd244 <__addsf3+0x1a>
    d240:	1e f4       	brtc	.+6      	; 0xd248 <__addsf3+0x1e>
    d242:	5b c1       	rjmp	.+694    	; 0xd4fa <__fp_nan>
    d244:	0e f4       	brtc	.+2      	; 0xd248 <__addsf3+0x1e>
    d246:	e0 95       	com	r30
    d248:	e7 fb       	bst	r30, 7
    d24a:	51 c1       	rjmp	.+674    	; 0xd4ee <__fp_inf>

0000d24c <__addsf3x>:
    d24c:	e9 2f       	mov	r30, r25
    d24e:	77 d1       	rcall	.+750    	; 0xd53e <__fp_split3>
    d250:	80 f3       	brcs	.-32     	; 0xd232 <__addsf3+0x8>
    d252:	ba 17       	cp	r27, r26
    d254:	62 07       	cpc	r22, r18
    d256:	73 07       	cpc	r23, r19
    d258:	84 07       	cpc	r24, r20
    d25a:	95 07       	cpc	r25, r21
    d25c:	18 f0       	brcs	.+6      	; 0xd264 <__addsf3x+0x18>
    d25e:	71 f4       	brne	.+28     	; 0xd27c <__addsf3x+0x30>
    d260:	9e f5       	brtc	.+102    	; 0xd2c8 <__addsf3x+0x7c>
    d262:	8f c1       	rjmp	.+798    	; 0xd582 <__fp_zero>
    d264:	0e f4       	brtc	.+2      	; 0xd268 <__addsf3x+0x1c>
    d266:	e0 95       	com	r30
    d268:	0b 2e       	mov	r0, r27
    d26a:	ba 2f       	mov	r27, r26
    d26c:	a0 2d       	mov	r26, r0
    d26e:	0b 01       	movw	r0, r22
    d270:	b9 01       	movw	r22, r18
    d272:	90 01       	movw	r18, r0
    d274:	0c 01       	movw	r0, r24
    d276:	ca 01       	movw	r24, r20
    d278:	a0 01       	movw	r20, r0
    d27a:	11 24       	eor	r1, r1
    d27c:	ff 27       	eor	r31, r31
    d27e:	59 1b       	sub	r21, r25
    d280:	99 f0       	breq	.+38     	; 0xd2a8 <__addsf3x+0x5c>
    d282:	59 3f       	cpi	r21, 0xF9	; 249
    d284:	50 f4       	brcc	.+20     	; 0xd29a <__addsf3x+0x4e>
    d286:	50 3e       	cpi	r21, 0xE0	; 224
    d288:	68 f1       	brcs	.+90     	; 0xd2e4 <__addsf3x+0x98>
    d28a:	1a 16       	cp	r1, r26
    d28c:	f0 40       	sbci	r31, 0x00	; 0
    d28e:	a2 2f       	mov	r26, r18
    d290:	23 2f       	mov	r18, r19
    d292:	34 2f       	mov	r19, r20
    d294:	44 27       	eor	r20, r20
    d296:	58 5f       	subi	r21, 0xF8	; 248
    d298:	f3 cf       	rjmp	.-26     	; 0xd280 <__addsf3x+0x34>
    d29a:	46 95       	lsr	r20
    d29c:	37 95       	ror	r19
    d29e:	27 95       	ror	r18
    d2a0:	a7 95       	ror	r26
    d2a2:	f0 40       	sbci	r31, 0x00	; 0
    d2a4:	53 95       	inc	r21
    d2a6:	c9 f7       	brne	.-14     	; 0xd29a <__addsf3x+0x4e>
    d2a8:	7e f4       	brtc	.+30     	; 0xd2c8 <__addsf3x+0x7c>
    d2aa:	1f 16       	cp	r1, r31
    d2ac:	ba 0b       	sbc	r27, r26
    d2ae:	62 0b       	sbc	r22, r18
    d2b0:	73 0b       	sbc	r23, r19
    d2b2:	84 0b       	sbc	r24, r20
    d2b4:	ba f0       	brmi	.+46     	; 0xd2e4 <__addsf3x+0x98>
    d2b6:	91 50       	subi	r25, 0x01	; 1
    d2b8:	a1 f0       	breq	.+40     	; 0xd2e2 <__addsf3x+0x96>
    d2ba:	ff 0f       	add	r31, r31
    d2bc:	bb 1f       	adc	r27, r27
    d2be:	66 1f       	adc	r22, r22
    d2c0:	77 1f       	adc	r23, r23
    d2c2:	88 1f       	adc	r24, r24
    d2c4:	c2 f7       	brpl	.-16     	; 0xd2b6 <__addsf3x+0x6a>
    d2c6:	0e c0       	rjmp	.+28     	; 0xd2e4 <__addsf3x+0x98>
    d2c8:	ba 0f       	add	r27, r26
    d2ca:	62 1f       	adc	r22, r18
    d2cc:	73 1f       	adc	r23, r19
    d2ce:	84 1f       	adc	r24, r20
    d2d0:	48 f4       	brcc	.+18     	; 0xd2e4 <__addsf3x+0x98>
    d2d2:	87 95       	ror	r24
    d2d4:	77 95       	ror	r23
    d2d6:	67 95       	ror	r22
    d2d8:	b7 95       	ror	r27
    d2da:	f7 95       	ror	r31
    d2dc:	9e 3f       	cpi	r25, 0xFE	; 254
    d2de:	08 f0       	brcs	.+2      	; 0xd2e2 <__addsf3x+0x96>
    d2e0:	b3 cf       	rjmp	.-154    	; 0xd248 <__addsf3+0x1e>
    d2e2:	93 95       	inc	r25
    d2e4:	88 0f       	add	r24, r24
    d2e6:	08 f0       	brcs	.+2      	; 0xd2ea <__addsf3x+0x9e>
    d2e8:	99 27       	eor	r25, r25
    d2ea:	ee 0f       	add	r30, r30
    d2ec:	97 95       	ror	r25
    d2ee:	87 95       	ror	r24
    d2f0:	08 95       	ret

0000d2f2 <__cmpsf2>:
    d2f2:	d9 d0       	rcall	.+434    	; 0xd4a6 <__fp_cmp>
    d2f4:	08 f4       	brcc	.+2      	; 0xd2f8 <__cmpsf2+0x6>
    d2f6:	81 e0       	ldi	r24, 0x01	; 1
    d2f8:	08 95       	ret

0000d2fa <__divsf3>:
    d2fa:	0c d0       	rcall	.+24     	; 0xd314 <__divsf3x>
    d2fc:	0f c1       	rjmp	.+542    	; 0xd51c <__fp_round>
    d2fe:	07 d1       	rcall	.+526    	; 0xd50e <__fp_pscB>
    d300:	40 f0       	brcs	.+16     	; 0xd312 <__divsf3+0x18>
    d302:	fe d0       	rcall	.+508    	; 0xd500 <__fp_pscA>
    d304:	30 f0       	brcs	.+12     	; 0xd312 <__divsf3+0x18>
    d306:	21 f4       	brne	.+8      	; 0xd310 <__divsf3+0x16>
    d308:	5f 3f       	cpi	r21, 0xFF	; 255
    d30a:	19 f0       	breq	.+6      	; 0xd312 <__divsf3+0x18>
    d30c:	f0 c0       	rjmp	.+480    	; 0xd4ee <__fp_inf>
    d30e:	51 11       	cpse	r21, r1
    d310:	39 c1       	rjmp	.+626    	; 0xd584 <__fp_szero>
    d312:	f3 c0       	rjmp	.+486    	; 0xd4fa <__fp_nan>

0000d314 <__divsf3x>:
    d314:	14 d1       	rcall	.+552    	; 0xd53e <__fp_split3>
    d316:	98 f3       	brcs	.-26     	; 0xd2fe <__divsf3+0x4>

0000d318 <__divsf3_pse>:
    d318:	99 23       	and	r25, r25
    d31a:	c9 f3       	breq	.-14     	; 0xd30e <__divsf3+0x14>
    d31c:	55 23       	and	r21, r21
    d31e:	b1 f3       	breq	.-20     	; 0xd30c <__divsf3+0x12>
    d320:	95 1b       	sub	r25, r21
    d322:	55 0b       	sbc	r21, r21
    d324:	bb 27       	eor	r27, r27
    d326:	aa 27       	eor	r26, r26
    d328:	62 17       	cp	r22, r18
    d32a:	73 07       	cpc	r23, r19
    d32c:	84 07       	cpc	r24, r20
    d32e:	38 f0       	brcs	.+14     	; 0xd33e <__divsf3_pse+0x26>
    d330:	9f 5f       	subi	r25, 0xFF	; 255
    d332:	5f 4f       	sbci	r21, 0xFF	; 255
    d334:	22 0f       	add	r18, r18
    d336:	33 1f       	adc	r19, r19
    d338:	44 1f       	adc	r20, r20
    d33a:	aa 1f       	adc	r26, r26
    d33c:	a9 f3       	breq	.-22     	; 0xd328 <__divsf3_pse+0x10>
    d33e:	33 d0       	rcall	.+102    	; 0xd3a6 <__divsf3_pse+0x8e>
    d340:	0e 2e       	mov	r0, r30
    d342:	3a f0       	brmi	.+14     	; 0xd352 <__divsf3_pse+0x3a>
    d344:	e0 e8       	ldi	r30, 0x80	; 128
    d346:	30 d0       	rcall	.+96     	; 0xd3a8 <__divsf3_pse+0x90>
    d348:	91 50       	subi	r25, 0x01	; 1
    d34a:	50 40       	sbci	r21, 0x00	; 0
    d34c:	e6 95       	lsr	r30
    d34e:	00 1c       	adc	r0, r0
    d350:	ca f7       	brpl	.-14     	; 0xd344 <__divsf3_pse+0x2c>
    d352:	29 d0       	rcall	.+82     	; 0xd3a6 <__divsf3_pse+0x8e>
    d354:	fe 2f       	mov	r31, r30
    d356:	27 d0       	rcall	.+78     	; 0xd3a6 <__divsf3_pse+0x8e>
    d358:	66 0f       	add	r22, r22
    d35a:	77 1f       	adc	r23, r23
    d35c:	88 1f       	adc	r24, r24
    d35e:	bb 1f       	adc	r27, r27
    d360:	26 17       	cp	r18, r22
    d362:	37 07       	cpc	r19, r23
    d364:	48 07       	cpc	r20, r24
    d366:	ab 07       	cpc	r26, r27
    d368:	b0 e8       	ldi	r27, 0x80	; 128
    d36a:	09 f0       	breq	.+2      	; 0xd36e <__divsf3_pse+0x56>
    d36c:	bb 0b       	sbc	r27, r27
    d36e:	80 2d       	mov	r24, r0
    d370:	bf 01       	movw	r22, r30
    d372:	ff 27       	eor	r31, r31
    d374:	93 58       	subi	r25, 0x83	; 131
    d376:	5f 4f       	sbci	r21, 0xFF	; 255
    d378:	2a f0       	brmi	.+10     	; 0xd384 <__divsf3_pse+0x6c>
    d37a:	9e 3f       	cpi	r25, 0xFE	; 254
    d37c:	51 05       	cpc	r21, r1
    d37e:	68 f0       	brcs	.+26     	; 0xd39a <__divsf3_pse+0x82>
    d380:	b6 c0       	rjmp	.+364    	; 0xd4ee <__fp_inf>
    d382:	00 c1       	rjmp	.+512    	; 0xd584 <__fp_szero>
    d384:	5f 3f       	cpi	r21, 0xFF	; 255
    d386:	ec f3       	brlt	.-6      	; 0xd382 <__divsf3_pse+0x6a>
    d388:	98 3e       	cpi	r25, 0xE8	; 232
    d38a:	dc f3       	brlt	.-10     	; 0xd382 <__divsf3_pse+0x6a>
    d38c:	86 95       	lsr	r24
    d38e:	77 95       	ror	r23
    d390:	67 95       	ror	r22
    d392:	b7 95       	ror	r27
    d394:	f7 95       	ror	r31
    d396:	9f 5f       	subi	r25, 0xFF	; 255
    d398:	c9 f7       	brne	.-14     	; 0xd38c <__divsf3_pse+0x74>
    d39a:	88 0f       	add	r24, r24
    d39c:	91 1d       	adc	r25, r1
    d39e:	96 95       	lsr	r25
    d3a0:	87 95       	ror	r24
    d3a2:	97 f9       	bld	r25, 7
    d3a4:	08 95       	ret
    d3a6:	e1 e0       	ldi	r30, 0x01	; 1
    d3a8:	66 0f       	add	r22, r22
    d3aa:	77 1f       	adc	r23, r23
    d3ac:	88 1f       	adc	r24, r24
    d3ae:	bb 1f       	adc	r27, r27
    d3b0:	62 17       	cp	r22, r18
    d3b2:	73 07       	cpc	r23, r19
    d3b4:	84 07       	cpc	r24, r20
    d3b6:	ba 07       	cpc	r27, r26
    d3b8:	20 f0       	brcs	.+8      	; 0xd3c2 <__divsf3_pse+0xaa>
    d3ba:	62 1b       	sub	r22, r18
    d3bc:	73 0b       	sbc	r23, r19
    d3be:	84 0b       	sbc	r24, r20
    d3c0:	ba 0b       	sbc	r27, r26
    d3c2:	ee 1f       	adc	r30, r30
    d3c4:	88 f7       	brcc	.-30     	; 0xd3a8 <__divsf3_pse+0x90>
    d3c6:	e0 95       	com	r30
    d3c8:	08 95       	ret

0000d3ca <__fixsfsi>:
    d3ca:	04 d0       	rcall	.+8      	; 0xd3d4 <__fixunssfsi>
    d3cc:	68 94       	set
    d3ce:	b1 11       	cpse	r27, r1
    d3d0:	d9 c0       	rjmp	.+434    	; 0xd584 <__fp_szero>
    d3d2:	08 95       	ret

0000d3d4 <__fixunssfsi>:
    d3d4:	bc d0       	rcall	.+376    	; 0xd54e <__fp_splitA>
    d3d6:	88 f0       	brcs	.+34     	; 0xd3fa <__fixunssfsi+0x26>
    d3d8:	9f 57       	subi	r25, 0x7F	; 127
    d3da:	90 f0       	brcs	.+36     	; 0xd400 <__fixunssfsi+0x2c>
    d3dc:	b9 2f       	mov	r27, r25
    d3de:	99 27       	eor	r25, r25
    d3e0:	b7 51       	subi	r27, 0x17	; 23
    d3e2:	a0 f0       	brcs	.+40     	; 0xd40c <__fixunssfsi+0x38>
    d3e4:	d1 f0       	breq	.+52     	; 0xd41a <__fixunssfsi+0x46>
    d3e6:	66 0f       	add	r22, r22
    d3e8:	77 1f       	adc	r23, r23
    d3ea:	88 1f       	adc	r24, r24
    d3ec:	99 1f       	adc	r25, r25
    d3ee:	1a f0       	brmi	.+6      	; 0xd3f6 <__fixunssfsi+0x22>
    d3f0:	ba 95       	dec	r27
    d3f2:	c9 f7       	brne	.-14     	; 0xd3e6 <__fixunssfsi+0x12>
    d3f4:	12 c0       	rjmp	.+36     	; 0xd41a <__fixunssfsi+0x46>
    d3f6:	b1 30       	cpi	r27, 0x01	; 1
    d3f8:	81 f0       	breq	.+32     	; 0xd41a <__fixunssfsi+0x46>
    d3fa:	c3 d0       	rcall	.+390    	; 0xd582 <__fp_zero>
    d3fc:	b1 e0       	ldi	r27, 0x01	; 1
    d3fe:	08 95       	ret
    d400:	c0 c0       	rjmp	.+384    	; 0xd582 <__fp_zero>
    d402:	67 2f       	mov	r22, r23
    d404:	78 2f       	mov	r23, r24
    d406:	88 27       	eor	r24, r24
    d408:	b8 5f       	subi	r27, 0xF8	; 248
    d40a:	39 f0       	breq	.+14     	; 0xd41a <__fixunssfsi+0x46>
    d40c:	b9 3f       	cpi	r27, 0xF9	; 249
    d40e:	cc f3       	brlt	.-14     	; 0xd402 <__fixunssfsi+0x2e>
    d410:	86 95       	lsr	r24
    d412:	77 95       	ror	r23
    d414:	67 95       	ror	r22
    d416:	b3 95       	inc	r27
    d418:	d9 f7       	brne	.-10     	; 0xd410 <__fixunssfsi+0x3c>
    d41a:	3e f4       	brtc	.+14     	; 0xd42a <__fixunssfsi+0x56>
    d41c:	90 95       	com	r25
    d41e:	80 95       	com	r24
    d420:	70 95       	com	r23
    d422:	61 95       	neg	r22
    d424:	7f 4f       	sbci	r23, 0xFF	; 255
    d426:	8f 4f       	sbci	r24, 0xFF	; 255
    d428:	9f 4f       	sbci	r25, 0xFF	; 255
    d42a:	08 95       	ret

0000d42c <__floatunsisf>:
    d42c:	e8 94       	clt
    d42e:	09 c0       	rjmp	.+18     	; 0xd442 <__floatsisf+0x12>

0000d430 <__floatsisf>:
    d430:	97 fb       	bst	r25, 7
    d432:	3e f4       	brtc	.+14     	; 0xd442 <__floatsisf+0x12>
    d434:	90 95       	com	r25
    d436:	80 95       	com	r24
    d438:	70 95       	com	r23
    d43a:	61 95       	neg	r22
    d43c:	7f 4f       	sbci	r23, 0xFF	; 255
    d43e:	8f 4f       	sbci	r24, 0xFF	; 255
    d440:	9f 4f       	sbci	r25, 0xFF	; 255
    d442:	99 23       	and	r25, r25
    d444:	a9 f0       	breq	.+42     	; 0xd470 <__floatsisf+0x40>
    d446:	f9 2f       	mov	r31, r25
    d448:	96 e9       	ldi	r25, 0x96	; 150
    d44a:	bb 27       	eor	r27, r27
    d44c:	93 95       	inc	r25
    d44e:	f6 95       	lsr	r31
    d450:	87 95       	ror	r24
    d452:	77 95       	ror	r23
    d454:	67 95       	ror	r22
    d456:	b7 95       	ror	r27
    d458:	f1 11       	cpse	r31, r1
    d45a:	f8 cf       	rjmp	.-16     	; 0xd44c <__floatsisf+0x1c>
    d45c:	fa f4       	brpl	.+62     	; 0xd49c <__floatsisf+0x6c>
    d45e:	bb 0f       	add	r27, r27
    d460:	11 f4       	brne	.+4      	; 0xd466 <__floatsisf+0x36>
    d462:	60 ff       	sbrs	r22, 0
    d464:	1b c0       	rjmp	.+54     	; 0xd49c <__floatsisf+0x6c>
    d466:	6f 5f       	subi	r22, 0xFF	; 255
    d468:	7f 4f       	sbci	r23, 0xFF	; 255
    d46a:	8f 4f       	sbci	r24, 0xFF	; 255
    d46c:	9f 4f       	sbci	r25, 0xFF	; 255
    d46e:	16 c0       	rjmp	.+44     	; 0xd49c <__floatsisf+0x6c>
    d470:	88 23       	and	r24, r24
    d472:	11 f0       	breq	.+4      	; 0xd478 <__floatsisf+0x48>
    d474:	96 e9       	ldi	r25, 0x96	; 150
    d476:	11 c0       	rjmp	.+34     	; 0xd49a <__floatsisf+0x6a>
    d478:	77 23       	and	r23, r23
    d47a:	21 f0       	breq	.+8      	; 0xd484 <__floatsisf+0x54>
    d47c:	9e e8       	ldi	r25, 0x8E	; 142
    d47e:	87 2f       	mov	r24, r23
    d480:	76 2f       	mov	r23, r22
    d482:	05 c0       	rjmp	.+10     	; 0xd48e <__floatsisf+0x5e>
    d484:	66 23       	and	r22, r22
    d486:	71 f0       	breq	.+28     	; 0xd4a4 <__floatsisf+0x74>
    d488:	96 e8       	ldi	r25, 0x86	; 134
    d48a:	86 2f       	mov	r24, r22
    d48c:	70 e0       	ldi	r23, 0x00	; 0
    d48e:	60 e0       	ldi	r22, 0x00	; 0
    d490:	2a f0       	brmi	.+10     	; 0xd49c <__floatsisf+0x6c>
    d492:	9a 95       	dec	r25
    d494:	66 0f       	add	r22, r22
    d496:	77 1f       	adc	r23, r23
    d498:	88 1f       	adc	r24, r24
    d49a:	da f7       	brpl	.-10     	; 0xd492 <__floatsisf+0x62>
    d49c:	88 0f       	add	r24, r24
    d49e:	96 95       	lsr	r25
    d4a0:	87 95       	ror	r24
    d4a2:	97 f9       	bld	r25, 7
    d4a4:	08 95       	ret

0000d4a6 <__fp_cmp>:
    d4a6:	99 0f       	add	r25, r25
    d4a8:	00 08       	sbc	r0, r0
    d4aa:	55 0f       	add	r21, r21
    d4ac:	aa 0b       	sbc	r26, r26
    d4ae:	e0 e8       	ldi	r30, 0x80	; 128
    d4b0:	fe ef       	ldi	r31, 0xFE	; 254
    d4b2:	16 16       	cp	r1, r22
    d4b4:	17 06       	cpc	r1, r23
    d4b6:	e8 07       	cpc	r30, r24
    d4b8:	f9 07       	cpc	r31, r25
    d4ba:	c0 f0       	brcs	.+48     	; 0xd4ec <__fp_cmp+0x46>
    d4bc:	12 16       	cp	r1, r18
    d4be:	13 06       	cpc	r1, r19
    d4c0:	e4 07       	cpc	r30, r20
    d4c2:	f5 07       	cpc	r31, r21
    d4c4:	98 f0       	brcs	.+38     	; 0xd4ec <__fp_cmp+0x46>
    d4c6:	62 1b       	sub	r22, r18
    d4c8:	73 0b       	sbc	r23, r19
    d4ca:	84 0b       	sbc	r24, r20
    d4cc:	95 0b       	sbc	r25, r21
    d4ce:	39 f4       	brne	.+14     	; 0xd4de <__fp_cmp+0x38>
    d4d0:	0a 26       	eor	r0, r26
    d4d2:	61 f0       	breq	.+24     	; 0xd4ec <__fp_cmp+0x46>
    d4d4:	23 2b       	or	r18, r19
    d4d6:	24 2b       	or	r18, r20
    d4d8:	25 2b       	or	r18, r21
    d4da:	21 f4       	brne	.+8      	; 0xd4e4 <__fp_cmp+0x3e>
    d4dc:	08 95       	ret
    d4de:	0a 26       	eor	r0, r26
    d4e0:	09 f4       	brne	.+2      	; 0xd4e4 <__fp_cmp+0x3e>
    d4e2:	a1 40       	sbci	r26, 0x01	; 1
    d4e4:	a6 95       	lsr	r26
    d4e6:	8f ef       	ldi	r24, 0xFF	; 255
    d4e8:	81 1d       	adc	r24, r1
    d4ea:	81 1d       	adc	r24, r1
    d4ec:	08 95       	ret

0000d4ee <__fp_inf>:
    d4ee:	97 f9       	bld	r25, 7
    d4f0:	9f 67       	ori	r25, 0x7F	; 127
    d4f2:	80 e8       	ldi	r24, 0x80	; 128
    d4f4:	70 e0       	ldi	r23, 0x00	; 0
    d4f6:	60 e0       	ldi	r22, 0x00	; 0
    d4f8:	08 95       	ret

0000d4fa <__fp_nan>:
    d4fa:	9f ef       	ldi	r25, 0xFF	; 255
    d4fc:	80 ec       	ldi	r24, 0xC0	; 192
    d4fe:	08 95       	ret

0000d500 <__fp_pscA>:
    d500:	00 24       	eor	r0, r0
    d502:	0a 94       	dec	r0
    d504:	16 16       	cp	r1, r22
    d506:	17 06       	cpc	r1, r23
    d508:	18 06       	cpc	r1, r24
    d50a:	09 06       	cpc	r0, r25
    d50c:	08 95       	ret

0000d50e <__fp_pscB>:
    d50e:	00 24       	eor	r0, r0
    d510:	0a 94       	dec	r0
    d512:	12 16       	cp	r1, r18
    d514:	13 06       	cpc	r1, r19
    d516:	14 06       	cpc	r1, r20
    d518:	05 06       	cpc	r0, r21
    d51a:	08 95       	ret

0000d51c <__fp_round>:
    d51c:	09 2e       	mov	r0, r25
    d51e:	03 94       	inc	r0
    d520:	00 0c       	add	r0, r0
    d522:	11 f4       	brne	.+4      	; 0xd528 <__fp_round+0xc>
    d524:	88 23       	and	r24, r24
    d526:	52 f0       	brmi	.+20     	; 0xd53c <__fp_round+0x20>
    d528:	bb 0f       	add	r27, r27
    d52a:	40 f4       	brcc	.+16     	; 0xd53c <__fp_round+0x20>
    d52c:	bf 2b       	or	r27, r31
    d52e:	11 f4       	brne	.+4      	; 0xd534 <__fp_round+0x18>
    d530:	60 ff       	sbrs	r22, 0
    d532:	04 c0       	rjmp	.+8      	; 0xd53c <__fp_round+0x20>
    d534:	6f 5f       	subi	r22, 0xFF	; 255
    d536:	7f 4f       	sbci	r23, 0xFF	; 255
    d538:	8f 4f       	sbci	r24, 0xFF	; 255
    d53a:	9f 4f       	sbci	r25, 0xFF	; 255
    d53c:	08 95       	ret

0000d53e <__fp_split3>:
    d53e:	57 fd       	sbrc	r21, 7
    d540:	90 58       	subi	r25, 0x80	; 128
    d542:	44 0f       	add	r20, r20
    d544:	55 1f       	adc	r21, r21
    d546:	59 f0       	breq	.+22     	; 0xd55e <__fp_splitA+0x10>
    d548:	5f 3f       	cpi	r21, 0xFF	; 255
    d54a:	71 f0       	breq	.+28     	; 0xd568 <__fp_splitA+0x1a>
    d54c:	47 95       	ror	r20

0000d54e <__fp_splitA>:
    d54e:	88 0f       	add	r24, r24
    d550:	97 fb       	bst	r25, 7
    d552:	99 1f       	adc	r25, r25
    d554:	61 f0       	breq	.+24     	; 0xd56e <__fp_splitA+0x20>
    d556:	9f 3f       	cpi	r25, 0xFF	; 255
    d558:	79 f0       	breq	.+30     	; 0xd578 <__fp_splitA+0x2a>
    d55a:	87 95       	ror	r24
    d55c:	08 95       	ret
    d55e:	12 16       	cp	r1, r18
    d560:	13 06       	cpc	r1, r19
    d562:	14 06       	cpc	r1, r20
    d564:	55 1f       	adc	r21, r21
    d566:	f2 cf       	rjmp	.-28     	; 0xd54c <__fp_split3+0xe>
    d568:	46 95       	lsr	r20
    d56a:	f1 df       	rcall	.-30     	; 0xd54e <__fp_splitA>
    d56c:	08 c0       	rjmp	.+16     	; 0xd57e <__fp_splitA+0x30>
    d56e:	16 16       	cp	r1, r22
    d570:	17 06       	cpc	r1, r23
    d572:	18 06       	cpc	r1, r24
    d574:	99 1f       	adc	r25, r25
    d576:	f1 cf       	rjmp	.-30     	; 0xd55a <__fp_splitA+0xc>
    d578:	86 95       	lsr	r24
    d57a:	71 05       	cpc	r23, r1
    d57c:	61 05       	cpc	r22, r1
    d57e:	08 94       	sec
    d580:	08 95       	ret

0000d582 <__fp_zero>:
    d582:	e8 94       	clt

0000d584 <__fp_szero>:
    d584:	bb 27       	eor	r27, r27
    d586:	66 27       	eor	r22, r22
    d588:	77 27       	eor	r23, r23
    d58a:	cb 01       	movw	r24, r22
    d58c:	97 f9       	bld	r25, 7
    d58e:	08 95       	ret

0000d590 <__gesf2>:
    d590:	8a df       	rcall	.-236    	; 0xd4a6 <__fp_cmp>
    d592:	08 f4       	brcc	.+2      	; 0xd596 <__gesf2+0x6>
    d594:	8f ef       	ldi	r24, 0xFF	; 255
    d596:	08 95       	ret

0000d598 <__mulsf3>:
    d598:	0b d0       	rcall	.+22     	; 0xd5b0 <__mulsf3x>
    d59a:	c0 cf       	rjmp	.-128    	; 0xd51c <__fp_round>
    d59c:	b1 df       	rcall	.-158    	; 0xd500 <__fp_pscA>
    d59e:	28 f0       	brcs	.+10     	; 0xd5aa <__mulsf3+0x12>
    d5a0:	b6 df       	rcall	.-148    	; 0xd50e <__fp_pscB>
    d5a2:	18 f0       	brcs	.+6      	; 0xd5aa <__mulsf3+0x12>
    d5a4:	95 23       	and	r25, r21
    d5a6:	09 f0       	breq	.+2      	; 0xd5aa <__mulsf3+0x12>
    d5a8:	a2 cf       	rjmp	.-188    	; 0xd4ee <__fp_inf>
    d5aa:	a7 cf       	rjmp	.-178    	; 0xd4fa <__fp_nan>
    d5ac:	11 24       	eor	r1, r1
    d5ae:	ea cf       	rjmp	.-44     	; 0xd584 <__fp_szero>

0000d5b0 <__mulsf3x>:
    d5b0:	c6 df       	rcall	.-116    	; 0xd53e <__fp_split3>
    d5b2:	a0 f3       	brcs	.-24     	; 0xd59c <__mulsf3+0x4>

0000d5b4 <__mulsf3_pse>:
    d5b4:	95 9f       	mul	r25, r21
    d5b6:	d1 f3       	breq	.-12     	; 0xd5ac <__mulsf3+0x14>
    d5b8:	95 0f       	add	r25, r21
    d5ba:	50 e0       	ldi	r21, 0x00	; 0
    d5bc:	55 1f       	adc	r21, r21
    d5be:	62 9f       	mul	r22, r18
    d5c0:	f0 01       	movw	r30, r0
    d5c2:	72 9f       	mul	r23, r18
    d5c4:	bb 27       	eor	r27, r27
    d5c6:	f0 0d       	add	r31, r0
    d5c8:	b1 1d       	adc	r27, r1
    d5ca:	63 9f       	mul	r22, r19
    d5cc:	aa 27       	eor	r26, r26
    d5ce:	f0 0d       	add	r31, r0
    d5d0:	b1 1d       	adc	r27, r1
    d5d2:	aa 1f       	adc	r26, r26
    d5d4:	64 9f       	mul	r22, r20
    d5d6:	66 27       	eor	r22, r22
    d5d8:	b0 0d       	add	r27, r0
    d5da:	a1 1d       	adc	r26, r1
    d5dc:	66 1f       	adc	r22, r22
    d5de:	82 9f       	mul	r24, r18
    d5e0:	22 27       	eor	r18, r18
    d5e2:	b0 0d       	add	r27, r0
    d5e4:	a1 1d       	adc	r26, r1
    d5e6:	62 1f       	adc	r22, r18
    d5e8:	73 9f       	mul	r23, r19
    d5ea:	b0 0d       	add	r27, r0
    d5ec:	a1 1d       	adc	r26, r1
    d5ee:	62 1f       	adc	r22, r18
    d5f0:	83 9f       	mul	r24, r19
    d5f2:	a0 0d       	add	r26, r0
    d5f4:	61 1d       	adc	r22, r1
    d5f6:	22 1f       	adc	r18, r18
    d5f8:	74 9f       	mul	r23, r20
    d5fa:	33 27       	eor	r19, r19
    d5fc:	a0 0d       	add	r26, r0
    d5fe:	61 1d       	adc	r22, r1
    d600:	23 1f       	adc	r18, r19
    d602:	84 9f       	mul	r24, r20
    d604:	60 0d       	add	r22, r0
    d606:	21 1d       	adc	r18, r1
    d608:	82 2f       	mov	r24, r18
    d60a:	76 2f       	mov	r23, r22
    d60c:	6a 2f       	mov	r22, r26
    d60e:	11 24       	eor	r1, r1
    d610:	9f 57       	subi	r25, 0x7F	; 127
    d612:	50 40       	sbci	r21, 0x00	; 0
    d614:	8a f0       	brmi	.+34     	; 0xd638 <__mulsf3_pse+0x84>
    d616:	e1 f0       	breq	.+56     	; 0xd650 <__mulsf3_pse+0x9c>
    d618:	88 23       	and	r24, r24
    d61a:	4a f0       	brmi	.+18     	; 0xd62e <__mulsf3_pse+0x7a>
    d61c:	ee 0f       	add	r30, r30
    d61e:	ff 1f       	adc	r31, r31
    d620:	bb 1f       	adc	r27, r27
    d622:	66 1f       	adc	r22, r22
    d624:	77 1f       	adc	r23, r23
    d626:	88 1f       	adc	r24, r24
    d628:	91 50       	subi	r25, 0x01	; 1
    d62a:	50 40       	sbci	r21, 0x00	; 0
    d62c:	a9 f7       	brne	.-22     	; 0xd618 <__mulsf3_pse+0x64>
    d62e:	9e 3f       	cpi	r25, 0xFE	; 254
    d630:	51 05       	cpc	r21, r1
    d632:	70 f0       	brcs	.+28     	; 0xd650 <__mulsf3_pse+0x9c>
    d634:	5c cf       	rjmp	.-328    	; 0xd4ee <__fp_inf>
    d636:	a6 cf       	rjmp	.-180    	; 0xd584 <__fp_szero>
    d638:	5f 3f       	cpi	r21, 0xFF	; 255
    d63a:	ec f3       	brlt	.-6      	; 0xd636 <__mulsf3_pse+0x82>
    d63c:	98 3e       	cpi	r25, 0xE8	; 232
    d63e:	dc f3       	brlt	.-10     	; 0xd636 <__mulsf3_pse+0x82>
    d640:	86 95       	lsr	r24
    d642:	77 95       	ror	r23
    d644:	67 95       	ror	r22
    d646:	b7 95       	ror	r27
    d648:	f7 95       	ror	r31
    d64a:	e7 95       	ror	r30
    d64c:	9f 5f       	subi	r25, 0xFF	; 255
    d64e:	c1 f7       	brne	.-16     	; 0xd640 <__mulsf3_pse+0x8c>
    d650:	fe 2b       	or	r31, r30
    d652:	88 0f       	add	r24, r24
    d654:	91 1d       	adc	r25, r1
    d656:	96 95       	lsr	r25
    d658:	87 95       	ror	r24
    d65a:	97 f9       	bld	r25, 7
    d65c:	08 95       	ret

0000d65e <__usmulhisi3>:
    d65e:	a8 d0       	rcall	.+336    	; 0xd7b0 <__umulhisi3>

0000d660 <__usmulhisi3_tail>:
    d660:	b7 ff       	sbrs	r27, 7
    d662:	08 95       	ret
    d664:	82 1b       	sub	r24, r18
    d666:	93 0b       	sbc	r25, r19
    d668:	08 95       	ret

0000d66a <__muluhisi3>:
    d66a:	a2 d0       	rcall	.+324    	; 0xd7b0 <__umulhisi3>
    d66c:	a5 9f       	mul	r26, r21
    d66e:	90 0d       	add	r25, r0
    d670:	b4 9f       	mul	r27, r20
    d672:	90 0d       	add	r25, r0
    d674:	a4 9f       	mul	r26, r20
    d676:	80 0d       	add	r24, r0
    d678:	91 1d       	adc	r25, r1
    d67a:	11 24       	eor	r1, r1
    d67c:	08 95       	ret

0000d67e <__udivmodqi4>:
    d67e:	99 1b       	sub	r25, r25
    d680:	79 e0       	ldi	r23, 0x09	; 9
    d682:	04 c0       	rjmp	.+8      	; 0xd68c <__udivmodqi4_ep>

0000d684 <__udivmodqi4_loop>:
    d684:	99 1f       	adc	r25, r25
    d686:	96 17       	cp	r25, r22
    d688:	08 f0       	brcs	.+2      	; 0xd68c <__udivmodqi4_ep>
    d68a:	96 1b       	sub	r25, r22

0000d68c <__udivmodqi4_ep>:
    d68c:	88 1f       	adc	r24, r24
    d68e:	7a 95       	dec	r23
    d690:	c9 f7       	brne	.-14     	; 0xd684 <__udivmodqi4_loop>
    d692:	80 95       	com	r24
    d694:	08 95       	ret

0000d696 <__divmodqi4>:
    d696:	87 fb       	bst	r24, 7
    d698:	08 2e       	mov	r0, r24
    d69a:	06 26       	eor	r0, r22
    d69c:	87 fd       	sbrc	r24, 7
    d69e:	81 95       	neg	r24
    d6a0:	67 fd       	sbrc	r22, 7
    d6a2:	61 95       	neg	r22
    d6a4:	ec df       	rcall	.-40     	; 0xd67e <__udivmodqi4>
    d6a6:	0e f4       	brtc	.+2      	; 0xd6aa <__divmodqi4_1>
    d6a8:	91 95       	neg	r25

0000d6aa <__divmodqi4_1>:
    d6aa:	07 fc       	sbrc	r0, 7
    d6ac:	81 95       	neg	r24

0000d6ae <__divmodqi4_exit>:
    d6ae:	08 95       	ret

0000d6b0 <__udivmodhi4>:
    d6b0:	aa 1b       	sub	r26, r26
    d6b2:	bb 1b       	sub	r27, r27
    d6b4:	51 e1       	ldi	r21, 0x11	; 17
    d6b6:	07 c0       	rjmp	.+14     	; 0xd6c6 <__udivmodhi4_ep>

0000d6b8 <__udivmodhi4_loop>:
    d6b8:	aa 1f       	adc	r26, r26
    d6ba:	bb 1f       	adc	r27, r27
    d6bc:	a6 17       	cp	r26, r22
    d6be:	b7 07       	cpc	r27, r23
    d6c0:	10 f0       	brcs	.+4      	; 0xd6c6 <__udivmodhi4_ep>
    d6c2:	a6 1b       	sub	r26, r22
    d6c4:	b7 0b       	sbc	r27, r23

0000d6c6 <__udivmodhi4_ep>:
    d6c6:	88 1f       	adc	r24, r24
    d6c8:	99 1f       	adc	r25, r25
    d6ca:	5a 95       	dec	r21
    d6cc:	a9 f7       	brne	.-22     	; 0xd6b8 <__udivmodhi4_loop>
    d6ce:	80 95       	com	r24
    d6d0:	90 95       	com	r25
    d6d2:	bc 01       	movw	r22, r24
    d6d4:	cd 01       	movw	r24, r26
    d6d6:	08 95       	ret

0000d6d8 <__divmodhi4>:
    d6d8:	97 fb       	bst	r25, 7
    d6da:	07 2e       	mov	r0, r23
    d6dc:	16 f4       	brtc	.+4      	; 0xd6e2 <__divmodhi4+0xa>
    d6de:	00 94       	com	r0
    d6e0:	06 d0       	rcall	.+12     	; 0xd6ee <__divmodhi4_neg1>
    d6e2:	77 fd       	sbrc	r23, 7
    d6e4:	08 d0       	rcall	.+16     	; 0xd6f6 <__divmodhi4_neg2>
    d6e6:	e4 df       	rcall	.-56     	; 0xd6b0 <__udivmodhi4>
    d6e8:	07 fc       	sbrc	r0, 7
    d6ea:	05 d0       	rcall	.+10     	; 0xd6f6 <__divmodhi4_neg2>
    d6ec:	3e f4       	brtc	.+14     	; 0xd6fc <__divmodhi4_exit>

0000d6ee <__divmodhi4_neg1>:
    d6ee:	90 95       	com	r25
    d6f0:	81 95       	neg	r24
    d6f2:	9f 4f       	sbci	r25, 0xFF	; 255
    d6f4:	08 95       	ret

0000d6f6 <__divmodhi4_neg2>:
    d6f6:	70 95       	com	r23
    d6f8:	61 95       	neg	r22
    d6fa:	7f 4f       	sbci	r23, 0xFF	; 255

0000d6fc <__divmodhi4_exit>:
    d6fc:	08 95       	ret

0000d6fe <__divmodsi4>:
    d6fe:	05 2e       	mov	r0, r21
    d700:	97 fb       	bst	r25, 7
    d702:	16 f4       	brtc	.+4      	; 0xd708 <__divmodsi4+0xa>
    d704:	00 94       	com	r0
    d706:	0f d0       	rcall	.+30     	; 0xd726 <__negsi2>
    d708:	57 fd       	sbrc	r21, 7
    d70a:	05 d0       	rcall	.+10     	; 0xd716 <__divmodsi4_neg2>
    d70c:	60 d0       	rcall	.+192    	; 0xd7ce <__udivmodsi4>
    d70e:	07 fc       	sbrc	r0, 7
    d710:	02 d0       	rcall	.+4      	; 0xd716 <__divmodsi4_neg2>
    d712:	46 f4       	brtc	.+16     	; 0xd724 <__divmodsi4_exit>
    d714:	08 c0       	rjmp	.+16     	; 0xd726 <__negsi2>

0000d716 <__divmodsi4_neg2>:
    d716:	50 95       	com	r21
    d718:	40 95       	com	r20
    d71a:	30 95       	com	r19
    d71c:	21 95       	neg	r18
    d71e:	3f 4f       	sbci	r19, 0xFF	; 255
    d720:	4f 4f       	sbci	r20, 0xFF	; 255
    d722:	5f 4f       	sbci	r21, 0xFF	; 255

0000d724 <__divmodsi4_exit>:
    d724:	08 95       	ret

0000d726 <__negsi2>:
    d726:	90 95       	com	r25
    d728:	80 95       	com	r24
    d72a:	70 95       	com	r23
    d72c:	61 95       	neg	r22
    d72e:	7f 4f       	sbci	r23, 0xFF	; 255
    d730:	8f 4f       	sbci	r24, 0xFF	; 255
    d732:	9f 4f       	sbci	r25, 0xFF	; 255
    d734:	08 95       	ret

0000d736 <__prologue_saves__>:
    d736:	2f 92       	push	r2
    d738:	3f 92       	push	r3
    d73a:	4f 92       	push	r4
    d73c:	5f 92       	push	r5
    d73e:	6f 92       	push	r6
    d740:	7f 92       	push	r7
    d742:	8f 92       	push	r8
    d744:	9f 92       	push	r9
    d746:	af 92       	push	r10
    d748:	bf 92       	push	r11
    d74a:	cf 92       	push	r12
    d74c:	df 92       	push	r13
    d74e:	ef 92       	push	r14
    d750:	ff 92       	push	r15
    d752:	0f 93       	push	r16
    d754:	1f 93       	push	r17
    d756:	cf 93       	push	r28
    d758:	df 93       	push	r29
    d75a:	cd b7       	in	r28, 0x3d	; 61
    d75c:	de b7       	in	r29, 0x3e	; 62
    d75e:	ca 1b       	sub	r28, r26
    d760:	db 0b       	sbc	r29, r27
    d762:	0f b6       	in	r0, 0x3f	; 63
    d764:	f8 94       	cli
    d766:	de bf       	out	0x3e, r29	; 62
    d768:	0f be       	out	0x3f, r0	; 63
    d76a:	cd bf       	out	0x3d, r28	; 61
    d76c:	19 94       	eijmp

0000d76e <__epilogue_restores__>:
    d76e:	2a 88       	ldd	r2, Y+18	; 0x12
    d770:	39 88       	ldd	r3, Y+17	; 0x11
    d772:	48 88       	ldd	r4, Y+16	; 0x10
    d774:	5f 84       	ldd	r5, Y+15	; 0x0f
    d776:	6e 84       	ldd	r6, Y+14	; 0x0e
    d778:	7d 84       	ldd	r7, Y+13	; 0x0d
    d77a:	8c 84       	ldd	r8, Y+12	; 0x0c
    d77c:	9b 84       	ldd	r9, Y+11	; 0x0b
    d77e:	aa 84       	ldd	r10, Y+10	; 0x0a
    d780:	b9 84       	ldd	r11, Y+9	; 0x09
    d782:	c8 84       	ldd	r12, Y+8	; 0x08
    d784:	df 80       	ldd	r13, Y+7	; 0x07
    d786:	ee 80       	ldd	r14, Y+6	; 0x06
    d788:	fd 80       	ldd	r15, Y+5	; 0x05
    d78a:	0c 81       	ldd	r16, Y+4	; 0x04
    d78c:	1b 81       	ldd	r17, Y+3	; 0x03
    d78e:	aa 81       	ldd	r26, Y+2	; 0x02
    d790:	b9 81       	ldd	r27, Y+1	; 0x01
    d792:	ce 0f       	add	r28, r30
    d794:	d1 1d       	adc	r29, r1
    d796:	0f b6       	in	r0, 0x3f	; 63
    d798:	f8 94       	cli
    d79a:	de bf       	out	0x3e, r29	; 62
    d79c:	0f be       	out	0x3f, r0	; 63
    d79e:	cd bf       	out	0x3d, r28	; 61
    d7a0:	ed 01       	movw	r28, r26
    d7a2:	08 95       	ret

0000d7a4 <__tablejump2__>:
    d7a4:	ee 0f       	add	r30, r30
    d7a6:	ff 1f       	adc	r31, r31

0000d7a8 <__tablejump__>:
    d7a8:	05 90       	lpm	r0, Z+
    d7aa:	f4 91       	lpm	r31, Z
    d7ac:	e0 2d       	mov	r30, r0
    d7ae:	19 94       	eijmp

0000d7b0 <__umulhisi3>:
    d7b0:	a2 9f       	mul	r26, r18
    d7b2:	b0 01       	movw	r22, r0
    d7b4:	b3 9f       	mul	r27, r19
    d7b6:	c0 01       	movw	r24, r0
    d7b8:	a3 9f       	mul	r26, r19
    d7ba:	70 0d       	add	r23, r0
    d7bc:	81 1d       	adc	r24, r1
    d7be:	11 24       	eor	r1, r1
    d7c0:	91 1d       	adc	r25, r1
    d7c2:	b2 9f       	mul	r27, r18
    d7c4:	70 0d       	add	r23, r0
    d7c6:	81 1d       	adc	r24, r1
    d7c8:	11 24       	eor	r1, r1
    d7ca:	91 1d       	adc	r25, r1
    d7cc:	08 95       	ret

0000d7ce <__udivmodsi4>:
    d7ce:	a1 e2       	ldi	r26, 0x21	; 33
    d7d0:	1a 2e       	mov	r1, r26
    d7d2:	aa 1b       	sub	r26, r26
    d7d4:	bb 1b       	sub	r27, r27
    d7d6:	fd 01       	movw	r30, r26
    d7d8:	0d c0       	rjmp	.+26     	; 0xd7f4 <__udivmodsi4_ep>

0000d7da <__udivmodsi4_loop>:
    d7da:	aa 1f       	adc	r26, r26
    d7dc:	bb 1f       	adc	r27, r27
    d7de:	ee 1f       	adc	r30, r30
    d7e0:	ff 1f       	adc	r31, r31
    d7e2:	a2 17       	cp	r26, r18
    d7e4:	b3 07       	cpc	r27, r19
    d7e6:	e4 07       	cpc	r30, r20
    d7e8:	f5 07       	cpc	r31, r21
    d7ea:	20 f0       	brcs	.+8      	; 0xd7f4 <__udivmodsi4_ep>
    d7ec:	a2 1b       	sub	r26, r18
    d7ee:	b3 0b       	sbc	r27, r19
    d7f0:	e4 0b       	sbc	r30, r20
    d7f2:	f5 0b       	sbc	r31, r21

0000d7f4 <__udivmodsi4_ep>:
    d7f4:	66 1f       	adc	r22, r22
    d7f6:	77 1f       	adc	r23, r23
    d7f8:	88 1f       	adc	r24, r24
    d7fa:	99 1f       	adc	r25, r25
    d7fc:	1a 94       	dec	r1
    d7fe:	69 f7       	brne	.-38     	; 0xd7da <__udivmodsi4_loop>
    d800:	60 95       	com	r22
    d802:	70 95       	com	r23
    d804:	80 95       	com	r24
    d806:	90 95       	com	r25
    d808:	9b 01       	movw	r18, r22
    d80a:	ac 01       	movw	r20, r24
    d80c:	bd 01       	movw	r22, r26
    d80e:	cf 01       	movw	r24, r30
    d810:	08 95       	ret

0000d812 <memcpy_P>:
    d812:	fb 01       	movw	r30, r22
    d814:	dc 01       	movw	r26, r24
    d816:	02 c0       	rjmp	.+4      	; 0xd81c <memcpy_P+0xa>
    d818:	05 90       	lpm	r0, Z+
    d81a:	0d 92       	st	X+, r0
    d81c:	41 50       	subi	r20, 0x01	; 1
    d81e:	50 40       	sbci	r21, 0x00	; 0
    d820:	d8 f7       	brcc	.-10     	; 0xd818 <memcpy_P+0x6>
    d822:	08 95       	ret

0000d824 <ltoa>:
    d824:	fa 01       	movw	r30, r20
    d826:	cf 93       	push	r28
    d828:	ff 93       	push	r31
    d82a:	ef 93       	push	r30
    d82c:	22 30       	cpi	r18, 0x02	; 2
    d82e:	3c f1       	brlt	.+78     	; 0xd87e <ltoa+0x5a>
    d830:	25 32       	cpi	r18, 0x25	; 37
    d832:	2c f5       	brge	.+74     	; 0xd87e <ltoa+0x5a>
    d834:	c2 2f       	mov	r28, r18
    d836:	e8 94       	clt
    d838:	ca 30       	cpi	r28, 0x0A	; 10
    d83a:	49 f4       	brne	.+18     	; 0xd84e <ltoa+0x2a>
    d83c:	97 fb       	bst	r25, 7
    d83e:	3e f4       	brtc	.+14     	; 0xd84e <ltoa+0x2a>
    d840:	90 95       	com	r25
    d842:	80 95       	com	r24
    d844:	70 95       	com	r23
    d846:	61 95       	neg	r22
    d848:	7f 4f       	sbci	r23, 0xFF	; 255
    d84a:	8f 4f       	sbci	r24, 0xFF	; 255
    d84c:	9f 4f       	sbci	r25, 0xFF	; 255
    d84e:	2c 2f       	mov	r18, r28
    d850:	33 27       	eor	r19, r19
    d852:	44 27       	eor	r20, r20
    d854:	55 27       	eor	r21, r21
    d856:	ff 93       	push	r31
    d858:	ef 93       	push	r30
    d85a:	b9 df       	rcall	.-142    	; 0xd7ce <__udivmodsi4>
    d85c:	ef 91       	pop	r30
    d85e:	ff 91       	pop	r31
    d860:	60 5d       	subi	r22, 0xD0	; 208
    d862:	6a 33       	cpi	r22, 0x3A	; 58
    d864:	0c f0       	brlt	.+2      	; 0xd868 <ltoa+0x44>
    d866:	69 5d       	subi	r22, 0xD9	; 217
    d868:	61 93       	st	Z+, r22
    d86a:	b9 01       	movw	r22, r18
    d86c:	ca 01       	movw	r24, r20
    d86e:	60 50       	subi	r22, 0x00	; 0
    d870:	70 40       	sbci	r23, 0x00	; 0
    d872:	80 40       	sbci	r24, 0x00	; 0
    d874:	90 40       	sbci	r25, 0x00	; 0
    d876:	59 f7       	brne	.-42     	; 0xd84e <ltoa+0x2a>
    d878:	16 f4       	brtc	.+4      	; 0xd87e <ltoa+0x5a>
    d87a:	cd e2       	ldi	r28, 0x2D	; 45
    d87c:	c1 93       	st	Z+, r28
    d87e:	10 82       	st	Z, r1
    d880:	8f 91       	pop	r24
    d882:	9f 91       	pop	r25
    d884:	cf 91       	pop	r28
    d886:	23 c0       	rjmp	.+70     	; 0xd8ce <strrev>

0000d888 <__eerd_byte_m2560>:
    d888:	f9 99       	sbic	0x1f, 1	; 31
    d88a:	fe cf       	rjmp	.-4      	; 0xd888 <__eerd_byte_m2560>
    d88c:	92 bd       	out	0x22, r25	; 34
    d88e:	81 bd       	out	0x21, r24	; 33
    d890:	f8 9a       	sbi	0x1f, 0	; 31
    d892:	99 27       	eor	r25, r25
    d894:	80 b5       	in	r24, 0x20	; 32
    d896:	08 95       	ret

0000d898 <__eerd_word_m2560>:
    d898:	a8 e1       	ldi	r26, 0x18	; 24
    d89a:	b0 e0       	ldi	r27, 0x00	; 0
    d89c:	42 e0       	ldi	r20, 0x02	; 2
    d89e:	50 e0       	ldi	r21, 0x00	; 0
    d8a0:	28 c0       	rjmp	.+80     	; 0xd8f2 <__eerd_blraw_m2560>

0000d8a2 <__eeupd_byte_m2560>:
    d8a2:	26 2f       	mov	r18, r22

0000d8a4 <__eeupd_r18_m2560>:
    d8a4:	f9 99       	sbic	0x1f, 1	; 31
    d8a6:	fe cf       	rjmp	.-4      	; 0xd8a4 <__eeupd_r18_m2560>
    d8a8:	92 bd       	out	0x22, r25	; 34
    d8aa:	81 bd       	out	0x21, r24	; 33
    d8ac:	f8 9a       	sbi	0x1f, 0	; 31
    d8ae:	01 97       	sbiw	r24, 0x01	; 1
    d8b0:	00 b4       	in	r0, 0x20	; 32
    d8b2:	02 16       	cp	r0, r18
    d8b4:	39 f0       	breq	.+14     	; 0xd8c4 <__eeupd_r18_m2560+0x20>
    d8b6:	1f ba       	out	0x1f, r1	; 31
    d8b8:	20 bd       	out	0x20, r18	; 32
    d8ba:	0f b6       	in	r0, 0x3f	; 63
    d8bc:	f8 94       	cli
    d8be:	fa 9a       	sbi	0x1f, 2	; 31
    d8c0:	f9 9a       	sbi	0x1f, 1	; 31
    d8c2:	0f be       	out	0x3f, r0	; 63
    d8c4:	08 95       	ret

0000d8c6 <__eeupd_word_m2560>:
    d8c6:	01 96       	adiw	r24, 0x01	; 1
    d8c8:	27 2f       	mov	r18, r23
    d8ca:	ec df       	rcall	.-40     	; 0xd8a4 <__eeupd_r18_m2560>
    d8cc:	ea cf       	rjmp	.-44     	; 0xd8a2 <__eeupd_byte_m2560>

0000d8ce <strrev>:
    d8ce:	dc 01       	movw	r26, r24
    d8d0:	fc 01       	movw	r30, r24
    d8d2:	67 2f       	mov	r22, r23
    d8d4:	71 91       	ld	r23, Z+
    d8d6:	77 23       	and	r23, r23
    d8d8:	e1 f7       	brne	.-8      	; 0xd8d2 <strrev+0x4>
    d8da:	32 97       	sbiw	r30, 0x02	; 2
    d8dc:	04 c0       	rjmp	.+8      	; 0xd8e6 <strrev+0x18>
    d8de:	7c 91       	ld	r23, X
    d8e0:	6d 93       	st	X+, r22
    d8e2:	70 83       	st	Z, r23
    d8e4:	62 91       	ld	r22, -Z
    d8e6:	ae 17       	cp	r26, r30
    d8e8:	bf 07       	cpc	r27, r31
    d8ea:	c8 f3       	brcs	.-14     	; 0xd8de <strrev+0x10>
    d8ec:	08 95       	ret

0000d8ee <__eerd_block_m2560>:
    d8ee:	dc 01       	movw	r26, r24
    d8f0:	cb 01       	movw	r24, r22

0000d8f2 <__eerd_blraw_m2560>:
    d8f2:	fc 01       	movw	r30, r24
    d8f4:	f9 99       	sbic	0x1f, 1	; 31
    d8f6:	fe cf       	rjmp	.-4      	; 0xd8f4 <__eerd_blraw_m2560+0x2>
    d8f8:	06 c0       	rjmp	.+12     	; 0xd906 <__eerd_blraw_m2560+0x14>
    d8fa:	f2 bd       	out	0x22, r31	; 34
    d8fc:	e1 bd       	out	0x21, r30	; 33
    d8fe:	f8 9a       	sbi	0x1f, 0	; 31
    d900:	31 96       	adiw	r30, 0x01	; 1
    d902:	00 b4       	in	r0, 0x20	; 32
    d904:	0d 92       	st	X+, r0
    d906:	41 50       	subi	r20, 0x01	; 1
    d908:	50 40       	sbci	r21, 0x00	; 0
    d90a:	b8 f7       	brcc	.-18     	; 0xd8fa <__eerd_blraw_m2560+0x8>
    d90c:	08 95       	ret

0000d90e <_exit>:
    d90e:	f8 94       	cli

0000d910 <__stop_program>:
    d910:	ff cf       	rjmp	.-2      	; 0xd910 <__stop_program>
